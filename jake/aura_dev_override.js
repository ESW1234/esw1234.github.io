/*
     * Copyright (C) 2017 salesforce.com, inc.
     */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
        typeof define === 'function' && define.amd ? define(['exports'], factory) :
            (factory((global.Engine = {})));
}(this, (function (exports) {
    'use strict';

    const compareDocumentPosition = Node.prototype.compareDocumentPosition;
    const { DOCUMENT_POSITION_CONTAINS } = Node;
    const assert = {
        invariant(value, msg) {
            if (!value) {
                throw new Error(`Invariant Violation: ${msg}`);
            }
        },
        isTrue(value, msg) {
            if (!value) {
                throw new Error(`Assert Violation: ${msg}`);
            }
        },
        isFalse(value, msg) {
            if (value) {
                throw new Error(`Assert Violation: ${msg}`);
            }
        },
        vnode(vnode) {
            assert.isTrue(vnode && "sel" in vnode && "data" in vnode && "children" in vnode && "text" in vnode && "elm" in vnode && "key" in vnode, `${vnode} is not a vnode.`);
        },
        vm(vm) {
            assert.isTrue(vm && "component" in vm, `${vm} is not a vm.`);
        },
        fail(msg) {
            throw new Error(msg);
        },
        logError(msg) {
            try {
                throw new Error(msg);
            }
            catch (e) {
                console.error(e);
            }
        },
        logWarning(msg) {
            try {
                throw new Error(msg);
            }
            catch (e) {
                console.warn(e);
            }
        },
        childNode(container, node, msg) {
            assert.isTrue(compareDocumentPosition.call(node, container) & DOCUMENT_POSITION_CONTAINS, msg || `${node} must be a child node of ${container}`);
        }
    };

    const topLevelContextSymbol = Symbol('Top Level Context');
    let currentContext = {};
    currentContext[topLevelContextSymbol] = true;
    function establishContext(ctx) {
        currentContext = ctx;
    }

    const { freeze, seal, keys, create, assign, defineProperty, getPrototypeOf, setPrototypeOf, getOwnPropertyDescriptor, getOwnPropertyNames, defineProperties, getOwnPropertySymbols, hasOwnProperty, preventExtensions, isExtensible, } = Object;
    const { isArray } = Array;
    const { concat: ArrayConcat, filter: ArrayFilter, slice: ArraySlice, splice: ArraySplice, indexOf: ArrayIndexOf, push: ArrayPush, map: ArrayMap, forEach, } = Array.prototype;
    function isUndefined(obj) {
        return obj === undefined;
    }
    function isNull(obj) {
        return obj === null;
    }

    function isFunction(obj) {
        return typeof obj === 'function';
    }
    function isObject(obj) {
        return typeof obj === 'object';
    }
    function isString(obj) {
        return typeof obj === 'string';
    }

    const OtS = {}.toString;
    function toString$1(obj) {
        if (obj && typeof obj === 'object' && !obj.toString) {
            return OtS.call(obj);
        }
        return obj + '';
    }

    // Few more execptions that are using the attribute name to match the property in lowercase.
    // this list was compiled from https://msdn.microsoft.com/en-us/library/ms533062(v=vs.85).aspx
    // and https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes
    // Note: this list most be in sync with the compiler as well.
    const HTMLPropertyNamesWithLowercasedReflectiveAttributes = [
        'accessKey',
        'readOnly',
        'tabIndex',
        'bgColor',
        'colSpan',
        'rowSpan',
        'contentEditable',
        'dateTime',
        'formAction',
        'isMap',
        'maxLength',
        'useMap',
    ];
    // Global HTML Attributes & Properties
    // https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement
    const GlobalHTMLProperties = {
        id: {
            attribute: 'id',
        },
        accessKey: {
            attribute: 'accesskey',
        },
        accessKeyLabel: {
            readOnly: true,
        },
        className: {
            attribute: 'class',
            error: `Using property "className" is an anti-pattern because of slow runtime behavior and conflicting with classes provided by the owner element. Instead use property "classList".`,
        },
        contentEditable: {
            attribute: 'contenteditable',
        },
        isContentEditable: {
            readOnly: true,
        },
        contextMenu: {
            attribute: 'contextmenu',
        },
        dataset: {
            readOnly: true,
            msg: 'Using property "dataset" is an anti-pattern. Instead declare \`static observedAttributes = ["data-foo"]\` and use \`attributeChangedCallback(attrName, oldValue, newValue)\` to get a notification each time the attribute changes.',
        },
        dir: {
            attribute: 'dir',
        },
        draggable: {
            attribute: 'draggable',
            experimental: true,
        },
        dropzone: {
            attribute: 'dropzone',
            readOnly: true,
            experimental: true,
        },
        hidden: {
            attribute: 'hidden',
        },
        itemScope: {
            attribute: 'itemscope',
            experimental: true,
        },
        itemType: {
            attribute: 'itemtype',
            readOnly: true,
            experimental: true,
        },
        itemId: {
            attribute: 'itemid',
            experimental: true,
        },
        itemRef: {
            attribute: 'itemref',
            readOnly: true,
            experimental: true,
        },
        itemProp: {
            attribute: 'itemprop',
            readOnly: true,
            experimental: true,
        },
        itemValue: {
            experimental: true,
        },
        lang: {
            attribute: 'lang',
        },
        offsetHeight: {
            readOnly: true,
            experimental: true,
        },
        offsetLeft: {
            readOnly: true,
            experimental: true,
        },
        offsetParent: {
            readOnly: true,
            experimental: true,
        },
        offsetTop: {
            readOnly: true,
            experimental: true,
        },
        offsetWidth: {
            readOnly: true,
            experimental: true,
        },
        properties: {
            readOnly: true,
            experimental: true,
        },
        spellcheck: {
            experimental: true,
        },
        style: {
            attribute: 'style',
            error: `Using property or attribute "style" is an anti-pattern. Instead use property "classList".`,
        },
        tabIndex: {
            attribute: 'tabindex',
        },
        title: {
            attribute: 'title',
        },
        translate: {
            experimental: true,
        },
        // additional global attributes that are not present in the link above.
        role: {
            attribute: 'role',
        },
        slot: {
            attribute: 'slot',
            experimental: true,
            error: `Using property or attribute "slot" is an anti-pattern.`
        }
    };
    // TODO: complete this list with Element properties
    // https://developer.mozilla.org/en-US/docs/Web/API/Element
    // TODO: complete this list with Node properties
    // https://developer.mozilla.org/en-US/docs/Web/API/Node

    let nextTickCallbackQueue = [];
    const SPACE_CHAR = 32;
    const EmptyObject = seal(create(null));
    const EmptyArray = seal([]);
    function flushCallbackQueue() {
        {
            assert.invariant(nextTickCallbackQueue.length, `If callbackQueue is scheduled, it is because there must be at least one callback on this pending queue instead of ${nextTickCallbackQueue}.`);
        }
        const callbacks = nextTickCallbackQueue;
        nextTickCallbackQueue = []; // reset to a new queue
        for (let i = 0, len = callbacks.length; i < len; i += 1) {
            callbacks[i]();
        }
    }
    function addCallbackToNextTick(callback) {
        {
            assert.isTrue(isFunction(callback), `addCallbackToNextTick() can only accept a function callback as first argument instead of ${callback}`);
        }
        if (nextTickCallbackQueue.length === 0) {
            Promise.resolve().then(flushCallbackQueue);
        }
        // TODO: eventually, we might want to have priority when inserting callbacks
        ArrayPush.call(nextTickCallbackQueue, callback);
    }
    const CAMEL_REGEX = /-([a-z])/g;
    const attrNameToPropNameMap = create(null);
    function getPropNameFromAttrName(attrName) {
        let propName = attrNameToPropNameMap[attrName];
        if (!propName && isString(attrName)) {
            propName = attrName.replace(CAMEL_REGEX, (g) => g[1].toUpperCase());
            attrNameToPropNameMap[attrName] = propName;
        }
        return propName;
    }
    const CAPS_REGEX = /[A-Z]/g;
    /**
     * This dictionary contains the mapping between property names
     * and the corresponding attribute name. This helps to trigger observable attributes.
     */
    const propNameToAttributeNameMap = {
        // these are exceptions to the rule that cannot be inferred via `CAPS_REGEX`
        className: 'class',
        htmlFor: 'for',
    };
    // Few more exceptions where the attribute name matches the property in lowercase.
    HTMLPropertyNamesWithLowercasedReflectiveAttributes.forEach((propName) => {
        propNameToAttributeNameMap[propName] = propName.toLowerCase();
    });
    function getAttrNameFromPropName(propName) {
        let attrName = propNameToAttributeNameMap[propName];
        if (!attrName) {
            attrName = propName.replace(CAPS_REGEX, (match) => '-' + match.toLowerCase());
            propNameToAttributeNameMap[propName] = attrName;
        }
        return attrName;
    }
    function noop() { }
    const classNameToClassMap = create(null);
    function getMapFromClassName(className) {
        let map = classNameToClassMap[className];
        if (map) {
            return map;
        }
        map = {};
        let start = 0;
        let i, len = className.length;
        for (i = 0; i < len; i++) {
            if (className.charCodeAt(i) === SPACE_CHAR) {
                if (i > start) {
                    map[className.slice(start, i)] = true;
                }
                start = i + 1;
            }
        }
        if (i > start) {
            map[className.slice(start, i)] = true;
        }
        classNameToClassMap[className] = map;
        {
            // just to make sure that this object never changes as part of the diffing algo
            freeze(map);
        }
        return map;
    }

    const hooks$1 = ['wiring', 'rendered', 'connected', 'disconnected', 'piercing'];
    /* eslint-enable */
    const Services = create(null);
    function register(service) {
        {
            assert.isTrue(isObject(service), `Invalid service declaration, ${service}: service must be an object`);
        }
        for (let i = 0; i < hooks$1.length; ++i) {
            const hookName = hooks$1[i];
            if (hookName in service) {
                let l = Services[hookName];
                if (isUndefined(l)) {
                    Services[hookName] = l = [];
                }
                l.push(service[hookName]);
            }
        }
    }
    function invokeServiceHook(vm, cbs) {
        {
            assert.vm(vm);
            assert.isTrue(isArray(cbs) && cbs.length > 0, `Optimize invokeServiceHook() to be invoked only when needed`);
        }
        const { component, vnode: { data }, def, context } = vm;
        for (let i = 0, len = cbs.length; i < len; ++i) {
            cbs[i].call(undefined, component, data, def, context);
        }
    }

    let idx = 0;
    let uid = 0;
    const OwnerKey = Symbol('key');
    function addInsertionIndex(vm) {
        {
            assert.vm(vm);
            assert.invariant(vm.idx === 0, `${vm} is already locked to a previously generated idx.`);
        }
        vm.idx = ++idx;
        const { connected } = Services;
        if (connected) {
            invokeServiceHook(vm, connected);
        }
        const { component: { connectedCallback } } = vm;
        if (connectedCallback && connectedCallback !== noop) {
            invokeComponentMethod(vm, 'connectedCallback');
        }
    }
    function removeInsertionIndex(vm) {
        {
            assert.vm(vm);
            assert.invariant(vm.idx > 0, `${vm} is not locked to a previously generated idx.`);
        }
        vm.idx = 0;
        const { disconnected } = Services;
        if (disconnected) {
            invokeServiceHook(vm, disconnected);
        }
        const { component: { disconnectedCallback } } = vm;
        if (disconnectedCallback && disconnectedCallback !== noop) {
            invokeComponentMethod(vm, 'disconnectedCallback');
        }
    }
    function createVM(vnode) {
        {
            assert.vnode(vnode);
            assert.invariant(vnode.elm instanceof HTMLElement, `VM creation requires a DOM element to be associated to vnode ${vnode}.`);
        }
        const { elm, Ctor } = vnode;
        const def = getComponentDef(Ctor);
        uid += 1;
        const vm = {
            uid,
            idx: 0,
            isScheduled: false,
            isDirty: true,
            def,
            context: {},
            cmpProps: {},
            cmpTrack: {},
            cmpState: undefined,
            cmpSlots: undefined,
            cmpEvents: undefined,
            cmpListener: undefined,
            cmpClasses: undefined,
            cmpTemplate: undefined,
            cmpRoot: undefined,
            classListObj: undefined,
            component: undefined,
            vnode,
            shadowVNode: createShadowRootVNode(elm, []),
            // used to track down all object-key pairs that makes this vm reactive
            deps: [],
        };
        {
            vm.toString = () => {
                return `[object:vm ${def.name} (${vm.idx})]`;
            };
        }
        vnode.vm = vm;
        // linking elm with VM before creating the instance
        elm[ViewModelReflection] = vm;
        defineProperties(elm, def.descriptors);
        createComponent(vm, Ctor);
        linkComponent(vm);
        {
            const { component: { attributeChangedCallback }, def: { observedAttrs } } = vm;
            if (observedAttrs.length && isUndefined(attributeChangedCallback)) {
                console.warn(`${vm} has static observedAttributes set to ["${keys(observedAttrs).join('", "')}"] but it is missing the attributeChangedCallback() method to watch for changes on those attributes. Double check for typos on the name of the callback.`);
            }
        }
        return vm;
    }
    function relinkVM(vm, vnode) {
        {
            assert.vm(vm);
            assert.vnode(vnode);
            assert.isTrue(vnode.elm instanceof HTMLElement, `Only DOM elements can be linked to their corresponding component.`);
            assert.invariant(vm.component, `vm.component is required to be defined before ${vm} gets linked to ${vnode}.`);
        }
        vnode.vm = vm;
        vm.vnode = vnode;
    }
    function rehydrate(vm) {
        {
            assert.vm(vm);
        }
        if (vm.idx && vm.isDirty) {
            const { vnode } = vm;
            {
                assert.isTrue(vnode.elm instanceof HTMLElement, `rehydration can only happen after ${vm} was patched the first time.`);
            }
            const children = renderComponent(vm);
            vm.isScheduled = false;
            patchShadowRoot(vm, children);
            const { rendered } = Services;
            if (rendered) {
                invokeServiceHook(vm, rendered);
            }
            const { component: { renderedCallback } } = vm;
            if (renderedCallback && renderedCallback !== noop) {
                invokeComponentMethod(vm, 'renderedCallback');
            }
        }
    }
    let rehydrateQueue = [];
    function flushRehydrationQueue() {
        {
            assert.invariant(rehydrateQueue.length, `If rehydrateQueue was scheduled, it is because there must be at least one VM on this pending queue instead of ${rehydrateQueue}.`);
        }
        const vms = rehydrateQueue.sort((a, b) => a.idx > b.idx);
        rehydrateQueue = []; // reset to a new queue
        for (let i = 0, len = vms.length; i < len; i += 1) {
            rehydrate(vms[i]);
        }
    }
    function scheduleRehydration(vm) {
        {
            assert.vm(vm);
        }
        if (!vm.isScheduled) {
            vm.isScheduled = true;
            if (rehydrateQueue.length === 0) {
                addCallbackToNextTick(flushRehydrationQueue);
            }
            ArrayPush.call(rehydrateQueue, vm);
        }
    }
    function isNodeOwnedByVM(vm, node) {
        {
            assert.vm(vm);
            assert.invariant(node instanceof Node, `isNodeOwnedByVM() should be called with a node as the second argument instead of ${node}`);
            assert.childNode(vm.vnode.elm, node, `isNodeOwnedByVM() should never be called with a node that is not a child node of ${vm}`);
        }
        // @ts-ignore
        return node[OwnerKey] === vm.uid;
    }
    function wasNodePassedIntoVM(vm, node) {
        {
            assert.vm(vm);
            assert.invariant(node instanceof Node, `isNodePassedToVM() should be called with a node as the second argument instead of ${node}`);
            assert.childNode(vm.vnode.elm, node, `isNodePassedToVM() should never be called with a node that is not a child node of ${vm}`);
        }
        const { vnode: { uid: ownerUid } } = vm;
        // TODO: we need to walk the parent path here as well, in case they passed it via slots multiple times
        // @ts-ignore
        return node[OwnerKey] === ownerUid;
    }
    function createShadowRootVNode(elm, children) {
        const sel = elm.tagName.toLocaleLowerCase();
        const vnode = {
            sel,
            data: EmptyObject,
            children,
            elm,
            key: undefined,
            text: undefined,
        };
        return vnode;
    }
    function patchShadowRoot(vm, children) {
        {
            assert.vm(vm);
        }
        const { shadowVNode: oldShadowVNode } = vm;
        const shadowVNode = createShadowRootVNode(vm.vnode.elm, children);
        vm.shadowVNode = patch(oldShadowVNode, shadowVNode);
    }

    const TargetToReactiveRecordMap = new WeakMap();
    function notifyListeners(target, key) {
        const reactiveRecord = TargetToReactiveRecordMap.get(target);
        if (reactiveRecord) {
            const value = reactiveRecord[key];
            if (value) {
                const len = value.length;
                for (let i = 0; i < len; i += 1) {
                    const vm = value[i];
                    {
                        assert.vm(vm);
                    }
                    if (!vm.isDirty) {
                        markComponentAsDirty(vm);
                        scheduleRehydration(vm);
                    }
                }
            }
        }
    }
    function subscribeToSetHook(vm, target, key) {
        {
            assert.vm(vm);
        }
        let reactiveRecord = TargetToReactiveRecordMap.get(target);
        if (isUndefined(reactiveRecord)) {
            const newRecord = create(null);
            reactiveRecord = newRecord;
            TargetToReactiveRecordMap.set(target, newRecord);
        }
        let value = reactiveRecord[key];
        if (isUndefined(value)) {
            value = [];
            reactiveRecord[key] = value;
        }
        else if (value[0] === vm) {
            return; // perf optimization considering that most subscriptions will come from the same vm
        }
        if (ArrayIndexOf.call(value, vm) === -1) {
            ArrayPush.call(value, vm);
            // we keep track of the sets that vm is listening from to be able to do some clean up later on
            ArrayPush.call(vm.deps, value);
        }
    }

    /*eslint-enable*/
    const TargetSlot = Symbol();
    const MembraneSlot = Symbol();
    function isReplicable(value) {
        const type = typeof value;
        return value && (type === 'object' || type === 'function');
    }
    function getReplica(membrane, value) {
        if (isNull(value)) {
            return value;
        }
        value = unwrap(value);
        if (!isReplicable(value)) {
            return value;
        }
        {
            assert.isTrue(membrane instanceof Membrane, `getReplica() first argument must be a membrane.`);
        }
        let { cells } = membrane;
        const r = cells.get(value);
        if (r) {
            return r;
        }
        const replica = new Proxy(value, membrane); // eslint-disable-line no-undef
        cells.set(value, replica);
        return replica;
    }
    class Membrane {
        constructor(handler) {
            this.handler = handler;
            this.cells = new WeakMap();
        }
        get(target, key) {
            if (key === TargetSlot) {
                return target;
            }
            else if (key === MembraneSlot) {
                return this;
            }
            return this.handler.get(this, target, key);
        }
        set(target, key, newValue) {
            return this.handler.set(this, target, key, newValue);
        }
        deleteProperty(target, key) {
            if (key === TargetSlot) {
                return false;
            }
            return this.handler.deleteProperty(this, target, key);
        }
        apply(target, thisArg, argumentsList) {
            thisArg = unwrap(thisArg);
            argumentsList = unwrap(argumentsList);
            if (isArray(argumentsList)) {
                argumentsList = ArrayMap.call(argumentsList, unwrap);
            }
            return this.handler.apply(this, target, thisArg, argumentsList);
        }
        construct(target, argumentsList, newTarget) {
            argumentsList = unwrap(argumentsList);
            if (isArray(argumentsList)) {
                argumentsList = ArrayMap.call(argumentsList, unwrap);
            }
            return this.handler.construct(this, target, argumentsList, newTarget);
        }
    }
    // TODO: we are using a funky and leaky abstraction here to try to identify if
    // the proxy is a compat proxy, and define the unwrap method accordingly.
    const { getKey } = Proxy;
    const unwrap = getKey ?
        (replicaOrAny) => (replicaOrAny && getKey(replicaOrAny, TargetSlot)) || replicaOrAny
        : (replicaOrAny) => (replicaOrAny && replicaOrAny[TargetSlot]) || replicaOrAny;

    const { create: create$1, getPrototypeOf: getPrototypeOf$1, getOwnPropertyNames: getOwnPropertyNames$1, getOwnPropertySymbols: getOwnPropertySymbols$1 } = Object;
    const { isArray: isArray$1 } = Array;
    /* eslint-enable */
    function getTarget(item) {
        return item && item[TargetSlot];
    }
    function extract(objectOrArray) {
        if (isArray$1(objectOrArray)) {
            return objectOrArray.map((item) => {
                const original = getTarget(item);
                if (original) {
                    return extract(original);
                }
                return item;
            });
        }
        const obj = create$1(getPrototypeOf$1(objectOrArray));
        return getOwnPropertyNames$1(objectOrArray).concat(getOwnPropertySymbols$1(objectOrArray))
            .reduce((seed, key) => {
                const item = objectOrArray[key];
                const original = getTarget(item);
                if (original) {
                    seed[key] = extract(original);
                }
                else {
                    seed[key] = item;
                }
                return seed;
            }, obj);
    }
    const formatter = {
        header: (plainOrProxy) => {
            const originalTarget = plainOrProxy[TargetSlot];
            if (!originalTarget) {
                return null;
            }
            const obj = extract(plainOrProxy);
            return ['object', { object: obj }];
        },
        hasBody: () => {
            return false;
        },
        body: () => {
            return null;
        }
    };
    function init$1() {
        // Custom Formatter for Dev Tools
        // To enable this, open Chrome Dev Tools
        // Go to Settings,
        // Under console, select "Enable custom formatters"
        // For more information, https://docs.google.com/document/d/1FTascZXT9cxfetuPRT2eXPQKXui4nWFivUnS_335T3U/preview
        const devWindow = window; // eslint-disable-line no-undef
        const devtoolsFormatters = devWindow.devtoolsFormatters || [];
        devtoolsFormatters.push(formatter);
        devWindow.devtoolsFormatters = devtoolsFormatters; // eslint-disable-line no-undef
    }

    {
        init$1();
    }
    /*eslint-enable*/
    const ReactiveMap = new WeakMap();
    const ObjectDotPrototype = Object.prototype;
    function lockShadowTarget(shadowTarget, originalTarget) {
        const targetKeys = ArrayConcat.call(getOwnPropertyNames(originalTarget), getOwnPropertySymbols(originalTarget));
        targetKeys.forEach((key) => {
            let descriptor = getOwnPropertyDescriptor(originalTarget, key);
            // We do not need to wrap the descriptor if not configurable
            // Because we can deal with wrapping it when user goes through
            // Get own property descriptor. There is also a chance that this descriptor
            // could change sometime in the future, so we can defer wrapping
            // until we need to
            if (!descriptor.configurable) {
                descriptor = wrapDescriptor(descriptor);
            }
            defineProperty(shadowTarget, key, descriptor);
        });
        preventExtensions(shadowTarget);
    }
    function wrapDescriptor(descriptor) {
        if ('value' in descriptor) {
            descriptor.value = isObservable(descriptor.value) ? getReactiveProxy(descriptor.value) : descriptor.value;
        }
        return descriptor;
    }
    function isObservable(value) {
        if (!value) {
            return false;
        }
        if (isArray(value)) {
            return true;
        }
        const proto = getPrototypeOf(value);
        return (proto === ObjectDotPrototype || proto === null || getPrototypeOf(proto) === null);
    }
    // Unwrap property descriptors
    // We only need to unwrap if value is specified
    function unwrapDescriptor(descriptor) {
        if ('value' in descriptor) {
            descriptor.value = unwrap(descriptor.value);
        }
        return descriptor;
    }
    class ReactiveProxyHandler {
        constructor(value) {
            this.originalTarget = value;
        }
        get(shadowTarget, key) {
            if (key === MembraneSlot) {
                return this;
            }
            const { originalTarget } = this;
            if (key === TargetSlot) {
                return originalTarget;
            }
            const value = originalTarget[key];
            if (isRendering) {
                subscribeToSetHook(vmBeingRendered, originalTarget, key); // eslint-disable-line no-undef
            }
            const observable = isObservable(value);
            {
                if (!observable && value !== null && isObject(value)) {
                    if (isRendering) {
                        assert.logWarning(`Rendering a non-reactive value ${value} from member property ${key} of ${vmBeingRendered} is not common because mutations on that value will not re-render the template.`);
                    }
                    else {
                        assert.logWarning(`Returning a non-reactive value ${value} to member property ${key} of ${toString$1(originalTarget)} is not common because mutations on that value cannot be observed.`);
                    }
                }
            }
            return observable ? getReactiveProxy(value) : value;
        }
        set(shadowTarget, key, value) {
            const { originalTarget } = this;
            if (isRendering) {
                {
                    assert.logError(`Setting property "${toString$1(key)}" of ${toString$1(shadowTarget)} during the rendering process of ${vmBeingRendered} is invalid. The render phase must have no side effects on the state of any component.`);
                }
                return false;
            }
            const oldValue = originalTarget[key];
            if (oldValue !== value) {
                originalTarget[key] = value;
                notifyListeners(originalTarget, key);
            }
            else if (key === 'length' && isArray(originalTarget)) {
                // fix for issue #236: push will add the new index, and by the time length
                // is updated, the internal length is already equal to the new length value
                // therefore, the oldValue is equal to the value. This is the forking logic
                // to support this use case.
                notifyListeners(originalTarget, key);
            }
            return true;
        }
        deleteProperty(shadowTarget, key) {
            const { originalTarget } = this;
            delete originalTarget[key];
            notifyListeners(originalTarget, key);
            return true;
        }
        apply(target /*, thisArg: any, argArray?: any*/) {
            {
                assert.fail(`invalid call invocation for property proxy ${toString$1(target)}`);
            }
        }
        construct(target, argArray, newTarget) {
            {
                assert.fail(`invalid construction invocation for property proxy ${toString$1(target)}`);
            }
        }
        has(shadowTarget, key) {
            const { originalTarget } = this;
            // make reactive
            if (isRendering) {
                subscribeToSetHook(vmBeingRendered, originalTarget, key); // eslint-disable-line no-undef
            }
            return key in originalTarget;
        }
        ownKeys(shadowTarget) {
            const { originalTarget } = this;
            return ArrayConcat.call(getOwnPropertyNames(originalTarget), getOwnPropertySymbols(originalTarget));
        }
        isExtensible(shadowTarget) {
            const shadowIsExtensible = isExtensible(shadowTarget);
            if (!shadowIsExtensible) {
                return shadowIsExtensible;
            }
            const { originalTarget } = this;
            const targetIsExtensible = isExtensible(originalTarget);
            if (!targetIsExtensible) {
                lockShadowTarget(shadowTarget, originalTarget);
            }
            return targetIsExtensible;
        }
        setPrototypeOf(shadowTarget, prototype) {
            {
                assert.fail(`Invalid setPrototypeOf invocation for reactive proxy ${toString$1(this.originalTarget)}. Prototype of reactive objects cannot be changed.`);
            }
        }
        getPrototypeOf(shadowTarget) {
            const { originalTarget } = this;
            return getPrototypeOf(originalTarget);
        }
        getOwnPropertyDescriptor(shadowTarget, key) {
            const { originalTarget } = this;
            // keys looked up via hasOwnProperty need to be reactive
            if (isRendering) {
                subscribeToSetHook(vmBeingRendered, originalTarget, key); // eslint-disable-line no-undef
            }
            let desc = getOwnPropertyDescriptor(originalTarget, key);
            if (!desc) {
                return desc;
            }
            let shadowDescriptor = getOwnPropertyDescriptor(shadowTarget, key);
            if (!desc.configurable && !shadowDescriptor) {
                // If descriptor from original target is not configurable,
                // We must copy the wrapped descriptor over to the shadow target.
                // Otherwise, proxy will throw an invariant error.
                // This is our last chance to lock the value.
                // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor#Invariants
                desc = wrapDescriptor(desc);
                defineProperty(shadowTarget, key, desc);
            }
            return shadowDescriptor || desc;
        }
        preventExtensions(shadowTarget) {
            const { originalTarget } = this;
            lockShadowTarget(shadowTarget, originalTarget);
            preventExtensions(originalTarget);
            return true;
        }
        defineProperty(shadowTarget, key, descriptor) {
            const { originalTarget } = this;
            const { configurable } = descriptor;
            // We have to check for value in descriptor
            // because Object.freeze(proxy) calls this method
            // with only { configurable: false, writeable: false }
            // Additionally, method will only be called with writeable:false
            // if the descriptor has a value, as opposed to getter/setter
            // So we can just check if writable is present and then see if
            // value is present. This eliminates getter and setter descriptors
            if ('writable' in descriptor && !('value' in descriptor)) {
                const originalDescriptor = getOwnPropertyDescriptor(originalTarget, key);
                descriptor.value = originalDescriptor.value;
            }
            defineProperty(originalTarget, key, unwrapDescriptor(descriptor));
            if (configurable === false) {
                defineProperty(shadowTarget, key, wrapDescriptor(descriptor));
            }
            notifyListeners(originalTarget, key);
            return true;
        }
    }
    function getReactiveProxy(value) {
        {
            assert.isTrue(isObservable(value), "perf-optimization: avoid calling this method with non-observable values.");
        }
        value = unwrap(value);
        let proxy = ReactiveMap.get(value);
        if (proxy) {
            return proxy;
        }
        const handler = new ReactiveProxyHandler(value);
        const shadowTarget = isArray(value) ? [] : {};
        proxy = new Proxy(shadowTarget, handler);
        ReactiveMap.set(value, proxy);
        return proxy;
    }

    // stub function to prevent misuse of the @track decorator
    function track() {
        {
            assert.fail("@track may only be used as a decorator.");
        }
    }
    // TODO: how to allow symbols as property keys?
    function createTrackedPropertyDescriptor(proto, key, descriptor) {
        defineProperty(proto, key, {
            get() {
                const vm = this[ViewModelReflection];
                {
                    assert.vm(vm);
                }
                if (isRendering) {
                    // this is needed because the proxy used by template is not sufficient
                    // for public props accessed from within a getter in the component.
                    subscribeToSetHook(vmBeingRendered, this, key);
                }
                return vm.cmpTrack[key];
            },
            set(newValue) {
                const vm = this[ViewModelReflection];
                {
                    assert.vm(vm);
                    assert.invariant(!isRendering, `${vmBeingRendered}.render() method has side effects on the state of ${vm}.${key}`);
                }
                const observable = isObservable(newValue);
                newValue = observable ? getReactiveProxy(newValue) : newValue;
                if (newValue !== vm.cmpTrack[key]) {
                    {
                        if (!observable && newValue !== null && (isObject(newValue) || isArray(newValue))) {
                            assert.logWarning(`Property "${key}" of ${vm} is set to a non-trackable object, which means changes into that object cannot be observed.`);
                        }
                    }
                    vm.cmpTrack[key] = newValue;
                    if (vm.idx > 0) {
                        // perf optimization to skip this step if not in the DOM
                        notifyListeners(this, key);
                    }
                }
            },
            enumerable: descriptor ? descriptor.enumerable : true,
            configurable: false,
        });
    }

    // stub function to prevent misuse of the @wire decorator
    function wire() {
        {
            assert.fail("@wire may only be used as a decorator.");
        }
    }
    // TODO: how to allow symbols as property keys?
    function createWiredPropertyDescriptor(proto, key, descriptor) {
        createTrackedPropertyDescriptor(proto, key, descriptor);
    }

    // stub function to prevent misuse of the @api decorator
    function api$1() {
        {
            assert.fail("@api may only be used as a decorator.");
        }
    }
    let vmBeingUpdated = null;
    function prepareForPropUpdate(vm) {
        {
            assert.vm(vm);
        }
        vmBeingUpdated = vm;
    }
    // TODO: how to allow symbols as property keys?
    function createPublicPropertyDescriptor(proto, key, descriptor) {
        defineProperty(proto, key, {
            get() {
                const vm = this[ViewModelReflection];
                {
                    assert.vm(vm);
                }
                if (isBeingConstructed(vm)) {
                    {
                        assert.logError(`${vm} constructor should not read the value of property "${key}". The owner component has not yet set the value. Instead use the constructor to set default values for properties.`);
                    }
                    return;
                }
                if (isRendering) {
                    // this is needed because the proxy used by template is not sufficient
                    // for public props accessed from within a getter in the component.
                    subscribeToSetHook(vmBeingRendered, this, key);
                }
                return vm.cmpProps[key];
            },
            set(newValue) {
                const vm = this[ViewModelReflection];
                {
                    assert.vm(vm);
                    assert.invariant(!isRendering, `${vmBeingRendered}.render() method has side effects on the state of ${vm}.${key}`);
                }
                if (vmBeingUpdated === vm) {
                    // not need to wrap or check the value since that is happening somewhere else
                    vmBeingUpdated = null; // releasing the lock
                    vm.cmpProps[key] = newValue;
                    // avoid notification of observability while constructing the instance
                    if (vm.idx > 0) {
                        // perf optimization to skip this step if not in the DOM
                        notifyListeners(this, key);
                    }
                }
                else if (isBeingConstructed(vm)) {
                    const observable = isObservable(newValue);
                    newValue = observable ? getReactiveProxy(newValue) : newValue;
                    {
                        if (!observable && newValue !== null && isObject(newValue)) {
                            assert.logWarning(`Assigning a non-reactive value ${newValue} to member property ${key} of ${vm} is not common because mutations on that value cannot be observed.`);
                        }
                    }
                    vm.cmpProps[key] = newValue;
                }
                else {
                    {
                        assert.logError(`${vm} can only set a new value for property "${key}" during construction.`);
                    }
                }
            },
            enumerable: descriptor ? descriptor.enumerable : true,
        });
    }
    function createPublicAccessorDescriptor(proto, key, descriptor) {
        const { get, set, enumerable } = descriptor || EmptyObject;
        defineProperty(proto, key, {
            get() {
                const vm = this[ViewModelReflection];
                {
                    assert.vm(vm);
                }
                if (get) {
                    return get.call(this);
                }
            },
            set(newValue) {
                const vm = this[ViewModelReflection];
                {
                    assert.vm(vm);
                }
                if (!isBeingConstructed(vm) && vmBeingUpdated !== vm) {
                    {
                        assert.logError(`${vm} can only set a new value for property "${key}" during construction.`);
                    }
                    return;
                }
                vmBeingUpdated = null; // releasing the lock
                if (set) {
                    set.call(this, newValue);
                }
                else {
                    {
                        assert.fail(`Invalid attempt to set a new value for property ${key} of ${vm} that does not has a setter.`);
                    }
                }
            },
            enumerable,
        });
    }

    function getLinkedElement$1(classList) {
        return classList[ViewModelReflection].vnode.elm;
    }
    // This needs some more work. ClassList is a weird DOM api because it
    // is a TokenList, but not an Array. For now, we are just implementing
    // the simplest one.
    // https://www.w3.org/TR/dom/#domtokenlist
    function ClassList(vm) {
        {
            assert.vm(vm);
        }
        defineProperty(this, ViewModelReflection, {
            value: vm,
            writable: false,
            enumerable: false,
            configurable: false,
        });
    }
    ClassList.prototype = {
        add() {
            const vm = this[ViewModelReflection];
            const { cmpClasses } = vm;
            const elm = getLinkedElement$1(this);
            // Add specified class values. If these classes already exist in attribute of the element, then they are ignored.
            forEach.call(arguments, (className) => {
                className = className + '';
                if (!cmpClasses[className]) {
                    cmpClasses[className] = true;
                    // this is not only an optimization, it is also needed to avoid adding the same
                    // class twice when the initial diffing algo kicks in without an old vm to track
                    // what was already added to the DOM.
                    if (vm.idx || vm.vnode.isRoot) {
                        // we intentionally make a sync mutation here and also keep track of the mutation
                        // for a possible rehydration later on without having to rehydrate just now.
                        elm.classList.add(className);
                    }
                }
            });
        },
        remove() {
            const vm = this[ViewModelReflection];
            const { cmpClasses, vnode } = vm;
            const elm = getLinkedElement$1(this);
            // Remove specified class values.
            forEach.call(arguments, (className) => {
                className = className + '';
                if (cmpClasses[className]) {
                    cmpClasses[className] = false;
                    // this is not only an optimization, it is also needed to avoid removing the same
                    // class twice when the initial diffing algo kicks in without an old vm to track
                    // what was already added to the DOM.
                    if (vm.idx || vnode.isRoot) {
                        // we intentionally make a sync mutation here when needed and also keep track of the mutation
                        // for a possible rehydration later on without having to rehydrate just now.
                        const ownerClass = vnode.data.class;
                        // This is only needed if the owner is not forcing that class to be present in case of conflicts.
                        if (isUndefined(ownerClass) || !ownerClass[className]) {
                            elm.classList.remove(className);
                        }
                    }
                }
            });
        },
        item(index) {
            const vm = this[ViewModelReflection];
            const { cmpClasses } = vm;
            // Return class value by index in collection.
            return getOwnPropertyNames(cmpClasses)
                .filter((className) => cmpClasses[className + ''])[index] || null;
        },
        toggle(className, force) {
            const vm = this[ViewModelReflection];
            const { cmpClasses } = vm;
            // When only one argument is present: Toggle class value; i.e., if class exists then remove it and return false, if not, then add it and return true.
            // When a second argument is present: If the second argument evaluates to true, add specified class value, and if it evaluates to false, remove it.
            if (arguments.length > 1) {
                if (force) {
                    this.add(className);
                }
                else if (!force) {
                    this.remove(className);
                }
                return !!force;
            }
            if (cmpClasses[className]) {
                this.remove(className);
                return false;
            }
            this.add(className);
            return true;
        },
        contains(className) {
            const vm = this[ViewModelReflection];
            const { cmpClasses } = vm;
            // Checks if specified class value exists in class attribute of the element.
            return !!cmpClasses[className];
        },
        toString() {
            const vm = this[ViewModelReflection];
            const { cmpClasses } = vm;
            return getOwnPropertyNames(cmpClasses).filter((className) => cmpClasses[className + '']).join(' ');
        }
    };

    /* eslint-enable */
    function piercingHook(membrane, target, key, value) {
        const { handler: { vm } } = membrane;
        {
            assert.vm(vm);
        }
        const { piercing } = Services;
        if (piercing) {
            const { component, vnode: { data }, def, context } = vm;
            let result = value;
            let next = true;
            const callback = (newValue) => {
                next = false;
                result = newValue;
            };
            for (let i = 0, len = piercing.length; next && i < len; ++i) {
                piercing[i].call(undefined, component, data, def, context, target, key, value, callback);
            }
            return result === value ? getReplica(membrane, result) : result;
        }
    }
    class PiercingMembraneHandler {
        constructor(vm) {
            {
                assert.vm(vm);
            }
            this.vm = vm;
        }
        get(membrane, target, key) {
            if (key === OwnerKey) {
                return undefined;
            }
            let value = target[key];
            return piercingHook(membrane, target, key, value);
        }
        set(membrane, target, key, newValue) {
            target[key] = newValue;
            return true;
        }
        deleteProperty(membrane, target, key) {
            delete target[key];
            return true;
        }
        apply(membrane, targetFn, thisArg, argumentsList) {
            return getReplica(membrane, targetFn.apply(thisArg, argumentsList));
        }
        construct(membrane, targetFn, argumentsList, newTarget) {
            {
                assert.isTrue(newTarget, `construct handler expects a 3rd argument with a newly created object that will be ignored in favor of the wrapped constructor.`);
            }
            return getReplica(membrane, new targetFn(...argumentsList));
        }
    }
    function pierce(vm, value) {
        {
            assert.vm(vm);
        }
        let { membrane } = vm;
        if (!membrane) {
            const handler = new PiercingMembraneHandler(vm);
            membrane = new Membrane(handler);
            vm.membrane = membrane;
        }
        return getReplica(membrane, value);
    }

    const { querySelector, querySelectorAll } = Element.prototype;
    function getLinkedElement$2(root) {
        return root[ViewModelReflection].vnode.elm;
    }
    function shadowRootQuerySelector(shadowRoot, selector) {
        const vm = shadowRoot[ViewModelReflection];
        {
            assert.isFalse(isBeingConstructed(vm), `this.root.querySelector() cannot be called during the construction of the custom element for ${this} because no content has been rendered yet.`);
        }
        const elm = getLinkedElement$2(shadowRoot);
        pierce(vm, elm);
        const querySelector = piercingHook(vm.membrane, elm, 'querySelector', elm.querySelector);
        return querySelector.call(elm, selector);
    }
    function shadowRootQuerySelectorAll(shadowRoot, selector) {
        const vm = shadowRoot[ViewModelReflection];
        {
            assert.isFalse(isBeingConstructed(vm), `this.root.querySelectorAll() cannot be called during the construction of the custom element for ${this} because no content has been rendered yet.`);
        }
        const elm = getLinkedElement$2(shadowRoot);
        pierce(vm, elm);
        const querySelectorAll = piercingHook(vm.membrane, elm, 'querySelectorAll', elm.querySelectorAll);
        return querySelectorAll.call(elm, selector);
    }
    function Root(vm) {
        {
            assert.vm(vm);
        }
        defineProperty(this, ViewModelReflection, {
            value: vm,
            writable: false,
            enumerable: false,
            configurable: false,
        });
    }
    Root.prototype = {
        get mode() {
            return 'closed';
        },
        get host() {
            return this[ViewModelReflection].component;
        },
        querySelector(selector) {
            const node = shadowRootQuerySelector(this, selector);
            {
                const vm = this[ViewModelReflection];
                if (!node && vm.component.querySelector(selector)) {
                    assert.logWarning(`this.root.querySelector() can only return elements from the template declaration of ${vm.component}. It seems that you are looking for elements that were passed via slots, in which case you should use this.querySelector() instead.`);
                }
            }
            return node;
        },
        querySelectorAll(selector) {
            const nodeList = shadowRootQuerySelectorAll(this, selector);
            {
                const vm = this[ViewModelReflection];
                if (nodeList.length === 0 && vm.component.querySelectorAll(selector).length) {
                    assert.logWarning(`this.root.querySelectorAll() can only return elements from template declaration of ${vm.component}. It seems that you are looking for elements that were passed via slots, in which case you should use this.querySelectorAll() instead.`);
                }
            }
            return nodeList;
        },
        toString() {
            const vm = this[ViewModelReflection];
            return `Current ShadowRoot for ${vm.component}`;
        }
    };
    function getFirstMatch(vm, elm, selector) {
        const nodeList = querySelectorAll.call(elm, selector);
        // search for all, and find the first node that is owned by the VM in question.
        for (let i = 0, len = nodeList.length; i < len; i += 1) {
            if (isNodeOwnedByVM(vm, nodeList[i])) {
                return pierce(vm, nodeList[i]);
            }
        }
        return null;
    }
    function getAllMatches(vm, elm, selector) {
        const nodeList = querySelectorAll.call(elm, selector);
        const filteredNodes = ArrayFilter.call(nodeList, (node) => isNodeOwnedByVM(vm, node));
        return pierce(vm, filteredNodes);
    }
    function isParentNodeKeyword(key) {
        return (key === 'parentNode' || key === 'parentElement');
    }
    // Registering a service to enforce the shadowDOM semantics via the Raptor membrane implementation
    register({
        piercing(component, data, def, context, target, key, value, callback) {
            const vm = component[ViewModelReflection];
            const { elm } = vm.vnode; // eslint-disable-line no-undef
            if (value) {
                if (value === querySelector) {
                    // TODO: it is possible that they invoke the querySelector() function via call or apply to set a new context, what should
                    // we do in that case? Right now this is essentially a bound function, but the original is not.
                    return callback((selector) => getFirstMatch(vm, target, selector));
                }
                if (value === querySelectorAll) {
                    // TODO: it is possible that they invoke the querySelectorAll() function via call or apply to set a new context, what should
                    // we do in that case? Right now this is essentially a bound function, but the original is not.
                    return callback((selector) => getAllMatches(vm, target, selector));
                }
                if (isParentNodeKeyword(key)) {
                    if (value === elm) {
                        // walking up via parent chain might end up in the shadow root element
                        return callback(component.root);
                    }
                    else if (target[OwnerKey] !== value[OwnerKey]) {
                        // cutting out access to something outside of the shadow of the current target (usually slots)
                        return callback();
                    }
                }
                if (value === elm) {
                    // prevent access to the original Host element
                    return callback(component);
                }
            }
        }
    });

    function getLinkedElement(cmp) {
        return cmp[ViewModelReflection].vnode.elm;
    }
    function querySelectorAllFromComponent(cmp, selectors) {
        const elm = getLinkedElement(cmp);
        return elm.querySelectorAll(selectors);
    }
    // This should be as performant as possible, while any initialization should be done lazily
    function ComponentElement() {
        {
            assert.vm(vmBeingConstructed);
            assert.vnode(vmBeingConstructed.vnode);
            assert.invariant(vmBeingConstructed.vnode.elm instanceof HTMLElement, `Component creation requires a DOM element to be associated to ${vmBeingConstructed.vnode}.`);
        }
        vmBeingConstructed.component = this;
        this[ViewModelReflection] = vmBeingConstructed;
    }
    /*eslint-disable*/
    ComponentElement.prototype = {
        // Raptor.Element APIs
        renderedCallback: noop,
        render: noop,
        // Web Component - The Good Parts
        connectedCallback: noop,
        disconnectedCallback: noop,
        // HTML Element - The Good Parts
        dispatchEvent(event) {
            const elm = getLinkedElement(this);
            const vm = this[ViewModelReflection];
            {
                const { type: evtName, composed, bubbles } = event;
                assert.isFalse(isBeingConstructed(vm), `this.dispatchEvent() should not be called during the construction of the custom element for ${this} because no one is listening for the event "${evtName}" just yet.`);
                if (bubbles && ('composed' in event && !composed)) {
                    assert.logWarning(`Invalid event "${evtName}" dispatched in element ${this}. Events with 'bubbles: true' must also be 'composed: true'. Without 'composed: true', the dispatched event will not be observable outside of your component.`);
                }
                if (vm.idx === 0) {
                    assert.logWarning(`Unreachable event "${evtName}" dispatched from disconnected element ${this}. Events can only reach the parent element after the element is connected (via connectedCallback) and before the element is disconnected(via disconnectedCallback).`);
                }
                if (!evtName.match(/^[a-z]+([a-z0-9]+)?$/)) {
                    assert.logWarning(`Invalid event type: '${evtName}' dispatched in element ${this}. Event name should only contain lowercase alphanumeric characters.`);
                }
            }
            // Pierce dispatchEvent so locker service has a chance to overwrite
            pierce(vm, elm);
            const dispatchEvent = piercingHook(vm.membrane, elm, 'dispatchEvent', elm.dispatchEvent);
            return dispatchEvent.call(elm, event);
        },
        addEventListener(type, listener) {
            const vm = this[ViewModelReflection];
            {
                assert.vm(vm);
                if (arguments.length > 2) {
                    // TODO: can we synthetically implement `passive` and `once`? Capture is probably ok not supporting it.
                    assert.logWarning(`this.addEventListener() on ${vm} does not support more than 2 arguments. Options to make the listener passive, once or capture are not allowed at the top level of the component's fragment.`);
                }
            }
            addComponentEventListener(vm, type, listener);
        },
        removeEventListener(type, listener) {
            const vm = this[ViewModelReflection];
            {
                assert.vm(vm);
                if (arguments.length > 2) {
                    assert.logWarning(`this.removeEventListener() on ${vm} does not support more than 2 arguments. Options to make the listener passive or capture are not allowed at the top level of the component's fragment.`);
                }
            }
            removeComponentEventListener(vm, type, listener);
        },
        getAttribute(attrName) {
            const vm = this[ViewModelReflection];
            // logging errors for experimentals and special attributes
            {
                assert.vm(vm);
                const propName = getPropNameFromAttrName(attrName);
                const { def: { props: publicPropsConfig } } = vm;
                if (publicPropsConfig[propName]) {
                    throw new ReferenceError(`Attribute "${attrName}" corresponds to public property ${propName} from ${vm}. Instead use \`this.${propName}\`. Only use \`getAttribute()\` to access global HTML attributes.`);
                }
                else if (GlobalHTMLProperties[propName] && GlobalHTMLProperties[propName].attribute) {
                    const { error, experimental } = GlobalHTMLProperties[propName];
                    if (error) {
                        assert.logError(error);
                    }
                    else if (experimental) {
                        assert.logError(`Attribute \`${attrName}\` is an experimental attribute that is not standardized or supported by all browsers. Property "${propName}" and attribute "${attrName}" are ignored.`);
                    }
                }
            }
            const elm = getLinkedElement(this);
            return elm.getAttribute.apply(elm, ArraySlice.call(arguments));
        },
        getBoundingClientRect() {
            const elm = getLinkedElement(this);
            {
                assert.isFalse(isBeingConstructed(this[ViewModelReflection]), `this.getBoundingClientRect() should not be called during the construction of the custom element for ${this} because the element is not yet in the DOM, instead, you can use it in one of the available life-cycle hooks.`);
            }
            return elm.getBoundingClientRect();
        },
        querySelector(selectors) {
            const vm = this[ViewModelReflection];
            {
                assert.isFalse(isBeingConstructed(vm), `this.querySelector() cannot be called during the construction of the custom element for ${this} because no children has been added to this element yet.`);
            }
            const nodeList = querySelectorAllFromComponent(this, selectors);
            for (let i = 0, len = nodeList.length; i < len; i += 1) {
                if (wasNodePassedIntoVM(vm, nodeList[i])) {
                    // TODO: locker service might need to return a membrane proxy
                    return pierce(vm, nodeList[i]);
                }
            }
            {
                if (shadowRootQuerySelector(this.root, selectors)) {
                    assert.logWarning(`this.querySelector() can only return elements that were passed into ${vm.component} via slots. It seems that you are looking for elements from your template declaration, in which case you should use this.root.querySelector() instead.`);
                }
            }
            return null;
        },
        querySelectorAll(selectors) {
            const vm = this[ViewModelReflection];
            {
                assert.isFalse(isBeingConstructed(vm), `this.querySelectorAll() cannot be called during the construction of the custom element for ${this} because no children has been added to this element yet.`);
            }
            const nodeList = querySelectorAllFromComponent(this, selectors);
            // TODO: locker service might need to do something here
            const filteredNodes = ArrayFilter.call(nodeList, (node) => wasNodePassedIntoVM(vm, node));
            {
                if (filteredNodes.length === 0 && shadowRootQuerySelectorAll(this.root, selectors).length) {
                    assert.logWarning(`this.querySelectorAll() can only return elements that were passed into ${vm.component} via slots. It seems that you are looking for elements from your template declaration, in which case you should use this.root.querySelectorAll() instead.`);
                }
            }
            return pierce(vm, filteredNodes);
        },
        get tagName() {
            const elm = getLinkedElement(this);
            return elm.tagName + ''; // avoiding side-channeling
        },
        get tabIndex() {
            const elm = getLinkedElement(this);
            return elm.tabIndex;
        },
        set tabIndex(value) {
            const vm = this[ViewModelReflection];
            {
                assert.isFalse(isRendering, `Setting property "tabIndex" of ${toString(value)} during the rendering process of ${vmBeingRendered} is invalid. The render phase must have no side effects on the state of any component.`);
                if (isBeingConstructed(vm)) {
                    assert.fail(`Setting property "tabIndex" during the construction process of ${vm} is invalid.`);
                }
            }
            if (isBeingConstructed(vm)) {
                return;
            }
            const elm = getLinkedElement(this);
            elm.tabIndex = value;
        },
        get classList() {
            const vm = this[ViewModelReflection];
            {
                assert.vm(vm);
            }
            let { classListObj } = vm;
            // lazy creation of the ClassList Object the first time it is accessed.
            if (isUndefined(classListObj)) {
                vm.cmpClasses = {};
                classListObj = new ClassList(vm);
                vm.classListObj = classListObj;
            }
            return classListObj;
        },
        get root() {
            const vm = this[ViewModelReflection];
            {
                assert.vm(vm);
            }
            let { cmpRoot } = vm;
            // lazy creation of the ShadowRoot Object the first time it is accessed.
            if (isUndefined(cmpRoot)) {
                cmpRoot = new Root(vm);
                vm.cmpRoot = cmpRoot;
            }
            return cmpRoot;
        },
        toString() {
            const vm = this[ViewModelReflection];
            {
                assert.vm(vm);
            }
            const { vnode: { sel, data: { attrs } } } = vm;
            const is = attrs && attrs.is;
            return `<${sel}${is ? ' is="${is}' : ''}>`;
        },
    };
    // Global HTML Attributes
    {
        getOwnPropertyNames(GlobalHTMLProperties).forEach((propName) => {
            if (propName in ComponentElement.prototype) {
                return; // no need to redefine something that we are already exposing
            }
            defineProperty(ComponentElement.prototype, propName, {
                get: function () {
                    const vm = this[ViewModelReflection];
                    assert.vm(vm);
                    const { error, attribute, readOnly, experimental } = GlobalHTMLProperties[propName];
                    const msg = [];
                    msg.push(`Accessing the global HTML property "${propName}" in ${vm} is disabled.`);
                    if (error) {
                        msg.push(error);
                    }
                    else {
                        if (experimental) {
                            msg.push(`This is an experimental property that is not standardized or supported by all browsers. Property "${propName}" and attribute "${attribute}" are ignored.`);
                        }
                        if (readOnly) {
                            // TODO - need to improve this message
                            msg.push(`Property is read-only.`);
                        }
                        if (attribute) {
                            msg.push(`"Instead access it via the reflective attribute "${attribute}" with one of these techniques:`);
                            msg.push(`  * Use \`this.getAttribute("${attribute}")\` to access the attribute value. This option is best suited for accessing the value in a getter during the rendering process.`);
                            msg.push(`  * Declare \`static observedAttributes = ["${attribute}"]\` and use \`attributeChangedCallback(attrName, oldValue, newValue)\` to get a notification each time the attribute changes. This option is best suited for reactive programming, eg. fetching new data each time the attribute is updated.`);
                        }
                    }
                    console.log(msg.join('\n'));
                    return; // explicit undefined
                },
                enumerable: false,
            });
        });
    }
    freeze(ComponentElement);
    seal(ComponentElement.prototype);

    /**
     * This module is responsible for producing the ComponentDef object that is always
     * accessible via `vm.def`. This is lazily created during the creation of the first
     * instance of a component class, and shared across all instances.
     *
     * This structure can be used to synthetically create proxies, and understand the
     * shape of a component. It is also used internally to apply extra optimizations.
     */
    /*eslint-enable*/
    const ViewModelReflection = Symbol('internal');
    let observableHTMLAttrs;
    {
        observableHTMLAttrs = getOwnPropertyNames(GlobalHTMLProperties).reduce((acc, key) => {
            const globalProperty = GlobalHTMLProperties[key];
            if (globalProperty && globalProperty.attribute) {
                acc[globalProperty.attribute] = true;
            }
            return acc;
        }, create(null));
    }
    const CtorToDefMap = new WeakMap();
    const COMPUTED_GETTER_MASK = 1;
    const COMPUTED_SETTER_MASK = 2;
    function isElementComponent(Ctor, protoSet) {
        protoSet = protoSet || [];
        if (!Ctor || ArrayIndexOf.call(protoSet, Ctor) >= 0) {
            return false; // null, undefined, or circular prototype definition
        }
        const proto = getPrototypeOf(Ctor);
        if (proto === ComponentElement) {
            return true;
        }
        getComponentDef(proto); // ensuring that the prototype chain is already expanded
        ArrayPush.call(protoSet, Ctor);
        return isElementComponent(proto, protoSet);
    }
    function createComponentDef(Ctor) {
        {
            assert.isTrue(isElementComponent(Ctor), `${Ctor} is not a valid component, or does not extends Element from "engine". You probably forgot to add the extend clause on the class declaration.`);
            // local to dev block
            const ctorName = Ctor.name;
            assert.isTrue(ctorName && isString(ctorName), `${toString$1(Ctor)} should have a "name" property with string value, but found ${ctorName}.`);
            assert.isTrue(Ctor.constructor, `Missing ${ctorName}.constructor, ${ctorName} should have a "constructor" property.`);
        }
        const name = Ctor.name;
        let props = getPublicPropertiesHash(Ctor);
        let methods = getPublicMethodsHash(Ctor);
        let observedAttrs = getObservedAttributesHash(Ctor);
        let wire$$1 = getWireHash(Ctor);
        let track$$1 = getTrackHash(Ctor);
        const proto = Ctor.prototype;
        for (let propName in props) {
            const propDef = props[propName];
            // initializing getters and setters for each public prop on the target prototype
            const descriptor = getOwnPropertyDescriptor(proto, propName);
            const { config } = propDef;
            if (COMPUTED_SETTER_MASK & config || COMPUTED_GETTER_MASK & config) {
                {
                    assert.invariant(!descriptor || (isFunction(descriptor.get) || isFunction(descriptor.set)), `Invalid ${name}.prototype.${propName} definition, it cannot be a prototype definition if it is a public property. Instead use the constructor to define it.`);
                    const mustHaveGetter = COMPUTED_GETTER_MASK & config;
                    const mustHaveSetter = COMPUTED_SETTER_MASK & config;
                    if (mustHaveGetter) {
                        assert.isTrue(isObject(descriptor) && isFunction(descriptor.get), `Missing getter for property ${propName} decorated with @api in ${name}`);
                    }
                    if (mustHaveSetter) {
                        assert.isTrue(isObject(descriptor) && isFunction(descriptor.set), `Missing setter for property ${propName} decorated with @api in ${name}`);
                        assert.isTrue(mustHaveGetter, `Missing getter for property ${propName} decorated with @api in ${name}. You cannot have a setter without the corresponding getter.`);
                    }
                }
                createPublicAccessorDescriptor(proto, propName, descriptor);
            }
            else {
                createPublicPropertyDescriptor(proto, propName, descriptor);
            }
        }
        if (wire$$1) {
            for (let propName in wire$$1) {
                if (wire$$1[propName].method) {
                    // for decorated methods we need to do nothing
                    continue;
                }
                const descriptor = getOwnPropertyDescriptor(proto, propName);
                // TODO: maybe these conditions should be always applied.
                {
                    const { get, set, configurable, writable } = descriptor || EmptyObject;
                    assert.isTrue(!get && !set, `Compiler Error: A decorator can only be applied to a public field.`);
                    assert.isTrue(configurable !== false, `Compiler Error: A decorator can only be applied to a configurable property.`);
                    assert.isTrue(writable !== false, `Compiler Error: A decorator can only be applied to a writable property.`);
                }
                // initializing getters and setters for each public prop on the target prototype
                createWiredPropertyDescriptor(proto, propName, descriptor);
            }
        }
        if (track$$1) {
            for (let propName in track$$1) {
                const descriptor = getOwnPropertyDescriptor(proto, propName);
                // TODO: maybe these conditions should be always applied.
                {
                    const { get, set, configurable, writable } = descriptor || EmptyObject;
                    assert.isTrue(!get && !set, `Compiler Error: A decorator can only be applied to a public field.`);
                    assert.isTrue(configurable !== false, `Compiler Error: A decorator can only be applied to a configurable property.`);
                    assert.isTrue(writable !== false, `Compiler Error: A decorator can only be applied to a writable property.`);
                }
                // initializing getters and setters for each public prop on the target prototype
                createTrackedPropertyDescriptor(proto, propName, descriptor);
            }
        }
        const superProto = getPrototypeOf(Ctor);
        if (superProto !== ComponentElement) {
            const superDef = getComponentDef(superProto);
            props = assign(create(null), superDef.props, props);
            methods = assign(create(null), superDef.methods, methods);
            wire$$1 = (superDef.wire || wire$$1) ? assign(create(null), superDef.wire, wire$$1) : undefined;
        }
        const descriptors = createDescriptorMap(props, methods);
        const def = {
            name,
            wire: wire$$1,
            track: track$$1,
            props,
            methods,
            observedAttrs,
            descriptors,
        };
        {
            freeze(Ctor.prototype);
            freeze(wire$$1);
            freeze(props);
            freeze(methods);
            freeze(observedAttrs);
            for (let key in def) {
                defineProperty(def, key, {
                    configurable: false,
                    writable: false,
                });
            }
        }
        return def;
    }
    function createGetter(key) {
        return function () {
            const vm = this[ViewModelReflection];
            return vm.component[key];
        };
    }
    function createSetter(key) {
        return function (newValue) {
            const vm = this[ViewModelReflection];
            // logic for setting new properties of the element directly from the DOM
            // will only be allowed for root elements created via createElement()
            if (!vm.vnode.isRoot) {
                {
                    assert.logError(`Invalid attempt to set property ${key} from ${vm} to ${newValue}. This property was decorated with @api, and can only be changed via the template.`);
                }
                return;
            }
            const observable = isObservable(newValue);
            newValue = observable ? getReactiveProxy(newValue) : newValue;
            {
                if (!observable && newValue !== null && isObject(newValue)) {
                    assert.logWarning(`Assigning a non-reactive value ${newValue} to member property ${key} of ${vm} is not common because mutations on that value cannot be observed.`);
                }
            }
            prepareForPropUpdate(vm);
            vm.component[key] = newValue;
        };
    }
    function createMethodCaller(key) {
        return function () {
            const vm = this[ViewModelReflection];
            return vm.component[key].apply(vm.component, ArraySlice.call(arguments));
        };
    }
    const { getAttribute, setAttribute, removeAttribute } = Element.prototype;
    function getAttributePatched(attrName) {
        const vm = this[ViewModelReflection];
        {
            assert.vm(vm);
            assertPublicAttributeColission(vm, attrName);
        }
        return getAttribute.apply(this, ArraySlice.call(arguments));
    }
    function setAttributePatched(attrName, newValue) {
        const vm = this[ViewModelReflection];
        {
            assert.vm(vm);
            assertTemplateMutationViolation(vm, attrName);
            assertPublicAttributeColission(vm, attrName);
        }
        const { def: { observedAttrs } } = vm;
        const oldValue = getAttribute.call(this, attrName);
        setAttribute.apply(this, ArraySlice.call(arguments));
        newValue = getAttribute.call(this, attrName);
        if (!isNull(attrName) && attrName in observedAttrs && oldValue !== newValue) {
            invokeComponentAttributeChangedCallback(vm, attrName, oldValue, newValue);
        }
    }
    function removeAttributePatched(attrName) {
        const vm = this[ViewModelReflection];
        {
            assert.vm(vm);
            assertTemplateMutationViolation(vm, attrName);
            assertPublicAttributeColission(vm, attrName);
        }
        const { def: { observedAttrs } } = vm;
        const oldValue = getAttribute.call(this, attrName);
        removeAttribute.apply(this, ArraySlice.call(arguments));
        const newValue = getAttribute.call(this, attrName);
        if (!isNull(attrName) && attrName in observedAttrs && oldValue !== newValue) {
            invokeComponentAttributeChangedCallback(vm, attrName, oldValue, newValue);
        }
    }
    function assertPublicAttributeColission(vm, attrName) {
        const lowercasedAttrName = isString(attrName) ? attrName.toLocaleLowerCase() : null;
        const propName = getPropNameFromAttrName(lowercasedAttrName);
        const { def: { props: propsConfig } } = vm;
        if (propsConfig && propsConfig[propName]) {
            assert.logError(`Invalid attribute "${lowercasedAttrName}" for ${vm}. Instead access the public property with \`element.${propName};\`.`);
        }
    }
    function assertTemplateMutationViolation(vm, attrName) {
        const { vnode: { isRoot } } = vm;
        if (!isAttributeChangeControlled(attrName) && !isRoot) {
            assert.logError(`Invalid operation on Element ${vm}. Elements created via a template should not be mutated using DOM APIs. Instead of attempting to update this element directly to change the value of attribute "${attrName}", you can update the state of the component, and let the engine to rehydrate the element accordingly.`);
        }
        // attribute change control must be released every time its value is checked
        resetAttibuteChangeControl();
    }
    let controlledAttributeChange = false;
    let controlledAttributeName;
    function isAttributeChangeControlled(attrName) {
        return controlledAttributeChange && attrName === controlledAttributeName;
    }
    function resetAttibuteChangeControl() {
        controlledAttributeChange = false;
        controlledAttributeName = undefined;
    }
    function prepareForAttributeMutationFromTemplate(elm, key) {
        if (elm[ViewModelReflection]) {
            // TODO: we should guarantee that the methods of the element are all patched
            controlledAttributeChange = true;
            controlledAttributeName = key;
        }
    }
    function createDescriptorMap(publicProps, publicMethodsConfig) {
        // replacing mutators and accessors on the element itself to catch any mutation
        const descriptors = {
            getAttribute: {
                value: getAttributePatched,
                configurable: true,
            },
            setAttribute: {
                value: setAttributePatched,
                configurable: true,
            },
            removeAttribute: {
                value: removeAttributePatched,
                configurable: true,
            },
        };
        // expose getters and setters for each public props on the Element
        for (let key in publicProps) {
            descriptors[key] = {
                get: createGetter(key),
                set: createSetter(key),
            };
        }
        // expose public methods as props on the Element
        for (let key in publicMethodsConfig) {
            descriptors[key] = {
                value: createMethodCaller(key),
                configurable: true,
            };
        }
        return descriptors;
    }
    function getTrackHash(target) {
        const track$$1 = target.track;
        if (!track$$1 || !getOwnPropertyNames(track$$1).length) {
            return;
        }
        // TODO: check that anything in `track` is correctly defined in the prototype
        return assign(create(null), track$$1);
    }
    function getWireHash(target) {
        const wire$$1 = target.wire;
        if (!wire$$1 || !getOwnPropertyNames(wire$$1).length) {
            return;
        }
        // TODO: check that anything in `wire` is correctly defined in the prototype
        return assign(create(null), wire$$1);
    }
    function getPublicPropertiesHash(target) {
        const props = target.publicProps;
        if (!props || !getOwnPropertyNames(props).length) {
            return EmptyObject;
        }
        return getOwnPropertyNames(props).reduce((propsHash, propName) => {
            {
                if (GlobalHTMLProperties[propName] && GlobalHTMLProperties[propName].attribute) {
                    const { error, attribute, experimental } = GlobalHTMLProperties[propName];
                    const msg = [];
                    if (error) {
                        msg.push(error);
                    }
                    else if (experimental) {
                        msg.push(`"${propName}" is an experimental property that is not standardized or supported by all browsers. You should not use "${propName}" and attribute "${attribute}" in your component.`);
                    }
                    else {
                        msg.push(`"${propName}" is a global HTML property. Instead access it via the reflective attribute "${attribute}" with one of these techniques:`);
                        msg.push(`  * Use \`this.getAttribute("${attribute}")\` to access the attribute value. This option is best suited for accessing the value in a getter during the rendering process.`);
                        msg.push(`  * Declare \`static observedAttributes = ["${attribute}"]\` and use \`attributeChangedCallback(attrName, oldValue, newValue)\` to get a notification each time the attribute changes. This option is best suited for reactive programming, eg. fetching new data each time the attribute is updated.`);
                    }
                    console.error(msg.join('\n'));
                }
            }
            propsHash[propName] = assign({ config: 0 }, props[propName]);
            return propsHash;
        }, create(null));
    }
    function getPublicMethodsHash(target) {
        const publicMethods = target.publicMethods;
        if (!publicMethods || !publicMethods.length) {
            return EmptyObject;
        }
        return publicMethods.reduce((methodsHash, methodName) => {
            methodsHash[methodName] = 1;
            {
                assert.isTrue(isFunction(target.prototype[methodName]), `Component "${target.name}" should have a method \`${methodName}\` instead of ${target.prototype[methodName]}.`);
                freeze(target.prototype[methodName]);
            }
            return methodsHash;
        }, create(null));
    }
    function getObservedAttributesHash(target) {
        const observedAttributes = target.observedAttributes;
        if (!observedAttributes || !observedAttributes.length) {
            return EmptyObject;
        }
        return observedAttributes.reduce((observedAttributes, attrName) => {
            {
                const propName = getPropNameFromAttrName(attrName);
                // Check if it is a user defined public property
                if (target.publicProps && target.publicProps[propName]) {
                    assert.fail(`Invalid entry "${attrName}" in component ${target.name} observedAttributes. To observe mutations of the public property "${propName}" you can define a public getter and setter decorated with @api in component ${target.name}.`);
                }
                else if (!observableHTMLAttrs[attrName] && (GlobalHTMLProperties[propName] && GlobalHTMLProperties[propName].attribute)) {
                    // Check for misspellings
                    assert.fail(`Invalid entry "${attrName}" in component ${target.name} observedAttributes. "${attrName}" is not a valid global HTML Attribute. Did you mean "${GlobalHTMLProperties[propName].attribute}"? See https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes`);
                }
                else if (!observableHTMLAttrs[attrName] && (attrName.indexOf('data-') === -1 && attrName.indexOf('aria-') === -1)) {
                    // Attribute is not valid observable HTML Attribute
                    assert.fail(`Invalid entry "${attrName}" in component ${target.name} observedAttributes. "${attrName}" is not a valid global HTML Attribute. See https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes`);
                }
            }
            observedAttributes[attrName] = 1;
            return observedAttributes;
        }, create(null));
    }
    function getComponentDef(Ctor) {
        let def = CtorToDefMap.get(Ctor);
        if (def) {
            return def;
        }
        def = createComponentDef(Ctor);
        CtorToDefMap.set(Ctor, def);
        return def;
    }

    const EmptySlots = create(null);
    function getSlotsetValue(slotset, slotName) {
        {
            assert.isTrue(isObject(slotset), `Invalid slotset value ${toString$1(slotset)}`);
        }
        // TODO: mark slotName as reactive
        return slotset && slotset[slotName];
    }
    const slotsetProxyHandler = {
        get: (slotset, key) => getSlotsetValue(slotset, key),
        set: () => {
            {
                assert.logError(`$slotset object cannot be mutated from template.`);
            }
            return false;
        },
        deleteProperty: () => {
            {
                assert.logError(`$slotset object cannot be mutated from template.`);
            }
            return false;
        },
        apply() {
            {
                assert.fail(`invalid call invocation from slotset`);
            }
        },
        construct() {
            {
                assert.fail(`invalid construction invocation from slotset`);
            }
        },
    };
    function validateSlots(vm, html) {
        {
            let { cmpSlots = EmptySlots } = vm;
            const { slots = [] } = html;
            for (let slotName in cmpSlots) {
                if (ArrayIndexOf.call(slots, slotName) === -1) {
                    // TODO: this should never really happen because the compiler should always validate
                    console.warn(`Ignoring unknown provided slot name "${slotName}" in ${vm}. This is probably a typo on the slot attribute.`);
                }
            }
        }
    }
    function validateFields(vm, html) {
        {
            let { component } = vm;
            // validating identifiers used by template that should be provided by the component
            const { ids = [] } = html;
            ids.forEach((propName) => {
                if (!(propName in component)) {
                    console.warn(`The template rendered by ${vm} references \`this.${propName}\`, which is not declared. This is likely a typo in the template.`);
                }
                else if (hasOwnProperty.call(component, propName)) {
                    {
                        assert.fail(`${component}'s template is accessing \`this.${toString$1(propName)}\` directly, which is considered a private field. Instead access it via a getter or make it reactive by moving it to \`this.state.${toString$1(propName)}\`.`);
                    }
                }
            });
        }
    }
    function validateTemplate(vm, html) {
        validateSlots(vm, html);
        validateFields(vm, html);
    }
    function applyTokenToHost(vm, html) {
        const { vnode, context } = vm;
        const oldToken = context.tplToken;
        const newToken = html.token;
        if (oldToken !== newToken) {
            const host = vnode.elm;
            // Remove the token currently applied to the host element if different than the one associated
            // with the current template
            if (!isUndefined(oldToken)) {
                {
                    prepareForAttributeMutationFromTemplate(host, oldToken);
                }
                host.removeAttribute(oldToken);
            }
            // If the template has a token apply the token to the host element
            if (!isUndefined(newToken)) {
                {
                    prepareForAttributeMutationFromTemplate(host, newToken);
                }
                host.setAttribute(newToken, '');
            }
        }
    }
    function evaluateTemplate(vm, html) {
        {
            assert.vm(vm);
            assert.isTrue(isFunction(html), `evaluateTemplate() second argument must be a function instead of ${html}`);
        }
        // TODO: add identity to the html functions
        let { component, context, cmpSlots = EmptySlots, cmpTemplate } = vm;
        // reset the cache momizer for template when needed
        if (html !== cmpTemplate) {
            applyTokenToHost(vm, html);
            vm.cmpTemplate = html;
            context.tplCache = create(null);
            context.tplToken = html.token;
            {
                validateTemplate(vm, html);
            }
        }
        {
            assert.isTrue(isObject(context.tplCache), `vm.context.tplCache must be an object associated to ${cmpTemplate}.`);
        }
        const { proxy: slotset, revoke: slotsetRevoke } = Proxy.revocable(cmpSlots, slotsetProxyHandler);
        let vnodes = html.call(undefined, api, component, slotset, context.tplCache);
        {
            assert.invariant(isArray(vnodes), `Compiler should produce html functions that always return an array.`);
        }
        slotsetRevoke();
        return vnodes;
    }

    let isRendering = false;
    let vmBeingRendered = null;
    function invokeComponentCallback(vm, fn, fnCtx, args) {
        const { context } = vm;
        const ctx = currentContext;
        establishContext(context);
        let result, error;
        try {
            // TODO: membrane proxy for all args that are objects
            result = fn.apply(fnCtx, args);
        }
        catch (e) {
            error = e;
        }
        establishContext(ctx);
        if (error) {
            error.wcStack = getComponentStack(vm);
            throw error; // rethrowing the original error after restoring the context
        }
        return result;
    }
    function invokeComponentMethod(vm, methodName, args) {
        const { component } = vm;
        return invokeComponentCallback(vm, component[methodName], component, args);
    }
    function invokeComponentConstructor(vm, Ctor) {
        const { context } = vm;
        const ctx = currentContext;
        establishContext(context);
        let component, error;
        try {
            component = new Ctor();
        }
        catch (e) {
            error = e;
        }
        establishContext(ctx);
        if (error) {
            error.wcStack = getComponentStack(vm);
            throw error; // rethrowing the original error after restoring the context
        }
        return component;
    }
    function invokeComponentRenderMethod(vm) {
        const { component, context } = vm;
        const ctx = currentContext;
        establishContext(context);
        const isRenderingInception = isRendering;
        const vmBeingRenderedInception = vmBeingRendered;
        isRendering = true;
        vmBeingRendered = vm;
        let result, error;
        try {
            const html = component.render();
            if (isFunction(html)) {
                result = evaluateTemplate(vm, html);
            }
            else if (!isUndefined(html)) {
                {
                    assert.fail(`The template rendered by ${vm} must return an imported template tag (e.g.: \`import html from "./mytemplate.html"\`) or undefined, instead, it has returned ${html}.`);
                }
            }
        }
        catch (e) {
            error = e;
        }
        isRendering = isRenderingInception;
        vmBeingRendered = vmBeingRenderedInception;
        establishContext(ctx);
        if (error) {
            error.wcStack = getComponentStack(vm);
            throw error; // rethrowing the original error after restoring the context
        }
        return result || [];
    }
    function invokeComponentAttributeChangedCallback(vm, attrName, oldValue, newValue) {
        const { component, context } = vm;
        const { attributeChangedCallback } = component;
        if (isUndefined(attributeChangedCallback)) {
            return;
        }
        const ctx = currentContext;
        establishContext(context);
        let error;
        try {
            component.attributeChangedCallback(attrName, oldValue, newValue);
        }
        catch (e) {
            error = e;
        }
        establishContext(ctx);
        if (error) {
            error.wcStack = getComponentStack(vm);
            throw error; // rethrowing the original error after restoring the context
        }
    }
    function getComponentStack(vm) {
        const wcStack = [];
        let elm = vm.vnode.elm;
        do {
            const vm = elm[ViewModelReflection];
            if (!isUndefined(vm)) {
                wcStack.push(vm.component.toString());
            }
            elm = elm.parentElement;
        } while (elm);
        return wcStack.reverse().join('\n\t');
    }

    /*eslint-enable*/
    let vmBeingConstructed = null;
    function isBeingConstructed(vm) {
        {
            assert.vm(vm);
        }
        return vmBeingConstructed === vm;
    }
    function createComponent(vm, Ctor) {
        {
            assert.vm(vm);
        }
        // create the component instance
        const vmBeingConstructedInception = vmBeingConstructed;
        vmBeingConstructed = vm;
        const component = invokeComponentConstructor(vm, Ctor);
        vmBeingConstructed = vmBeingConstructedInception;
        {
            assert.isTrue(vm.component === component, `Invalid construction for ${vm}, maybe you are missing the call to super() on classes extending Element.`);
            const { track } = getComponentDef(Ctor);
            if ('state' in component && (!track || !track.state)) {
                assert.logWarning(`Non-trackable component state detected in ${component}. Updates to state property will not be reactive. To make state reactive, add @track decorator.`);
            }
        }
    }
    function linkComponent(vm) {
        {
            assert.vm(vm);
        }
        // wiring service
        const { def: { wire } } = vm;
        if (wire) {
            const { wiring } = Services;
            if (wiring) {
                invokeServiceHook(vm, wiring);
            }
        }
    }
    function clearListeners(vm) {
        {
            assert.vm(vm);
        }
        const { deps } = vm;
        const len = deps.length;
        if (len) {
            for (let i = 0; i < len; i += 1) {
                const set = deps[i];
                const pos = ArrayIndexOf.call(deps[i], vm);
                {
                    assert.invariant(pos > -1, `when clearing up deps, the vm must be part of the collection.`);
                }
                ArraySplice.call(set, pos, 1);
            }
            deps.length = 0;
        }
    }
    function createComponentListener() {
        return function handler(event) {
            dispatchComponentEvent(handler.vm, event);
        };
    }
    function addComponentEventListener(vm, eventName, newHandler) {
        {
            assert.vm(vm);
            assert.invariant(!isRendering, `${vmBeingRendered}.render() method has side effects on the state of ${vm} by adding a new event listener for "${eventName}".`);
        }
        let { cmpEvents, cmpListener, idx: vmIdx } = vm;
        if (isUndefined(cmpEvents)) {
            // this piece of code must be in sync with modules/component-events
            vm.cmpEvents = cmpEvents = create(null);
            vm.cmpListener = cmpListener = createComponentListener();
            cmpListener.vm = vm;
        }
        if (isUndefined(cmpEvents[eventName])) {
            cmpEvents[eventName] = [];
            // this is not only an optimization, it is also needed to avoid adding the same
            // listener twice when the initial diffing algo kicks in without an old vm to track
            // what was already added to the DOM.
            if (!vm.isDirty || vmIdx > 0) {
                // if the element is already in the DOM and rendered, we intentionally make a sync mutation
                // here and also keep track of the mutation for a possible rehydration later on without having
                // to rehydrate just now.
                const { vnode: { elm } } = vm;
                elm.addEventListener(eventName, cmpListener, false);
            }
        }
        {
            if (cmpEvents[eventName] && ArrayIndexOf.call(cmpEvents[eventName], newHandler) !== -1) {
                assert.logWarning(`${vm} has duplicate listeners for event "${eventName}". Instead add the event listener in the connectedCallback() hook.`);
            }
        }
        ArrayPush.call(cmpEvents[eventName], newHandler);
    }
    function removeComponentEventListener(vm, eventName, oldHandler) {
        {
            assert.vm(vm);
            assert.invariant(!isRendering, `${vmBeingRendered}.render() method has side effects on the state of ${vm} by removing an event listener for "${eventName}".`);
        }
        const { cmpEvents } = vm;
        if (cmpEvents) {
            const handlers = cmpEvents[eventName];
            const pos = handlers && ArrayIndexOf.call(handlers, oldHandler);
            if (handlers && pos > -1) {
                ArraySplice.call(cmpEvents[eventName], pos, 1);
                return;
            }
        }
        {
            assert.logWarning(`Did not find event listener ${oldHandler} for event "${eventName}" on ${vm}. Instead only remove an event listener once.`);
        }
    }
    function dispatchComponentEvent(vm, event) {
        {
            assert.vm(vm);
            assert.invariant(event instanceof Event, `dispatchComponentEvent() must receive an event instead of ${event}`);
        }
        const { cmpEvents, component } = vm;
        const { type } = event;
        {
            assert.invariant(cmpEvents && cmpEvents[type] && cmpEvents[type].length, `dispatchComponentEvent() should only be invoked if there is at least one listener in queue for ${type} on ${vm}.`);
        }
        const handlers = cmpEvents[type];
        let uninterrupted = true;
        const { stopImmediatePropagation } = event;
        event.stopImmediatePropagation = function () {
            uninterrupted = false;
            stopImmediatePropagation.call(this);
        };
        const e = pierce(vm, event);
        for (let i = 0, len = handlers.length; uninterrupted && i < len; i += 1) {
            // TODO: only if the event is `composed` it can be dispatched
            invokeComponentCallback(vm, handlers[i], component, [e]);
        }
        // restoring original methods
        event.stopImmediatePropagation = stopImmediatePropagation;
    }
    function addComponentSlot(vm, slotName, newValue) {
        {
            assert.vm(vm);
            assert.invariant(!isRendering, `${vmBeingRendered}.render() method has side effects on the state of slot ${slotName} in ${vm}`);
            assert.isTrue(isArray(newValue) && newValue.length > 0, `Slots can only be set to a non-empty array, instead received ${toString$1(newValue)} for slot ${slotName} in ${vm}.`);
        }
        let { cmpSlots } = vm;
        let oldValue = cmpSlots && cmpSlots[slotName];
        // TODO: hot-slots names are those slots used during the last rendering cycle, and only if
        // one of those is changed, the vm should be marked as dirty.
        // TODO: Issue #133
        if (!isArray(newValue)) {
            newValue = undefined;
        }
        if (oldValue !== newValue) {
            if (isUndefined(cmpSlots)) {
                vm.cmpSlots = cmpSlots = create(null);
            }
            cmpSlots[slotName] = newValue;
            if (!vm.isDirty) {
                markComponentAsDirty(vm);
            }
        }
    }
    function removeComponentSlot(vm, slotName) {
        {
            assert.vm(vm);
            assert.invariant(!isRendering, `${vmBeingRendered}.render() method has side effects on the state of slot ${slotName} in ${vm}`);
        }
        // TODO: hot-slots names are those slots used during the last rendering cycle, and only if
        // one of those is changed, the vm should be marked as dirty.
        const { cmpSlots } = vm;
        if (cmpSlots && cmpSlots[slotName]) {
            cmpSlots[slotName] = undefined; // delete will de-opt the cmpSlots, better to set it to undefined
            if (!vm.isDirty) {
                markComponentAsDirty(vm);
            }
        }
    }
    function renderComponent(vm) {
        {
            assert.vm(vm);
            assert.invariant(vm.isDirty, `${vm} is not dirty.`);
        }
        clearListeners(vm);
        const vnodes = invokeComponentRenderMethod(vm);
        vm.isDirty = false;
        {
            assert.invariant(isArray(vnodes), `${vm}.render() should always return an array of vnodes instead of ${vnodes}`);
        }
        return vnodes;
    }
    function markComponentAsDirty(vm) {
        {
            assert.vm(vm);
            assert.isFalse(vm.isDirty, `markComponentAsDirty() for ${vm} should not be called when the componet is already dirty.`);
            assert.isFalse(isRendering, `markComponentAsDirty() for ${vm} cannot be called during rendering of ${vmBeingRendered}.`);
        }
        vm.isDirty = true;
    }

    function insert(vnode) {
        {
            assert.vnode(vnode);
            assert.vm(vnode.vm);
            if (vnode.vm.idx > 0) {
                assert.isTrue(vnode.isRoot, `${vnode.vm} is already inserted.`);
            }
        }
        const { vm } = vnode;
        if (vm.idx > 0) {
            destroy(vnode); // moving the element from one place to another is observable via life-cycle hooks
        }
        addInsertionIndex(vm);
        if (vm.isDirty) {
            // this code path guarantess that when patching the custom element for the first time,
            // the body is computed only after the element is in the DOM, otherwise the hooks
            // for any children's vnode are not going to be useful.
            rehydrate(vm);
        }
    }
    function update(oldVnode, vnode) {
        {
            assert.vnode(vnode);
            assert.vm(vnode.vm);
        }
        const { vm } = vnode;
        // TODO: we don't really need this block anymore, but it will require changes
        // on many tests that are just patching the element directly.
        if (vm.idx === 0 && !vnode.isRoot) {
            // when inserting a root element, or when reusing a DOM element for a new
            // component instance, the insert() hook is never called because the element
            // was already in the DOM before creating the instance, and diffing the
            // vnode, for that, we wait until the patching process has finished, and we
            // use the postpatch() hook to trigger the connectedCallback logic.
            insert(vnode);
            // Note: we don't have to worry about destroy() hook being called before this
            // one because they never happen in the same patching mechanism, only one
            // of them is called. In the case of the insert() hook, we use the value of `idx`
            // to dedupe the calls since they both can happen in the same patching process.
        }
        if (vm.isDirty) {
            // this code path guarantess that when patching the custom element the body is computed only after the element is in the DOM
            rehydrate(vm);
        }
    }
    function destroy(vnode) {
        {
            assert.vnode(vnode);
            assert.vm(vnode.vm);
            assert.isTrue(vnode.vm.idx, `${vnode.vm} is not inserted.`);
        }
        const { vm } = vnode;
        removeInsertionIndex(vm);
        // just in case it comes back, with this we guarantee re-rendering it
        vm.isDirty = true;
        clearListeners(vm);
        // At this point we need to force the removal of all children because
        // we don't have a way to know that children custom element were removed
        // from the DOM. Once we move to use realm custom elements, we can remove this.
        patchShadowRoot(vm, []);
    }
    const lifeCycleHooks = {
        insert,
        update,
        destroy,
    };

    const CHAR_S = 115;
    const CHAR_V = 118;
    const CHAR_G = 103;
    const EmptyData = create(null);
    const NamespaceAttributeForSVG = 'http://www.w3.org/2000/svg';
    const SymbolIterator = Symbol.iterator;
    function addNS(data, children, sel) {
        data.ns = NamespaceAttributeForSVG;
        if (isUndefined(children) || sel === 'foreignObject') {
            return;
        }
        const len = children.length;
        for (let i = 0; i < len; ++i) {
            const child = children[i];
            let { data } = child;
            if (data !== undefined) {
                const grandChildren = child.children;
                addNS(data, grandChildren, child.sel);
            }
        }
    }
    // [v]node node
    function v(sel, data, children, text, elm, Ctor) {
        data = data || EmptyData;
        let { key } = data;
        let uid = 0;
        // For root elements and other special cases the vm is not set.
        if (!isNull(vmBeingRendered)) {
            uid = vmBeingRendered.uid;
            data.token = vmBeingRendered.context.tplToken;
        }
        const vnode = { sel, data, children, text, elm, key, Ctor, uid };
        {
            // adding toString to all vnodes for debuggability
            vnode.toString = () => `[object:vnode ${sel}]`;
        }
        return vnode;
    }
    // [h]tml node
    function h(sel, data, children) {
        {
            assert.isTrue(isString(sel), `h() 1st argument sel must be a string.`);
            assert.isTrue(isObject(data), `h() 2nd argument data must be an object.`);
            assert.isTrue(isArray(children), `h() 3rd argument children must be an array.`);
            // checking reserved internal data properties
            assert.invariant(data.class === undefined, `vnode.data.class should be undefined when calling h().`);
            assert.isFalse(data.className && data.classMap, `vnode.data.className and vnode.data.classMap ambiguous declaration.`);
            assert.isFalse(data.styleMap && data.style, `vnode.data.styleMap and vnode.data.style ambiguous declaration.`);
            if (data.style && !isString(data.style)) {
                assert.logWarning(`Invalid 'style' attribute passed to <${sel}> should be a string value, and will be ignored.`);
            }
        }
        const { classMap, className, style, styleMap } = data;
        data.class = classMap || (className && getMapFromClassName(className));
        data.style = styleMap || (style && style + '');
        {
            children.forEach((vnode) => {
                if (vnode !== null) {
                    assert.vnode(vnode);
                }
            });
        }
        if (sel.length === 3 && sel.charCodeAt(0) === CHAR_S && sel.charCodeAt(1) === CHAR_V && sel.charCodeAt(2) === CHAR_G) {
            addNS(data, children, sel);
        }
        return v(sel, data, children);
    }
    // [c]ustom element node
    function c(sel, Ctor, data) {
        // The compiler produce AMD modules that do not support circular dependencies
        // We need to create an indirection to circumvent those cases.
        // We could potentially move this check to the definition
        if (Ctor.__circular__) {
            Ctor = Ctor();
        }
        {
            assert.isTrue(isString(sel), `c() 1st argument sel must be a string.`);
            assert.isTrue(isFunction(Ctor), `c() 2nd argument Ctor must be a function.`);
            assert.isTrue(isObject(data), `c() 3nd argument data must be an object.`);
            // checking reserved internal data properties
            assert.invariant(data.class === undefined, `vnode.data.class should be undefined when calling c().`);
            assert.isTrue(arguments.length < 4, `Compiler Issue: Custom elements expect up to 3 arguments, received ${arguments.length} instead.`);
            assert.isFalse(data.className && data.classMap, `vnode.data.className and vnode.data.classMap ambiguous declaration.`);
            assert.isFalse(data.styleMap && data.style, `vnode.data.styleMap and vnode.data.style ambiguous declaration.`);
            if (data.style && !isString(data.style)) {
                assert.logWarning(`Invalid 'style' attribute passed to <${sel}> should be a string value, and will be ignored.`);
            }
        }
        const { key, slotset, styleMap, style, on, className, classMap, props: _props } = data;
        let { attrs } = data;
        // hack to allow component authors to force the usage of the "is" attribute in their components
        const { forceTagName } = Ctor;
        if (!isUndefined(forceTagName) && (isUndefined(attrs) || isUndefined(attrs.is))) {
            attrs = attrs || {};
            attrs.is = sel;
            sel = forceTagName;
        }
        data = { hook: lifeCycleHooks, key, slotset, attrs, on, _props };
        data.class = classMap || (className && getMapFromClassName(className));
        data.style = styleMap || (style && style + '');
        return v(sel, data, EmptyArray, undefined, undefined, Ctor);
    }
    // [i]terable node
    function i(iterable, factory) {
        const list = [];
        if (isUndefined(iterable) || iterable === null) {
            {
                assert.logWarning(`Invalid template iteration for value "${iterable}" in ${vmBeingRendered}, it should be an Array or an iterable Object.`);
            }
            return list;
        }
        {
            assert.isFalse(isUndefined(iterable[SymbolIterator]), `Invalid template iteration for value \`${iterable}\` in ${vmBeingRendered}, it requires an array-like object, not \`null\` or \`undefined\`.`);
        }
        const iterator = iterable[SymbolIterator]();
        {
            assert.isTrue(iterator && isFunction(iterator.next), `Invalid iterator function for "${iterable}" in ${vmBeingRendered}.`);
        }
        let next = iterator.next();
        let i = 0;
        let { value, done: last } = next;
        while (last === false) {
            // implementing a look-back-approach because we need to know if the element is the last
            next = iterator.next();
            last = next.done;
            // template factory logic based on the previous collected value
            const vnode = factory(value, i, i === 0, last);
            if (isArray(vnode)) {
                ArrayPush.apply(list, vnode);
            }
            else {
                ArrayPush.call(list, vnode);
            }
            {
                const vnodes = isArray(vnode) ? vnode : [vnode];
                vnodes.forEach((vnode) => {
                    if (vnode && isObject(vnode) && vnode.sel && vnode.Ctor && isUndefined(vnode.key)) {
                        // TODO - it'd be nice to log the owner component rather than the iteration children
                        assert.logWarning(`Missing "key" attribute in iteration with child "${toString$1(vnode.Ctor.name)}", index ${i}. Instead set a unique "key" attribute value on all iteration children so internal state can be preserved during rehydration.`);
                    }
                });
            }
            // preparing next value
            i += 1;
            value = next.value;
        }
        return list;
    }
    /**
     * [f]lattening
     */
    function f(items) {
        {
            assert.isTrue(isArray(items), 'flattening api can only work with arrays.');
        }
        const len = items.length;
        const flattened = [];
        for (let i = 0; i < len; i += 1) {
            const item = items[i];
            if (isArray(item)) {
                ArrayPush.apply(flattened, item);
            }
            else {
                ArrayPush.call(flattened, item);
            }
        }
        return flattened;
    }
    // [t]ext node
    function t(value) {
        return v(undefined, undefined, undefined, value);
    }
    // [d]ynamic value to produce a text vnode
    function d(value) {
        if (value === undefined || value === null) {
            return null;
        }
        return v(undefined, undefined, undefined, value);
    }
    // [b]ind function
    function b(fn) {
        {
            assert.vm(vmBeingRendered);
        }
        function handler(event) {
            // TODO: only if the event is `composed` it can be dispatched
            invokeComponentCallback(handler.vm, handler.fn, handler.vm.component, [event]);
        }
        handler.vm = vmBeingRendered;
        handler.fn = fn;
        return handler;
    }



    var api = Object.freeze({
        v: v,
        h: h,
        c: c,
        i: i,
        f: f,
        t: t,
        d: d,
        b: b
    });

    var array = Array.isArray;
    function primitive(s) {
        return typeof s === 'string' || typeof s === 'number';
    }

    const { createElement: createElement$1, createElementNS, createTextNode, createComment, } = document;
    const { insertBefore: insertBefore$1, removeChild: removeChild$1, appendChild: appendChild$1, } = Node.prototype;
    function parentNode(node) {
        return node.parentNode;
    }
    function nextSibling(node) {
        return node.nextSibling;
    }
    function tagName(elm) {
        return elm.tagName;
    }
    function setTextContent(node, text) {
        node.nodeValue = text;
    }
    function getTextContent(node) {
        return node.nodeValue;
    }
    function isElement(node) {
        return node.nodeType === 1;
    }
    function isText(node) {
        // Performance optimization over `return node.nodeType === 3;`
        return node.splitText !== undefined;
    }
    function isComment(node) {
        return node.nodeType === 8;
    }
    var htmlDomApi = {
        createElement(tagName) {
            return createElement$1.call(document, tagName);
        },
        createElementNS(namespaceURI, qualifiedName) {
            return createElementNS.call(document, namespaceURI, qualifiedName);
        },
        createTextNode(text) {
            return createTextNode.call(document, text);
        },
        createComment(text) {
            return createComment.call(document, text);
        },
        insertBefore(parentNode, newNode, referenceNode) {
            insertBefore$1.call(parentNode, newNode, referenceNode);
        },
        removeChild(node, child) {
            removeChild$1.call(node, child);
        },
        appendChild(node, child) {
            appendChild$1.call(node, child);
        },
        parentNode: parentNode,
        nextSibling: nextSibling,
        tagName: tagName,
        setTextContent: setTextContent,
        getTextContent: getTextContent,
        isElement: isElement,
        isText: isText,
        isComment: isComment,
    };

    function isUndef(s) { return s === undefined; }
    function isDef(s) { return s !== undefined; }
    var emptyNode = { sel: "", data: {}, children: [] };
    function sameVnode(vnode1, vnode2) {
        return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;
    }
    function isVnode(vnode) {
        return vnode.sel !== undefined;
    }
    function createKeyToOldIdx(children, beginIdx, endIdx) {
        var i$$1, map = {}, key, ch;
        for (i$$1 = beginIdx; i$$1 <= endIdx; ++i$$1) {
            ch = children[i$$1];
            if (ch != null) {
                key = ch.key;
                if (key !== undefined)
                    map[key] = i$$1;
            }
        }
        return map;
    }
    var hooks = ['create', 'update', 'remove', 'destroy', 'pre', 'post'];
    // export { h } from './h';
    // export { thunk } from './thunk';
    function init(modules, domApi) {
        var i$$1, j, cbs = {};
        var api = domApi !== undefined ? domApi : htmlDomApi;
        for (i$$1 = 0; i$$1 < hooks.length; ++i$$1) {
            cbs[hooks[i$$1]] = [];
            for (j = 0; j < modules.length; ++j) {
                var hook = modules[j][hooks[i$$1]];
                if (hook !== undefined) {
                    cbs[hooks[i$$1]].push(hook);
                }
            }
        }
        function emptyNodeAt(elm) {
            var id = elm.id ? '#' + elm.id : '';
            var c$$1 = elm.className ? '.' + elm.className.split(' ').join('.') : '';
            return v(api.tagName(elm).toLowerCase() + id + c$$1, {}, [], undefined, elm);
        }
        function createRmCb(childElm, listeners) {
            return function rmCb() {
                if (--listeners === 0) {
                    var parent_1 = api.parentNode(childElm);
                    api.removeChild(parent_1, childElm);
                }
            };
        }
        function createElm(vnode, insertedVnodeQueue) {
            var i$$1, data = vnode.data;
            if (data !== undefined) {
                if (isDef(i$$1 = data.hook) && isDef(i$$1 = i$$1.init)) {
                    i$$1(vnode);
                    data = vnode.data;
                }
            }
            var children = vnode.children, sel = vnode.sel;
            if (sel === '!') {
                if (isUndef(vnode.text)) {
                    vnode.text = '';
                }
                vnode.elm = api.createComment(vnode.text);
            }
            else if (sel !== undefined) {
                // Parse selector
                var hashIdx = sel.indexOf('#');
                var dotIdx = sel.indexOf('.', hashIdx);
                var hash = hashIdx > 0 ? hashIdx : sel.length;
                var dot = dotIdx > 0 ? dotIdx : sel.length;
                var tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel;
                var elm = vnode.elm = isDef(data) && isDef(i$$1 = data.ns) ? api.createElementNS(i$$1, tag)
                    : api.createElement(tag);
                if (hash < dot)
                    elm.id = sel.slice(hash + 1, dot);
                if (dotIdx > 0)
                    elm.className = sel.slice(dot + 1).replace(/\./g, ' ');
                for (i$$1 = 0; i$$1 < cbs.create.length; ++i$$1)
                    cbs.create[i$$1](emptyNode, vnode);
                if (array(children)) {
                    for (i$$1 = 0; i$$1 < children.length; ++i$$1) {
                        var ch = children[i$$1];
                        if (ch != null) {
                            api.appendChild(elm, createElm(ch, insertedVnodeQueue));
                        }
                    }
                }
                else if (primitive(vnode.text)) {
                    api.appendChild(elm, api.createTextNode(vnode.text));
                }
                i$$1 = vnode.data.hook; // Reuse variable
                if (isDef(i$$1)) {
                    if (i$$1.create)
                        i$$1.create(emptyNode, vnode);
                    if (i$$1.insert)
                        insertedVnodeQueue.push(vnode);
                }
            }
            else {
                vnode.elm = api.createTextNode(vnode.text);
            }
            return vnode.elm;
        }
        function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {
            for (; startIdx <= endIdx; ++startIdx) {
                var ch = vnodes[startIdx];
                if (ch != null) {
                    api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);
                }
            }
        }
        function invokeDestroyHook(vnode) {
            var i$$1, j, data = vnode.data;
            if (data !== undefined) {
                if (isDef(i$$1 = data.hook) && isDef(i$$1 = i$$1.destroy))
                    i$$1(vnode);
                for (i$$1 = 0; i$$1 < cbs.destroy.length; ++i$$1)
                    cbs.destroy[i$$1](vnode);
                if (vnode.children !== undefined) {
                    for (j = 0; j < vnode.children.length; ++j) {
                        i$$1 = vnode.children[j];
                        if (i$$1 != null && typeof i$$1 !== "string") {
                            invokeDestroyHook(i$$1);
                        }
                    }
                }
            }
        }
        function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
            for (; startIdx <= endIdx; ++startIdx) {
                var i_1 = void 0, listeners = void 0, rm = void 0, ch = vnodes[startIdx];
                if (ch != null) {
                    if (isDef(ch.sel)) {
                        invokeDestroyHook(ch);
                        listeners = cbs.remove.length + 1;
                        rm = createRmCb(ch.elm, listeners);
                        for (i_1 = 0; i_1 < cbs.remove.length; ++i_1)
                            cbs.remove[i_1](ch, rm);
                        if (isDef(i_1 = ch.data) && isDef(i_1 = i_1.hook) && isDef(i_1 = i_1.remove)) {
                            i_1(ch, rm);
                        }
                        else {
                            rm();
                        }
                    }
                    else {
                        api.removeChild(parentElm, ch.elm);
                    }
                }
            }
        }
        function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {
            var oldStartIdx = 0, newStartIdx = 0;
            var oldEndIdx = oldCh.length - 1;
            var oldStartVnode = oldCh[0];
            var oldEndVnode = oldCh[oldEndIdx];
            var newEndIdx = newCh.length - 1;
            var newStartVnode = newCh[0];
            var newEndVnode = newCh[newEndIdx];
            var oldKeyToIdx;
            var idxInOld;
            var elmToMove;
            var before;
            while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
                if (oldStartVnode == null) {
                    oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left
                }
                else if (oldEndVnode == null) {
                    oldEndVnode = oldCh[--oldEndIdx];
                }
                else if (newStartVnode == null) {
                    newStartVnode = newCh[++newStartIdx];
                }
                else if (newEndVnode == null) {
                    newEndVnode = newCh[--newEndIdx];
                }
                else if (sameVnode(oldStartVnode, newStartVnode)) {
                    patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
                    oldStartVnode = oldCh[++oldStartIdx];
                    newStartVnode = newCh[++newStartIdx];
                }
                else if (sameVnode(oldEndVnode, newEndVnode)) {
                    patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
                    oldEndVnode = oldCh[--oldEndIdx];
                    newEndVnode = newCh[--newEndIdx];
                }
                else if (sameVnode(oldStartVnode, newEndVnode)) {
                    patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
                    api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));
                    oldStartVnode = oldCh[++oldStartIdx];
                    newEndVnode = newCh[--newEndIdx];
                }
                else if (sameVnode(oldEndVnode, newStartVnode)) {
                    patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
                    api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
                    oldEndVnode = oldCh[--oldEndIdx];
                    newStartVnode = newCh[++newStartIdx];
                }
                else {
                    if (oldKeyToIdx === undefined) {
                        oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
                    }
                    idxInOld = oldKeyToIdx[newStartVnode.key];
                    if (isUndef(idxInOld)) {
                        api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
                        newStartVnode = newCh[++newStartIdx];
                    }
                    else {
                        elmToMove = oldCh[idxInOld];
                        if (elmToMove.sel !== newStartVnode.sel) {
                            api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
                        }
                        else {
                            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
                            oldCh[idxInOld] = undefined;
                            api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
                        }
                        newStartVnode = newCh[++newStartIdx];
                    }
                }
            }
            if (oldStartIdx > oldEndIdx) {
                before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;
                addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
            }
            else if (newStartIdx > newEndIdx) {
                removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
            }
        }
        function patchVnode(oldVnode, vnode, insertedVnodeQueue) {
            var i$$1, hook;
            if (isDef(i$$1 = vnode.data) && isDef(hook = i$$1.hook) && isDef(i$$1 = hook.prepatch)) {
                i$$1(oldVnode, vnode);
            }
            var elm = vnode.elm = oldVnode.elm;
            var oldCh = oldVnode.children;
            var ch = vnode.children;
            if (oldVnode === vnode)
                return;
            if (vnode.data !== undefined) {
                for (i$$1 = 0; i$$1 < cbs.update.length; ++i$$1)
                    cbs.update[i$$1](oldVnode, vnode);
                i$$1 = vnode.data.hook;
                if (isDef(i$$1) && isDef(i$$1 = i$$1.update))
                    i$$1(oldVnode, vnode);
            }
            if (isUndef(vnode.text)) {
                if (isDef(oldCh) && isDef(ch)) {
                    if (oldCh !== ch)
                        updateChildren(elm, oldCh, ch, insertedVnodeQueue);
                }
                else if (isDef(ch)) {
                    if (isDef(oldVnode.text))
                        api.setTextContent(elm, '');
                    addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
                }
                else if (isDef(oldCh)) {
                    removeVnodes(elm, oldCh, 0, oldCh.length - 1);
                }
                else if (isDef(oldVnode.text)) {
                    api.setTextContent(elm, '');
                }
            }
            else if (oldVnode.text !== vnode.text) {
                api.setTextContent(elm, vnode.text);
            }
            if (isDef(hook) && isDef(i$$1 = hook.postpatch)) {
                i$$1(oldVnode, vnode);
            }
        }
        return function patch(oldVnode, vnode) {
            var i$$1, elm, parent;
            var insertedVnodeQueue = [];
            for (i$$1 = 0; i$$1 < cbs.pre.length; ++i$$1)
                cbs.pre[i$$1]();
            if (!isVnode(oldVnode)) {
                oldVnode = emptyNodeAt(oldVnode);
            }
            if (sameVnode(oldVnode, vnode)) {
                patchVnode(oldVnode, vnode, insertedVnodeQueue);
            }
            else {
                elm = oldVnode.elm;
                parent = api.parentNode(elm);
                createElm(vnode, insertedVnodeQueue);
                if (parent !== null) {
                    api.insertBefore(parent, vnode.elm, api.nextSibling(elm));
                    removeVnodes(parent, [oldVnode], 0, 0);
                }
            }
            for (i$$1 = 0; i$$1 < insertedVnodeQueue.length; ++i$$1) {
                insertedVnodeQueue[i$$1].data.hook.insert(insertedVnodeQueue[i$$1]);
            }
            for (i$$1 = 0; i$$1 < cbs.post.length; ++i$$1)
                cbs.post[i$$1]();
            return vnode;
        };
    }

    // this hook will set up the component instance associated to the new vnode,
    // and link the new vnode with the corresponding component
    function initializeComponent(oldVnode, vnode) {
        const { Ctor } = vnode;
        if (isUndefined(Ctor)) {
            return;
        }
        /**
         * The reason why we do the initialization here instead of prepatch or any other hook
         * is because the creation of the component does require the element to be available.
         */
        {
            assert.invariant(vnode.elm, `${vnode}.elm should be ready.`);
        }
        if (oldVnode.vm && oldVnode.Ctor === Ctor) {
            {
                assert.invariant(vnode.elm === oldVnode.elm, `${vnode}.elm should always match the oldVnode's element.`);
            }
            relinkVM(oldVnode.vm, vnode);
        }
        else {
            createVM(vnode);
        }
        {
            assert.invariant(vnode.vm.component, `vm ${vnode.vm} should have a component and element associated to it.`);
        }
    }
    var componentInit = {
        create: initializeComponent,
        update: initializeComponent,
    };

    function syncProps(oldVnode, vnode) {
        const { vm } = vnode;
        if (isUndefined(vm)) {
            return;
        }
        const { component, def: { props: publicProps } } = vm;
        let { data: { _props: oldProps } } = oldVnode;
        let { data: { _props: newProps } } = vnode;
        // infuse key-value pairs from _props into the component
        if (oldProps !== newProps && (oldProps || newProps)) {
            let key, cur;
            oldProps = oldProps || EmptyObject;
            newProps = newProps || EmptyObject;
            // removed props should be reset in component's props
            for (key in oldProps) {
                if (!(key in newProps)) {
                    prepareForPropUpdate(vm);
                    component[key] = undefined;
                }
            }
            // new or different props should be set in component's props
            for (key in newProps) {
                cur = newProps[key];
                if (!(key in oldProps) || oldProps[key] != cur) {
                    if (isUndefined(publicProps[key])) {
                        // TODO: this should never really happen because the compiler should always validate
                        {
                            assert.fail(`Ignoring unknown public property "${key}" of ${vm}. This is likely a typo on the corresponding attribute "${getAttrNameFromPropName(key)}".`);
                        }
                        return;
                    }
                    prepareForPropUpdate(vm);
                    component[key] = cur;
                }
            }
        }
        // Note: _props, which comes from api.c()'s data.props, is only used to populate
        //       public props, and any other alien key added to it by the compiler will be
        //       ignored, and a warning is shown.
    }
    var componentProps = {
        create: syncProps,
        update: syncProps,
    };

    function removeAllCmpEventListeners(vnode) {
        const { vm } = vnode;
        if (isUndefined(vm)) {
            return;
        }
        const { cmpEvents: on, listener } = vm;
        if (on && listener) {
            const { elm } = vnode;
            let name;
            for (name in on) {
                elm.removeEventListener(name, listener, false);
            }
            vm.listener = undefined;
        }
    }
    function updateCmpEventListeners(oldVnode, vnode) {
        const { vm } = vnode;
        if (isUndefined(vm)) {
            return;
        }
        const { vm: oldVm } = oldVnode;
        if (oldVm === vm) {
            return;
        }
        const oldOn = (oldVm && oldVm.cmpEvents) || EmptyObject;
        const { cmpEvents: on = EmptyObject } = vm;
        if (oldOn === on) {
            return;
        }
        const { elm } = vnode;
        const { elm: oldElm } = oldVnode;
        const listener = vm.cmpListener = (oldVm && oldVm.cmpListener) || createComponentListener();
        listener.vm = vm;
        let name;
        for (name in on) {
            if (isUndefined(oldOn[name])) {
                elm.addEventListener(name, listener, false);
            }
        }
        for (name in oldOn) {
            if (isUndefined(on[name])) {
                oldElm.removeEventListener(name, listener, false);
            }
        }
    }
    const eventListenersModule = {
        create: updateCmpEventListeners,
        update: updateCmpEventListeners,
        destroy: removeAllCmpEventListeners
    };

    function syncClassNames(oldVnode, vnode) {
        const { vm } = vnode;
        if (isUndefined(vm)) {
            return;
        }
        const { vm: oldVm } = oldVnode;
        if (oldVm === vm) {
            return;
        }
        const oldClass = (oldVm && oldVm.cmpClasses) || EmptyObject;
        const { cmpClasses: klass = EmptyObject } = vm;
        if (oldClass === klass) {
            return;
        }
        const { elm, data: { class: ownerClass = EmptyObject } } = vnode;
        let name;
        for (name in oldClass) {
            // remove only if it was removed from within the instance and it is not set from owner
            if (oldClass[name] && !klass[name] && !ownerClass[name]) {
                elm.classList.remove(name);
            }
        }
        for (name in klass) {
            if (klass[name] && !oldClass[name]) {
                elm.classList.add(name);
            }
        }
    }
    var componentClasses = {
        create: syncClassNames,
        update: syncClassNames,
    };

    function update$1(oldVnode, vnode) {
        const { vm } = vnode;
        if (isUndefined(vm)) {
            return;
        }
        let { data: { slotset: oldSlots } } = oldVnode;
        let { data: { slotset: newSlots } } = vnode;
        // infuse key-value pairs from slotset into the component
        if (oldSlots !== newSlots && (oldSlots || newSlots)) {
            let key, cur;
            oldSlots = oldSlots || EmptyObject;
            newSlots = newSlots || EmptyObject;
            // removed slots should be removed from component's slotset
            for (key in oldSlots) {
                if (!(key in newSlots)) {
                    removeComponentSlot(vm, key);
                }
            }
            // new or different slots should be set in component's slotset
            for (key in newSlots) {
                cur = newSlots[key];
                if (!(key in oldSlots) || oldSlots[key] != cur) {
                    if (cur && cur.length) {
                        addComponentSlot(vm, key, cur);
                    }
                    else {
                        removeComponentSlot(vm, key);
                    }
                }
            }
        }
    }
    var componentSlotset = {
        create: update$1,
        update: update$1,
    };

    // TODO: eventually use the one shipped by snabbdom directly
    function update$2(oldVnode, vnode) {
        let oldProps = oldVnode.data.props;
        let props = vnode.data.props;
        if (isUndefined(oldProps) && isUndefined(props)) {
            return;
        }
        if (oldProps === props) {
            return;
        }
        oldProps = oldProps || EmptyObject;
        props = props || EmptyObject;
        let key, cur, old;
        const { elm } = vnode;
        for (key in oldProps) {
            if (!(key in props)) {
                delete elm[key];
            }
        }
        for (key in props) {
            cur = props[key];
            old = oldProps[key];
            if (old !== cur) {
                if (old !== cur && (key !== 'value' || elm[key] !== cur)) {
                    // only touching the dom if the prop really changes.
                    {
                        if (elm[key] === cur && old !== undefined) {
                            console.warn(`Unneccessary update of property "${key}" in ${elm}, it has the same value in ${vnode.vm || vnode}.`);
                        }
                    }
                    elm[key] = cur;
                }
            }
        }
    }
    var props = {
        create: update$2,
        update: update$2,
    };

    const xlinkNS = 'http://www.w3.org/1999/xlink';
    const xmlNS = 'http://www.w3.org/XML/1998/namespace';
    const ColonCharCode = 58;
    const XCharCode = 120;
    function updateAttrs(oldVnode, vnode) {
        let { data: { attrs: oldAttrs } } = oldVnode;
        let { data: { attrs } } = vnode;
        if (!oldAttrs && !attrs) {
            return;
        }
        if (oldAttrs === attrs) {
            return;
        }
        const { elm } = vnode;
        const { setAttribute, removeAttribute, setAttributeNS } = elm;
        let key;
        oldAttrs = oldAttrs || {};
        attrs = attrs || {};
        // update modified attributes, add new attributes
        for (key in attrs) {
            const cur = attrs[key];
            const old = oldAttrs[key];
            if (old !== cur) {
                // TODO: once we fix issue #861, we can move the prepareForAttributeMutationFromTemplate up here.
                if (cur === true) {
                    {
                        prepareForAttributeMutationFromTemplate(elm, key);
                    }
                    setAttribute.call(elm, key, "");
                }
                else if (cur === false) {
                    {
                        prepareForAttributeMutationFromTemplate(elm, key);
                    }
                    removeAttribute.call(elm, key);
                }
                else {
                    if (key.charCodeAt(0) !== XCharCode) {
                        {
                            prepareForAttributeMutationFromTemplate(elm, key);
                        }
                        setAttribute.call(elm, key, cur);
                    }
                    else if (key.charCodeAt(3) === ColonCharCode) {
                        // Assume xml namespace
                        setAttributeNS.call(elm, xmlNS, key, cur);
                    }
                    else if (key.charCodeAt(5) === ColonCharCode) {
                        // Assume xlink namespace
                        setAttributeNS.call(elm, xlinkNS, key, cur);
                    }
                    else {
                        {
                            prepareForAttributeMutationFromTemplate(elm, key);
                        }
                        setAttribute.call(elm, key, cur);
                    }
                }
            }
        }
        // remove removed attributes
        for (key in oldAttrs) {
            if (!(key in attrs)) {
                {
                    prepareForAttributeMutationFromTemplate(elm, key);
                }
                removeAttribute.call(elm, key);
            }
        }
    }
    const attributesModule = {
        create: updateAttrs,
        update: updateAttrs
    };

    const DashCharCode = 45;
    function updateStyle(oldVnode, vnode) {
        let { data: { style: oldStyle } } = oldVnode;
        let { data: { style } } = vnode;
        if (!oldStyle && !style) {
            return;
        }
        if (oldStyle === style) {
            return;
        }
        oldStyle = oldStyle || {};
        style = style || {};
        let name;
        const { elm } = vnode;
        if (isString(style)) {
            elm.style.cssText = style;
        }
        else {
            if (isString(oldStyle)) {
                elm.style.cssText = '';
            }
            else {
                for (name in oldStyle) {
                    if (!(name in style)) {
                        elm.style.removeProperty(name);
                    }
                }
            }
            for (name in style) {
                const cur = style[name];
                if (cur !== oldStyle[name]) {
                    if (name.charCodeAt(0) === DashCharCode && name.charCodeAt(1) === DashCharCode) {
                        // if the name is prefied with --, it will be considered a variable, and setProperty() is needed
                        elm.style.setProperty(name, cur);
                    }
                    else {
                        elm.style[name] = cur;
                    }
                }
            }
        }
    }
    const styleModule = {
        create: updateStyle,
        update: updateStyle,
    };

    function updateClass(oldVnode, vnode) {
        const { data: { class: oldClass = EmptyObject } } = oldVnode;
        const { elm, data: { class: klass = EmptyObject } } = vnode;
        if (oldClass === klass) {
            return;
        }
        const innerClass = (vnode.vm && vnode.vm.cmpClasses) || EmptyObject;
        let name;
        for (name in oldClass) {
            // remove only if it is not in the new class collection and it is not set from within the instance
            if (!klass[name] && !innerClass[name]) {
                elm.classList.remove(name);
            }
        }
        for (name in klass) {
            if (!oldClass[name]) {
                elm.classList.add(name);
            }
        }
    }
    var classes = {
        create: updateClass,
        update: updateClass
    };

    function handleEvent(event, vnode) {
        const { type } = event;
        const { data: { on } } = vnode;
        let handler = on && on[type];
        // call event handler if exists
        if (handler) {
            handler.call(undefined, event);
        }
    }
    function createListener() {
        return function handler(event) {
            handleEvent(event, handler.vnode);
        };
    }
    function removeAllEventListeners(vnode) {
        const { data: { on }, listener } = vnode;
        if (on && listener) {
            const { elm } = vnode;
            let name;
            for (name in on) {
                elm.removeEventListener(name, listener, false);
            }
            vnode.listener = undefined;
        }
    }
    function updateEventListeners(oldVnode, vnode) {
        const { data: { on: oldOn = EmptyObject } } = oldVnode;
        const { data: { on = EmptyObject } } = vnode;
        if (oldOn === on) {
            return;
        }
        const { elm } = vnode;
        const { elm: oldElm } = oldVnode;
        const listener = vnode.listener = oldVnode.listener || createListener();
        listener.vnode = vnode;
        let name;
        for (name in on) {
            if (isUndefined(oldOn[name])) {
                elm.addEventListener(name, listener, false);
            }
        }
        for (name in oldOn) {
            if (isUndefined(on[name])) {
                oldElm.removeEventListener(name, listener, false);
            }
        }
    }
    const eventListenersModule$1 = {
        create: updateEventListeners,
        update: updateEventListeners,
        destroy: removeAllEventListeners
    };

    function updateToken(oldVnode, vnode) {
        const { data: { token: oldToken } } = oldVnode;
        const { data: { token: newToken }, elm } = vnode;
        if (oldToken === newToken) {
            return;
        }
        if (!isUndefined(oldToken)) {
            {
                prepareForAttributeMutationFromTemplate(elm, oldToken);
            }
            elm.removeAttribute(oldToken);
        }
        if (!isUndefined(newToken)) {
            {
                prepareForAttributeMutationFromTemplate(elm, newToken);
            }
            elm.setAttribute(newToken, '');
        }
    }
    const tokenModule = {
        create: updateToken,
        update: updateToken,
    };

    function updateUID(oldVnode, vnode) {
        const { uid: oldUid } = oldVnode;
        const { elm, uid } = vnode;
        if (uid === oldUid) {
            return;
        }
        // @ts-ignore
        elm[OwnerKey] = uid;
    }
    const uidModule = {
        create: updateUID,
        update: updateUID,
    };

    const patch = init([
        componentInit,
        componentSlotset,
        componentProps,
        // from this point on, we do a series of DOM mutations
        eventListenersModule,
        componentClasses,
        // Attrs need to be applied to element before props
        // IE11 will wipe out value on radio inputs if value
        // is set before type=radio.
        // See https://git.soma.salesforce.com/raptor/raptor/issues/791 for more
        attributesModule,
        props,
        classes,
        styleModule,
        eventListenersModule$1,
        tokenModule,
        uidModule,
    ]);

    const { removeChild, appendChild, insertBefore, replaceChild } = Node.prototype;
    const ConnectingSlot = Symbol();
    const DisconnectingSlot = Symbol();
    function callNodeSlot(node, slot) {
        {
            assert.isTrue(node, `callNodeSlot() should not be called for a non-object`);
        }
        if (!isUndefined(node[slot])) {
            node[slot]();
        }
        return node; // for convenience
    }
    // monkey patching Node methods to be able to detect the insertions and removal of
    // root elements created via createElement.
    assign(Node.prototype, {
        appendChild(newChild) {
            const appendedNode = appendChild.call(this, newChild);
            return callNodeSlot(appendedNode, ConnectingSlot);
        },
        insertBefore(newChild, referenceNode) {
            const insertedNode = insertBefore.call(this, newChild, referenceNode);
            return callNodeSlot(insertedNode, ConnectingSlot);
        },
        removeChild(oldChild) {
            const removedNode = removeChild.call(this, oldChild);
            return callNodeSlot(removedNode, DisconnectingSlot);
        },
        replaceChild(newChild, oldChild) {
            const replacedNode = replaceChild.call(this, newChild, oldChild);
            callNodeSlot(replacedNode, DisconnectingSlot);
            callNodeSlot(newChild, ConnectingSlot);
            return replacedNode;
        }
    });
    // this could happen for two reasons:
    // * it is a root, and was removed manually
    // * the element was appended to another container which requires disconnection to happen first
    function forceDisconnection(vnode) {
        {
            assert.vnode(vnode);
            assert.vm(vnode.vm);
        }
        const { vm } = vnode;
        vm.isDirty = true;
        removeInsertionIndex(vm);
        clearListeners(vm);
        // At this point we need to force the removal of all children because
        // we don't have a way to know that children custom element were removed
        // from the DOM. Once we move to use realm custom elements, we can remove this.
        patchShadowRoot(vm, []);
    }
    /**
     * This method is almost identical to document.createElement
     * (https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement)
     * with the slightly difference that in the options, you can pass the `is`
     * property set to a Constructor instead of just a string value. E.g.:
     *
     * const el = createElement('x-foo', { is: FooCtor });
     *
     * If the value of `is` attribute is not a constructor,
     * then we fallback to the normal Web-Components workflow.
     */
    function createElement(tagName, options = {}) {
        const Ctor = isFunction(options.is) ? options.is : null;
        let vnode = undefined;
        // If we have a Ctor, create our VNode
        if (Ctor) {
            vnode = c(tagName, Ctor, {});
            vnode.isRoot = true;
            // If Ctor defines forceTagName
            // vnode.sel will be the tagname we should use
            tagName = vnode.sel;
        }
        // Create element with correct tagName
        const element = document.createElement(tagName);
        // If we created a vnode
        if (vnode) {
            // patch that guy
            patch(element, vnode); // eslint-disable-line no-undef
            // Handle insertion and removal from the DOM
            element[ConnectingSlot] = () => {
                insert(vnode); // eslint-disable-line no-undef
            };
            element[DisconnectingSlot] = () => {
                forceDisconnection(vnode); // eslint-disable-line no-undef
            };
        }
        return element;
    }

    exports.createElement = createElement;
    exports.getComponentDef = getComponentDef;
    exports.Element = ComponentElement;
    exports.register = register;
    exports.unwrap = unwrap;
    exports.api = api$1;
    exports.track = track;
    exports.wire = wire;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
/** version: 0.16.8 */

try {
/**
 * Copyright (C) 2017 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Bundle from LockerService-Core
 * Generated: 2017-12-20
 * Version: 0.3.6
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.AuraLocker = global.AuraLocker || {})));
}(this, (function (exports) { 'use strict';

const DEFAULT = {};
const FUNCTION = { type: 'function' };
const FUNCTION_TRUST_RETURN_VALUE = { type: 'function', trustReturnValue: true };
const EVENT = { type: '@event' };
const SKIP_OPAQUE = { skipOpaque: true };
const FUNCTION_RAW_ARGS = { type: 'function', rawArguments: true };

const CTOR = { type: '@ctor' };
const RAW = { type: '@raw' };
const READ_ONLY_PROPERTY = { writable: false };

/*
 * Copyright (C) 2013 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let substituteMapForWeakMap = false;

if (typeof WeakMap !== 'undefined' && typeof Proxy !== 'undefined') {
  // Test for the Edge weakmap with proxies bug https://github.com/Microsoft/ChakraCore/issues/1662
  const map = new WeakMap();
  const proxyAsKey = new Proxy({}, {});
  map.set(proxyAsKey, true);
  substituteMapForWeakMap = map.get(proxyAsKey) !== true;
}

// TODO: RJ probably move this out to utils
function newWeakMap() {
  return typeof WeakMap !== 'undefined'
    ? !substituteMapForWeakMap ? new WeakMap() : new Map()
    : {
        /* WeakMap dummy polyfill */
        get: function() {
          return undefined;
        },
        set: function() {}
      };
}

// Keyed objects can only have one owner. We prevent "null" and "undefined"
// keys by guarding all set operations.
const keychain = newWeakMap();
const rawToSecureByKey = new Map();
const secureToRaw = newWeakMap();
const opaqueSecure = newWeakMap();
const objectToKeyedData = newWeakMap();
const secureProxy = newWeakMap();
const filteringProxy = newWeakMap();
const secureFunction = newWeakMap();

function getKey(thing) {
  return keychain.get(thing);
}

function isOpaque(st) {
  return opaqueSecure.get(st) === true;
}

function setKey(thing, key) {
  if (!thing) {
    return;
  }
  if (!key) {
    throw new Error('Setting an empty key is prohibited.');
  }
  const hasKey = keychain.get(thing);
  if (hasKey === undefined) {
    keychain.set(thing, key);
  } else if (hasKey === key) {
    // noop.
  } else {
    // Prevent keyed objects from being keyed again.
    throw new Error('Re-setting of key is prohibited.');
  }
}

function trust$1(from, thing) {
  if (from) {
    const key = keychain.get(from);
    if (key) {
      setKey(thing, key);
    }
  }
}

function hasAccess(from, to) {
  return keychain.get(from) === keychain.get(to);
}

function verifyAccess(from, to, skipOpaque) {
  const fromKey = keychain.get(from);
  const toKey = keychain.get(to);
  if (fromKey !== toKey || (skipOpaque && isOpaque(to))) {
    throw new Error(
      `Access denied: ${JSON.stringify({
        from: fromKey,
        to: toKey
      })}`
    );
  }
}

function getRef(st, key, skipOpaque) {
  const toKey = keychain.get(st);
  if (toKey !== key || (skipOpaque && opaqueSecure.get(st))) {
    throw new Error(
      `Access denied: ${JSON.stringify({
        from: key,
        to: toKey
      })}`
    );
  }

  return secureToRaw.get(st);
}

function setRef(st, raw, key, isOpaque) {
  if (!st) {
    throw new Error('Setting an empty reference is prohibited.');
  }
  if (!key) {
    throw new Error('Setting an empty key is prohibited.');
  }
  setKey(st, key);
  secureToRaw.set(st, raw);
  if (isOpaque) {
    opaqueSecure.set(st, true);
  }
}

function getData(object, key) {
  const keyedData = objectToKeyedData.get(object);
  return keyedData ? keyedData.get(key) : undefined;
}

function setData(object, key, data) {
  let keyedData = objectToKeyedData.get(object);
  if (!keyedData) {
    keyedData = newWeakMap();
    objectToKeyedData.set(object, keyedData);
  }

  keyedData.set(key, data);
}

function isProxy(st) {
  return secureProxy.get(st) === true;
}

function registerProxy(st) {
  secureProxy.set(st, true);
}

function registerFilteringProxy(st) {
  filteringProxy.set(st, true);
}

function isFilteringProxy(st) {
  return filteringProxy.get(st) === true;
}

function registerSecureFunction(st) {
  secureFunction.set(st, true);
}

function isSecureFunction(st) {
  return secureFunction.get(st) === true;
}

function unwrap$1(from, st) {
  if (!st) {
    return st;
  }

  const key = keychain.get(from);
  let ref;

  if (Array.isArray(st)) {
    // Only getRef on "secure" arrays
    if (secureToRaw.get(st)) {
      // Secure array - reconcile modifications to the filtered clone with the actual array
      ref = getRef(st, key);

      const originalLength = ref.length;
      let insertIndex = 0;
      for (let n = 0; n < st.length; n++) {
        // Find the next available location that corresponds to the filtered projection of the array
        while (insertIndex < originalLength && getKey(ref[insertIndex]) !== key) {
          insertIndex++;
        }

        ref[insertIndex++] = unwrap$1(from, st[n]);
      }
    } else {
      ref = [];
    }
  } else {
    ref = getRef(st, key);
  }

  return ref;
}

function addToCache(raw, st, key) {
  if (!raw) {
    throw new Error('Caching an empty reference is prohibited.');
  }

  if (!key) {
    throw new Error('Caching with an empty key is prohibited.');
  }

  let rawToSecure = rawToSecureByKey.get(key);
  if (!rawToSecure) {
    rawToSecure = new WeakMap();
    rawToSecureByKey.set(key, rawToSecure);
  }

  rawToSecure.set(raw, st);
}

function getFromCache(raw, key) {
  const rawToSecure = rawToSecureByKey.get(key);
  return rawToSecure && rawToSecure.get(raw);
}

/*
 * Copyright (C) 2013 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const metadata$1 = {
  prototypes: {
    CanvasRenderingContext2D: {
      addHitRegion: FUNCTION,
      arc: FUNCTION,
      arcTo: FUNCTION,
      beginPath: FUNCTION,
      bezierCurveTo: FUNCTION,
      canvas: READ_ONLY_PROPERTY,
      clearHitRegions: FUNCTION,
      clearRect: FUNCTION,
      clip: FUNCTION,
      closePath: FUNCTION,
      createImageData: FUNCTION,
      createLinearGradient: FUNCTION,
      createPattern: FUNCTION_RAW_ARGS,
      createRadialGradient: FUNCTION,
      currentTransform: RAW,
      direction: DEFAULT,
      drawFocusIfNeeded: FUNCTION_RAW_ARGS,
      drawImage: FUNCTION_RAW_ARGS,
      ellipse: FUNCTION,
      fill: FUNCTION_RAW_ARGS,
      fillRect: FUNCTION,
      fillStyle: DEFAULT,
      fillText: FUNCTION,
      font: DEFAULT,
      getImageData: FUNCTION,
      getLineDash: FUNCTION,
      globalAlpha: DEFAULT,
      globalCompositeOperation: DEFAULT,
      imageSmoothingEnabled: DEFAULT,
      isPointInPath: FUNCTION,
      isPointInStroke: FUNCTION,
      lineCap: DEFAULT,
      lineDashOffset: DEFAULT,
      lineJoin: DEFAULT,
      lineTo: FUNCTION,
      lineWidth: DEFAULT,
      measureText: FUNCTION,
      miterLimit: DEFAULT,
      moveTo: FUNCTION,
      putImageData: FUNCTION_RAW_ARGS,
      quadraticCurveTo: FUNCTION,
      rect: FUNCTION,
      removeHitRegion: FUNCTION,
      restore: FUNCTION,
      resetTransform: FUNCTION,
      rotate: FUNCTION,
      save: FUNCTION,
      scale: FUNCTION,
      setLineDash: FUNCTION,
      setTransform: FUNCTION,
      scrollPathIntoView: FUNCTION_RAW_ARGS,
      strokeRect: FUNCTION,
      strokeStyle: DEFAULT,
      strokeText: FUNCTION,
      shadowBlur: DEFAULT,
      shadowColor: DEFAULT,
      shadowOffsetX: DEFAULT,
      shadowOffsetY: DEFAULT,
      stroke: FUNCTION_RAW_ARGS,
      textAlign: DEFAULT,
      textBaseline: DEFAULT,
      translate: FUNCTION,
      transform: FUNCTION
    }
  }
};

function SecureCanvasRenderingContext2D(ctx, key) {
  let o = getFromCache(ctx, key);
  if (o) {
    return o;
  }
  o = Object.create(null, {
    toString: {
      value: function() {
        return `SecureCanvasRenderingContext2D: ${ctx}{ key: ${JSON.stringify(key)} }`;
      }
    }
  });

  SecureObject.addPrototypeMethodsAndProperties(metadata$1, o, ctx, key);

  setRef(o, ctx, key);
  addToCache(ctx, o, key);
  registerProxy(o);

  return o;
}

/*
 * Copyright (C) 2013 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Declare shorthand functions. Sharing these declarations accross modules
// improves both consitency and minification. Unused declarations are dropped
// by the tree shaking process.

const { getPrototypeOf, setPrototypeOf, defineProperty, deleteProperty, ownKeys } = Reflect;

const {
  defineProperties,
  hasOwnProperty,
  getOwnPropertyDescriptor,
  getOwnPropertyDescriptors,
  getOwnPropertyNames,
  create: create$1,
  assign,
  freeze,
  seal
} = Object;



const objectToString = Object.prototype.toString;

/*
 * Copyright (C) 2017 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Adapted from SES/Caja
// Copyright (C) 2011 Google Inc.
// https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js
// https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js

function repairAccessors(global) {
  // W-2961201 Prevent execution in the global context.

  // Fixing properties of Object to comply with strict mode
  // and ES2016 semantics, we do this by redefining them while in 'use strict'
  // https://tc39.github.io/ecma262/#sec-object.prototype.__defineGetter__
  defineProperties(global.Object.prototype, {
    __defineGetter__: {
      value: function(prop, func) {
        return defineProperty(this, prop, {
          get: func,
          enumerable: true,
          configurable: true
        });
      }
    },
    __defineSetter__: {
      value: function(prop, func) {
        return defineProperty(this, prop, {
          set: func,
          enumerable: true,
          configurable: true
        });
      }
    },
    __lookupGetter__: {
      value: function(prop) {
        let base = this;
        let desc;
        while (base && !(desc = getOwnPropertyDescriptor(base, prop))) {
          base = getPrototypeOf(base);
        }
        return desc && desc.get;
      }
    },
    __lookupSetter__: {
      value: function(prop) {
        let base = this;
        let desc;
        while (base && !(desc = getOwnPropertyDescriptor(base, prop))) {
          base = getPrototypeOf(base);
        }
        return desc && desc.set;
      }
    }
  });
}

/*
 * Copyright (C) 2017 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Adapted from SES/Caja
// Copyright (C) 2011 Google Inc.
// https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js
// https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js

// The code verifyStrictFunctionBody has been simplified since
// https://bugs.webkit.org/show_bug.cgi?id=173303 is now declassified

/**
 * The unsafe* variables hold precious values that must not escape
 * to untrusted code.
 */
// see startSES.js
const unsafeFunction = Function;

/**
 * <p>We use Crock's trick of simply passing {@code funcBodySrc} to
 * the original {@code Function} constructor, which will throw a
 * SyntaxError if it does not parse as a FunctionBody.
 */
// See repairES5.js
function verifyStrictFunctionBody(funcBodySrc) {
  funcBodySrc = String(funcBodySrc);
  unsafeFunction(`
"use strict";
${funcBodySrc}`);
  return funcBodySrc;
}

/*
 * Copyright (C) 2017 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Adapted from SES/Caja
// Copyright (C) 2011 Google Inc.
// https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js
// https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js

/**
 * Fails if {@code exprSource} does not parse as a strict
 * Expression production.
 *
 * <p>To verify that exprSrc parses as a strict Expression, we
 * verify that, when surrounded by parens and followed by ";", it
 * parses as a strict FunctionBody, and that when surrounded with
 * double parens it still parses as a strict FunctionBody. We
 * place a newline before the terminal token so that a "//"
 * comment cannot suppress the close paren or parens.
 *
 * <p>We never check without parens because not all
 * expressions, for example "function(){}", form valid expression
 * statements. We check both single and double parens so there's
 * no exprSrc text which can close the left paren(s), do
 * something, and then provide open paren(s) to balance the final
 * close paren(s). No one such attack will survive both tests.
 *
 * <p>Note that all verify*(allegedString) functions now always
 * start by coercing the alleged string to a guaranteed primitive
 * string, do their verification checks on that, and if it passes,
 * returns that. Otherwise they throw. If you don't know whether
 * something is a string before verifying, use only the output of
 * the verifier, not the input. Or coerce it early yourself.
 */
// see startSES.js
function verifyStrictExpression(exprSrc) {
  exprSrc = String(exprSrc);
  verifyStrictFunctionBody(`( ${exprSrc}\n);`);
  verifyStrictFunctionBody(`(( ${exprSrc}\n));`);
  return exprSrc;
}

/*
 * Copyright (C) 2017 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Adapted from SES/Caja
// Copyright (C) 2011 Google Inc.
// https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js
// https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js

/**
 * A safe form of the indirect {@code eval} function, which
 * evaluates {@code src} as strict code that can only refer freely
 * to the {@code sharedImports}.
 *
 * <p>Given our parserless methods of verifying untrusted sources,
 * we unfortunately have no practical way to obtain the completion
 * value of a safely evaluated Program. Instead, we adopt a
 * compromise based on the following observation. All Expressions
 * are valid Programs, and all Programs are valid
 * FunctionBodys. If {@code src} parses as a strict expression,
 * then we evaluate it as an expression and correctly return its
 * completion value, since that is simply the value of the
 * expression.
 *
 * <p>Otherwise, we evaluate {@code src} as a FunctionBody and
 * return what that would return from its implicit enclosing
 * function. If {@code src} is simply a Program, then it would not
 * have an explicit {@code return} statement, and so we fail to
 * return its completion value.
 *
 * <p>When SES {@code eval} is provided primitively, it should
 * accept a Program and evaluate it to the Program's completion
 * value. Unfortunately, this is not possible on ES5 without
 * parsing.
 */
// See fakeEval in startSES.js
function completion(src) {
  src = String(src);
  try {
    return verifyStrictExpression(src);
  } catch (err) {
    return `
(function(){
  "use strict";
  ${verifyStrictFunctionBody(src)}
}).call(this)`;
  }
}

/**
 * Sanitizes a URL string . Will prevent:
 * - usage of UTF-8 control characters. Update BLACKLIST constant to support more
 * - usage of \n, \t in url strings
 * @param {String} urlString
 * @returns {String}
 */
function sanitizeURLString(urlString) {
  const BLACKLIST = /[\u2029\u2028\n\r\t]/gi;

  // false, '', undefined, null
  if (!urlString) {
    return urlString;
  }

  if (typeof urlString !== 'string') {
    throw new TypeError('URL argument is not a string');
  }

  return urlString.replace(BLACKLIST, '');
}

/**
 * Sanitizes for a DOM element. Typical use would be when wanting to sanitize for
 * an href or src attribute of an element or window.open
 * @param {*} url
 */
function sanitizeURLForElement(url) {
  const normalized = document.createElement('a');
  normalized.href = url;
  return sanitizeURLString(normalized.href);
}

/*
 * Copyright (C) 2013 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0(the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let initalized = false;

// Immutable Prototype Exotic Objects
// https://github.com/tc39/ecma262/issues/272
function freezeIntrinsics(global) {
  seal(global.Object.prototype);
}

// wrapping the source with `with` statements create a new lexical scope,
// that can prevent access to the globals in the worker by shodowing them
// with the members of new scopes passed as arguments into the `hookFn` call.
// additionally, when specified, strict mode will be enforced to avoid leaking
// global variables into the worker.
function makeEvaluatorSource(src, sourceURL) {
  // Create the evaluator function.
  // The shadow is a proxy that has all window properties defined as undefined.
  // We mute globals for convenience. However, they remain available on window.
  // force strict mode
  // Objects: this = globals, window = globals

  let fnSource = `
(function () {
    with (new Proxy({}, {
        has: (target, prop) => prop in window
    })) {
    with (arguments[0]) {
        return (function(window){
            "use strict";
            return (
                ${completion(src)}
            );

        }).call(arguments[0], arguments[0]);
    }}
})`;

  // Sanitize the URL
  sourceURL = sanitizeURLForElement(sourceURL);
  if (sourceURL) {
    fnSource += `\n//# sourceURL=${sourceURL}`;
  }

  return fnSource;
}

function safeEval(src, sourceURL, globals) {
  if (!src) {
    return undefined;
  }

  const fnSource = makeEvaluatorSource(src, sourceURL);
  const fn = (0, eval)(fnSource); // eslint-disable-line no-eval

  if (typeof fn === 'function') {
    if (!initalized) {
      repairAccessors(window);
      freezeIntrinsics(window);
      initalized = true;
    }

    return fn(globals);
  }

  throw new SyntaxError(`Unable to evaluate code at: ${sourceURL}`);
}

/*
 * Copyright (C) 2013 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const keyToEnvironment = new Map();

function getEnv$1(key) {
  let env = keyToEnvironment.get(key);
  if (!env) {
    env = SecureWindow(window, key);
    keyToEnvironment.set(key, env);
  }

  return env;
}

function evaluate(src, key, sourceURL) {
  return safeEval(src, sourceURL, getEnv$1(key));
}

/*
 * Copyright (C) 2013 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function SecureDOMEvent(event, key) {
  let o = getFromCache(event, key);
  if (o) {
    return o;
  }

  o = Object.create(null, {
    toString: {
      value: function() {
        return `SecureDOMEvent: ${event}{ key: ${JSON.stringify(key)} }`;
      }
    }
  });

  const DOMEventSecureDescriptors = {
    // Events properties that are DOM Elements were compiled from
    // https://developer.mozilla.org/en-US/docs/Web/Events
    target: SecureObject.createFilteredProperty(o, event, 'target'),
    currentTarget: SecureObject.createFilteredProperty(o, event, 'currentTarget'),

    initEvent: SecureObject.createFilteredMethod(o, event, 'initEvent'),
    // Touch Events are special on their own:
    // https://developer.mozilla.org/en-US/docs/Web/API/Touch
    touches: SecureDOMEvent.filterTouchesDescriptor(o, event, 'touches'),
    targetTouches: SecureDOMEvent.filterTouchesDescriptor(o, event, 'targetTouches'),
    changedTouches: SecureDOMEvent.filterTouchesDescriptor(o, event, 'changedTouches'),

    view: {
      get: function() {
        const key = getKey(o);
        const swin = getEnv$1(key);
        const win = getRef(swin, key);
        return win === event.view ? swin : undefined;
      }
    }
  };

  ['preventDefault', 'stopImmediatePropagation', 'stopPropagation'].forEach(method =>
    SecureObject.addMethodIfSupported(o, event, method)
  );

  // non-standard properties and aliases
  ['relatedTarget', 'srcElement', 'explicitOriginalTarget', 'originalTarget'].forEach(property =>
    SecureObject.addPropertyIfSupported(o, event, property)
  );

  // re-exposing externals
  // TODO: we might need to include non-enumerables
  for (const name in event) {
    if (!(name in o)) {
      // every DOM event has a different shape, we apply filters when possible,
      // and bypass when no secure filter is found.
      Object.defineProperty(
        o,
        name,
        DOMEventSecureDescriptors[name] || SecureObject.createFilteredProperty(o, event, name)
      );
    }
  }

  setRef(o, event, key);
  addToCache(event, o, key);
  registerProxy(o);

  return o;
}

SecureDOMEvent.filterTouchesDescriptor = function(se, event, propName) {
  let valueOverride;
  // descriptor to produce a new collection of touches where the target of each
  // touch is a secure element
  return {
    get: function() {
      if (valueOverride) {
        return valueOverride;
      }
      // perf hard-wired in case there is not a touches to wrap
      const touches = event[propName];
      if (!touches) {
        return touches;
      }
      // touches, of type ToucheList does not implement "map"
      return Array.prototype.map.call(touches, touch => {
        // touches is normally a big big collection of touch objects,
        // we do not want to pre-process them all, just create the getters
        // and process the accessor on the spot. e.g.:
        // https://developer.mozilla.org/en-US/docs/Web/Events/touchstart
        let keys = [];
        let touchShape = touch;
        // Walk up the prototype chain and gather all properties
        do {
          keys = keys.concat(Object.keys(touchShape));
        } while (
          (touchShape = Object.getPrototypeOf(touchShape)) &&
          touchShape !== Object.prototype
        );

        // Create a stub object with all the properties
        return keys.reduce(
          (o, p) =>
            Object.defineProperty(o, p, {
              // all props in a touch object are readonly by spec:
              // https://developer.mozilla.org/en-US/docs/Web/API/Touch
              get: function() {
                return SecureObject.filterEverything(se, touch[p]);
              }
            }),
          {}
        );
      });
    },
    set: function(value) {
      valueOverride = value;
    }
  };
};

/*
 * Copyright (C) 2013 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function SecureScriptElement() {}

SecureScriptElement.setOverrides = function(elementOverrides, prototype) {
  function getAttributeName(name) {
    const lowercasedName = name.toLowerCase();
    switch (lowercasedName) {
      case 'src':
        return 'data-locker-src';
      case 'href':
        return 'data-locker-href';
      default:
        return name;
    }
  }

  function isAttributeAllowed(name) {
    // null, undefined, ''
    // allow a passthrough of these values
    if (!name) {
      return true;
    }

    const BLACKLIST = ['xlink:href'];
    const lowercasedName = name.toLowerCase();
    return BLACKLIST.indexOf(lowercasedName) === -1;
  }

  elementOverrides['src'] = {
    enumerable: true,
    get: function() {
      return this.getAttribute.apply(this, ['src']);
    },
    set: function(value) {
      this.setAttribute.apply(this, ['src', value]);
    }
  };

  const orignalGetAttribute = prototype.getAttribute;
  elementOverrides['getAttribute'] = {
    value: function(name) {
      return orignalGetAttribute.apply(this, [getAttributeName(name)]);
    }
  };

  const orignalSetAttribute = prototype.setAttribute;
  elementOverrides['setAttribute'] = {
    value: function(name, value) {
      if (isAttributeAllowed(name)) {
        orignalSetAttribute.apply(this, [getAttributeName(name), value]);
      }
    }
  };

  const orignalGetAttributeNS = prototype.getAttributeNS;
  elementOverrides['getAttributeNS'] = {
    value: function(ns, name) {
      return orignalGetAttributeNS.apply(this, [ns, getAttributeName(name)]);
    }
  };

  const orignalSetAttributeNS = prototype.setAttributeNS;
  elementOverrides['setAttributeNS'] = {
    value: function(ns, name, value) {
      if (isAttributeAllowed(name)) {
        orignalSetAttributeNS.apply(this, [ns, getAttributeName(name), value]);
      }
    }
  };

  const orignalGetAttributeNode = prototype.getAttributeNode;
  elementOverrides['getAttributeNode'] = {
    value: function(name) {
      return orignalGetAttributeNode.apply(this, [getAttributeName(name)]);
    }
  };

  const orignalGetAttributeNodeNS = prototype.getAttributeNodeNS;
  elementOverrides['getAttributeNodeNS'] = {
    value: function(ns, name) {
      return orignalGetAttributeNodeNS.apply(this, [ns, getAttributeName(name)]);
    }
  };

  const orignalSetAttributeNode = prototype.setAttributeNode;
  elementOverrides['setAttributeNode'] = {
    value: function(attr) {
      let raw = unwrap$1(this, attr);
      if (!raw) {
        // this will allow the browser to throw TypeError using native error messages
        orignalGetAttributeNode.call(this, raw);
      }

      /* We are interested in the value of the given attribute but we want
            to avoid executing any getters so we will clone it and attach it
            to a floating element which is not going to be a script tag.
            According to https://dev.w3.org/html5/spec-preview/the-script-element.html section 14
            some browsers may initiate fetching the script before it has been
            added to the DOM. Not using a script tag will prevent that. */
      const clone = raw.cloneNode();
      const normalizer = document.createElement('span');
      normalizer.setAttributeNode(clone);

      const attrNode = normalizer.attributes[0];
      switch (attrNode.name) {
        case 'xlink:href': {
          return undefined;
        }
        case 'src':
        case 'href': {
          raw = document.createAttribute(getAttributeName(attrNode.name));
          raw.value = attrNode.value;
          break;
        }
        default: {
          break;
        }
      }

      const replacedAttr = orignalSetAttributeNode.call(this, raw);
      return SecureObject.filterEverything(this, replacedAttr);
    }
  };

  elementOverrides['attributes'] = SecureObject.createFilteredPropertyStateless(
    'attributes',
    prototype,
    {
      writable: false,
      afterGetCallback: function(attributes) {
        if (!attributes) {
          return attributes;
        }
        // Secure attributes
        const secureAttributes = [];
        const raw = SecureObject.getRaw(this);
        for (let i = 0; i < attributes.length; i++) {
          const attribute = attributes[i];

          // Only add supported attributes
          if (SecureElement.isValidAttributeName(raw, attribute.name, prototype)) {
            let attributeName = attribute.name;
            if (attribute.name === 'src') {
              continue;
            }
            if (attribute.name === 'data-locker-src') {
              attributeName = 'src';
            }

            if (attribute.name === 'data-locker-href') {
              attributeName = 'href';
            }

            secureAttributes.push({
              name: attributeName,
              value: SecureObject.filterEverything(this, attribute.value)
            });
          }
        }
        return secureAttributes;
      }
    }
  );
};

SecureScriptElement.run = function(st) {
  const src = st.getAttribute('src');
  const href = st.getAttribute('href');
  const scriptUrl = src || href;

  if (!scriptUrl) {
    return;
  }

  const el = SecureObject.getRaw(st);
  document.head.appendChild(el);

  if (href && !(el instanceof SVGScriptElement)) {
    return;
  }

  // Get source using XHR and secure it using
  const xhr = new XMLHttpRequest();
  xhr.onreadystatechange = function() {
    const key = getKey(st);
    if (xhr.readyState === 4 && xhr.status === 200) {
      const code = xhr.responseText;
      evaluate(code, key, scriptUrl);

      el.dispatchEvent(new Event('load'));
    }

    // DCHASMAN TODO W-2837800 Add in error handling for 404's etc
  };

  xhr.open('GET', scriptUrl, true);

  // for relative urls enable sending credentials
  if (scriptUrl.indexOf('/') === 0) {
    xhr.withCredentials = true;
  }
  xhr.send();
};

/*
 * Copyright (C) 2013 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

let warn = window.console.warn;
let error = Error;

function registerReportAPI(api) {
  if (api) {
    warn = api.warn;
    error = api.error;
  }
}

/*
 * Copyright (C) 2013 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function assert(condition) {
  if (!condition) {
    throw new Error();
  }
}

// TODO: remove these functions. Our filtering mechanism should not
// rely on the more expensive operation.

function isObjectObject(value) {
  return (
    typeof value === 'object' && value !== null && objectToString.call(value) === '[object Object]'
  );
}

// https://github.com/jonschlinkert/is-plain-object
// Copyright ? 2017, Jon Schlinkert. Released under the MIT License.
function isPlainObject(value) {
  if (isObjectObject(value) === false) {
    return false;
  }

  // If has modified constructor
  const ctor = value.constructor;
  if (typeof ctor !== 'function') {
    return false;
  }

  try {
    // If has modified prototype
    const proto = ctor.prototype;
    if (isObjectObject(proto) === false) {
      return false;
    }
    // If constructor does not have an Object-specific method
    if (proto.hasOwnProperty('isPrototypeOf') === false) {
      return false;
    }
  } catch (e) {
    /* Assume is  object when throws */
  }

  // Most likely a plain Object
  return true;
}

/**
 * Basic URL Scheme checking utility.
 * Checks for http: and https: url schemes.
 * @param {String} url
 * @return {Boolean}
 */
function isValidURLScheme(url) {
  const normalized = document.createElement('a');
  normalized.href = url;
  return normalized.protocol === 'https:' || normalized.protocol === 'http:';
}

/*
 * Copyright (C) 2013 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const SecureIFrameElement = {
  addMethodsAndProperties: function(prototype) {
    Object.defineProperties(prototype, {
      // Standard HTMLElement methods
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement#Methods
      blur: SecureObject.createFilteredMethodStateless('blur', prototype),
      focus: SecureObject.createFilteredMethodStateless('focus', prototype),
      contentWindow: {
        get: function() {
          const raw = SecureObject.getRaw(this);
          return raw.contentWindow
            ? SecureIFrameElement.SecureIFrameContentWindow(raw.contentWindow, getKey(this))
            : raw.contentWindow;
        }
      },
      // Reason: [W-4437391] Cure53 Report SF-04-004: Window access via encoded path segments.
      src: {
        get: function() {
          const raw = SecureObject.getRaw(this);
          return raw.src;
        },
        set: function(url) {
          const urlString = sanitizeURLForElement(url);
          if (urlString.length > 0) {
            if (!isValidURLScheme(urlString)) {
              warn(
                'SecureIframeElement.src supports http://, https:// schemes and relative urls.'
              );
            } else {
              const raw = SecureObject.getRaw(this);
              raw.src = urlString;
            }
          }
        }
      }
    });

    // Standard list of iframe's properties from:
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLIFrameElement
    // Note: Ignoring 'contentDocument', 'sandbox' and 'srcdoc' from the list above.
    ['height', 'width', 'name'].forEach(name =>
      Object.defineProperty(
        prototype,
        name,
        SecureObject.createFilteredPropertyStateless(name, prototype)
      )
    );
  },

  SecureIFrameContentWindow: function(w, key) {
    const sicw = Object.create(null, {
      toString: {
        value: function() {
          return `SecureIFrameContentWindow: ${w}{ key: ${JSON.stringify(key)} }`;
        }
      }
    });

    Object.defineProperties(sicw, {
      postMessage: SecureObject.createFilteredMethod(sicw, w, 'postMessage', { rawArguments: true })
    });

    setRef(sicw, w, key);
    addToCache(w, sicw, key);
    registerProxy(sicw);

    return sicw;
  }
};

/*
 * Copyright (C) 2013 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const metadata$3 = {
  ATTRIBUTE_NODE: DEFAULT,
  CDATA_SECTION_NODE: DEFAULT,
  COMMENT_NODE: DEFAULT,
  DOCUMENT_FRAGMENT_NODE: DEFAULT,
  DOCUMENT_NODE: DEFAULT,
  DOCUMENT_POSITION_CONTAINED_BY: DEFAULT,
  DOCUMENT_POSITION_CONTAINS: DEFAULT,
  DOCUMENT_POSITION_DISCONNECTED: DEFAULT,
  DOCUMENT_POSITION_FOLLOWING: DEFAULT,
  DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: DEFAULT,
  DOCUMENT_POSITION_PRECEDING: DEFAULT,
  DOCUMENT_TYPE_NODE: DEFAULT,
  ELEMENT_NODE: DEFAULT,
  ENTITY_NODE: DEFAULT,
  ENTITY_REFERENCE_NODE: DEFAULT,
  NOTATION_NODE: DEFAULT,
  PROCESSING_INSTRUCTION_NODE: DEFAULT,
  TEXT_NODE: DEFAULT,
  appendChild: FUNCTION,
  baseURI: DEFAULT,
  childNodes: DEFAULT,
  cloneNode: FUNCTION,
  compareDocumentPosition: FUNCTION_RAW_ARGS,
  contains: FUNCTION_RAW_ARGS,
  firstChild: SKIP_OPAQUE,
  hasChildNodes: FUNCTION,
  insertBefore: FUNCTION,
  isDefaultNamespace: FUNCTION,
  isEqualNode: FUNCTION_RAW_ARGS,
  isSameNode: FUNCTION_RAW_ARGS,
  lastChild: SKIP_OPAQUE,
  lookupNamespaceURI: FUNCTION,
  lookupPrefix: FUNCTION,
  nextSibling: SKIP_OPAQUE,
  nodeName: DEFAULT,
  nodeType: DEFAULT,
  nodeValue: DEFAULT,
  normalize: FUNCTION,
  ownerDocument: DEFAULT,
  parentElement: SKIP_OPAQUE,
  parentNode: SKIP_OPAQUE,
  previousSibling: SKIP_OPAQUE,
  removeChild: FUNCTION,
  replaceChild: FUNCTION,
  textContent: DEFAULT
};

/*
 * Copyright (C) 2013 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const metadata$4 = {
  addEventListener: FUNCTION,
  dispatchEvent: FUNCTION,
  removeEventListener: FUNCTION
};

function createAddEventListenerDescriptor(st, el, key) {
  return {
    writable: true,
    value: function(event, callback, useCapture) {
      if (!callback) {
        return; // by spec, missing callback argument does not throw,
        // just ignores it.
      }

      let sCallback = getFromCache(callback, key);
      if (!sCallback) {
        sCallback = function(e) {
          verifyAccess(st, callback, true);
          const se = SecureDOMEvent(e, key);
          callback.call(st, se);
        };

        // Back reference for removeEventListener() support
        addToCache(callback, sCallback, key);
        setKey(callback, key);
      }

      el.addEventListener(event, sCallback, useCapture);
    }
  };
}

function addEventTargetMethods(st, raw, key) {
  Object.defineProperties(st, {
    addEventListener: createAddEventListenerDescriptor(st, raw, key),
    dispatchEvent: SecureObject.createFilteredMethod(st, raw, 'dispatchEvent', {
      rawArguments: true
    }),

    // removeEventListener() is special in that we do not want to
    // unfilter/unwrap the listener argument or it will not match what
    // was actually wired up originally
    removeEventListener: {
      writable: true,
      value: function(type, listener, options) {
        const sCallback = getFromCache(listener, key);
        raw.removeEventListener(type, sCallback, options);
      }
    }
  });
}

function createAddEventListenerDescriptorStateless() {
  return {
    value: function(event, callback, useCapture) {
      if (!callback) {
        return; // by spec, missing callback argument does not throw,
        // just ignores it.
      }

      const so = this;
      const el = SecureObject.getRaw(so);
      const key = getKey(so);
      let sCallback = getFromCache(callback, key);
      if (!sCallback) {
        sCallback = function(e) {
          verifyAccess(so, callback, true);
          const se = SecureDOMEvent(e, key);
          callback.call(so, se);
        };

        // Back reference for removeEventListener() support
        addToCache(callback, sCallback, key);
        setKey(callback, key);
      }

      el.addEventListener(event, sCallback, useCapture);
    }
  };
}

function createEventTargetMethodsStateless(config, prototype) {
  config['addEventListener'] = createAddEventListenerDescriptorStateless(prototype);

  config['dispatchEvent'] = SecureObject.createFilteredMethodStateless('dispatchEvent', prototype, {
    rawArguments: true
  });

  // removeEventListener() is special in that we do not want to
  // unfilter/unwrap the listener argument or it will not match what
  // was actually wired up originally
  config['removeEventListener'] = {
    value: function(type, listener, options) {
      const raw = SecureObject.getRaw(this);
      const sCallback = getFromCache(listener, getKey(this));
      raw.removeEventListener(type, sCallback, options);
    }
  };
}

const assert$1 = {
  block: fn => fn()
};

/*
 * Copyright (C) 2013 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const proxyMap = newWeakMap();
function addProxy(proxy, raw) {
  proxyMap.set(proxy, raw);
}

const lsProxyFormatter = {
  header: proxy => {
    const raw = proxyMap.get(proxy);
    if (!raw) {
      return null;
    }
    // If SecureElement proxy, show the original element
    if (raw instanceof Element) {
      return ['object', { object: raw }];
    }
    // TODO: If Array proxy or HTMLCollection/NodeList proxy, we need to filter the elements and display only the raw values of those elements
    return null;
  },
  // let the browser display the object in its native format
  hasBody: () => false,
  body: () => null
};

/** Custom Formatter for Dev Tools
 * To enable this, open Chrome Dev Tools
 * Go to Settings,
 * Under console, select "Enable custom formatters"
 * For more information, https://docs.google.com/document/d/1FTascZXT9cxfetuPRT2eXPQKXui4nWFivUnS_335T3U/preview
 */
window.devtoolsFormatters = window.devtoolsFormatters || [];
window.devtoolsFormatters.push(lsProxyFormatter);

/*
 * Copyright (C) 2013 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* import { isValidURLScheme } from '../utils/checks';
import { sanitizeURLForElement } from '../utils/sanitize';
 */
const metadata$2 = {
  prototypes: {
    DocumentFragment: {
      childElementCount: DEFAULT,
      children: DEFAULT,
      firstElementChild: SKIP_OPAQUE,
      getElementById: FUNCTION,
      lastElementChild: SKIP_OPAQUE,
      querySelector: FUNCTION,
      querySelectorAll: FUNCTION
    },
    HTMLAnchorElement: {
      charset: DEFAULT,
      coords: DEFAULT,
      download: DEFAULT,
      hash: DEFAULT,
      host: DEFAULT,
      hostname: DEFAULT,
      href: DEFAULT,
      hreflang: DEFAULT,
      name: DEFAULT,
      origin: DEFAULT,
      password: DEFAULT,
      pathname: DEFAULT,
      ping: DEFAULT,
      port: DEFAULT,
      protocol: DEFAULT,
      referrerPolicy: DEFAULT,
      rel: DEFAULT,
      rev: DEFAULT,
      search: DEFAULT,
      shape: DEFAULT,
      target: DEFAULT,
      text: DEFAULT,
      type: DEFAULT,
      username: DEFAULT
    },
    HTMLAreaElement: {
      alt: DEFAULT,
      coords: DEFAULT,
      hash: DEFAULT,
      host: DEFAULT,
      hostname: DEFAULT,
      href: DEFAULT,
      noHref: DEFAULT,
      origin: DEFAULT,
      password: DEFAULT,
      pathname: DEFAULT,
      ping: DEFAULT,
      port: DEFAULT,
      protocol: DEFAULT,
      referrerPolicy: DEFAULT,
      search: DEFAULT,
      shape: DEFAULT,
      target: DEFAULT,
      username: DEFAULT
    },
    HTMLAudioElement: {},
    HTMLMediaElement: {
      HAVE_CURRENT_DATA: DEFAULT,
      HAVE_ENOUGH_DATA: DEFAULT,
      HAVE_FUTURE_DATA: DEFAULT,
      HAVE_METADATA: DEFAULT,
      HAVE_NOTHING: DEFAULT,
      NETWORK_EMPTY: DEFAULT,
      NETWORK_IDLE: DEFAULT,
      NETWORK_LOADING: DEFAULT,
      NETWORK_NO_SOURCE: DEFAULT,
      addTextTrack: FUNCTION,
      autoplay: DEFAULT,
      buffered: DEFAULT,
      canPlayType: FUNCTION,
      controls: DEFAULT,
      crossOrigin: DEFAULT,
      currentSrc: DEFAULT,
      currentTime: DEFAULT,
      defaultMuted: DEFAULT,
      defaultPlaybackRate: DEFAULT,
      disableRemotePlayback: DEFAULT,
      duration: DEFAULT,
      ended: DEFAULT,
      error: DEFAULT,
      load: FUNCTION,
      loop: DEFAULT,
      mediaKeys: DEFAULT,
      muted: DEFAULT,
      networkState: DEFAULT,
      onencrypted: EVENT,
      pause: FUNCTION,
      paused: DEFAULT,
      play: FUNCTION,
      playbackRate: DEFAULT,
      played: DEFAULT,
      preload: DEFAULT,
      readyState: DEFAULT,
      seekable: DEFAULT,
      seeking: DEFAULT,
      setMediaKeys: FUNCTION,
      setSinkId: FUNCTION,
      sinkId: DEFAULT,
      src: DEFAULT,
      srcObject: DEFAULT,
      textTracks: DEFAULT,
      volume: DEFAULT,
      webkitAudioDecodedByteCount: DEFAULT,
      webkitVideoDecodedByteCount: DEFAULT
    },
    HTMLBaseElement: {
      href: DEFAULT,
      target: DEFAULT
    },
    HTMLButtonElement: {
      autofocus: DEFAULT,
      checkValidity: FUNCTION,
      disabled: DEFAULT,
      form: DEFAULT,
      formAction: DEFAULT,
      formEnctype: DEFAULT,
      formMethod: DEFAULT,
      formNoValidate: DEFAULT,
      formTarget: DEFAULT,
      labels: DEFAULT,
      name: DEFAULT,
      reportValidity: FUNCTION,
      setCustomValidity: FUNCTION,
      type: DEFAULT,
      validationMessage: DEFAULT,
      validity: DEFAULT,
      value: DEFAULT,
      willValidate: DEFAULT
    },
    HTMLCanvasElement: {
      captureStream: FUNCTION,
      getContext: FUNCTION,
      height: DEFAULT,
      toBlob: FUNCTION,
      toDataURL: FUNCTION,
      width: DEFAULT
    },
    HTMLTableColElement: {
      align: DEFAULT,
      ch: DEFAULT,
      chOff: DEFAULT,
      span: DEFAULT,
      vAlign: DEFAULT,
      width: DEFAULT
    },
    HTMLUnknownElement: {},
    HTMLModElement: {
      cite: DEFAULT,
      dateTime: DEFAULT
    },
    HTMLDetailsElement: {
      open: DEFAULT
    },
    HTMLEmbedElement: {
      align: DEFAULT,
      getSVGDocument: FUNCTION,
      height: DEFAULT,
      name: DEFAULT,
      src: DEFAULT,
      type: DEFAULT,
      width: DEFAULT
    },
    HTMLFieldSetElement: {
      checkValidity: FUNCTION,
      disabled: DEFAULT,
      elements: DEFAULT,
      form: DEFAULT,
      name: DEFAULT,
      reportValidity: FUNCTION,
      setCustomValidity: FUNCTION,
      type: DEFAULT,
      validationMessage: DEFAULT,
      validity: DEFAULT,
      willValidate: DEFAULT
    },
    HTMLFormElement: {
      acceptCharset: DEFAULT,
      action: DEFAULT,
      autocomplete: DEFAULT,
      checkValidity: FUNCTION,
      elements: DEFAULT,
      encoding: DEFAULT,
      enctype: DEFAULT,
      length: DEFAULT,
      method: DEFAULT,
      name: DEFAULT,
      noValidate: DEFAULT,
      reportValidity: FUNCTION,
      requestAutocomplete: FUNCTION,
      reset: FUNCTION,
      submit: FUNCTION,
      target: DEFAULT
    },
    HTMLIFrameElement: {
      align: DEFAULT,
      allowFullscreen: DEFAULT,
      frameBorder: DEFAULT,
      height: DEFAULT,
      longDesc: DEFAULT,
      marginHeight: DEFAULT,
      marginWidth: DEFAULT,
      name: DEFAULT,
      referrerPolicy: DEFAULT,
      scrolling: DEFAULT,
      src: DEFAULT,
      width: DEFAULT
    },
    HTMLImageElement: {
      align: DEFAULT,
      alt: DEFAULT,
      border: DEFAULT,
      complete: DEFAULT,
      crossOrigin: DEFAULT,
      currentSrc: DEFAULT,
      height: DEFAULT,
      hspace: DEFAULT,
      isMap: DEFAULT,
      longDesc: DEFAULT,
      lowsrc: DEFAULT,
      name: DEFAULT,
      naturalHeight: DEFAULT,
      naturalWidth: DEFAULT,
      referrerPolicy: DEFAULT,
      sizes: DEFAULT,
      src: DEFAULT,
      srcset: DEFAULT,
      useMap: DEFAULT,
      vspace: DEFAULT,
      width: DEFAULT,
      x: DEFAULT,
      y: DEFAULT
    },
    HTMLInputElement: {
      accept: DEFAULT,
      align: DEFAULT,
      alt: DEFAULT,
      autocapitalize: DEFAULT,
      autocomplete: DEFAULT,
      autocorrect: DEFAULT,
      autofocus: DEFAULT,
      checkValidity: FUNCTION,
      checked: DEFAULT,
      defaultChecked: DEFAULT,
      defaultValue: DEFAULT,
      dirName: DEFAULT,
      disabled: DEFAULT,
      files: DEFAULT,
      form: DEFAULT,
      formAction: DEFAULT,
      formEnctype: DEFAULT,
      formMethod: DEFAULT,
      formNoValidate: DEFAULT,
      formTarget: DEFAULT,
      height: DEFAULT,
      incremental: DEFAULT,
      indeterminate: DEFAULT,
      labels: DEFAULT,
      list: DEFAULT,
      max: DEFAULT,
      maxLength: DEFAULT,
      min: DEFAULT,
      minLength: DEFAULT,
      multiple: DEFAULT,
      name: DEFAULT,
      pattern: DEFAULT,
      placeholder: DEFAULT,
      readOnly: DEFAULT,
      reportValidity: FUNCTION,
      required: DEFAULT,
      results: DEFAULT,
      select: FUNCTION,
      selectionDirection: DEFAULT,
      selectionEnd: DEFAULT,
      selectionStart: DEFAULT,
      setCustomValidity: FUNCTION,
      setRangeText: FUNCTION,
      setSelectionRange: FUNCTION,
      size: DEFAULT,
      src: DEFAULT,
      step: DEFAULT,
      stepDown: FUNCTION,
      stepUp: FUNCTION,
      type: DEFAULT,
      useMap: DEFAULT,
      validationMessage: DEFAULT,
      validity: DEFAULT,
      value: DEFAULT,
      valueAsDate: DEFAULT,
      valueAsNumber: DEFAULT,
      webkitEntries: DEFAULT,
      webkitdirectory: DEFAULT,
      width: DEFAULT,
      willValidate: DEFAULT,
      'x-moz-errormessage': DEFAULT
    },
    HTMLLabelElement: {
      control: DEFAULT,
      form: DEFAULT,
      htmlFor: DEFAULT
    },
    HTMLLIElement: {
      type: DEFAULT,
      value: DEFAULT
    },
    HTMLLinkElement: {
      as: DEFAULT,
      charset: DEFAULT,
      crossOrigin: DEFAULT,
      disabled: DEFAULT,
      href: DEFAULT,
      hreflang: DEFAULT,
      import: DEFAULT,
      integrity: DEFAULT,
      media: DEFAULT,
      rel: DEFAULT,
      relList: DEFAULT,
      rev: DEFAULT,
      sheet: DEFAULT,
      sizes: DEFAULT,
      target: DEFAULT,
      type: DEFAULT
    },
    HTMLMapElement: {
      areas: DEFAULT,
      name: DEFAULT
    },
    HTMLMetaElement: {
      content: DEFAULT,
      httpEquiv: DEFAULT,
      name: DEFAULT,
      scheme: DEFAULT
    },
    HTMLMeterElement: {
      high: DEFAULT,
      labels: DEFAULT,
      low: DEFAULT,
      max: DEFAULT,
      min: DEFAULT,
      optimum: DEFAULT,
      value: DEFAULT
    },
    HTMLObjectElement: {
      align: DEFAULT,
      archive: DEFAULT,
      border: DEFAULT,
      checkValidity: FUNCTION,
      code: DEFAULT,
      codeBase: DEFAULT,
      codeType: DEFAULT,
      contentDocument: DEFAULT,
      data: DEFAULT,
      declare: DEFAULT,
      form: DEFAULT,
      getSVGDocument: FUNCTION,
      height: DEFAULT,
      hspace: DEFAULT,
      name: DEFAULT,
      reportValidity: FUNCTION,
      setCustomValidity: FUNCTION,
      standby: DEFAULT,
      type: DEFAULT,
      useMap: DEFAULT,
      validationMessage: DEFAULT,
      validity: DEFAULT,
      vspace: DEFAULT,
      width: DEFAULT,
      willValidate: DEFAULT
    },
    HTMLOListElement: {
      compact: DEFAULT,
      reversed: DEFAULT,
      start: DEFAULT,
      type: DEFAULT
    },
    HTMLOptGroupElement: {
      disabled: DEFAULT,
      label: DEFAULT
    },
    HTMLOptionElement: {
      defaultSelected: DEFAULT,
      disabled: DEFAULT,
      form: DEFAULT,
      index: DEFAULT,
      label: DEFAULT,
      selected: DEFAULT,
      text: DEFAULT,
      value: DEFAULT
    },
    HTMLOutputElement: {
      checkValidity: FUNCTION,
      defaultValue: DEFAULT,
      form: DEFAULT,
      htmlFor: DEFAULT,
      labels: DEFAULT,
      name: DEFAULT,
      reportValidity: FUNCTION,
      setCustomValidity: FUNCTION,
      type: DEFAULT,
      validationMessage: DEFAULT,
      validity: DEFAULT,
      value: DEFAULT,
      willValidate: DEFAULT
    },
    HTMLParamElement: {
      name: DEFAULT,
      type: DEFAULT,
      value: DEFAULT,
      valueType: DEFAULT
    },
    HTMLProgressElement: {
      labels: DEFAULT,
      max: DEFAULT,
      position: DEFAULT,
      value: DEFAULT
    },
    HTMLQuoteElement: {
      cite: DEFAULT
    },
    HTMLScriptElement: {
      src: DEFAULT,
      type: DEFAULT
    },
    HTMLSelectElement: {
      add: FUNCTION,
      autofocus: DEFAULT,
      checkValidity: FUNCTION,
      disabled: DEFAULT,
      form: DEFAULT,
      item: FUNCTION,
      labels: DEFAULT,
      length: DEFAULT,
      multiple: DEFAULT,
      name: DEFAULT,
      namedItem: FUNCTION,
      options: DEFAULT,
      remove: FUNCTION,
      reportValidity: FUNCTION,
      required: DEFAULT,
      selectedIndex: DEFAULT,
      selectedOptions: DEFAULT,
      setCustomValidity: FUNCTION,
      size: DEFAULT,
      type: DEFAULT,
      validationMessage: DEFAULT,
      validity: DEFAULT,
      value: DEFAULT,
      willValidate: DEFAULT
    },
    HTMLSourceElement: {
      media: DEFAULT,
      sizes: DEFAULT,
      src: DEFAULT,
      srcset: DEFAULT,
      type: DEFAULT
    },
    HTMLTableCellElement: {
      abbr: DEFAULT,
      align: DEFAULT,
      axis: DEFAULT,
      bgColor: DEFAULT,
      cellIndex: DEFAULT,
      ch: DEFAULT,
      chOff: DEFAULT,
      colSpan: DEFAULT,
      headers: DEFAULT,
      height: DEFAULT,
      noWrap: DEFAULT,
      rowSpan: DEFAULT,
      scope: DEFAULT,
      vAlign: DEFAULT,
      width: DEFAULT
    },
    HTMLTableElement: {
      caption: DEFAULT,
      tHead: SKIP_OPAQUE,
      tFoot: SKIP_OPAQUE,
      tBodies: DEFAULT,
      createTHead: FUNCTION_TRUST_RETURN_VALUE,
      deleteTHead: FUNCTION,
      createTFoot: FUNCTION_TRUST_RETURN_VALUE,
      deleteTFoot: FUNCTION,
      createCaption: FUNCTION_TRUST_RETURN_VALUE,
      deleteCaption: FUNCTION,
      rows: DEFAULT,
      insertRow: FUNCTION_TRUST_RETURN_VALUE,
      deleteRow: FUNCTION,
      width: DEFAULT
    },
    HTMLTableRowElement: {
      cells: DEFAULT,
      rowIndex: DEFAULT,
      sectionRowIndex: DEFAULT,
      insertCell: FUNCTION_TRUST_RETURN_VALUE,
      deleteCell: FUNCTION
    },
    HTMLTableSectionElement: {
      rows: DEFAULT,
      insertRow: FUNCTION_TRUST_RETURN_VALUE,
      deleteRow: FUNCTION
    },
    HTMLTemplateElement: {
      content: DEFAULT
    },
    HTMLTextAreaElement: {
      autocapitalize: DEFAULT,
      autofocus: DEFAULT,
      checkValidity: FUNCTION,
      cols: DEFAULT,
      defaultValue: DEFAULT,
      dirName: DEFAULT,
      disabled: DEFAULT,
      form: DEFAULT,
      labels: DEFAULT,
      maxLength: DEFAULT,
      minLength: DEFAULT,
      name: DEFAULT,
      placeholder: DEFAULT,
      readOnly: DEFAULT,
      reportValidity: FUNCTION,
      required: DEFAULT,
      rows: DEFAULT,
      select: FUNCTION,
      selectionDirection: DEFAULT,
      selectionEnd: DEFAULT,
      selectionStart: DEFAULT,
      setCustomValidity: FUNCTION,
      setRangeText: FUNCTION,
      setSelectionRange: FUNCTION,
      textLength: DEFAULT,
      type: DEFAULT,
      validationMessage: DEFAULT,
      validity: DEFAULT,
      value: DEFAULT,
      willValidate: DEFAULT,
      wrap: DEFAULT
    },
    HTMLTrackElement: {
      ERROR: DEFAULT,
      LOADED: DEFAULT,
      LOADING: DEFAULT,
      NONE: DEFAULT,
      default: DEFAULT,
      kind: DEFAULT,
      label: DEFAULT,
      readyState: DEFAULT,
      src: DEFAULT,
      srclang: DEFAULT,
      track: DEFAULT
    },
    HTMLVideoElement: {
      height: DEFAULT,
      poster: DEFAULT,
      videoHeight: DEFAULT,
      videoWidth: DEFAULT,
      width: DEFAULT
    },
    HTMLElement: {
      accessKey: DEFAULT,
      blur: FUNCTION,
      click: FUNCTION,
      contentEditable: DEFAULT,
      dataset: DEFAULT,
      dir: DEFAULT,
      draggable: DEFAULT,
      focus: FUNCTION,
      hidden: DEFAULT,
      innerText: DEFAULT,
      isContentEditable: DEFAULT,
      lang: DEFAULT,
      offsetHeight: DEFAULT,
      offsetLeft: DEFAULT,
      offsetParent: DEFAULT,
      offsetTop: DEFAULT,
      offsetWidth: DEFAULT,
      onabort: EVENT,
      onautocomplete: EVENT,
      onautocompleteerror: EVENT,
      onblur: EVENT,
      oncancel: EVENT,
      oncanplay: EVENT,
      oncanplaythrough: EVENT,
      onchange: EVENT,
      onclick: EVENT,
      onclose: EVENT,
      oncontextmenu: EVENT,
      oncuechange: EVENT,
      ondblclick: EVENT,
      ondrag: EVENT,
      ondragend: EVENT,
      ondragenter: EVENT,
      ondragleave: EVENT,
      ondragover: EVENT,
      ondragstart: EVENT,
      ondrop: EVENT,
      ondurationchange: EVENT,
      onemptied: EVENT,
      onended: EVENT,
      onerror: EVENT,
      onfocus: EVENT,
      oninput: EVENT,
      oninvalid: EVENT,
      onkeydown: EVENT,
      onkeypress: EVENT,
      onkeyup: EVENT,
      onload: EVENT,
      onloadeddata: EVENT,
      onloadedmetadata: EVENT,
      onloadstart: EVENT,
      onmousedown: EVENT,
      onmouseenter: EVENT,
      onmouseleave: EVENT,
      onmousemove: EVENT,
      onmouseout: EVENT,
      onmouseover: EVENT,
      onmouseup: EVENT,
      onmousewheel: EVENT,
      onpause: EVENT,
      onplay: EVENT,
      onplaying: EVENT,
      onprogress: EVENT,
      onratechange: EVENT,
      onreset: EVENT,
      onresize: EVENT,
      onscroll: EVENT,
      onseeked: EVENT,
      onseeking: EVENT,
      onselect: EVENT,
      onshow: EVENT,
      onstalled: EVENT,
      onsubmit: EVENT,
      onsuspend: EVENT,
      ontimeupdate: EVENT,
      ontoggle: EVENT,
      ontouchcancel: EVENT,
      ontouchend: EVENT,
      ontouchmove: EVENT,
      ontouchstart: EVENT,
      onvolumechange: EVENT,
      onwaiting: EVENT,
      outerText: DEFAULT,
      spellcheck: DEFAULT,
      style: DEFAULT,
      tabIndex: DEFAULT,
      title: DEFAULT,
      translate: DEFAULT,
      webkitdropzone: DEFAULT
    },
    SVGAngle: {
      unitType: DEFAULT,
      value: DEFAULT,
      valueInSpecifiedUnits: DEFAULT,
      valueAsString: DEFAULT,
      newValueSpecifiedUnits: FUNCTION,
      convertToSpecifiedUnits: FUNCTION
    },
    SVGAnimatedAngle: {
      baseVal: DEFAULT,
      animVal: DEFAULT
    },
    SVGAnimatedBoolean: {
      baseVal: DEFAULT,
      animVal: DEFAULT
    },
    SVGAnimatedEnumeration: {
      baseVal: DEFAULT,
      animVal: DEFAULT
    },
    SVGAnimatedInteger: {
      baseVal: DEFAULT,
      animVal: DEFAULT
    },
    SVGAnimatedLength: {
      baseVal: DEFAULT,
      animVal: DEFAULT
    },
    SVGAnimatedLengthList: {
      baseVal: DEFAULT,
      animVal: DEFAULT
    },
    SVGAnimatedNumber: {
      baseVal: DEFAULT,
      animVal: DEFAULT
    },
    SVGAnimatedNumberList: {
      baseVal: DEFAULT,
      animVal: DEFAULT
    },
    SVGAnimatedPreserveAspectRatio: {
      baseVal: DEFAULT,
      animVal: DEFAULT
    },
    SVGAnimatedRect: {
      baseVal: DEFAULT,
      animVal: DEFAULT
    },
    SVGAnimatedString: {
      baseVal: DEFAULT,
      animVal: DEFAULT
    },
    SVGAnimatedTransformList: {
      baseVal: DEFAULT,
      animVal: DEFAULT
    },
    SVGAnimationElement: {
      targetElement: SKIP_OPAQUE,
      getCurrentTime: FUNCTION,
      getSimpleDuration: FUNCTION
    },
    SVGCircleElement: {
      cx: DEFAULT,
      cy: DEFAULT,
      r: DEFAULT
    },
    SVGClipPathElement: {
      clipPathUnits: DEFAULT
    },
    SVGEllipseElement: {
      cx: DEFAULT,
      cy: DEFAULT,
      rx: DEFAULT,
      ry: DEFAULT
    },
    SVGFilterElement: {
      filterUnits: DEFAULT,
      primitiveUnits: DEFAULT,
      x: DEFAULT,
      y: DEFAULT,
      width: DEFAULT,
      height: DEFAULT,
      filterResX: DEFAULT,
      fitlerResY: DEFAULT
    },
    SVGForeignObjectElement: {
      x: DEFAULT,
      y: DEFAULT,
      width: DEFAULT,
      height: DEFAULT
    },
    SVGGeometryElement: {
      pathLength: DEFAULT,
      isPointInFill: FUNCTION,
      isPointInStroke: FUNCTION,
      getTotalLength: FUNCTION,
      getPointAtLength: FUNCTION
    },
    SVGGradientElement: {
      gradientUnits: DEFAULT,
      gradientTransform: DEFAULT,
      spreadMethod: DEFAULT
    },
    SVGGraphicsElement: {
      transform: DEFAULT,
      getBBox: FUNCTION,
      getCTM: FUNCTION,
      getScreenCTM: FUNCTION
    },
    SVGImageElement: {
      x: DEFAULT,
      y: DEFAULT,
      width: DEFAULT,
      height: DEFAULT,
      preserveAspectRatio: DEFAULT,
      crossOrigin: DEFAULT
    },
    SVGLength: {
      SVG_LENGTHTYPE_UNKNOWN: DEFAULT,
      SVG_LENGTHTYPE_NUMBER: DEFAULT,
      SVG_LENGTHTYPE_PERCENTAGE: DEFAULT,
      SVG_LENGTHTYPE_EMS: DEFAULT,
      SVG_LENGTHTYPE_EXS: DEFAULT,
      SVG_LENGTHTYPE_PX: DEFAULT,
      SVG_LENGTHTYPE_CM: DEFAULT,
      SVG_LENGTHTYPE_MM: DEFAULT,
      SVG_LENGTHTYPE_IN: DEFAULT,
      SVG_LENGTHTYPE_PT: DEFAULT,
      SVG_LENGTHTYPE_PC: DEFAULT,
      unitType: DEFAULT,
      value: DEFAULT,
      valueInSpecifiedUnits: DEFAULT,
      valueAsString: DEFAULT,
      newValueSpecifiedUnits: FUNCTION,
      convertToSpecifiedUnits: FUNCTION
    },
    SVGLengthList: {
      numberOfItem: DEFAULT,
      clear: FUNCTION,
      initialize: FUNCTION,
      getItem: SKIP_OPAQUE,
      insertItemBefore: FUNCTION,
      replaceItem: FUNCTION,
      removeItem: SKIP_OPAQUE,
      appendItem: FUNCTION
    },
    SVGLineElement: {
      x1: DEFAULT,
      x2: DEFAULT,
      y1: DEFAULT,
      y2: DEFAULT
    },
    SVGLinearGradientElement: {
      x1: DEFAULT,
      x2: DEFAULT,
      y1: DEFAULT,
      y2: DEFAULT
    },
    SVGMaskElement: {
      maskUnits: DEFAULT,
      maskContentUnits: DEFAULT,
      x: DEFAULT,
      y: DEFAULT,
      width: DEFAULT,
      height: DEFAULT
    },
    SVGNumber: {
      value: DEFAULT
    },
    SVGNumberList: {
      numberOfItem: DEFAULT,
      clear: FUNCTION,
      initialize: FUNCTION,
      getItem: SKIP_OPAQUE,
      insertItemBefore: FUNCTION,
      replaceItem: FUNCTION,
      removeItem: SKIP_OPAQUE,
      appendItem: FUNCTION
    },
    SVGPatternElement: {
      x: DEFAULT,
      y: DEFAULT,
      width: DEFAULT,
      height: DEFAULT,
      patternUnits: DEFAULT,
      patternContentUnits: DEFAULT,
      patternTransform: DEFAULT
    },
    SVGPreserveAspectRatio: {
      align: DEFAULT,
      meetOrSlice: DEFAULT,
      SVG_PRESERVEASPECTRATIO_UNKNOWN: DEFAULT,
      SVG_PRESERVEASPECTRATIO_NONE: DEFAULT,
      SVG_PRESERVEASPECTRATIO_XMINYMIN: DEFAULT,
      SVG_PRESERVEASPECTRATIO_XMIDYMIN: DEFAULT,
      SVG_PRESERVEASPECTRATIO_XMAXYMIN: DEFAULT,
      SVG_PRESERVEASPECTRATIO_XMINYMID: DEFAULT,
      SVG_PRESERVEASPECTRATIO_XMIDYMID: DEFAULT,
      SVG_PRESERVEASPECTRATIO_XMAXYMID: DEFAULT,
      SVG_PRESERVEASPECTRATIO_XMINYMAX: DEFAULT,
      SVG_PRESERVEASPECTRATIO_XMIDYMAX: DEFAULT,
      SVG_PRESERVEASPECTRATIO_XMAXYMAX: DEFAULT,
      SVG_MEETORSLICE_UNKNOWN: DEFAULT,
      SVG_MEETORSLICE_MEET: DEFAULT,
      SVG_MEETORSLICE_SLICE: DEFAULT
    },
    SVGRadialGradientElement: {
      cx: DEFAULT,
      cy: DEFAULT,
      r: DEFAULT,
      fx: DEFAULT,
      fy: DEFAULT
    },
    SVGRect: {
      x: DEFAULT,
      y: DEFAULT,
      width: DEFAULT,
      height: DEFAULT
    },
    SVGRectElement: {
      x: DEFAULT,
      y: DEFAULT,
      width: DEFAULT,
      height: DEFAULT,
      rx: DEFAULT,
      ry: DEFAULT
    },
    SVGScriptElement: {
      type: DEFAULT,
      crossOrigin: DEFAULT
    },
    SVGStopElement: {
      offset: DEFAULT
    },
    SVGStringList: {
      numberOfItem: DEFAULT,
      clear: FUNCTION,
      initialize: FUNCTION,
      getItem: SKIP_OPAQUE,
      insertItemBefore: FUNCTION,
      replaceItem: FUNCTION,
      removeItem: SKIP_OPAQUE,
      appendItem: FUNCTION
    },
    SVGStyleElement: {
      type: DEFAULT,
      media: DEFAULT,
      title: DEFAULT
    },
    SVGSVGElement: {
      animationsPaused: FUNCTION,
      checkIntersection: FUNCTION,
      checkEnclosure: FUNCTION,
      contentScriptType: DEFAULT,
      contentStyleType: DEFAULT,
      createSVGAngle: FUNCTION,
      createSVGLength: FUNCTION,
      createSVGMatrix: FUNCTION,
      createSVGNumber: FUNCTION,
      createSVGPoint: FUNCTION,
      createSVGRect: FUNCTION,
      createSVGTransform: FUNCTION,
      createSVGTransformFromMatrix: FUNCTION,
      currentScale: DEFAULT,
      currentTranslate: DEFAULT,
      currentView: DEFAULT,
      forceRedraw: FUNCTION,
      height: DEFAULT,
      pauseAnimations: FUNCTION,
      pixelUnitToMillimeterX: DEFAULT,
      pixelUnitToMillimeterY: DEFAULT,
      getCurrentTime: FUNCTION,
      getEnclosureList: FUNCTION,
      getElementById: FUNCTION,
      getIntersectionList: FUNCTION,
      screenPixelToMillimeterX: DEFAULT,
      screenPixelToMillimeterY: DEFAULT,
      setCurrentTime: FUNCTION,
      suspendRedraw: FUNCTION,
      unpauseAnimations: FUNCTION,
      unsuspendRedraw: FUNCTION,
      unsuspendRedrawAll: FUNCTION,
      useCurrentView: DEFAULT,
      viewport: DEFAULT,
      width: DEFAULT,
      x: DEFAULT,
      y: DEFAULT
    },
    SVGTextContentElement: {
      LENGTHADJUST_UNKNOWN: DEFAULT,
      LENGTHADJUST_SPACING: DEFAULT,
      LENGTHADJUST_SPACINGANDGLYPHS: DEFAULT,
      textLength: DEFAULT,
      lengthAdjust: DEFAULT,
      getNumberOfChars: FUNCTION,
      getComputedTextLength: FUNCTION,
      getSubStringLength: FUNCTION,
      getStartPositionOfChar: FUNCTION,
      getEndPositionOfChar: FUNCTION,
      getExtentOfChar: FUNCTION,
      getRotationOfChar: FUNCTION,
      getCharNumAtPosition: FUNCTION
    },
    SVGTextPositioningElement: {
      x: DEFAULT,
      y: DEFAULT,
      dx: DEFAULT,
      dy: DEFAULT,
      rotate: DEFAULT
    },
    SVGTransform: {
      SVG_TRANSFORM_UNKNOWN: DEFAULT,
      SVG_TRANSFORM_MATRIX: DEFAULT,
      SVG_TRANSFORM_TRANSLATE: DEFAULT,
      SVG_TRANSFORM_SCALE: DEFAULT,
      SVG_TRANSFORM_ROTATE: DEFAULT,
      SVG_TRANSFORM_SKEWX: DEFAULT,
      SVG_TRANSFORM_SKEWY: DEFAULT,
      type: DEFAULT,
      angle: DEFAULT,
      matrix: DEFAULT,
      setMatrix: FUNCTION,
      setTranslate: FUNCTION,
      setScale: FUNCTION,
      setRotate: FUNCTION,
      setSkewX: FUNCTION,
      setSkewY: FUNCTION
    },
    SVGTransformList: {
      numberOfItem: DEFAULT,
      clear: FUNCTION,
      initialize: FUNCTION,
      getItem: SKIP_OPAQUE,
      insertItemBefore: FUNCTION,
      replaceItem: FUNCTION,
      removeItem: SKIP_OPAQUE,
      appendItem: FUNCTION,
      createSVGTransformFromMatrix: FUNCTION,
      consolidate: FUNCTION
    },
    SVGUseElement: {
      x: DEFAULT,
      y: DEFAULT,
      width: DEFAULT,
      height: DEFAULT,
      instanceRoot: DEFAULT,
      animatedInstanceRoot: DEFAULT
    },
    SVGViewElement: {
      viewTarget: DEFAULT
    },
    SVGElement: {
      blur: FUNCTION,
      focus: FUNCTION,
      getBBox: FUNCTION,
      ownerSVGElement: SKIP_OPAQUE,
      onabort: EVENT,
      onblur: EVENT,
      oncancel: EVENT,
      oncanplay: EVENT,
      oncanplaythrough: EVENT,
      onchange: EVENT,
      onclick: EVENT,
      onclose: EVENT,
      oncontextmenu: EVENT,
      oncuechange: EVENT,
      ondblclick: EVENT,
      ondrag: EVENT,
      ondragend: EVENT,
      ondragenter: EVENT,
      ondragleave: EVENT,
      ondragover: EVENT,
      ondragstart: EVENT,
      ondrop: EVENT,
      ondurationchange: EVENT,
      onemptied: EVENT,
      onended: EVENT,
      onerror: EVENT,
      onfocus: EVENT,
      oninput: EVENT,
      oninvalid: EVENT,
      onkeydown: EVENT,
      onkeypress: EVENT,
      onkeyup: EVENT,
      onload: EVENT,
      onloadeddata: EVENT,
      onloadedmetadata: EVENT,
      onloadstart: EVENT,
      onmousedown: EVENT,
      onmouseenter: EVENT,
      onmouseleave: EVENT,
      onmousemove: EVENT,
      onmouseout: EVENT,
      onmouseover: EVENT,
      onmouseup: EVENT,
      onmousewheel: EVENT,
      onpause: EVENT,
      onplay: EVENT,
      onplaying: EVENT,
      onprogress: EVENT,
      onratechange: EVENT,
      onreset: EVENT,
      onresize: EVENT,
      onscroll: EVENT,
      onseeked: EVENT,
      onseeking: EVENT,
      onselect: EVENT,
      onshow: EVENT,
      onstalled: EVENT,
      onsubmit: EVENT,
      onsuspend: EVENT,
      ontimeupdate: EVENT,
      ontoggle: EVENT,
      ontouchcancel: EVENT,
      ontouchend: EVENT,
      ontouchmove: EVENT,
      ontouchstart: EVENT,
      onvolumechange: EVENT,
      onwaiting: EVENT,
      style: DEFAULT,
      tabIndex: DEFAULT,
      viewportElement: SKIP_OPAQUE
    },
    Element: {
      animate: FUNCTION,
      attributes: DEFAULT,
      children: DEFAULT,
      classList: DEFAULT,
      className: DEFAULT,
      clientHeight: DEFAULT,
      clientLeft: DEFAULT,
      clientTop: DEFAULT,
      clientWidth: DEFAULT,
      closest: FUNCTION,
      getAttribute: FUNCTION,
      getAttributeNS: FUNCTION,
      getAttributeNode: FUNCTION,
      getAttributeNodeNS: FUNCTION,
      getBoundingClientRect: FUNCTION,
      getClientRects: FUNCTION,
      getDestinationInsertionPoints: FUNCTION,
      getElementsByClassName: FUNCTION,
      getElementsByTagName: FUNCTION,
      getElementsByTagNameNS: FUNCTION,
      hasAttribute: FUNCTION,
      hasAttributeNS: FUNCTION,
      hasAttributes: FUNCTION,
      id: DEFAULT,
      innerHTML: DEFAULT,
      insertAdjacentElement: FUNCTION,
      insertAdjacentHTML: FUNCTION,
      insertAdjacentText: FUNCTION,
      localName: DEFAULT,
      matches: FUNCTION,
      namespaceURI: DEFAULT,
      nextElementSibling: SKIP_OPAQUE,
      onbeforecopy: EVENT,
      onbeforecut: EVENT,
      onbeforepaste: EVENT,
      oncopy: EVENT,
      oncut: EVENT,
      onpaste: EVENT,
      onsearch: EVENT,
      onselectstart: EVENT,
      onwebkitfullscreenchange: EVENT,
      onwebkitfullscreenerror: EVENT,
      onwheel: EVENT,
      outerHTML: DEFAULT,
      prefix: DEFAULT,
      previousElementSibling: SKIP_OPAQUE,
      querySelector: FUNCTION,
      querySelectorAll: FUNCTION,
      remove: FUNCTION,
      removeAttribute: FUNCTION,
      removeAttributeNS: FUNCTION,
      removeAttributeNode: FUNCTION,
      requestPointerLock: FUNCTION,
      scrollHeight: DEFAULT,
      scrollIntoView: FUNCTION,
      scrollIntoViewIfNeeded: FUNCTION,
      scrollLeft: DEFAULT,
      scrollTop: DEFAULT,
      scrollWidth: DEFAULT,
      setAttribute: FUNCTION,
      setAttributeNS: FUNCTION,
      setAttributeNode: FUNCTION,
      setAttributeNodeNS: FUNCTION,
      tagName: DEFAULT
    },
    CharacterData: {
      after: FUNCTION,
      appendData: FUNCTION,
      before: FUNCTION,
      data: DEFAULT,
      deleteData: FUNCTION,
      insertData: FUNCTION,
      length: DEFAULT,
      nextElementSibling: SKIP_OPAQUE,
      previousElementSibling: SKIP_OPAQUE,
      remove: FUNCTION,
      replaceData: FUNCTION,
      replaceWith: FUNCTION,
      substringData: FUNCTION
    },
    Text: {
      assignedSlot: DEFAULT,
      isElementContentWhitespace: DEFAULT,
      replaceWholeText: FUNCTION,
      splitText: FUNCTION,
      wholeText: DEFAULT
    },
    Attr: {
      name: DEFAULT,
      namespaceURI: DEFAULT,
      localName: DEFAULT,
      prefix: DEFAULT,
      ownerElement: DEFAULT,
      specified: DEFAULT,
      value: DEFAULT
    },
    Node: metadata$3,
    EventTarget: metadata$4
  }
};

function cloneFiltered(el, st) {
  const root = el.cloneNode(false);
  function cloneChildren(parent, parentClone) {
    const childNodes = parent.childNodes;
    for (let i = 0; i < childNodes.length; i++) {
      const child = childNodes[i];
      if (hasAccess(st, child) || child.nodeType === Node.TEXT_NODE) {
        const childClone = child.cloneNode(false);
        parentClone.appendChild(childClone);
        trust$1(st, childClone);
        cloneChildren(child, childClone);
      }
    }
  }
  cloneChildren(el, root);
  return root;
}

function runIfRunnable(st) {
  const shouldRun = st instanceof HTMLScriptElement || st instanceof SVGScriptElement;
  if (shouldRun) {
    SecureScriptElement.run(st);
    return true;
  }
  return false;
}

function trustChildNodesRecursive(node, key) {
  const children = node.childNodes;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    setKey(child, key);
    trustChildNodesRecursive(child, key);
  }
}

function trustChildNodes(from, node) {
  const key = getKey(from);
  if (key) {
    trustChildNodesRecursive(node, key);
  }
}

const KEY_TO_PROTOTYPES = typeof Map !== 'undefined' ? new Map() : undefined;

const domPurifyConfig = {
  // Allow SVG <use> element
  ADD_TAGS: ['use'],
  ADD_ATTR: [
    'aria-activedescendant',
    'aria-atomic',
    'aria-autocomplete',
    'aria-busy',
    'aria-checked',
    'aria-controls',
    'aria-describedby',
    'aria-disabled',
    'aria-readonly',
    'aria-dropeffect',
    'aria-expanded',
    'aria-flowto',
    'aria-grabbed',
    'aria-haspopup',
    'aria-hidden',
    'aria-disabled',
    'aria-invalid',
    'aria-label',
    'aria-labelledby',
    'aria-level',
    'aria-live',
    'aria-multiline',
    'aria-multiselectable',
    'aria-orientation',
    'aria-owns',
    'aria-posinset',
    'aria-pressed',
    'aria-readonly',
    'aria-relevant',
    'aria-required',
    'aria-selected',
    'aria-setsize',
    'aria-sort',
    'aria-valuemax',
    'aria-valuemin',
    'aria-valuenow',
    'aria-valuetext',
    'role',
    'target'
  ]
};

function propertyIsSupported(target, property) {
  // If the SecureElement prototype does not have the property directly on it then this
  // is an attempt to get a property that we do not support
  return Object.getPrototypeOf(target).hasOwnProperty(property);
}

function SecureElement(el, key) {
  let o = getFromCache(el, key);
  if (o) {
    return o;
  }

  // A secure element can have multiple forms, this block allows us to apply
  // some polymorphic behavior to SecureElement depending on the tagName
  let tagName = el.tagName && el.tagName.toUpperCase();
  switch (tagName) {
    case 'FRAME':
      throw new error('The deprecated FRAME element is not supported in LockerService!');
    default:
      break;
  }

  // SecureElement is it then!

  // Lazily create and cache tag name specific prototype
  switch (el.nodeType) {
    case Node.TEXT_NODE:
      tagName = '#text';
      break;

    case Node.DOCUMENT_FRAGMENT_NODE:
      tagName = '#fragment';
      break;

    case Node.ATTRIBUTE_NODE:
      tagName = 'Attr';
      break;

    case Node.COMMENT_NODE:
      tagName = '#comment';
      break;

    default:
      break;
  }

  // Segregate prototypes by their locker
  let prototypes = KEY_TO_PROTOTYPES.get(key);
  if (!prototypes) {
    prototypes = new Map();
    KEY_TO_PROTOTYPES.set(key, prototypes);
  }

  let prototypeInfo = prototypes.get(tagName);
  if (!prototypeInfo) {
    const basePrototype = Object.getPrototypeOf(el);

    const expandoCapturingHandler = {
      get: function(target, property) {
        if (property in basePrototype) {
          return property in target ? target[property] : undefined;
        }

        // Expando - retrieve it from a private locker scoped object
        const raw = getRef(target, key);
        const data = getData(raw, key);
        return data ? data[property] : undefined;
      },

      set: function(target, property, value) {
        if (property in basePrototype) {
          if (!propertyIsSupported(target, property)) {
            throw new Error(`SecureElement does not allow access to ${property}`);
          }

          target[property] = value;
          return true;
        }

        // Expando - store it from a private locker scoped object
        const raw = getRef(target, key);

        // SELECT elements allow options to be specified in array assignment style
        if (raw instanceof HTMLSelectElement && !Number.isNaN(Number(property))) {
          const rawOption = getRef(value, key);
          raw[property] = rawOption;
          return value;
        }

        let data = getData(raw, key);
        if (!data) {
          data = {};
          setData(raw, key, data);
        }

        data[property] = value;
        return true;
      },

      has: function(target, property) {
        if (property in basePrototype) {
          return true;
        }
        const raw = getRef(target, key);
        const data = getData(raw, key);
        return !!data && property in data;
      },

      deleteProperty: function(target, property) {
        const raw = getRef(target, key);
        const data = getData(raw, key);
        if (data && property in data) {
          return delete data[property];
        }
        return delete target[property];
      },

      ownKeys: function(target) {
        const raw = getRef(target, key);
        const data = getData(raw, key);
        let keys = Object.keys(raw);
        if (data) {
          keys = keys.concat(Object.keys(data));
        }
        return keys;
      },

      getOwnPropertyDescriptor: function(target, property) {
        let desc = Object.getOwnPropertyDescriptor(target, property);
        if (!desc) {
          const raw = getRef(target, key);
          const data = getData(raw, key);
          desc = data ? Object.getOwnPropertyDescriptor(data, property) : undefined;
        }
        return desc;
      },

      getPrototypeOf: function() {
        return basePrototype;
      },

      setPrototypeOf: function() {
        throw new Error(`Illegal attempt to set the prototype of: ${basePrototype}`);
      }
    };

    // "class", "id", etc global attributes are special because they do not directly correspond to any property
    const caseInsensitiveAttributes = {
      class: true,
      contextmenu: true,
      dropzone: true,
      id: true,
      role: true
    };

    const prototype = (function() {
      function SecureElementPrototype() {}
      SecureElementPrototype.prototype['tagName'] = tagName;

      const sep = new SecureElementPrototype();
      sep.constructor = function() {
        throw new TypeError('Illegal constructor');
      };
      return sep;
    })();

    // Allow React to register spies on input nodes
    // See inputValueTracking.js
    // https://github.com/facebook/react/blob/master/packages/react-dom/src/client/inputValueTracking.js
    ['checked', 'value'].forEach(prop => {
      if (prop in el) {
        const descriptor = Object.getOwnPropertyDescriptor(el.constructor.prototype, prop);

        Object.defineProperty(prototype.constructor.prototype, prop, {
          configurable: descriptor.configurable,
          enumerable: true,
          get: function() {
            const rawEl = SecureObject.getRaw(this);
            return SecureObject.filterEverything(this, rawEl[prop]);
          },
          set: function(value) {
            const rawEl = SecureObject.getRaw(this);
            rawEl[prop] = SecureObject.filterEverything(this, value);
          }
        });
      }
    });

    SecureElement.addStandardMethodAndPropertyOverrides(prototype, caseInsensitiveAttributes, key);

    Object.defineProperties(prototype, {
      toString: {
        value: function() {
          const e = SecureObject.getRaw(this);
          return `SecureElement: ${e}{ key: ${JSON.stringify(getKey(this))} }`;
        }
      }
    });

    const prototypicalInstance = Object.create(prototype);
    setRef(prototypicalInstance, el, key);

    if (tagName === 'IFRAME') {
      SecureIFrameElement.addMethodsAndProperties(prototype);
    }

    const tagNameSpecificConfig = SecureObject.addPrototypeMethodsAndPropertiesStateless(
      metadata$2,
      prototypicalInstance,
      prototype
    );

    // Conditionally add things that not all Node types support
    if ('attributes' in el) {
      tagNameSpecificConfig['attributes'] = SecureObject.createFilteredPropertyStateless(
        'attributes',
        prototype,
        {
          writable: false,
          afterGetCallback: function(attributes) {
            if (!attributes) {
              return attributes;
            }

            return SecureObject.createProxyForNamedNodeMap(
              attributes,
              key,
              prototype,
              caseInsensitiveAttributes
            );
          }
        }
      );
    }

    if ('innerText' in el) {
      tagNameSpecificConfig['innerText'] = {
        get: function() {
          /*
                     * innerText changes it's return value based on style and whether the element is live in
                     * the DOM or not. This implementation does not account for that and simply returns the
                     * innerText of the cloned node. This may cause subtle differences, such as missing newlines,
                     * from the original implementation.
                     *
                     * https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent#Differences_from_innerText
                     */
          const rawEl = SecureObject.getRaw(this);
          const filtered = cloneFiltered(rawEl, o);
          const ret = filtered.innerText;
          return ret;
        },
        set: function(value) {
          const raw = SecureObject.getRaw(this);
          if (SecureElement.isSharedElement(raw)) {
            throw new error(
              `SecureElement.innerText cannot be used with ${raw.tagName} elements!`
            );
          }

          raw.innerText = value;

          trustChildNodes(this, raw);
        }
      };
    }

    if ('innerHTML' in el) {
      tagNameSpecificConfig['innerHTML'] = {
        get: function() {
          return cloneFiltered(SecureObject.getRaw(this), o).innerHTML;
        },
        set: function(value) {
          const raw = SecureObject.getRaw(this);
          // Do not allow innerHTML on shared elements (body/head)
          if (SecureElement.isSharedElement(raw)) {
            throw new error(
              `SecureElement.innerHTML cannot be used with ${raw.tagName} elements!`
            );
          }
          raw.innerHTML = DOMPurify['sanitize'](value, domPurifyConfig);
          trustChildNodes(this, raw);
        }
      };
    }

    // Reason: [W-3564204] Web Components HTML imports only supported in Chrome.
    // TODO: Implement SecureLinkElement when it is more standardized across browsers.
    if (tagName === 'LINK' && 'rel' in el) {
      tagNameSpecificConfig['rel'] = {
        get: function() {
          const raw = SecureObject.getRaw(this);
          return raw.rel;
        },
        set: function(value) {
          value = String(value);
          if (value.toLowerCase() === 'import') {
            warn(
              "SecureLinkElement does not allow setting 'rel' property to 'import' value."
            );
          } else {
            const raw = SecureObject.getRaw(this);
            raw.rel = value;
          }
        }
      };
    }

    // special handling for Text.splitText() instead of creating a new secure wrapper
    if (tagName === '#text' && 'splitText' in el) {
      tagNameSpecificConfig['splitText'] = {
        value: function(index) {
          const raw = SecureObject.getRaw(this);
          const newNode = raw.splitText(index);

          const fromKey = getKey(raw);
          if (fromKey) {
            setKey(newNode, fromKey);
          }

          return SecureElement(newNode, getKey(this));
        }
      };
    }
    if ('outerHTML' in el) {
      tagNameSpecificConfig['outerHTML'] = {
        get: function() {
          return cloneFiltered(SecureObject.getRaw(this), o).outerHTML;
        },
        set: function(value) {
          const raw = SecureObject.getRaw(this);
          // Do not allow on shared elements (body/head)
          if (SecureElement.isSharedElement(raw)) {
            throw new error(
              `SecureElement.outerHTML cannot be used with ${raw.tagName} elements!`
            );
          }

          const parent = raw.parentElement;

          // As per specifications, throw when there is no parent
          if (!parent) {
            throw new DOMException(
              `Failed to set the 'outerHTML' property on ${
                raw.tagName
              }: This element has no parent node.`
            );
          }

          // Setting outerHTML on an element removes it from the document tree.
          // It returns no handle to trust the new elements. Here we create the
          // elements in a fragment then insert them in their proper location.

          const frag = document
            .createRange()
            .createContextualFragment(DOMPurify['sanitize'](value, domPurifyConfig));
          trustChildNodes(this, frag);
          while (frag.childNodes.length > 0) {
            const node = frag.childNodes[0];
            parent.insertBefore(node, raw);
          }
          parent.removeChild(raw);
        }
      };
    }

    // special handling for Text.splitText() instead of creating a new secure wrapper
    if (tagName === '#text' && 'splitText' in el) {
      tagNameSpecificConfig['splitText'] = {
        value: function(index) {
          const raw = SecureObject.getRaw(this);
          const newNode = raw.splitText(index);

          const fromKey = getKey(raw);
          if (fromKey) {
            setKey(newNode, fromKey);
          }

          return SecureElement(newNode, getKey(this));
        }
      };
    }

    // special handle insertRow since it may automatically also insert a <tbody> element that
    // also needs to be keyed.
    if ('insertRow' in el && el instanceof HTMLTableElement) {
      tagNameSpecificConfig['insertRow'] = {
        value: function(index) {
          function getFirstTBody(table) {
            for (let i = 0; i < table.childNodes.length; i++) {
              const node = table.childNodes[i];
              if (node instanceof HTMLTableSectionElement) {
                return node;
              }
            }
            return undefined;
          }

          const raw = SecureObject.getRaw(this);
          const tbodyExists = !!getFirstTBody(raw);
          const newRow = raw.insertRow(index);
          trust$1(this, newRow);
          if (!tbodyExists) {
            // a new tbody element has also been inserted, key that too.
            const tbody = getFirstTBody(raw);
            trust$1(this, tbody);
          }
          return SecureElement(newRow, getKey(this));
        }
      };
    }

    createEventTargetMethodsStateless(tagNameSpecificConfig, prototype);

    if (tagName === 'SCRIPT') {
      SecureScriptElement.setOverrides(tagNameSpecificConfig, prototype);
    }

    Object.defineProperties(prototype, tagNameSpecificConfig);

    // Build case insensitive index for attribute validation
    Object.keys(prototype).forEach(k => {
      const lower = k.toLowerCase();
      if (lower !== k) {
        caseInsensitiveAttributes[lower] = true;
      }
    });

    prototypeInfo = {
      prototype: prototype,
      expandoCapturingHandler: expandoCapturingHandler
    };

    prototypes.set(tagName, prototypeInfo);
  }

  o = Object.create(prototypeInfo.prototype);

  if (prototypeInfo.expandoCapturingHandler) {
    setRef(o, el, key);
    o = new Proxy(o, prototypeInfo.expandoCapturingHandler);
  }

  setRef(o, el, key);
  addToCache(el, o, key);
  registerProxy(o);
  // Mark the proxy to be unwrapped by custom formatter
  assert$1.block(() => {
    addProxy(o, el);
  });
  return o;
}

SecureElement.isValidAttributeName = function(raw, name, prototype, caseInsensitiveAttributes) {
  // Reason: [W-4210397] Locker does not allow setting custom HTTP headers.
  if (raw.tagName === 'META' && name.toLowerCase() === 'http-equiv') {
    return false;
  }

  // Always allow names with the form a-b.* (e.g. data-foo, x-foo, ng-repeat, etc)
  if (name.indexOf('-') >= 0) {
    return true;
  }

  if (name in caseInsensitiveAttributes) {
    return true;
  }

  // Allow SVG elements free reign
  if (raw instanceof SVGElement) {
    return true;
  }

  if (name in prototype) {
    return true;
  }

  // Special case Label element's 'for' attribute. It called 'htmlFor' on prototype but
  // needs to be addressable as 'for' via accessors like .attributes/getAttribute()/setAtribute()
  if (raw.tagName === 'LABEL' && name.toLowerCase() === 'for') {
    return true;
  }

  // Special case Meta element's custom 'property' attribute. It used by the Open Graph protocol.
  if (raw.tagName === 'META' && name.toLowerCase() === 'property') {
    return true;
  }

  return false;
};

SecureElement.addStandardMethodAndPropertyOverrides = function(
  prototype,
  caseInsensitiveAttributes,
  key
) {
  Object.defineProperties(prototype, {
    appendChild: {
      writable: true,
      value: function(child) {
        if (!runIfRunnable(child)) {
          const e = SecureObject.getRaw(this);
          e.appendChild(getRef(child, getKey(this), true));
        }

        return child;
      }
    },

    replaceChild: {
      writable: true,
      value: function(newChild, oldChild) {
        if (!runIfRunnable(newChild)) {
          const e = SecureObject.getRaw(this);
          const k = getKey(this);
          e.replaceChild(getRef(newChild, k, true), getRef(oldChild, k, true));
        }

        return oldChild;
      }
    },

    insertBefore: {
      writable: true,
      value: function(newNode, referenceNode) {
        if (!runIfRunnable(newNode)) {
          const e = SecureObject.getRaw(this);
          const k = getKey(this);
          e.insertBefore(
            getRef(newNode, k, true),
            referenceNode ? getRef(referenceNode, k, true) : null
          );
        }

        return newNode;
      }
    },

    querySelector: {
      writable: true,
      value: function(selector) {
        const raw = SecureObject.getRaw(this);
        return SecureElement.secureQuerySelector(raw, getKey(this), selector);
      }
    },

    insertAdjacentHTML: {
      writable: true,
      value: function(position, text) {
        const raw = SecureObject.getRaw(this);

        // Do not allow insertAdjacentHTML on shared elements (body/head)
        if (SecureElement.isSharedElement(raw)) {
          throw new error(
            `SecureElement.insertAdjacentHTML cannot be used with ${raw.tagName} elements!`
          );
        }

        let parent;
        if (position === 'afterbegin' || position === 'beforeend') {
          // We have access to el, nothing else to check.
        } else if (position === 'beforebegin' || position === 'afterend') {
          // Prevent writing outside secure node.
          parent = raw.parentNode;
          verifyAccess(this, parent, true);
        } else {
          throw new error(
            "SecureElement.insertAdjacentHTML requires position 'beforeBegin', 'afterBegin', 'beforeEnd', or 'afterEnd'."
          );
        }

        raw.insertAdjacentHTML(position, DOMPurify['sanitize'](text, domPurifyConfig));

        trustChildNodes(this, parent || raw);
      }
    },

    removeChild: SecureObject.createFilteredMethodStateless('removeChild', prototype, {
      rawArguments: true,
      beforeCallback: function(child) {
        // Verify that the passed in child is not opaque!
        verifyAccess(this, child, true);
      }
    }),

    cloneNode: {
      writable: true,
      value: function(deep) {
        function copyKeys(from, to) {
          // Copy keys from the original to the cloned tree
          const fromKey = getKey(from);
          if (fromKey) {
            setKey(to, fromKey);
          }

          const toChildren = to.childNodes;
          const length = toChildren.length;
          if (length > 0) {
            const fromChildren = from.childNodes;
            for (let i = 0; i < length; i++) {
              copyKeys(fromChildren[i], toChildren[i]);
            }
          }
        }

        const e = SecureObject.getRaw(this);
        const root = e.cloneNode(deep);

        // Maintain the same ownership in the cloned subtree
        copyKeys(e, root);

        return SecureElement(root, getKey(this));
      }
    },

    textContent: {
      get: function() {
        return cloneFiltered(SecureObject.getRaw(this), this).textContent;
      },
      set: function(value) {
        const raw = SecureObject.getRaw(this);
        if (SecureElement.isSharedElement(raw)) {
          throw new error(
            `SecureElement.textContent cannot be used with ${raw.tagName} elements!`
          );
        }

        raw.textContent = value;

        trustChildNodes(this, raw);
      }
    },

    hasChildNodes: {
      value: function() {
        const raw = SecureObject.getRaw(this);
        // If this is a shared element, delegate the call to the shared element, no need to check for access
        if (SecureElement.isSharedElement(raw)) {
          return raw.hasChildNodes();
        }
        const childNodes = raw.childNodes;
        for (let i = 0; i < childNodes.length; i++) {
          if (hasAccess(this, childNodes[i])) {
            return true;
          }
        }
        return false;
      }
    },

    getAttribute: SecureElement.createAttributeAccessMethodConfig(
      'getAttribute',
      prototype,
      caseInsensitiveAttributes,
      null,
      undefined,
      undefined,
      key
    ),
    getAttributeNS: SecureElement.createAttributeAccessMethodConfig(
      'getAttributeNS',
      prototype,
      caseInsensitiveAttributes,
      null,
      true,
      undefined,
      key
    ),
    getAttributeNode: SecureElement.createAttributeAccessMethodConfig(
      'getAttributeNode',
      prototype,
      caseInsensitiveAttributes,
      null,
      undefined,
      undefined,
      key
    ),
    getAttributeNodeNS: SecureElement.createAttributeAccessMethodConfig(
      'getAttributeNodeNS',
      prototype,
      caseInsensitiveAttributes,
      null,
      true,
      undefined,
      key
    ),

    setAttribute: SecureElement.createAttributeAccessMethodConfig(
      'setAttribute',
      prototype,
      caseInsensitiveAttributes,
      undefined,
      undefined,
      undefined,
      key
    ),
    setAttributeNS: SecureElement.createAttributeAccessMethodConfig(
      'setAttributeNS',
      prototype,
      caseInsensitiveAttributes,
      undefined,
      true,
      undefined,
      key
    ),
    setAttributeNode: SecureElement.createAttributeAccessMethodConfig(
      'setAttributeNode',
      prototype,
      caseInsensitiveAttributes,
      undefined,
      undefined,
      'name',
      key
    ),
    setAttributeNodeNS: SecureElement.createAttributeAccessMethodConfig(
      'setAttributeNodeNS',
      prototype,
      caseInsensitiveAttributes,
      undefined,
      true,
      'name',
      key
    ),

    removeAttributeNode: SecureElement.createAttributeAccessMethodConfig(
      'removeAttributeNode',
      prototype,
      caseInsensitiveAttributes,
      undefined,
      undefined,
      'name',
      key
    ),
    removeAttributeNodeNS: SecureElement.createAttributeAccessMethodConfig(
      'removeAttributeNodeNS',
      prototype,
      caseInsensitiveAttributes,
      undefined,
      true,
      'name',
      key
    )
  });
};

/* SecureElement.validateURLScheme = function(value) {
  const url = sanitizeURLForElement(value);

  if (!isValidURLScheme(url)) {
    throw new report.error(
      'An unsupported URL scheme was detected. Only http:// and https:// are supported.'
    );
  }

  return url;
}; */

SecureElement.createAttributeAccessMethodConfig = function(
  methodName,
  prototype,
  caseInsensitiveAttributes,
  invalidAttributeReturnValue,
  namespaced,
  nameProp,
  key
) {
  return {
    writable: true,
    value: function() {
      const raw = SecureObject.getRaw(this);
      let args = SecureObject.ArrayPrototypeSlice.call(arguments);

      let name = args[namespaced ? 1 : 0];
      if (nameProp) {
        name = name[nameProp];
      }
      if (!SecureElement.isValidAttributeName(raw, name, prototype, caseInsensitiveAttributes)) {
        warn(
          `${this} does not allow getting/setting the ${name.toLowerCase()} attribute, ignoring!`
        );
        return invalidAttributeReturnValue;
      }

      // args[0] is the attribute name. args[1] is the attribute value
      /* if (args[0] === 'href' || args[0] === 'src') {
        args[1] = SecureElement.validateURLScheme(args[1]);
      } */

      args = SecureObject.filterArguments(this, args, { rawArguments: true });
      const ret = raw[methodName].apply(raw, args);
      return ret instanceof Node ? SecureElement(ret, key) : ret;
    }
  };
};

SecureElement.isSharedElement = function(el) {
  return el === document.body || el === document.head || el === document.documentElement;
};

SecureElement.secureQuerySelector = function(el, key, selector) {
  const rawAll = el.querySelectorAll(selector);
  for (let n = 0; n < rawAll.length; n++) {
    const raw = rawAll[n];
    const rawKey = getKey(raw);
    if (rawKey === key || SecureElement.isSharedElement(raw)) {
      return SecureElement(raw, key);
    }
  }

  return null;
};

/*
 * Copyright (C) 2013 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

let filterTypeHook$1;
function registerFilterTypeHook(hook) {
  filterTypeHook$1 = hook;
}
let isUnfilteredTypeHook$1;
function registerIsUnfilteredTypeHook(hook) {
  isUnfilteredTypeHook$1 = hook;
}

function SecureObject(thing, key) {
  let o = getFromCache(thing, key);
  if (o) {
    return o;
  }

  o = Object.create(null, {
    toString: {
      value: function() {
        return `SecureObject: ${thing}{ key: ${JSON.stringify(key)} }`;
      }
    }
  });

  setRef(o, thing, key, true);
  addToCache(thing, o, key);
  registerProxy(o);

  return Object.seal(o);
}

const defaultSecureObjectKey = {
  defaultSecureObjectKey: true
};

SecureObject.getRaw = function(so) {
  const raw = getRef(so, getKey(so));

  if (!raw) {
    throw new Error('Blocked attempt to invoke secure method with altered this!');
  }

  return raw;
};

SecureObject.isDOMElementOrNode = function(el) {
  return (
    typeof el === 'object' &&
    ((typeof HTMLElement === 'object' && el instanceof HTMLElement) ||
      (typeof Node === 'object' && el instanceof Node) ||
      (typeof el.nodeType === 'number' && typeof el.nodeName === 'string'))
  );
};

/**
 * Filter the given raw object with the accessors key and provide a filtered view.
 * Best used when the type of "raw" is not known
 * @param st Represents the accessor who is trying to access "raw"
 * @param raw The raw object that we are trying to filter
 * @param options
 * @returns {*}
 */
SecureObject.filterEverything = function(st, raw, options) {
  if (!raw) {
    // ignoring falsy, nully references.
    return raw;
  }

  const t = typeof raw;

  const key = getKey(st);
  const cached = getFromCache(raw, key);
  if (cached) {
    return cached;
  }

  // Handle already proxied things
  const rawKey = getKey(raw);
  const belongsToLocker = rawKey === key;
  const defaultKey = options && options.defaultKey ? options.defaultKey : defaultSecureObjectKey;

  if (isProxy(raw)) {
    // - If !belongsToLocker then this is a jump from one locker to another - we just need to unwrap and then reproxy based on the target locker's perspective
    // otherwise just return the proxy (do not proxy a proxy).
    // - Bypass unwrapping and refiltering for SecureFunction so arguments and 'this' are filtered against the
    // Locker where the function was originally defined.
    return belongsToLocker || isSecureFunction(raw)
      ? raw
      : SecureObject.filterEverything(st, getRef(raw, rawKey), options);
  }

  let swallowed;
  let mutated = false;
  if (t === 'function') {
    // wrapping functions to guarantee that they run in system mode but their
    // returned value complies with user-mode.
    swallowed = function SecureFunction() {
      // special unfiltering logic to unwrap Proxies passed back to origin.
      // this could potentially be folded into filterArguments with an option set if needed.
      const filteredArgs = [];
      for (let i = 0; i < arguments.length; i++) {
        let arg = arguments[i];
        if (isFilteringProxy(arg)) {
          const unfilteredProxy = getRef(arg, getKey(arg));
          const unfilteredKey = getKey(unfilteredProxy);
          arg =
            unfilteredKey === getKey(raw)
              ? unfilteredProxy
              : SecureObject.filterEverything(st, arg);
        } else {
          arg = SecureObject.filterEverything(st, arg);
        }
        filteredArgs[i] = arg;
      }

      let self = SecureObject.filterEverything(st, this);
      if (isFilteringProxy(self) && getKey(self) === getKey(st)) {
        self = getRef(self, key);
      }

      const fnReturnedValue = raw.apply(self, filteredArgs);

      return SecureObject.filterEverything(st, fnReturnedValue, options);
    };

    mutated = true;
    setRef(swallowed, raw, key);

    if (!rawKey) {
      setKey(raw, defaultKey);
    }

    registerProxy(swallowed);
    registerSecureFunction(swallowed);
  } else if (t === 'object') {
    if (raw === window) {
      return getEnv$1(key);
    } else if (raw === document) {
      return getEnv$1(key).document;
    } else if (raw === window.location) {
      return getEnv$1(key).location;
    }

    const isNodeList = raw && (raw instanceof NodeList || raw instanceof HTMLCollection);
    if (Array.isArray(raw)) {
      if (!belongsToLocker) {
        if (!rawKey) {
          // Array that was created in this locker or system mode but not yet keyed - key it now
          setKey(raw, defaultKey);
          return SecureObject.filterEverything(st, raw, options);
        }
        swallowed = SecureObject.createProxyForArrayObjects(raw, key);
        setRef(swallowed, raw, key);
        addToCache(raw, swallowed, key);
        mutated = true;
      }
    } else if (isNodeList) {
      swallowed = SecureObject.createProxyForArrayLikeObjects(raw, key);
      setRef(swallowed, raw, key);
      mutated = true;
    } else {
      assert(key, 'A secure object should always have a key.');
      if (filterTypeHook$1) {
        swallowed = filterTypeHook$1(raw, key, belongsToLocker);
      }
      if (swallowed) {
        mutated = raw !== swallowed;
      } else if (SecureObject.isDOMElementOrNode(raw)) {
        if (belongsToLocker || SecureElement.isSharedElement(raw)) {
          swallowed = SecureElement(raw, key);
        } else if (!options) {
          swallowed = SecureObject(raw, key);
        } else if (raw instanceof Attr && !rawKey) {
          setKey(raw, defaultKey);
          return SecureObject.filterEverything(st, raw, options);
        } else {
          swallowed = options.defaultValue;
          addToCache(raw, swallowed, key);
        }
        mutated = true;
      } else if (raw instanceof Event) {
        swallowed = SecureDOMEvent(raw, key);
        mutated = true;
      } else if (typeof raw['Window'] === 'function' && raw instanceof raw['Window']) {
        // Cross realm window instances (window.open() and iframe.contentWindow)
        swallowed = SecureIFrameElement.SecureIFrameContentWindow(raw, key);
        SecureObject.addMethodIfSupported(swallowed, raw, 'close');
        SecureObject.addMethodIfSupported(swallowed, raw, 'focus');
        SecureObject.addPropertyIfSupported(swallowed, raw, 'opener');
        SecureObject.addPropertyIfSupported(swallowed, raw, 'closed', { writable: false });

        mutated = true;
      } else if (raw instanceof CanvasRenderingContext2D) {
        swallowed = SecureCanvasRenderingContext2D(raw, key);
        mutated = true;
      } else if (SecureObject.isUnfilteredType(raw, key)) {
        // return raw for unfiltered types
        mutated = false;
      } else {
        if (!belongsToLocker) {
          if (!rawKey) {
            // Object that was created in this locker or in system mode and not yet keyed - key it now
            setKey(raw, defaultKey);
            return SecureObject.filterEverything(st, raw, options);
          }
          swallowed = SecureObject.createFilteringProxy(raw, key);
          addToCache(raw, swallowed, key);
          mutated = true;
        }
      }
    }
  }

  return mutated ? swallowed : raw;
};

SecureObject.filterArguments = function(st, args, options) {
  function getRaw(v) {
    if (isProxy(v)) {
      const key = getKey(v);
      const ref = getRef(v, key);
      v = ref;
    }

    return v;
  }

  function getRawArray(v) {
    const result = [];
    for (let i = 0; i < v.length; i++) {
      result.push(getRaw(v[i]));
    }
    return result;
  }

  args = SecureObject.ArrayPrototypeSlice.call(args);

  if (options && options.beforeCallback) {
    options.beforeCallback.apply(st, args);
  }
  if (options && options.unfilterEverything) {
    return options.unfilterEverything.call(st, args);
  }

  const rawArguments = options && options.rawArguments;
  for (let n = 0; n < args.length; n++) {
    const value = args[n];
    if (value) {
      if (rawArguments && typeof value === 'object') {
        args[n] = Array.isArray(value) ? getRawArray(value) : getRaw(value);
      } else {
        args[n] = SecureObject.filterEverything(st, value, options);
      }
    }
  }

  return args;
};

function convertSymbol(property) {
  // Symbols have to be handled in some browsers
  if (typeof property === 'symbol') {
    if (property === Symbol['toStringTag']) {
      property = 'toString';
    } else {
      property = property.toString();
    }
  }

  return property;
}

const unfilteredConstructors = [Object, Array];

const filteringProxyHandler = (function() {
  function FilteringProxyHandler() {}

  FilteringProxyHandler.prototype['get'] = function(target, property) {
    const raw = getRef(target, getKey(target));
    const value = raw[property];

    if (!value) {
      return value;
    }

    if (property === 'constructor' && unfilteredConstructors.includes(value)) {
      return value;
    }

    return SecureObject.filterEverything(target, value);
  };

  FilteringProxyHandler.prototype['set'] = function(target, property, value) {
    const raw = getRef(target, getKey(target));

    const filteredValue = value ? SecureObject.filterEverything(target, value) : value;

    raw[property] = filteredValue;

    return true;
  };

  // These are all direct pass through methods to preserve the shape etc of the delegate

  FilteringProxyHandler.prototype['getPrototypeOf'] = function(target) {
    const raw = getRef(target, getKey(target));
    return Object.getPrototypeOf(raw);
  };

  FilteringProxyHandler.prototype['setPrototypeOf'] = function(target, prototype) {
    const raw = getRef(target, getKey(target));
    return Object.setPrototypeOf(raw, prototype);
  };

  FilteringProxyHandler.prototype['has'] = function(target, property) {
    const raw = getRef(target, getKey(target));
    return property in raw;
  };

  FilteringProxyHandler.prototype['defineProperty'] = function(target, property, descriptor) {
    const raw = getRef(target, getKey(target));
    Object.defineProperty(raw, property, descriptor);
    return true;
  };

  FilteringProxyHandler.prototype['deleteProperty'] = function(target, property) {
    const raw = getRef(target, getKey(target));
    delete target[property];
    delete raw[property];
    return true;
  };

  FilteringProxyHandler.prototype['ownKeys'] = function(target) {
    const raw = getRef(target, getKey(target));
    return Object.keys(raw);
  };

  FilteringProxyHandler.prototype['getOwnPropertyDescriptor'] = function(target, property) {
    // If the property is non-writable and non-configurable, there is nothing to do.
    const targetDescriptor = Object.getOwnPropertyDescriptor(target, property);
    if (targetDescriptor && !targetDescriptor.configurable && !targetDescriptor.writable) {
      return targetDescriptor;
    }

    // Always get the descriptor of the raw object.
    const raw = getRef(target, getKey(target));
    const rawDescriptor = Object.getOwnPropertyDescriptor(raw, property);
    if (rawDescriptor) {
      // Always filter the descriptor value.
      if (rawDescriptor.hasOwnProperty('value')) {
        rawDescriptor.value = SecureObject.filterEverything(target, rawDescriptor.value);
      }

      // Always remove from the surrogate (and redefine if necessary).
      if (targetDescriptor) {
        Reflect.deleteProperty(target, property);
      }

      // Use the surrogate to preserve invariants.
      // Only non-configurable properties are verified against the target.
      if (!rawDescriptor.configurable) {
        Object.defineProperty(target, property, rawDescriptor);
      }
    } else if (targetDescriptor) {
      // Update the surrogate when the property is no longer on raw.
      Reflect.deleteProperty(target, property);
    }

    return rawDescriptor;
  };

  FilteringProxyHandler.prototype['isExtensible'] = function(target) {
    const raw = getRef(target, getKey(target));
    return Object.isExtensible(raw);
  };

  FilteringProxyHandler.prototype['preventExtensions'] = function(target) {
    const raw = getRef(target, getKey(target));
    return Object.preventExtensions(raw);
  };

  return Object.freeze(new FilteringProxyHandler());
})();

SecureObject.createFilteringProxy = function(raw, key) {
  // Use a direct proxy on raw to a proxy on {} to avoid the Proxy invariants for non-writable, non-configurable properties
  const surrogate = Object.create(Object.getPrototypeOf(raw));
  setRef(surrogate, raw, key);

  const rawKey = getKey(raw);
  if (!rawKey) {
    // This is a newly created plain old js object - stamp it with the key
    setKey(raw, key);
  }

  const swallowed = new Proxy(surrogate, filteringProxyHandler);
  registerProxy(swallowed);

  // DCHASMAN TODO We should be able to remove this (replaced with ls.setKey()) in the next phase of proxy work where we remove unfilterEverything() as something that is done all the time
  setRef(swallowed, raw, key);

  addToCache(raw, swallowed, key);

  registerFilteringProxy(swallowed);

  return swallowed;
};

// We cache 1 array like thing proxy per key
const KEY_TO_ARRAY_LIKE_THING_HANDLER = typeof Map !== 'undefined' ? new Map() : undefined;

function getFilteredArrayLikeThings(raw, key) {
  const filtered = [];

  for (let n = 0; n < raw.length; n++) {
    const value = raw[n];
    if (getKey(value) === key || SecureElement.isSharedElement(value)) {
      filtered.push(value);
    }
  }
  return filtered;
}

function getArrayLikeThingProxyHandler(key) {
  function getFromFiltered(so, filtered, index) {
    // Numeric indexing into array
    const value = filtered[index];
    return value ? SecureObject.filterEverything(so, value) : value;
  }

  let handler = KEY_TO_ARRAY_LIKE_THING_HANDLER.get(key);
  if (!handler) {
    handler = {
      get: function(target, property) {
        const raw = getRef(target, key);

        const filtered = getFilteredArrayLikeThings(raw, key);
        let ret;

        property = convertSymbol(property);
        if (Number.isNaN(Number(property))) {
          switch (property) {
            case 'length':
              ret = filtered.length;
              break;

            case 'item':
              ret = function(index) {
                return getFromFiltered(handler, filtered, index);
              };
              break;

            case 'namedItem':
              ret = function(name) {
                const value = raw.namedItem(name);
                return value ? SecureObject.filterEverything(handler, value) : value;
              };
              break;

            case 'toString':
              ret = function() {
                return raw.toString();
              };
              break;

            case 'toJSON':
              ret = function() {
                return JSON.stringify(filtered);
              };
              break;
            case 'Symbol(Symbol.iterator)':
              ret = function() {
                let nextIndex = 0;
                return {
                  next: function() {
                    if (nextIndex < filtered.length) {
                      const value = filtered[nextIndex];
                      nextIndex++;
                      return {
                        value: value ? SecureObject.filterEverything(handler, value) : value,
                        done: false
                      };
                    }
                    return { done: true };
                  }
                };
              };
              break;
            default:
              warn(`Unsupported ${raw} method: ${property}. Returning undefined`);
              return undefined;
          }
        } else {
          ret = getFromFiltered(handler, filtered, property);
        }

        return ret;
      },
      has: function(target, property) {
        const raw = getRef(target, key);
        const filtered = getFilteredArrayLikeThings(raw, key);
        return property in filtered;
      }
    };

    setKey(handler, key);

    KEY_TO_ARRAY_LIKE_THING_HANDLER.set(key, handler);

    Object.freeze(handler);
  }

  return handler;
}

SecureObject.createProxyForArrayLikeObjects = function(raw, key) {
  const surrogate = Object.create(Object.getPrototypeOf(raw));
  setRef(surrogate, raw, key);

  const proxy = new Proxy(surrogate, getArrayLikeThingProxyHandler(key));
  setKey(proxy, key);
  registerProxy(proxy);

  return proxy;
};

// We cache 1 array proxy per key
const KEY_TO_ARRAY_HANLDER = typeof Map !== 'undefined' ? new Map() : undefined;

function getFilteredArray(st, raw, key) {
  const filtered = [];
  // TODO: RJ, we are missing named(non-integer) properties, changing this for loop to for..in should fix it
  for (let n = 0; n < raw.length; n++) {
    const value = raw[n];
    let validEntry = false;
    if (
      !value || // Array can contain undefined/null/false/0 such falsy values
      getKey(value) === key // Value has been keyed and belongs to this locker
    ) {
      validEntry = true;
    } else {
      const filteredValue = SecureObject.filterEverything(st, value, { defaultKey: key });
      if (filteredValue && !isOpaque(filteredValue)) {
        validEntry = true;
      }
    }
    if (validEntry) {
      // Store the raw index and value in an object
      filtered.push({ rawIndex: n, rawValue: value });
    }
  }

  return filtered;
}

function getArrayProxyHandler(key) {
  function getFromFiltered(so, filtered, index) {
    // Numeric indexing into array
    const value = filtered[index] ? filtered[index]['rawValue'] : filtered[index];
    return value ? SecureObject.filterEverything(so, value) : value;
  }
  function getFilteredValues(so, filtered) {
    // Gather values from the filtered array
    const ret = [];
    filtered.forEach(item => {
      const value = item['rawValue'];
      ret.push(value ? SecureObject.filterEverything(so, value) : value);
    });
    return ret;
  }
  let handler = KEY_TO_ARRAY_HANLDER.get(key);
  if (!handler) {
    handler = {
      getPrototypeOf: function(target) {
        return Object.getPrototypeOf(target);
      },
      setPrototypeOf: function(target, newProto) {
        return Object.setPrototypeOf(target, newProto);
      },
      isExtensible: function(target) {
        return Object.isExtensible(target);
      },
      preventExtensions: function(target) {
        Object.preventExtensions(target);
        return getFromCache(target, key);
      },
      getOwnPropertyDescriptor: function(target, property) {
        const raw = target;
        const filtered = getFilteredArray(handler, raw, key);
        if (property === 'length') {
          return Object.getOwnPropertyDescriptor(filtered, property);
        }
        if (property in filtered) {
          return Object.getOwnPropertyDescriptor(raw, filtered[property]['rawIndex']);
        }
        return undefined;
      },
      defineProperty: function(target, property, descriptor) {
        const raw = target;
        Object.defineProperty(raw, property, descriptor);
        return true;
      },
      get: function(target, property) {
        const raw = target;
        const filtered = getFilteredArray(handler, raw, key);
        let ret;

        if (property === 'constructor' && unfilteredConstructors.includes(raw[property])) {
          return raw[property];
        }

        property = convertSymbol(property);
        const coercedProperty = Number(property);
        // If the property is 0 or a positive integer
        if (
          !Number.isNaN(coercedProperty) &&
          Number.isInteger(coercedProperty) &&
          coercedProperty >= 0
        ) {
          ret = getFromFiltered(handler, filtered, property);
        } else {
          switch (property) {
            case 'length':
              ret = filtered.length;
              break;
            case 'pop':
              ret = function() {
                if (filtered.length > 0) {
                  // Get the filtered value by index to return
                  const itemValue = getFromFiltered(handler, filtered, filtered.length - 1);
                  // Get raw index and update the raw array
                  const itemToRemove = filtered.pop();
                  raw.splice(itemToRemove['rawIndex'], 1);
                  return itemValue;
                }
                return undefined;
              };
              break;
            case 'push':
              ret = function() {
                if (arguments.length === 0) {
                  return filtered.length;
                }
                for (let i = 0; i < arguments.length; i++) {
                  raw.push(SecureObject.filterEverything(handler, arguments[i]));
                }
                return filtered.length + arguments.length;
              };
              break;
            case 'reverse':
              ret = function() {
                raw.reverse();
                return getFromCache(raw, key);
              };
              break;
            case 'shift':
              ret = function() {
                if (filtered.length > 0) {
                  // Get the filtered value by index to return
                  const itemValue = getFromFiltered(handler, filtered, 0);
                  // Get raw index and update the raw array
                  const itemToRemove = filtered.shift();
                  raw.splice(itemToRemove['rawIndex'], 1);
                  return itemValue;
                }
                return undefined;
              };
              break;
            case 'sort':
              ret = function(compareFunction) {
                if (arguments.length > 0) {
                  raw.sort(SecureObject.filterEverything(handler, compareFunction));
                } else {
                  raw.sort();
                }
                return getFromCache(raw, key);
              };
              break;
            case 'splice':
              ret = function(start, deleteCount) {
                let positionToInsert = raw.length; // By default insert at the end of raw
                const itemsToRemove = filtered.splice(start, deleteCount);
                // If there are items to remove
                if (itemsToRemove.length > 0) {
                  // Get position to insert the new items if there are any
                  positionToInsert = itemsToRemove[0]['rawIndex'];
                  // Remove from raw
                  for (let i = 0; i < itemsToRemove.length; i++) {
                    const itemToRemove = itemsToRemove[i];
                    // Remove from raw
                    raw.splice(itemToRemove['rawIndex'] - i, 1); // Since we are removing elements from raw, account for index adjustment
                  }
                } else {
                  // Not deleting anything but inserting
                  if (start >= 0 && start < filtered.length) {
                    positionToInsert = filtered[start]['rawIndex'];
                  } else if (start >= filtered.length) {
                    // If position is bigger than filtered's last index, insert at end of raw
                    positionToInsert = raw.length;
                  } else {
                    // If start is a negative
                    // If trying to insert at the beginning of filtered array
                    if (filtered.length + start <= 0) {
                      positionToInsert = filtered.length > 0 ? filtered[0]['rawIndex'] : raw.length;
                    } else {
                      // Else inserting in the middle of filtered array, get index of element in raw array
                      positionToInsert = filtered[filtered.length + start]['rawIndex'];
                    }
                  }
                }
                // If there are items to be inserted
                const newItems = [];
                if (arguments.length > 2) {
                  for (let j = 2; j < arguments.length; j++) {
                    newItems.push(SecureObject.filterEverything(handler, arguments[j]));
                  }
                }
                if (newItems.length > 0) {
                  raw.splice.apply(raw, [positionToInsert, 0].concat(newItems));
                }
                return getFilteredValues(handler, itemsToRemove);
              };
              break;
            case 'unshift':
              ret = function() {
                if (arguments.length === 0) {
                  return filtered.length;
                }
                const newItems = [];
                for (let i = 0; i < arguments.length; i++) {
                  newItems.push(SecureObject.filterEverything(handler, arguments[i]));
                }
                raw.splice.apply(raw, [0, 0].concat(newItems));
                return filtered.length + newItems.length;
              };
              break;
            case 'concat':
            case 'indexOf':
            case 'join':
            case 'lastIndexOf':
            case 'slice':
              ret = function() {
                const filteredValues = getFilteredValues(handler, filtered);
                return filteredValues[property].apply(filteredValues, arguments);
              };
              break;
            // For the iteration handlers, secure the callback function and invoke the method on filtered array
            case 'every':
            case 'filter':
            case 'forEach':
            case 'map':
            case 'reduce':
            case 'reduceRight':
            case 'some':
              ret = function() {
                if (arguments.length > 0) {
                  const secureCallback = SecureObject.filterEverything(handler, arguments[0]);
                  arguments[0] = secureCallback;
                }
                const filteredValues = getFilteredValues(handler, filtered);
                return filteredValues[property].apply(filteredValues, arguments);
              };
              break;
            case 'toString':
              ret = function() {
                const filteredValues = getFilteredValues(handler, filtered);
                return filteredValues.toString();
              };
              break;
            case 'Symbol(Symbol.iterator)':
              ret = function() {
                let nextIndex = 0;
                return {
                  next: function() {
                    if (nextIndex < filtered.length) {
                      const value = filtered[nextIndex]['rawValue'];
                      nextIndex++;
                      return {
                        value: value ? SecureObject.filterEverything(handler, value) : value,
                        done: false
                      };
                    }
                    return { done: true };
                  }
                };
              };
              break;
            case 'Symbol(Symbol.isConcatSpreadable)':
              ret = raw[Symbol.isConcatSpreadable];
              break;
            default:
              if (raw[property]) {
                // If trying to use array like an associative array
                ret = SecureObject.filterEverything(handler, raw[property]);
              } else {
                warn(`Unsupported ${raw} method: ${property}. Returning undefined`);
                return undefined;
              }
          }
        }
        return ret;
      },
      set: function(target, property, value) {
        const raw = target;
        // Setting numerical indexes, number has to be positive integer, else its treated as an associative array key
        const coercedProperty = Number(property);
        if (
          !Number.isNaN(coercedProperty) &&
          Number.isInteger(coercedProperty) &&
          coercedProperty >= 0
        ) {
          // Refilter raw to recreate the index mapping between raw and filtered value
          const filtered = getFilteredArray(handler, raw, key);
          // If we are replacing existing index
          if (filtered[property]) {
            raw[filtered[property]['rawIndex']] = SecureObject.filterEverything(handler, value);
            return true;
          }
          // Adding values at a random numerical index greater than length
          const filteredLength = filtered.length;
          const newItems = [];
          for (let i = 0; i < property - filtered.length; i++) {
            newItems.push(undefined);
          }
          newItems.push(value);
          // Find the position in raw where we have to insert the new items
          // If filtered is empty, insert at beginning of raw
          // else, find the rawIndex of last filtered element and insert one after
          const positionToInsert = filteredLength
            ? filtered[filteredLength - 1]['rawIndex'] + 1
            : 0;
          raw.splice.apply(raw, [positionToInsert, 0].concat(newItems));
          return true;
        }
        // Trying to use it like an associative array
        raw[property] = SecureObject.filterEverything(handler, value);
        return true;
      },
      has: function(target, property) {
        const raw = target;
        const filtered = getFilteredArray(handler, raw, key);
        return property in filtered;
      },
      ownKeys: function(target) {
        const raw = target;
        const filtered = getFilteredArray(handler, raw, key);
        return Object.getOwnPropertyNames(filtered);
      },
      deleteProperty: function(target, property) {
        const raw = target;
        const coercedProperty = Number(property);
        // If property is a numerical index(0 or positive integer)
        if (
          !Number.isNaN(coercedProperty) &&
          Number.isInteger(coercedProperty) &&
          coercedProperty >= 0
        ) {
          const filtered = getFilteredArray(handler, raw, key);
          if (filtered[property]) {
            delete raw[filtered[property]['rawIndex']];
          }
        } else {
          const value = raw[property];
          // If value was set by using the array like an associative array
          if (value) {
            // Check if we have access
            const rawValue = getRef(value, key);
            if (rawValue) {
              delete raw[property];
            }
          }
        }
        return true;
      }
      // Not handling "apply" and "construct" trap and letting the underlying raw handle apply and throw the error
    };

    setKey(handler, key);

    KEY_TO_ARRAY_HANLDER.set(key, handler);

    Object.freeze(handler);
  }

  return handler;
}

SecureObject.createProxyForArrayObjects = function(raw, key) {
  if (!Array.isArray(raw)) {
    warn('Illegal usage of SecureObject.createProxyForArrayObjects');
    return SecureObject.createFilteringProxy(raw, key);
  }
  // Not using a surrogate for array Proxy because we want to support for..in style of looping on arrays
  // Having a fake surrogate does not allow for correct looping. Mitigating this risk by handling all traps for Proxy.
  const proxy = new Proxy(raw, getArrayProxyHandler(key));
  setKey(proxy, key);
  registerProxy(proxy);

  return proxy;
};

const KEY_TO_NAMED_NODE_MAP_HANLDER = typeof Map !== 'undefined' ? new Map() : undefined;

function getFilteredNamedNodeMap(raw, key, prototype, caseInsensitiveAttributes) {
  const filtered = {};

  for (let n = 0; n < raw.length; n++) {
    const value = raw[n];
    if (SecureElement.isValidAttributeName(raw, value.name, prototype, caseInsensitiveAttributes)) {
      filtered[n] = value;
    }
  }

  return filtered;
}

function getNamedNodeMapProxyHandler(key, prototype, caseInsensitiveAttributes) {
  function getFromFiltered(so, filtered, index) {
    const value = filtered[index];
    return value ? SecureObject.filterEverything(so, value, { defaultKey: key }) : value;
  }

  let handler = KEY_TO_NAMED_NODE_MAP_HANLDER.get(key);
  if (!handler) {
    handler = {
      get: function(target, property) {
        const raw = getRef(target, key);

        const filtered = getFilteredNamedNodeMap(raw, key, prototype, caseInsensitiveAttributes);
        let ret;

        property = convertSymbol(property);
        if (Number.isNaN(Number(property))) {
          switch (property) {
            case 'length':
              ret = Object.keys(filtered).length;
              break;
            case 'item':
              ret = function(index) {
                return getFromFiltered(handler, filtered, index);
              };
              break;
            case 'getNamedItem':
              ret = function(name) {
                for (const val in filtered) {
                  if (name === filtered[val].name) {
                    return SecureObject.filterEverything(handler, filtered[val], {
                      defaultKey: key
                    });
                  }
                }
                return null;
              };
              break;
            case 'setNamedItem':
              ret = function(attribute) {
                if (
                  !SecureElement.isValidAttributeName(
                    raw,
                    attribute.name,
                    prototype,
                    caseInsensitiveAttributes
                  )
                ) {
                  warn(
                    `${this} does not allow getting/setting the ${attribute.name.toLowerCase()} attribute, ignoring!`
                  );
                  return undefined;
                }
                // it may not be possible to get here from another Locker so the access check may be unnecessary
                // keep to error on the safe side
                verifyAccess(attribute, target);
                if (isProxy(attribute)) {
                  attribute = getRef(attribute, key);
                }
                return SecureObject.filterEverything(handler, raw['setNamedItem'](attribute), {
                  defaultKey: key
                });
              };
              break;
            case 'removeNamedItem':
              ret = function(name) {
                if (
                  !SecureElement.isValidAttributeName(
                    raw,
                    name,
                    prototype,
                    caseInsensitiveAttributes
                  )
                ) {
                  warn(
                    `${this} does not allow removing the ${name.toLowerCase()} attribute, ignoring!`
                  );
                  return undefined;
                }
                return SecureObject.filterEverything(handler, raw['removeNamedItem'](name), {
                  defaultKey: key
                });
              };
              break;
            case 'getNamedItemNS':
              ret = function(namespace, localName) {
                for (const val in filtered) {
                  if (
                    namespace === filtered[val].namespaceURI &&
                    localName === filtered[val].localName
                  ) {
                    return SecureObject.filterEverything(handler, filtered[val], {
                      defaultKey: key
                    });
                  }
                }
                return null;
              };
              break;
            case 'setNamedItemNS':
              ret = function(attribute) {
                if (
                  !SecureElement.isValidAttributeName(
                    raw,
                    attribute.name,
                    prototype,
                    caseInsensitiveAttributes
                  )
                ) {
                  warn(
                    `${this} does not allow getting/setting the ${attribute.name.toLowerCase()} attribute, ignoring!`
                  );
                  return undefined;
                }
                verifyAccess(attribute, target);
                if (isProxy(attribute)) {
                  attribute = getRef(attribute, key);
                }
                return SecureObject.filterEverything(handler, raw['setNamedItemNS'](attribute), {
                  defaultKey: key
                });
              };
              break;
            case 'removeNamedItemNS':
              ret = function(namespace, localName) {
                if (
                  !SecureElement.isValidAttributeName(
                    raw,
                    localName,
                    prototype,
                    caseInsensitiveAttributes
                  )
                ) {
                  warn(
                    `${this} does not allow removing the ${localName.toLowerCase()} attribute, ignoring!`
                  );
                  return undefined;
                }
                return SecureObject.filterEverything(
                  handler,
                  raw['removeNamedItemNS'](namespace, localName),
                  { defaultKey: key }
                );
              };
              break;
            case 'toString':
              ret = function() {
                return raw.toString();
              };
              break;

            case 'toJSON':
              ret = function() {
                return JSON.stringify(filtered);
              };
              break;
            case 'Symbol(Symbol.iterator)':
              ret = function() {
                let nextIndex = 0;
                return {
                  next: function() {
                    if (nextIndex < filtered.length) {
                      const value = filtered[nextIndex];
                      nextIndex++;
                      return {
                        value: value ? SecureObject.filterEverything(handler, value) : value,
                        done: false
                      };
                    }
                    return { done: true };
                  }
                };
              };
              break;
            default:
              warn(`Unsupported ${raw} method: ${property}. Returning undefined`);
              return undefined;
          }
        } else {
          ret = getFromFiltered(handler, filtered, property);
        }

        return ret;
      },
      has: function(target, property) {
        const raw = getRef(target, key);
        const filtered = getFilteredNamedNodeMap(
          handler,
          raw,
          key,
          prototype,
          caseInsensitiveAttributes
        );
        return property in filtered;
      }
    };

    setKey(handler, key);

    KEY_TO_NAMED_NODE_MAP_HANLDER.set(key, handler);

    Object.freeze(handler);
  }

  return handler;
}

SecureObject.createProxyForNamedNodeMap = function(raw, key, prototype, caseInsensitiveAttributes) {
  const surrogate = Object.create(Object.getPrototypeOf(raw));
  setRef(surrogate, raw, key);

  const proxy = new Proxy(
    surrogate,
    getNamedNodeMapProxyHandler(key, prototype, caseInsensitiveAttributes)
  );
  setKey(proxy, key);
  registerProxy(proxy);

  return proxy;
};

SecureObject.createFilteredMethod = function(st, raw, methodName, options) {
  // Do not expose properties that the raw object does not actually support
  if (!(methodName in raw)) {
    if (options && options.ignoreNonexisting) {
      return undefined;
    }
    throw new error(`Underlying raw object ${raw} does not support method: ${methodName}`);
  }

  return {
    enumerable: true,
    writable: true,
    value: function() {
      const filteredArgs = SecureObject.filterArguments(st, arguments, options);
      let fnReturnedValue = raw[methodName].apply(raw, filteredArgs);

      if (options && options.afterCallback) {
        fnReturnedValue = options.afterCallback(fnReturnedValue);
      }

      return SecureObject.filterEverything(st, fnReturnedValue, options);
    }
  };
};

SecureObject.createFilteredMethodStateless = function(methodName, prototype, options) {
  if (!prototype) {
    throw new Error('SecureObject.createFilteredMethodStateless() called without prototype');
  }

  return {
    enumerable: true,
    writable: true,
    value: function() {
      const st = this;
      const raw = SecureObject.getRaw(st);

      const filteredArgs = SecureObject.filterArguments(st, arguments, options);
      let fnReturnedValue = raw[methodName].apply(raw, filteredArgs);

      if (options) {
        if (options.afterCallback) {
          fnReturnedValue = options.afterCallback.call(st, fnReturnedValue);
        }

        if (options.trustReturnValue) {
          trust$1(st, fnReturnedValue);
        }
      }

      return SecureObject.filterEverything(st, fnReturnedValue, options);
    }
  };
};

SecureObject.createFilteredProperty = function(st, raw, propertyName, options) {
  // Do not expose properties that the raw object does not actually support.
  if (!(propertyName in raw)) {
    if (options && options.ignoreNonexisting) {
      return undefined;
    }
    throw new error(
      `Underlying raw object ${raw} does not support property: ${propertyName}`
    );
  }

  const descriptor = {
    enumerable: true
  };

  descriptor.get = function() {
    let value = raw[propertyName];

    // Continue from the current object until we find an acessible object.
    if (options && options.skipOpaque === true) {
      while (value) {
        const hasAccess$$1 = hasAccess(st, value);
        if (hasAccess$$1 || SecureElement.isSharedElement(value)) {
          break;
        }
        value = value[propertyName];
      }
    }

    if (options && options.afterGetCallback) {
      // The caller wants to handle the property value
      return options.afterGetCallback(value);
    }
    return SecureObject.filterEverything(st, value, options);
  };

  if (!options || options.writable !== false) {
    descriptor.set = function(value) {
      if (options && options.beforeSetCallback) {
        value = options.beforeSetCallback(value);
      }

      raw[propertyName] = SecureObject.filterEverything(st, value);

      if (options && options.afterSetCallback) {
        options.afterSetCallback();
      }
    };
  }

  return descriptor;
};

SecureObject.createFilteredPropertyStateless = function(propertyName, prototype, options) {
  if (!prototype) {
    throw new Error('SecureObject.createFilteredPropertyStateless() called without prototype');
  }

  const descriptor = {
    enumerable: true
  };

  descriptor.get = function() {
    const st = this;
    const raw = SecureObject.getRaw(st);

    let value = raw[propertyName];

    // Continue from the current object until we find an acessible object.
    if (options && options.skipOpaque === true) {
      while (value) {
        const hasAccess$$1 = hasAccess(st, value);
        if (
          hasAccess$$1 ||
          value === document.body ||
          value === document.head ||
          value === document.documentElement ||
          value === document
        ) {
          break;
        }
        value = value[propertyName];
      }
    }

    if (options && options.afterGetCallback) {
      // The caller wants to handle the property value
      return options.afterGetCallback.call(st, value);
    }
    return SecureObject.filterEverything(st, value, options);
  };

  if (!options || options.writable !== false) {
    descriptor.set = function(value) {
      const st = this;
      const key = getKey(st);
      const raw = getRef(st, key);

      if (options && options.beforeSetCallback) {
        value = options.beforeSetCallback.call(st, value);
      }

      raw[propertyName] = SecureObject.filterEverything(st, value);

      if (options && options.afterSetCallback) {
        options.afterSetCallback.call(st);
      }
    };
  }

  return descriptor;
};

SecureObject.addIfSupported = function(behavior, st, element, name, options) {
  options = options || {};
  options.ignoreNonexisting = true;

  const prop = behavior(st, element, name, options);
  if (prop) {
    Object.defineProperty(st, name, prop);
  }
};

SecureObject.addPropertyIfSupported = function(st, raw, name, options) {
  SecureObject.addIfSupported(SecureObject.createFilteredProperty, st, raw, name, options);
};

SecureObject.addMethodIfSupported = function(st, raw, name, options) {
  SecureObject.addIfSupported(SecureObject.createFilteredMethod, st, raw, name, options);
};

// Return the set of interfaces supported by the object in order of most specific to least specific
function getSupportedInterfaces(o) {
  const interfaces = [];
  if (o instanceof Window) {
    interfaces.push('Window', 'EventTarget');
  } else if (o instanceof Document) {
    if (o instanceof HTMLDocument) {
      interfaces.push('HTMLDocument');
    }
    interfaces.push('Document', 'Node', 'EventTarget');
  } else if (o instanceof DocumentFragment) {
    interfaces.push('Node', 'EventTarget', 'DocumentFragment');
  } else if (o instanceof Element) {
    if (o instanceof HTMLElement) {
      // Look for all HTMLElement subtypes
      if (o instanceof HTMLAnchorElement) {
        interfaces.push('HTMLAnchorElement');
      } else if (o instanceof HTMLAreaElement) {
        interfaces.push('HTMLAreaElement');
      } else if (o instanceof HTMLMediaElement) {
        if (o instanceof HTMLAudioElement) {
          interfaces.push('HTMLAudioElement');
        } else if (o instanceof HTMLVideoElement) {
          interfaces.push('HTMLVideoElement');
        }
        interfaces.push('HTMLMediaElement');
      } else if (o instanceof HTMLBaseElement) {
        interfaces.push('HTMLBaseElement');
      } else if (o instanceof HTMLButtonElement) {
        interfaces.push('HTMLButtonElement');
      } else if (o instanceof HTMLCanvasElement) {
        interfaces.push('HTMLCanvasElement');
      } else if (o instanceof HTMLTableColElement) {
        interfaces.push('HTMLTableColElement');
      } else if (o instanceof HTMLTableRowElement) {
        interfaces.push('HTMLTableRowElement');
      } else if (o instanceof HTMLModElement) {
        interfaces.push('HTMLModElement');
      } else if (typeof HTMLDetailsElement !== 'undefined' && o instanceof HTMLDetailsElement) {
        interfaces.push('HTMLDetailsElement');
      } else if (o instanceof HTMLEmbedElement) {
        interfaces.push('HTMLEmbedElement');
      } else if (o instanceof HTMLFieldSetElement) {
        interfaces.push('HTMLFieldSetElement');
      } else if (o instanceof HTMLFormElement) {
        interfaces.push('HTMLFormElement');
      } else if (o instanceof HTMLIFrameElement) {
        interfaces.push('HTMLIFrameElement');
      } else if (o instanceof HTMLImageElement) {
        interfaces.push('HTMLImageElement');
      } else if (o instanceof HTMLInputElement) {
        interfaces.push('HTMLInputElement');
      } else if (o instanceof HTMLLabelElement) {
        interfaces.push('HTMLLabelElement');
      } else if (o instanceof HTMLLIElement) {
        interfaces.push('HTMLLIElement');
      } else if (o instanceof HTMLLinkElement) {
        interfaces.push('HTMLLinkElement');
      } else if (o instanceof HTMLMapElement) {
        interfaces.push('HTMLMapElement');
      } else if (o instanceof HTMLMetaElement) {
        interfaces.push('HTMLMetaElement');
      } else if (typeof HTMLMeterElement !== 'undefined' && o instanceof HTMLMeterElement) {
        interfaces.push('HTMLMeterElement');
      } else if (o instanceof HTMLObjectElement) {
        interfaces.push('HTMLObjectElement');
      } else if (o instanceof HTMLOListElement) {
        interfaces.push('HTMLOListElement');
      } else if (o instanceof HTMLOptGroupElement) {
        interfaces.push('HTMLOptGroupElement');
      } else if (o instanceof HTMLOptionElement) {
        interfaces.push('HTMLOptionElement');
      } else if (typeof HTMLOutputElement !== 'undefined' && o instanceof HTMLOutputElement) {
        interfaces.push('HTMLOutputElement');
      } else if (o instanceof HTMLParamElement) {
        interfaces.push('HTMLParamElement');
      } else if (o instanceof HTMLProgressElement) {
        interfaces.push('HTMLProgressElement');
      } else if (o instanceof HTMLQuoteElement) {
        interfaces.push('HTMLQuoteElement');
      } else if (o instanceof HTMLScriptElement) {
        interfaces.push('HTMLScriptElement');
      } else if (o instanceof HTMLSelectElement) {
        interfaces.push('HTMLSelectElement');
      } else if (o instanceof HTMLSourceElement) {
        interfaces.push('HTMLSourceElement');
      } else if (o instanceof HTMLTableCellElement) {
        interfaces.push('HTMLTableCellElement');
      } else if (o instanceof HTMLTableElement) {
        interfaces.push('HTMLTableElement');
      } else if (typeof HTMLTemplateElement !== 'undefined' && o instanceof HTMLTemplateElement) {
        interfaces.push('HTMLTemplateElement');
      } else if (o instanceof HTMLTextAreaElement) {
        interfaces.push('HTMLTextAreaElement');
      } else if (o instanceof HTMLTrackElement) {
        interfaces.push('HTMLTrackElement');
      }

      if (o instanceof HTMLTableSectionElement) {
        interfaces.push('HTMLTableSectionElement');
      }

      interfaces.push('HTMLElement');
    } else if (o instanceof SVGElement) {
      if (o instanceof SVGSVGElement) {
        interfaces.push('SVGSVGElement');
      } else if (o instanceof SVGAngle) {
        interfaces.push('SVGAngle');
      } else if (o instanceof SVGCircleElement) {
        interfaces.push('SVGCircleElement');
      } else if (o instanceof SVGClipPathElement) {
        interfaces.push('SVGClipPathElement');
      } else if (o instanceof SVGDefsElement) {
        interfaces.push('SVGGraphicsElement');
      } else if (o instanceof SVGEllipseElement) {
        interfaces.push('SVGEllipseElement');
      } else if (o instanceof SVGFilterElement) {
        interfaces.push('SVGFilterElement');
      } else if (o instanceof SVGForeignObjectElement) {
        interfaces.push('SVGForeignObjectElement');
      } else if (o instanceof SVGImageElement) {
        interfaces.push('SVGImageElement');
      } else if (o instanceof SVGLength) {
        interfaces.push('SVGLength');
      } else if (o instanceof SVGLengthList) {
        interfaces.push('SVGLengthList');
      } else if (o instanceof SVGLineElement) {
        interfaces.push('SVGLineElement');
      } else if (o instanceof SVGLinearGradientElement) {
        interfaces.push('SVGLinearGradientElement');
      } else if (o instanceof SVGMaskElement) {
        interfaces.push('SVGMaskElement');
      } else if (o instanceof SVGNumber) {
        interfaces.push('SVGNumber');
      } else if (o instanceof SVGNumberList) {
        interfaces.push('SVGNumberList');
      } else if (o instanceof SVGPatternElement) {
        interfaces.push('SVGPatternElement');
      } else if (o instanceof SVGPreserveAspectRatio) {
        interfaces.push('SVGPreserveAspectRatio');
      } else if (o instanceof SVGRadialGradientElement) {
        interfaces.push('SVGRadialGradientElement');
      } else if (o instanceof SVGRect) {
        interfaces.push('SVGRect');
      } else if (o instanceof SVGRectElement) {
        interfaces.push('SVGRectElement');
      } else if (o instanceof SVGScriptElement) {
        interfaces.push('SVGScriptElement');
      } else if (o instanceof SVGStopElement) {
        interfaces.push('SVGStopElement');
      } else if (o instanceof SVGStringList) {
        interfaces.push('SVGStringList');
      } else if (o instanceof SVGStyleElement) {
        interfaces.push('SVGStyleElement');
      } else if (o instanceof SVGTransform) {
        interfaces.push('SVGTransform');
      } else if (o instanceof SVGTransformList) {
        interfaces.push('SVGTransformList');
      } else if (o instanceof SVGUseElement) {
        interfaces.push('SVGUseElement');
      } else if (o instanceof SVGViewElement) {
        interfaces.push('SVGViewElement');
      } else if (o instanceof SVGAnimatedAngle) {
        interfaces.push('SVGAnimatedAngle');
      } else if (o instanceof SVGAnimatedBoolean) {
        interfaces.push('SVGAnimatedBoolean');
      } else if (o instanceof SVGAnimatedEnumeration) {
        interfaces.push('SVGAnimatedEnumeration');
      } else if (o instanceof SVGAnimatedInteger) {
        interfaces.push('SVGAnimatedInteger');
      } else if (o instanceof SVGAnimatedLength) {
        interfaces.push('SVGAnimatedLength');
      } else if (o instanceof SVGAnimatedLengthList) {
        interfaces.push('SVGAnimatedLengthList');
      } else if (o instanceof SVGAnimatedNumber) {
        interfaces.push('SVGAnimatedNumber');
      } else if (o instanceof SVGAnimatedNumberList) {
        interfaces.push('SVGAnimatedNumberList');
      } else if (o instanceof SVGAnimatedPreserveAspectRatio) {
        interfaces.push('SVGAnimatedPreserveAspectRatio');
      } else if (o instanceof SVGAnimatedRect) {
        interfaces.push('SVGAnimatedRect');
      } else if (o instanceof SVGAnimatedString) {
        interfaces.push('SVGAnimatedString');
      } else if (o instanceof SVGAnimatedTransformList) {
        interfaces.push('SVGAnimatedTransformList');
      }

      // below may be implemented by multiple types
      if (o instanceof SVGTextContentElement) {
        interfaces.push('SVGTextContentElement');
      }
      if (typeof SVGAnimationElement !== 'undefined' && o instanceof SVGAnimationElement) {
        interfaces.push('SVGAnimationElement');
      }
      if (o instanceof SVGGradientElement) {
        interfaces.push('SVGGradientElement');
      }
      if (typeof SVGGraphicsElement !== 'undefined' && o instanceof SVGGraphicsElement) {
        interfaces.push('SVGGraphicsElement');
      }
      if (typeof SVGGeometryElement !== 'undefined' && o instanceof SVGGeometryElement) {
        interfaces.push('SVGGeometryElement');
      }
      if (o instanceof SVGTextPositioningElement) {
        interfaces.push('SVGTextPositioningElement');
      }

      interfaces.push('SVGElement');
    }

    interfaces.push('Element', 'Node', 'EventTarget');
  } else if (o instanceof Text) {
    interfaces.push('Text', 'CharacterData', 'Node');
  } else if (o instanceof Comment) {
    interfaces.push('CharacterData', 'Node');
  } else if (o instanceof Attr) {
    interfaces.push('Attr', 'Node', 'EventTarget');
  } else if (o instanceof CanvasRenderingContext2D) {
    interfaces.push('CanvasRenderingContext2D');
  } else if (typeof RTCPeerConnection !== 'undefined' && o instanceof RTCPeerConnection) {
    interfaces.push('RTCPeerConnection');
  }

  return interfaces;
}

SecureObject.addPrototypeMethodsAndProperties = function(metadata$$1, so, raw, key) {
  let prototype;

  function worker(name) {
    const item = prototype[name];
    let valueOverride;
    if (!(name in so) && name in raw) {
      const options = {
        skipOpaque: item.skipOpaque || false,
        defaultValue: item.defaultValue || null,
        trustReturnValue: item.trustReturnValue || false,
        rawArguments: item.rawArguments || false
      };

      if (item.type === 'function') {
        SecureObject.addMethodIfSupported(so, raw, name, options);
      } else if (item.type === '@raw') {
        Object.defineProperty(so, name, {
          // Does not currently secure proxy the actual class
          get: function() {
            return valueOverride || raw[name];
          },
          set: function(value) {
            valueOverride = value;
          }
        });
      } else if (item.type === '@ctor') {
        Object.defineProperty(so, name, {
          get: function() {
            return (
              valueOverride ||
              function() {
                const cls = raw[name];
                const args = Array.prototype.slice.call(arguments);
                let result;

                if (typeof cls === 'function') {
                  //  Function.prototype.bind.apply is being used to invoke the constructor and to pass all the arguments provided by the caller
                  // TODO Switch to ES6 when available https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator
                  const ctor = Function.prototype.bind.apply(cls, [null].concat(args));
                  result = new ctor();
                } else {
                  // For browsers that use a constructor that's not a function, invoke the constructor directly.
                  // For example, on Mobile Safari window["Audio"] returns an object called AudioConstructor
                  // Passing the args as an array is the closest we got to passing the arguments.
                  result = new cls(args);
                }
                trust$1(so, result);

                return SecureObject.filterEverything(so, result);
              }
            );
          },
          set: function(value) {
            valueOverride = value;
          }
        });
      } else if (item.type === '@event') {
        Object.defineProperty(so, name, {
          get: function() {
            return SecureObject.filterEverything(so, raw[name]);
          },

          set: function(callback) {
            raw[name] = function(e) {
              if (callback) {
                callback.call(so, SecureDOMEvent(e, key));
              }
            };
          }
        });
      } else {
        // Properties
        const descriptor = SecureObject.createFilteredProperty(so, raw, name, options);
        if (descriptor) {
          Object.defineProperty(so, name, descriptor);
        }
      }
    }
  }

  const supportedInterfaces = getSupportedInterfaces(raw);

  const prototypes = metadata$$1['prototypes'];
  supportedInterfaces.forEach(name => {
    prototype = prototypes[name];
    Object.keys(prototype).forEach(worker);
  });
};

// Closure factory
function addPrototypeMethodsAndPropertiesStatelessHelper(
  name,
  prototype,
  prototypicalInstance,
  prototypeForValidation,
  rawPrototypicalInstance,
  config
) {
  let descriptor;
  const item = prototype[name];
  let valueOverride;

  if (!prototypeForValidation.hasOwnProperty(name) && name in rawPrototypicalInstance) {
    const options = {
      skipOpaque: item.skipOpaque || false,
      defaultValue: item.defaultValue || null,
      trustReturnValue: item.trustReturnValue || false,
      rawArguments: item.rawArguments || false
    };

    if (item.type === 'function') {
      descriptor = SecureObject.createFilteredMethodStateless(
        name,
        prototypeForValidation,
        options
      );
    } else if (item.type === '@raw') {
      descriptor = {
        // Does not currently secure proxy the actual class
        get: function() {
          if (valueOverride) {
            return valueOverride;
          }
          const raw = SecureObject.getRaw(this);
          return raw[name];
        },
        set: function(value) {
          valueOverride = value;
        }
      };
    } else if (item.type === '@ctor') {
      descriptor = {
        get:
          valueOverride ||
          function() {
            return function() {
              const so = this;
              const raw = SecureObject.getRaw(so);
              const cls = raw[name];

              // TODO Switch to ES6 when available https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator
              const ctor = Function.prototype.bind.apply(
                cls,
                [null].concat(Array.prototype.slice.call(arguments))
              );
              const result = new ctor();
              trust$1(so, result);

              return SecureObject.filterEverything(so, result);
            };
          },
        set: function(value) {
          valueOverride = value;
        }
      };
    } else if (item.type === '@event') {
      descriptor = {
        get: function() {
          return SecureObject.filterEverything(this, SecureObject.getRaw(this)[name]);
        },

        set: function(callback) {
          const raw = SecureObject.getRaw(this);

          // Insure that we pick up the current proxy for the raw object
          let key = getKey(raw);
          // Shared elements like <body> and <head> are not tied to specific namespaces.
          // Every namespace has a secure wrapper for these elements
          if (!key && SecureElement.isSharedElement(raw)) {
            // Obtain the key of the secure wrapper
            key = getKey(this);
          }
          const o = getFromCache(raw, key);

          raw[name] = function(e) {
            if (callback) {
              callback.call(o, SecureDOMEvent(e, key));
            }
          };
        }
      };
    } else {
      // Properties
      descriptor = SecureObject.createFilteredPropertyStateless(
        name,
        prototypeForValidation,
        options
      );
    }
  }

  if (descriptor) {
    config[name] = descriptor;
  }
}

SecureObject.addPrototypeMethodsAndPropertiesStateless = function(
  metadata$$1,
  prototypicalInstance,
  prototypeForValidation
) {
  const rawPrototypicalInstance = SecureObject.getRaw(prototypicalInstance);
  let prototype;
  const config = {};

  const supportedInterfaces = getSupportedInterfaces(rawPrototypicalInstance);

  const prototypes = metadata$$1['prototypes'];
  supportedInterfaces.forEach(name => {
    prototype = prototypes[name];
    for (const property in prototype) {
      addPrototypeMethodsAndPropertiesStatelessHelper(
        property,
        prototype,
        prototypicalInstance,
        prototypeForValidation,
        rawPrototypicalInstance,
        config
      );
    }
  });

  return config;
};

function getUnfilteredTypes() {
  const ret = [];
  const unfilteredTypesMeta = [
    'File',
    'FileList',
    'CSSStyleDeclaration',
    'TimeRanges',
    'Date',
    'Promise',
    'MessagePort',
    'MessageChannel',
    'MessageEvent',
    'FormData',
    'ValidityState',
    'Crypto',
    'DOMTokenList',
    'ArrayBuffer'
  ];
  unfilteredTypesMeta.forEach(unfilteredType => {
    if (typeof window[unfilteredType] !== 'undefined') {
      ret.push(window[unfilteredType]);
    }
  });
  return ret;
}
const unfilteredTypes = getUnfilteredTypes();

SecureObject.isUnfilteredType = function(raw, key) {
  for (let n = 0; n < unfilteredTypes.length; n++) {
    if (raw instanceof unfilteredTypes[n]) {
      return true;
    }
  }

  // Do not filter ArrayBufferView types. https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView
  if (raw && raw.buffer instanceof ArrayBuffer && raw.byteLength !== undefined) {
    return true;
  }

  if (isUnfilteredTypeHook$1 && isUnfilteredTypeHook$1(raw, key)) {
    return true;
  }

  return false;
};

SecureObject.addUnfilteredPropertyIfSupported = function(st, raw, name) {
  if (raw[name]) {
    const config = {
      enumerable: true,
      value: raw[name],
      writable: true
    };
    Object.defineProperty(st, name, config);
  }
};

SecureObject.FunctionPrototypeBind = Function.prototype.bind;
SecureObject.ArrayPrototypeSlice = Array.prototype.slice;

/*
 * Copyright (C) 2013 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const metadata$5 = {
  prototypes: {
    HTMLDocument: {
      // Defined on Instance
      location: DEFAULT,
      // Defined on Proto
      fgColor: DEFAULT,
      linkColor: DEFAULT,
      vlinkColor: DEFAULT,
      alinkColor: DEFAULT,
      bgColor: DEFAULT,
      clear: FUNCTION,
      captureEvents: FUNCTION,
      releaseEvents: FUNCTION
    },
    Document: {
      URL: DEFAULT,
      activeElement: DEFAULT,
      adoptNode: FUNCTION,
      anchors: DEFAULT,
      applets: DEFAULT,
      body: DEFAULT,
      caretRangeFromPoint: FUNCTION,
      characterSet: DEFAULT,
      charset: DEFAULT,
      childElementCount: DEFAULT,
      children: DEFAULT,
      close: FUNCTION,
      compatMode: DEFAULT,
      contentType: DEFAULT,
      cookie: DEFAULT,
      createAttribute: FUNCTION,
      createAttributeNS: FUNCTION,
      createCDATASection: FUNCTION,
      createComment: FUNCTION,
      createDocumentFragment: FUNCTION,
      createElement: FUNCTION,
      createElementNS: FUNCTION,
      createEvent: FUNCTION,
      createExpression: FUNCTION,
      createNSResolver: FUNCTION,
      createNodeIterator: FUNCTION,
      createProcessingInstruction: FUNCTION,
      createRange: FUNCTION,
      createTextNode: FUNCTION,
      createTreeWalker: FUNCTION,
      defaultView: DEFAULT,
      designMode: DEFAULT,
      dir: DEFAULT,
      doctype: DEFAULT,
      documentElement: DEFAULT,
      documentURI: DEFAULT,
      // SecureDocument does not allow setting domain property.
      // "domain":                           DEFAULT,
      elementFromPoint: FUNCTION,
      elementsFromPoint: FUNCTION,
      embeds: DEFAULT,
      evaluate: FUNCTION,
      execCommand: FUNCTION,
      exitPointerLock: FUNCTION,
      firstElementChild: DEFAULT,
      fonts: DEFAULT,
      forms: DEFAULT,
      getElementById: FUNCTION,
      getElementsByClassName: FUNCTION,
      getElementsByName: FUNCTION,
      getElementsByTagName: FUNCTION,
      getElementsByTagNameNS: FUNCTION,
      getSelection: FUNCTION,
      hasFocus: FUNCTION,
      head: DEFAULT,
      hidden: DEFAULT,
      images: DEFAULT,
      implementation: DEFAULT,
      importNode: FUNCTION,
      inputEncoding: DEFAULT,
      lastElementChild: DEFAULT,
      lastModified: DEFAULT,
      links: DEFAULT,
      onabort: EVENT,
      onautocomplete: EVENT,
      onautocompleteerror: EVENT,
      onbeforecopy: EVENT,
      onbeforecut: EVENT,
      onbeforepaste: EVENT,
      onblur: EVENT,
      oncancel: EVENT,
      oncanplay: EVENT,
      oncanplaythrough: EVENT,
      onchange: EVENT,
      onclick: EVENT,
      onclose: EVENT,
      oncontextmenu: EVENT,
      oncopy: EVENT,
      oncuechange: EVENT,
      oncut: EVENT,
      ondblclick: EVENT,
      ondrag: EVENT,
      ondragend: EVENT,
      ondragenter: EVENT,
      ondragleave: EVENT,
      ondragover: EVENT,
      ondragstart: EVENT,
      ondrop: EVENT,
      ondurationchange: EVENT,
      onemptied: EVENT,
      onended: EVENT,
      onerror: EVENT,
      onfocus: EVENT,
      oninput: EVENT,
      oninvalid: EVENT,
      onkeydown: EVENT,
      onkeypress: EVENT,
      onkeyup: EVENT,
      onload: EVENT,
      onloadeddata: EVENT,
      onloadedmetadata: EVENT,
      onloadstart: EVENT,
      onmousedown: EVENT,
      onmouseenter: EVENT,
      onmouseleave: EVENT,
      onmousemove: EVENT,
      onmouseout: EVENT,
      onmouseover: EVENT,
      onmouseup: EVENT,
      onmousewheel: EVENT,
      onpaste: EVENT,
      onpause: EVENT,
      onplay: EVENT,
      onplaying: EVENT,
      onpointerlockchange: EVENT,
      onpointerlockerror: EVENT,
      onprogress: EVENT,
      onratechange: EVENT,
      onreadystatechange: EVENT,
      onreset: EVENT,
      onresize: EVENT,
      onscroll: EVENT,
      onsearch: EVENT,
      onseeked: EVENT,
      onseeking: EVENT,
      onselect: EVENT,
      onselectionchange: EVENT,
      onselectstart: EVENT,
      onshow: EVENT,
      onstalled: EVENT,
      onsubmit: EVENT,
      onsuspend: EVENT,
      ontimeupdate: EVENT,
      ontoggle: EVENT,
      ontouchcancel: EVENT,
      ontouchend: EVENT,
      ontouchmove: EVENT,
      ontouchstart: EVENT,
      onvolumechange: EVENT,
      onwaiting: EVENT,
      onwebkitfullscreenchange: EVENT,
      onwebkitfullscreenerror: EVENT,
      onwheel: EVENT,
      open: FUNCTION,
      origin: DEFAULT,
      plugins: DEFAULT,
      pointerLockElement: DEFAULT,
      preferredStylesheetSet: DEFAULT,
      queryCommandEnabled: FUNCTION,
      queryCommandIndeterm: FUNCTION,
      queryCommandState: FUNCTION,
      queryCommandSupported: FUNCTION,
      queryCommandValue: FUNCTION,
      querySelector: FUNCTION,
      querySelectorAll: FUNCTION,
      readyState: DEFAULT,
      referrer: DEFAULT,
      registerElement: FUNCTION,
      rootElement: DEFAULT,
      scripts: DEFAULT,
      scrollingElement: DEFAULT,
      selectedStylesheetSet: DEFAULT,
      styleSheets: DEFAULT,
      title: DEFAULT,
      visibilityState: DEFAULT,
      webkitCancelFullScreen: FUNCTION,
      webkitCurrentFullScreenElement: DEFAULT,
      webkitExitFullscreen: FUNCTION,
      webkitFullscreenElement: DEFAULT,
      webkitFullscreenEnabled: DEFAULT,
      webkitHidden: DEFAULT,
      webkitIsFullScreen: DEFAULT,
      webkitVisibilityState: DEFAULT,
      // Blocked on purpose because of security risk
      // "write":                            FUNCTION,
      // "writeln":                          FUNCTION,
      xmlEncoding: DEFAULT,
      xmlStandalone: DEFAULT,
      xmlVersion: DEFAULT
    },
    Node: metadata$3,
    EventTarget: metadata$4
  }
};

function isForbiddenTag(el) {
  return el.constructor === HTMLStyleElement || el.constructor === SVGStyleElement;
}

function SecureDocument(doc, key) {
  let o = getFromCache(doc, key);
  if (o) {
    return o;
  }

  // create prototype to allow instanceof checks against document
  const prototype = function() {};
  Object.freeze(prototype);

  o = Object.create(prototype, {
    toString: {
      value: function() {
        return `SecureDocument: ${doc}{ key: ${JSON.stringify(key)} }`;
      }
    },
    createAttribute: {
      value: function(name) {
        const att = doc.createAttribute(name);
        setKey(att, key);
        return SecureElement(att, key);
      }
    },
    createElement: {
      value: function(tag) {
        const el = doc.createElement(tag);
        if (isForbiddenTag(el)) {
          throw new Error(`Creation of ${tag} tags is not allowed`);
        }
        setKey(el, key);
        return SecureElement(el, key);
      }
    },
    createElementNS: {
      value: function(namespace, tag) {
        const el = doc.createElementNS(namespace, tag);
        if (isForbiddenTag(el)) {
          throw new Error(`Creation of ${tag} tags is not allowed`);
        }
        setKey(el, key);
        return SecureElement(el, key);
      }
    },
    createDocumentFragment: {
      value: function() {
        const el = doc.createDocumentFragment();
        setKey(el, key);
        return SecureElement(el, key);
      }
    },
    createTextNode: {
      value: function(text) {
        const el = doc.createTextNode(text);
        setKey(el, key);
        return SecureElement(el, key);
      }
    },
    createComment: {
      value: function(data) {
        const el = doc.createComment(data);
        setKey(el, key);
        return SecureElement(el, key);
      }
    },
    domain: {
      get: function() {
        return doc.domain;
      },
      set: function() {
        throw new Error('SecureDocument does not allow setting domain property.');
      }
    },
    querySelector: {
      value: function(selector) {
        return SecureElement.secureQuerySelector(doc, key, selector);
      }
    }
  });

  addEventTargetMethods(o, doc, key);

  function getCookieKey() {
    return `LSKey[${key['namespace']}]`;
  }

  Object.defineProperty(o, 'cookie', {
    get: function() {
      const fullCookie = doc.cookie;
      const entries = fullCookie.split(';');
      const cookieKey = getCookieKey();
      // filter out cookies that do not match current namespace
      const nsFiltered = entries.filter(val => {
        const left = val.split('=')[0].trim();
        return left.indexOf(cookieKey) === 0;
      });
      // strip LockerService key before returning to user land
      const keyFiltered = nsFiltered.map(val => val.trim().substring(cookieKey.length));
      return keyFiltered.join('; ');
    },
    set: function(cookie) {
      const chunks = cookie.split(';');
      const entry = chunks[0].split('=');
      const newKey = getCookieKey() + entry[0];
      chunks[0] = `${newKey}=${entry[1]}`;
      const newCookie = chunks.join(';');
      doc.cookie = newCookie;
    }
  });

  ['implementation'].forEach(
    // These are direct passthrough's and should never be wrapped in a SecureObject
    name =>
      Object.defineProperty(o, name, {
        enumerable: true,
        value: doc[name]
      })
  );

  SecureObject.addPrototypeMethodsAndProperties(metadata$5, o, doc, key);

  setRef(o, doc, key);
  addToCache(doc, o, key);
  registerProxy(o);

  return o;
}

/*
 * Copyright (C) 2013 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function SecureLocation(loc, key) {
  let o = getFromCache(loc, key);
  if (o) {
    return o;
  }

  o = Object.create(null, {
    toString: {
      value: function() {
        return loc.href;
      }
    }
  });

  [
    'href',
    'protocol',
    'host',
    'hostname',
    'port',
    'pathname',
    'search',
    'hash',
    'username',
    'password',
    'origin'
  ].forEach(property => SecureObject.addPropertyIfSupported(o, loc, property));

  ['reload', 'replace'].forEach(method => SecureObject.addMethodIfSupported(o, loc, method));

  /**
   * When a location.assign() call is found the href provided is evaluated
   * to ensure it is a legal scheme. 'http' and 'https' are considered
   * legal, while other schemes will throw an error because they present a possibility for
   * un-intended script execution.
   */
  SecureObject.addMethodIfSupported(o, loc, 'assign', {
    beforeCallback: function(href) {
      if (href && typeof href === 'string' && href.length > 1) {
        const dummy = document.createElement('a');
        dummy.href = href;

        if (dummy.protocol === 'http:' || dummy.protocol === 'https:') {
          return href;
        }

        throw new error('SecureLocation.assign only supports http://, https:// schemes.');
      }
      return undefined;
    }
  });

  setRef(o, loc, key);
  addToCache(loc, o, key);
  registerProxy(o);

  return o;
}

/*
 * Copyright (C) 2013 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

let addPropertiesHook$1;
function registerAddPropertiesHook$1(hook) {
  addPropertiesHook$1 = hook;
}

function SecureNavigator(navigator, key) {
  let o = getFromCache(navigator, key);
  if (o) {
    return o;
  }

  o = Object.create(null, {
    toString: {
      value: function() {
        return `SecureNavigator: ${navigator}{ key: ${JSON.stringify(key)} }`;
      }
    }
  });

  [
    'appCodeName',
    'appName',
    'appVersion',
    'cookieEnabled',
    'geolocation',
    'language',
    'onLine',
    'platform',
    'product',
    'userAgent'
  ].forEach(name => SecureObject.addPropertyIfSupported(o, navigator, name));

  if (addPropertiesHook$1) {
    addPropertiesHook$1(o, navigator, key);
  }

  setRef(o, navigator, key);
  addToCache(navigator, o, key);
  registerProxy(o);

  return o;
}

/*
 * Copyright (C) 2013 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function SecureXMLHttpRequest(key) {
  // Create a new closure constructor for new XHMLHttpRequest() syntax support that captures the key
  return function() {
    const xhr = new XMLHttpRequest();

    const o = Object.create(null, {
      toString: {
        value: function() {
          return `SecureXMLHttpRequest: ${xhr} { key: ${JSON.stringify(key)} }`;
        }
      }
    });

    // Properties
    [
      'readyState',
      'status',
      'statusText',
      'response',
      'responseType',
      'responseText',
      'responseURL',
      'timeout',
      'withCredentials',
      'upload'
    ].forEach(name => SecureObject.addPropertyIfSupported(o, xhr, name));

    SecureObject.addPropertyIfSupported(o, xhr, 'responseXML', {
      afterGetCallback: function(value) {
        return value;
      }
    });

    // Event handlers
    [
      'onloadstart',
      'onprogress',
      'onabort',
      'onerror',
      'onload',
      'ontimeout',
      'onloadend',
      'onreadystatechange'
    ].forEach(name =>
      Object.defineProperty(o, name, {
        set: function(callback) {
          xhr[name] = function(e) {
            callback.call(o, SecureDOMEvent(e, key));
          };
        }
      })
    );

    Object.defineProperties(o, {
      abort: SecureObject.createFilteredMethod(o, xhr, 'abort'),

      addEventListener: createAddEventListenerDescriptor(o, xhr, key),

      open: {
        enumerable: true,
        writable: true,
        value: function() {
          const normalizer = document.createElement('a');
          normalizer.setAttribute('href', arguments[1]);

          // Order of operations are important!
          let pathname = normalizer.pathname;
          pathname = decodeURIComponent(pathname);
          pathname = pathname.toLowerCase();

          if (pathname.includes('/aura')) {
            throw new error(
              `SecureXMLHttpRequest.open cannot be used with Aura framework internal API endpoints ${
                arguments[1]
              }!`
            );
          }

          arguments[1] = normalizer.getAttribute('href');

          return xhr.open.apply(xhr, arguments);
        }
      },

      send: SecureObject.createFilteredMethod(o, xhr, 'send'),

      getAllResponseHeaders: SecureObject.createFilteredMethod(o, xhr, 'getAllResponseHeaders'),
      getResponseHeader: SecureObject.createFilteredMethod(o, xhr, 'getResponseHeader'),

      setRequestHeader: SecureObject.createFilteredMethod(o, xhr, 'setRequestHeader'),

      overrideMimeType: SecureObject.createFilteredMethod(o, xhr, 'overrideMimeType')
    });

    setRef(o, xhr, key);

    return Object.freeze(o);
  };
}

/*
 * Copyright (C) 2013 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function SecureMutationObserver(key) {
  function filterRecords(st, records) {
    const filtered = [];

    records.forEach(record => {
      if (hasAccess(st, record.target)) {
        filtered.push(SecureObject.filterEverything(st, record));
      }
    });

    return filtered;
  }

  // Create a new closure constructor for new XHMLHttpRequest() syntax support that captures the key
  return function(callback) {
    const o = Object.create(null);

    const observer = new MutationObserver(records => {
      const filtered = filterRecords(o, records);
      if (filtered.length > 0) {
        callback(filtered);
      }
    });

    Object.defineProperties(o, {
      toString: {
        value: function() {
          return `SecureMutationObserver: ${observer} { key: ${JSON.stringify(key)} }`;
        }
      },

      observe: SecureObject.createFilteredMethod(o, observer, 'observe', { rawArguments: true }),
      disconnect: SecureObject.createFilteredMethod(o, observer, 'disconnect'),

      takeRecords: {
        writable: true,
        value: function() {
          return filterRecords(o, observer['takeRecords']());
        }
      }
    });

    setRef(o, observer, key);

    return Object.freeze(o);
  };
}

/*
 * Copyright (C) 2013 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function SecureNotification(key) {
  // Create a new closure constructor for new Notification() syntax support that captures the key
  return function(title, options) {
    const notification = new Notification(title, options);

    const o = Object.create(null, {
      toString: {
        value: function() {
          return `SecureNotification: ${notification} { key: ${JSON.stringify(key)} }`;
        }
      }
    });

    // Properties
    [
      'actions',
      'badge',
      'body',
      'data',
      'dir',
      'lang',
      'tag',
      'icon',
      'image',
      'requireInteraction',
      'silent',
      'timestamp',
      'title',
      'vibrate',
      'noscreen',
      'renotify',
      'sound',
      'sticky'
    ].forEach(name => SecureObject.addPropertyIfSupported(o, notification, name));

    // Event handlers
    ['onclick', 'onerror'].forEach(name =>
      Object.defineProperty(o, name, {
        set: function(callback) {
          notification[name] = function(e) {
            callback.call(o, SecureDOMEvent(e, key));
          };
        }
      })
    );

    Object.defineProperties(o, {
      close: SecureObject.createFilteredMethod(o, notification, 'close')
    });

    addEventTargetMethods(o, notification, key);

    setRef(o, notification, key);

    return Object.freeze(o);
  };
}

/*
 * Copyright (C) 2013 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function SecureStorage(storage, type, key) {
  let o = getFromCache(storage, key);
  if (o) {
    return o;
  }

  // Read existing key to synthetic key index from storage
  const stringizedKey = JSON.stringify(key);
  const nextSyntheticKey = `LSSNextSynthtic:${type}`;
  const storedIndexKey = `LSSIndex:${type}${stringizedKey}`;
  let nameToSyntheticRaw;
  try {
    nameToSyntheticRaw = storage.getItem(storedIndexKey);
  } catch (e) {
    // There is a bug in google chrome where localStorage becomes inaccessible.
    // Don't fast fail and break all applications. Defer the exception throwing to when the app actually uses localStorage
  }
  let nameToSynthetic = nameToSyntheticRaw ? JSON.parse(nameToSyntheticRaw) : {};

  function persistSyntheticNameIndex() {
    // Persist the nameToSynthetic index
    const stringizedIndex = JSON.stringify(nameToSynthetic);
    storage.setItem(storedIndexKey, stringizedIndex);
  }

  function getSynthetic(name) {
    let synthetic = nameToSynthetic[name];
    if (!synthetic) {
      const nextSynthticRaw = storage.getItem(nextSyntheticKey);
      let nextSynthetic = nextSynthticRaw ? Number(nextSynthticRaw) : 1;

      synthetic = nextSynthetic++;

      // Persist the next synthetic counter
      storage.setItem(nextSyntheticKey, nextSynthetic);

      nameToSynthetic[name] = synthetic;

      persistSyntheticNameIndex();
    }

    return synthetic;
  }

  function forgetSynthetic(name) {
    const synthetic = getSynthetic(name);
    if (synthetic) {
      delete nameToSynthetic[name];
      persistSyntheticNameIndex();
    }
  }

  o = Object.create(null, {
    toString: {
      value: function() {
        return `SecureStorage: ${type} { key: ${JSON.stringify(key)} }`;
      }
    },

    length: {
      get: function() {
        return Object.keys(nameToSynthetic).length;
      }
    },

    getItem: {
      value: function(name) {
        const synthetic = getSynthetic(name);
        return synthetic ? storage.getItem(synthetic) : null;
      }
    },

    setItem: {
      value: function(name, value) {
        const synthetic = getSynthetic(name);
        storage.setItem(synthetic, value);
      }
    },

    removeItem: {
      value: function(name) {
        const syntheticKey = getSynthetic(name);
        if (syntheticKey) {
          storage.removeItem(syntheticKey);
          forgetSynthetic(name);
        }
      }
    },

    key: {
      value: function(index) {
        return Object.keys(nameToSynthetic)[index];
      }
    },

    clear: {
      value: function() {
        Object.keys(nameToSynthetic).forEach(name => {
          const syntheticKey = getSynthetic(name);
          storage.removeItem(syntheticKey);
        });

        // Forget all synthetic
        nameToSynthetic = {};
        storage.removeItem(storedIndexKey);
      }
    }
  });

  setRef(o, storage, key);
  addToCache(storage, o, key);
  registerProxy(o);

  return o;
}

/*
 * Copyright (C) 2013 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// For URL, we only need to tame one static method. That method is on the
// window.URL primordial and disappears from instances of URL. We only create
// the secure object and we will let the deep freeze operation make it tamper
// proof.

// Taming of URL createObjectURL will not be necessary on webkit
// "CSP rules ignored when a page navigates to a blob URL" is declassified,
// https://bugs.webkit.org/show_bug.cgi?id=174883

// and once the correct behavior on Edge is confirmed (curently in development)
// https://developer.microsoft.com/en-us/microsoft-edge/platform/status/urlapi/

// Only FireFox implements the correct behavior.

function SecureURL(raw) {
  const SecureURLMethods = Object.create(null, {
    createObjectURL: {
      value: function(object) {
        if (Object.prototype.toString.call(object) === '[object Blob]') {
          if (object.type === 'text/html') {
            // There are no relible ways to convert syncronously
            // a blob back to a string. Disallow until
            // <rdar://problem/33575448> is declassified
            throw new TypeError(
              `SecureURL does not allow creation of Object URL from blob type ${object.type}`
            );
          }
        }
        // IMPORTANT: thisArg is the target of the proxy.
        return raw.createObjectURL(object);
      }
    },
    toString: {
      value: function() {
        return `SecureURL: ${Object.prototype.toString.call(raw)}`;
      }
    }
  });

  return new Proxy(raw, {
    get: function(target, name) {
      // Give priority to the overritten methods.
      let desc = Object.getOwnPropertyDescriptor(SecureURLMethods, name);
      if (desc === undefined) {
        desc = Object.getOwnPropertyDescriptor(target, name);
      }
      if (desc === undefined || desc.value === undefined) {
        return undefined;
      }
      // Properties not found the object are not static.
      if (Object.keys(target).indexOf(name) < 0) {
        return desc.value;
      }
      // Prevent static methods from executing in the context of the proxy.
      return function() {
        return desc.value.apply(undefined, arguments);
      };
    },
    set: function() {
      return true;
    }
  });
}

/*
 * Copyright (C) 2013 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

let addPropertiesHook;
function registerAddPropertiesHook$$1(hook) {
  addPropertiesHook = hook;
}

// This whilelist represents reflective ECMAScript APIs or reflective DOM APIs
// which, by definition, do not provide authority or access to globals.
const whitelist = [
  // Accessible Intrinsics (not reachable by own property name traversal)
  // -> from ES5
  'ThrowTypeError',
  // -> from ES6.
  'IteratorPrototype',
  'ArrayIteratorPrototype',
  'StringIteratorPrototype',
  'MapIteratorPrototype',
  'SetIteratorPrototype',
  'GeneratorFunction',
  'TypedArray',

  // Intrinsics
  // -> from ES5
  'Function',
  'WeakMap',
  'StringMap',
  // Proxy,
  'escape',
  'unescape',
  'Object',
  'NaN',
  'Infinity',
  'undefined',
  // eval,
  'parseInt',
  'parseFloat',
  'isNaN',
  'isFinite',
  'decodeURI',
  'decodeURIComponent',
  'encodeURI',
  'encodeURIComponent',
  'Function',
  'Array',
  'String',
  'Boolean',
  'Number',
  'Math',
  'Date',
  'RegExp',
  'Error',
  'EvalError',
  'RangeError',
  'ReferenceError',
  'SyntaxError',
  'TypeError',
  'URIError',
  'JSON',
  // -> from ES6
  'ArrayBuffer',
  'Int8Array',
  'Uint8Array',
  'Uint8ClampedArray',
  'Int16Array',
  'Uint16Array',
  'Int32Array',
  'Uint32Array',
  'Float32Array',
  'Float64Array',
  'DataView',
  'Promise',

  // Misc
  'Intl'
];

const metadata$$1 = {
  prototypes: {
    Window: {
      AnalyserNode: FUNCTION,
      AnimationEvent: FUNCTION,
      AppBannerPromptResult: FUNCTION,
      ApplicationCache: FUNCTION,
      ApplicationCacheErrorEvent: FUNCTION,
      Array: RAW,
      ArrayBuffer: RAW,
      Attr: RAW,
      Audio: CTOR,
      AudioBuffer: FUNCTION,
      AudioBufferSourceNode: FUNCTION,
      AudioContext: CTOR,
      AudioDestinationNode: FUNCTION,
      AudioListener: FUNCTION,
      AudioNode: FUNCTION,
      AudioParam: FUNCTION,
      AudioProcessingEvent: FUNCTION,
      AutocompleteErrorEvent: FUNCTION,
      BarProp: FUNCTION,
      BatteryManager: FUNCTION,
      BeforeInstallPromptEvent: FUNCTION,
      BeforeUnloadEvent: FUNCTION,
      BiquadFilterNode: FUNCTION,
      BlobEvent: FUNCTION,
      Boolean: FUNCTION,
      CDATASection: FUNCTION,
      CSS: FUNCTION,
      CSSFontFaceRule: FUNCTION,
      CSSGroupingRule: FUNCTION,
      CSSImportRule: FUNCTION,
      CSSKeyframeRule: FUNCTION,
      CSSKeyframesRule: FUNCTION,
      CSSMediaRule: FUNCTION,
      CSSNamespaceRule: FUNCTION,
      CSSPageRule: FUNCTION,
      CSSRule: FUNCTION,
      CSSRuleList: FUNCTION,
      CSSStyleDeclaration: FUNCTION,
      CSSStyleRule: FUNCTION,
      CSSStyleSheet: FUNCTION,
      CSSSupportsRule: FUNCTION,
      CSSViewportRule: FUNCTION,
      CanvasCaptureMediaStreamTrack: FUNCTION,
      CanvasGradient: FUNCTION,
      CanvasPattern: FUNCTION,
      CanvasRenderingContext2D: RAW,
      ChannelMergerNode: FUNCTION,
      ChannelSplitterNode: FUNCTION,
      CharacterData: FUNCTION,
      ClientRect: FUNCTION,
      ClientRectList: FUNCTION,
      ClipboardEvent: FUNCTION,
      CloseEvent: FUNCTION,
      Comment: CTOR,
      CompositionEvent: FUNCTION,
      ConvolverNode: FUNCTION,
      Credential: FUNCTION,
      CredentialsContainer: FUNCTION,
      Crypto: FUNCTION,
      CryptoKey: FUNCTION,
      CustomEvent: CTOR,
      DOMError: FUNCTION,
      DOMException: FUNCTION,
      DOMImplementation: FUNCTION,
      DOMParser: RAW,
      DOMStringList: FUNCTION,
      DOMStringMap: FUNCTION,
      DOMTokenList: FUNCTION,
      DataTransfer: FUNCTION,
      DataTransferItem: FUNCTION,
      DataTransferItemList: FUNCTION,
      DataView: FUNCTION,
      Date: RAW,
      DelayNode: FUNCTION,
      DeviceMotionEvent: FUNCTION,
      DeviceOrientationEvent: FUNCTION,
      Document: FUNCTION,
      DocumentFragment: FUNCTION,
      DocumentType: FUNCTION,
      DragEvent: FUNCTION,
      DynamicsCompressorNode: FUNCTION,
      ES6Promise: DEFAULT,
      Element: RAW,
      Error: FUNCTION,
      ErrorEvent: FUNCTION,
      EvalError: FUNCTION,
      Event: CTOR,
      EventSource: FUNCTION,
      EventTarget: RAW,
      FederatedCredential: FUNCTION,
      FileError: FUNCTION,
      FileList: RAW,
      FileReader: RAW,
      Float32Array: RAW,
      Float64Array: RAW,
      FocusEvent: FUNCTION,
      FontFace: FUNCTION,
      Function: FUNCTION,
      GainNode: FUNCTION,
      HTMLAllCollection: FUNCTION,
      HTMLAnchorElement: RAW,
      HTMLAreaElement: RAW,
      HTMLAudioElement: RAW,
      HTMLBRElement: RAW,
      HTMLBaseElement: RAW,
      HTMLBodyElement: RAW,
      HTMLButtonElement: RAW,
      HTMLCanvasElement: RAW,
      HTMLCollection: RAW,
      HTMLContentElement: RAW,
      HTMLDListElement: RAW,
      HTMLDataListElement: RAW,
      HTMLDetailsElement: RAW,
      HTMLDialogElement: RAW,
      HTMLDirectoryElement: RAW,
      HTMLDivElement: RAW,
      HTMLDocument: RAW,
      HTMLElement: RAW,
      HTMLEmbedElement: RAW,
      HTMLFieldSetElement: RAW,
      HTMLFontElement: RAW,
      HTMLFormControlsCollection: FUNCTION,
      HTMLFormElement: RAW,
      HTMLFrameElement: RAW,
      HTMLFrameSetElement: RAW,
      HTMLHRElement: RAW,
      HTMLHeadElement: RAW,
      HTMLHeadingElement: RAW,
      HTMLHtmlElement: RAW,
      HTMLIFrameElement: RAW,
      HTMLImageElement: RAW,
      HTMLInputElement: RAW,
      HTMLKeygenElement: RAW,
      HTMLLIElement: RAW,
      HTMLLabelElement: RAW,
      HTMLLegendElement: RAW,
      HTMLLinkElement: RAW,
      HTMLMapElement: RAW,
      HTMLMarqueeElement: RAW,
      HTMLMediaElement: RAW,
      HTMLMenuElement: RAW,
      HTMLMetaElement: RAW,
      HTMLMeterElement: RAW,
      HTMLModElement: RAW,
      HTMLOListElement: RAW,
      HTMLObjectElement: RAW,
      HTMLOptGroupElement: RAW,
      HTMLOptionElement: RAW,
      HTMLOptionsCollection: RAW,
      HTMLOutputElement: RAW,
      HTMLParagraphElement: RAW,
      HTMLParamElement: RAW,
      HTMLPictureElement: RAW,
      HTMLPreElement: RAW,
      HTMLProgressElement: RAW,
      HTMLQuoteElement: RAW,
      HTMLScriptElement: RAW,
      HTMLSelectElement: RAW,
      HTMLShadowElement: RAW,
      HTMLSourceElement: RAW,
      HTMLSpanElement: RAW,
      HTMLStyleElement: RAW,
      HTMLTableCaptionElement: RAW,
      HTMLTableCellElement: RAW,
      HTMLTableColElement: RAW,
      HTMLTableElement: RAW,
      HTMLTableRowElement: RAW,
      HTMLTableSectionElement: RAW,
      HTMLTemplateElement: RAW,
      HTMLTextAreaElement: RAW,
      HTMLTitleElement: RAW,
      HTMLTrackElement: RAW,
      HTMLUListElement: RAW,
      HTMLUnknownElement: RAW,
      HTMLVideoElement: RAW,
      HashChangeEvent: FUNCTION,
      IdleDeadline: FUNCTION,
      Image: CTOR,
      ImageBitmap: FUNCTION,
      ImageData: FUNCTION,
      Infinity: DEFAULT,
      InputDeviceCapabilities: FUNCTION,
      Int16Array: FUNCTION,
      Int32Array: FUNCTION,
      Int8Array: FUNCTION,
      Intl: DEFAULT,
      JSON: DEFAULT,
      KeyboardEvent: FUNCTION,
      Location: FUNCTION,
      MIDIAccess: FUNCTION,
      MIDIConnectionEvent: FUNCTION,
      MIDIInput: FUNCTION,
      MIDIInputMap: FUNCTION,
      MIDIMessageEvent: FUNCTION,
      MIDIOutput: FUNCTION,
      MIDIOutputMap: FUNCTION,
      MIDIPort: FUNCTION,
      Map: RAW,
      Math: DEFAULT,
      MediaDevices: DEFAULT,
      MediaElementAudioSourceNode: FUNCTION,
      MediaEncryptedEvent: FUNCTION,
      MediaError: FUNCTION,
      MediaKeyMessageEvent: FUNCTION,
      MediaKeySession: FUNCTION,
      MediaKeyStatusMap: FUNCTION,
      MediaKeySystemAccess: FUNCTION,
      MediaKeys: FUNCTION,
      MediaList: FUNCTION,
      MediaQueryList: FUNCTION,
      MediaQueryListEvent: FUNCTION,
      MediaRecorder: CTOR,
      MediaSource: FUNCTION,
      MediaStreamAudioDestinationNode: CTOR,
      MediaStreamAudioSourceNode: CTOR,
      MediaStreamEvent: CTOR,
      MediaStreamTrack: FUNCTION,
      MessageChannel: RAW,
      MessageEvent: RAW,
      MessagePort: RAW,
      MimeType: FUNCTION,
      MimeTypeArray: FUNCTION,
      MutationObserver: CTOR,
      MutationRecord: FUNCTION,
      MouseEvent: CTOR,
      NaN: DEFAULT,
      NamedNodeMap: FUNCTION,
      Navigator: FUNCTION,
      Node: RAW,
      NodeFilter: FUNCTION,
      NodeIterator: FUNCTION,
      NodeList: FUNCTION,
      Number: FUNCTION,
      Object: FUNCTION,
      OfflineAudioCompletionEvent: FUNCTION,
      OfflineAudioContext: FUNCTION,
      Option: CTOR,
      OscillatorNode: FUNCTION,
      PERSISTENT: DEFAULT,
      PageTransitionEvent: FUNCTION,
      PasswordCredential: FUNCTION,
      Path2D: FUNCTION,
      Performance: RAW,
      PerformanceEntry: FUNCTION,
      PerformanceMark: FUNCTION,
      PerformanceMeasure: FUNCTION,
      PerformanceNavigation: FUNCTION,
      PerformanceResourceTiming: FUNCTION,
      PerformanceTiming: FUNCTION,
      PeriodicWave: FUNCTION,
      PopStateEvent: FUNCTION,
      Presentation: FUNCTION,
      PresentationAvailability: FUNCTION,
      PresentationConnection: FUNCTION,
      PresentationConnectionAvailableEvent: FUNCTION,
      PresentationConnectionCloseEvent: FUNCTION,
      PresentationRequest: FUNCTION,
      ProcessingInstruction: FUNCTION,
      ProgressEvent: FUNCTION,
      Promise: FUNCTION,
      PromiseRejectionEvent: FUNCTION,
      RTCCertificate: FUNCTION,
      RTCIceCandidate: FUNCTION,
      RTCSessionDescription: CTOR,
      RadioNodeList: FUNCTION,
      Range: FUNCTION,
      RangeError: FUNCTION,
      ReadableByteStream: FUNCTION,
      ReadableStream: FUNCTION,
      ReferenceError: FUNCTION,
      Reflect: DEFAULT,
      RegExp: FUNCTION,
      Request: FUNCTION,
      Response: FUNCTION,
      SVGAElement: FUNCTION,
      SVGAngle: FUNCTION,
      SVGAnimateElement: FUNCTION,
      SVGAnimateMotionElement: FUNCTION,
      SVGAnimateTransformElement: FUNCTION,
      SVGAnimatedAngle: FUNCTION,
      SVGAnimatedBoolean: FUNCTION,
      SVGAnimatedEnumeration: FUNCTION,
      SVGAnimatedInteger: FUNCTION,
      SVGAnimatedLength: FUNCTION,
      SVGAnimatedLengthList: FUNCTION,
      SVGAnimatedNumber: FUNCTION,
      SVGAnimatedNumberList: FUNCTION,
      SVGAnimatedPreserveAspectRatio: FUNCTION,
      SVGAnimatedRect: FUNCTION,
      SVGAnimatedString: FUNCTION,
      SVGAnimatedTransformList: FUNCTION,
      SVGAnimationElement: RAW,
      SVGCircleElement: RAW,
      SVGClipPathElement: RAW,
      SVGComponentTransferFunctionElement: RAW,
      SVGCursorElement: RAW,
      SVGDefsElement: RAW,
      SVGDescElement: RAW,
      SVGDiscardElement: RAW,
      SVGElement: RAW,
      SVGEllipseElement: RAW,
      SVGFEBlendElement: RAW,
      SVGFEColorMatrixElement: RAW,
      SVGFEComponentTransferElement: RAW,
      SVGFECompositeElement: RAW,
      SVGFEConvolveMatrixElement: RAW,
      SVGFEDiffuseLightingElement: RAW,
      SVGFEDisplacementMapElement: RAW,
      SVGFEDistantLightElement: RAW,
      SVGFEDropShadowElement: RAW,
      SVGFEFloodElement: RAW,
      SVGFEFuncAElement: RAW,
      SVGFEFuncBElement: RAW,
      SVGFEFuncGElement: RAW,
      SVGFEFuncRElement: RAW,
      SVGFEGaussianBlurElement: RAW,
      SVGFEImageElement: RAW,
      SVGFEMergeElement: RAW,
      SVGFEMergeNodeElement: RAW,
      SVGFEMorphologyElement: RAW,
      SVGFEOffsetElement: RAW,
      SVGFEPointLightElement: RAW,
      SVGFESpecularLightingElement: RAW,
      SVGFESpotLightElement: RAW,
      SVGFETileElement: RAW,
      SVGFETurbulenceElement: RAW,
      SVGFilterElement: RAW,
      SVGForeignObjectElement: RAW,
      SVGGElement: RAW,
      SVGGeometryElement: RAW,
      SVGGradientElement: RAW,
      SVGGraphicsElement: RAW,
      SVGImageElement: RAW,
      SVGLength: FUNCTION,
      SVGLengthList: FUNCTION,
      SVGLineElement: RAW,
      SVGLinearGradientElement: RAW,
      SVGMPathElement: RAW,
      SVGMarkerElement: RAW,
      SVGMaskElement: RAW,
      SVGMatrix: RAW,
      SVGMetadataElement: RAW,
      SVGNumber: FUNCTION,
      SVGNumberList: FUNCTION,
      SVGPathElement: RAW,
      SVGPatternElement: RAW,
      SVGPoint: FUNCTION,
      SVGPointList: FUNCTION,
      SVGPolygonElement: RAW,
      SVGPolylineElement: RAW,
      SVGPreserveAspectRatio: FUNCTION,
      SVGRadialGradientElement: RAW,
      SVGRect: FUNCTION,
      SVGRectElement: RAW,
      SVGSVGElement: RAW,
      SVGScriptElement: RAW,
      SVGSetElement: RAW,
      SVGStopElement: RAW,
      SVGStringList: FUNCTION,
      SVGStyleElement: RAW,
      SVGSwitchElement: RAW,
      SVGSymbolElement: RAW,
      SVGTSpanElement: RAW,
      SVGTextContentElement: RAW,
      SVGTextElement: RAW,
      SVGTextPathElement: RAW,
      SVGTextPositioningElement: RAW,
      SVGTitleElement: RAW,
      SVGTransform: FUNCTION,
      SVGTransformList: FUNCTION,
      SVGUnitTypes: FUNCTION,
      SVGUseElement: RAW,
      SVGViewElement: RAW,
      SVGViewSpec: FUNCTION,
      SVGZoomEvent: FUNCTION,
      Screen: FUNCTION,
      ScreenOrientation: FUNCTION,
      SecurityPolicyViolationEvent: FUNCTION,
      Selection: FUNCTION,
      Set: RAW,
      SourceBuffer: FUNCTION,
      SourceBufferList: FUNCTION,
      SpeechSynthesisEvent: FUNCTION,
      SpeechSynthesisUtterance: FUNCTION,
      String: RAW,
      StyleSheet: FUNCTION,
      StyleSheetList: FUNCTION,
      SubtleCrypto: FUNCTION,
      Symbol: RAW,
      SyntaxError: FUNCTION,
      TEMPORARY: DEFAULT,
      Text: CTOR,
      TextDecoder: FUNCTION,
      TextEncoder: RAW,
      TextEvent: FUNCTION,
      TextMetrics: FUNCTION,
      TextTrack: FUNCTION,
      TextTrackCue: FUNCTION,
      TextTrackCueList: FUNCTION,
      TextTrackList: FUNCTION,
      TimeRanges: RAW,
      Touch: FUNCTION,
      TouchEvent: FUNCTION,
      TouchList: FUNCTION,
      TrackEvent: FUNCTION,
      TransitionEvent: FUNCTION,
      TreeWalker: FUNCTION,
      TypeError: FUNCTION,
      UIEvent: FUNCTION,
      URIError: FUNCTION,
      // Replaced by SecureURL
      // "URL":                                  RAW,
      URLSearchParams: FUNCTION,
      Uint16Array: RAW,
      Uint32Array: RAW,
      Uint8Array: RAW,
      Uint8ClampedArray: RAW,
      VTTCue: FUNCTION,
      ValidityState: FUNCTION,
      WaveShaperNode: FUNCTION,
      WeakMap: RAW,
      WeakSet: RAW,
      WebGLActiveInfo: FUNCTION,
      WebGLBuffer: FUNCTION,
      WebGLContextEvent: FUNCTION,
      WebGLFramebuffer: FUNCTION,
      WebGLProgram: FUNCTION,
      WebGLRenderbuffer: FUNCTION,
      WebGLRenderingContext: FUNCTION,
      WebGLShader: FUNCTION,
      WebGLShaderPrecisionFormat: FUNCTION,
      WebGLTexture: FUNCTION,
      WebGLUniformLocation: FUNCTION,
      WebKitAnimationEvent: FUNCTION,
      WebKitCSSMatrix: CTOR,
      WebKitTransitionEvent: FUNCTION,
      WebSocket: RAW,
      WheelEvent: FUNCTION,
      Window: FUNCTION,
      XMLDocument: FUNCTION,
      XMLHttpRequest: CTOR,
      XMLHttpRequestEventTarget: FUNCTION,
      XMLHttpRequestUpload: FUNCTION,
      XMLSerializer: CTOR,
      XPathEvaluator: FUNCTION,
      XPathExpression: FUNCTION,
      XPathResult: FUNCTION,
      XSLTProcessor: FUNCTION,
      alert: FUNCTION,
      atob: FUNCTION,
      blur: FUNCTION,
      btoa: FUNCTION,
      cancelAnimationFrame: FUNCTION,
      cancelIdleCallback: FUNCTION,
      captureEvents: FUNCTION,
      chrome: DEFAULT,
      clearInterval: FUNCTION,
      clearTimeout: FUNCTION,
      close: FUNCTION,
      closed: DEFAULT,
      confirm: FUNCTION,
      console: RAW,
      createImageBitmap: FUNCTION,
      crypto: DEFAULT,
      decodeURI: FUNCTION,
      decodeURIComponent: FUNCTION,
      defaultStatus: DEFAULT,
      defaultstatus: DEFAULT,
      devicePixelRatio: DEFAULT,
      document: DEFAULT,
      encodeURI: FUNCTION,
      encodeURIComponent: FUNCTION,
      escape: FUNCTION,
      fetch: FUNCTION,
      find: FUNCTION,
      focus: FUNCTION,
      frameElement: DEFAULT,
      frames: DEFAULT,
      getComputedStyle: FUNCTION,
      getMatchedCSSRules: FUNCTION,
      getSelection: FUNCTION,
      history: RAW,
      innerHeight: DEFAULT,
      innerWidth: DEFAULT,
      isFinite: FUNCTION,
      isNaN: FUNCTION,
      isSecureContext: DEFAULT,
      length: DEFAULT,
      localStorage: DEFAULT,
      locationbar: DEFAULT,
      matchMedia: FUNCTION,
      menubar: DEFAULT,
      moveBy: FUNCTION,
      moveTo: FUNCTION,
      name: DEFAULT,
      navigator: DEFAULT,
      offscreenBuffering: DEFAULT,
      onabort: EVENT,
      onanimationend: EVENT,
      onanimationiteration: EVENT,
      onanimationstart: EVENT,
      onautocomplete: EVENT,
      onautocompleteerror: EVENT,
      onbeforeunload: EVENT,
      onblur: EVENT,
      oncancel: EVENT,
      oncanplay: EVENT,
      oncanplaythrough: EVENT,
      onchange: EVENT,
      onclick: EVENT,
      onclose: EVENT,
      oncontextmenu: EVENT,
      oncuechange: EVENT,
      ondblclick: EVENT,
      ondevicemotion: EVENT,
      ondeviceorientation: EVENT,
      ondeviceorientationabsolute: EVENT,
      ondrag: EVENT,
      ondragend: EVENT,
      ondragenter: EVENT,
      ondragleave: EVENT,
      ondragover: EVENT,
      ondragstart: EVENT,
      ondrop: EVENT,
      ondurationchange: EVENT,
      onemptied: EVENT,
      onended: EVENT,
      onerror: EVENT,
      onfocus: EVENT,
      onhashchange: EVENT,
      oninput: EVENT,
      oninvalid: EVENT,
      onkeydown: EVENT,
      onkeypress: EVENT,
      onkeyup: EVENT,
      onlanguagechange: EVENT,
      onload: EVENT,
      onloadeddata: EVENT,
      onloadedmetadata: EVENT,
      onloadstart: EVENT,
      onmessage: EVENT,
      onmousedown: EVENT,
      onmouseenter: EVENT,
      onmouseleave: EVENT,
      onmousemove: EVENT,
      onmouseout: EVENT,
      onmouseover: EVENT,
      onmouseup: EVENT,
      onmousewheel: EVENT,
      onoffline: EVENT,
      ononline: EVENT,
      onpagehide: EVENT,
      onpageshow: EVENT,
      onpause: EVENT,
      onplay: EVENT,
      onplaying: EVENT,
      onpopstate: EVENT,
      onprogress: EVENT,
      onratechange: EVENT,
      onrejectionhandled: EVENT,
      onreset: EVENT,
      onresize: EVENT,
      onscroll: EVENT,
      onsearch: EVENT,
      onseeked: EVENT,
      onseeking: EVENT,
      onselect: EVENT,
      onshow: EVENT,
      onstalled: EVENT,
      onstorage: EVENT,
      onsubmit: EVENT,
      onsuspend: EVENT,
      ontimeupdate: EVENT,
      ontoggle: EVENT,
      ontransitionend: EVENT,
      ontouchcancel: EVENT,
      ontouchend: EVENT,
      ontouchmove: EVENT,
      ontouchstart: EVENT,
      onunhandledrejection: EVENT,
      onunload: EVENT,
      onvolumechange: EVENT,
      onwaiting: EVENT,
      onwheel: EVENT,
      open: FUNCTION,
      outerHeight: DEFAULT,
      outerWidth: DEFAULT,
      pageStartTime: DEFAULT,
      pageXOffset: DEFAULT,
      pageYOffset: DEFAULT,
      parent: DEFAULT,
      parseFloat: FUNCTION,
      parseInt: FUNCTION,
      performance: RAW,
      personalbar: DEFAULT,
      postMessage: FUNCTION,
      print: FUNCTION,
      prompt: FUNCTION,
      releaseEvents: FUNCTION,
      requestAnimationFrame: FUNCTION,
      requestIdleCallback: FUNCTION,
      resizeBy: FUNCTION,
      resizeTo: FUNCTION,
      screen: RAW,
      screenLeft: DEFAULT,
      screenTop: DEFAULT,
      screenX: DEFAULT,
      screenY: DEFAULT,
      scroll: FUNCTION,
      scrollBy: FUNCTION,
      scrollTo: FUNCTION,
      scrollX: DEFAULT,
      scrollY: DEFAULT,
      scrollbars: DEFAULT,
      sessionStorage: DEFAULT,
      self: DEFAULT,
      setInterval: FUNCTION,
      setTimeout: FUNCTION,
      status: DEFAULT,
      statusbar: DEFAULT,
      stop: FUNCTION,
      styleMedia: DEFAULT,
      toolbar: DEFAULT,
      top: DEFAULT,
      undefined: DEFAULT,
      unescape: FUNCTION,
      window: DEFAULT
    },
    EventTarget: metadata$4
  }
};

function SecureWindow(win, key) {
  let o = getFromCache(win, key);
  if (o) {
    return o;
  }

  // Create prototype to allow basic object operations like hasOwnProperty etc
  const emptyProto = {};
  // Do not treat window like a plain object, $A.util.isPlainObject() returns true if we leave the constructor intact
  emptyProto.constructor = null;
  Object.freeze(emptyProto);

  o = Object.create(emptyProto, {
    document: {
      enumerable: true,
      value: SecureDocument(win.document, key)
    },
    window: {
      enumerable: true,
      get: function() {
        return o;
      }
    },
    localStorage: {
      enumerable: true,
      value: SecureStorage(win.localStorage, 'LOCAL', key)
    },
    sessionStorage: {
      enumerable: true,
      value: SecureStorage(win.sessionStorage, 'SESSION', key)
    },
    MutationObserver: {
      enumerable: true,
      value: SecureMutationObserver(key)
    },
    navigator: {
      enumerable: true,
      value: SecureNavigator(win.navigator, key)
    },
    XMLHttpRequest: {
      enumerable: true,
      value: SecureXMLHttpRequest(key)
    },
    setTimeout: {
      enumerable: true,
      value: function(callback) {
        return setTimeout.apply(
          win,
          [SecureObject.FunctionPrototypeBind.call(callback, o)].concat(
            SecureObject.ArrayPrototypeSlice.call(arguments, 1)
          )
        );
      }
    },
    setInterval: {
      enumerable: true,
      value: function(callback) {
        return setInterval.apply(
          win,
          [SecureObject.FunctionPrototypeBind.call(callback, o)].concat(
            SecureObject.ArrayPrototypeSlice.call(arguments, 1)
          )
        );
      }
    },
    location: {
      enumerable: true,
      get: function() {
        return SecureLocation(win.location, key);
      },
      set: function(value) {
        const ret = (win.location.href = value);
        return ret;
      }
    },
    URL: {
      enumerable: true,
      value: SecureURL(win.URL)
    },
    toString: {
      value: function() {
        return `SecureWindow: ${win}{ key: ${JSON.stringify(key)} }`;
      }
    }
  });

  SecureObject.addMethodIfSupported(o, win, 'getComputedStyle', {
    rawArguments: true
  });

  ['outerHeight', 'outerWidth'].forEach(name => SecureObject.addPropertyIfSupported(o, win, name));

  ['scroll', 'scrollBy', 'scrollTo'].forEach(name =>
    SecureObject.addMethodIfSupported(o, win, name)
  );

  ['open'].forEach(name =>
    SecureObject.addMethodIfSupported(o, win, name, {
      beforeCallback: function(url) {
        // If an url was provided to window.open()
        if (url) {
          // coerce argument to string and sanitize.
          const urlString = sanitizeURLForElement(url);
          // try to open only if we have a non-empty string
          if (urlString.length > 1) {
            if (!isValidURLScheme(urlString)) {
              throw new error(
                'SecureWindow.open supports http://, https:// schemes and relative urls.'
              );
            }
          }
        }
      }
    })
  );

  if ('FormData' in win) {
    let formDataValueOverride;
    Object.defineProperty(o, 'FormData', {
      get: function() {
        return (
          formDataValueOverride ||
          function() {
            const args = SecureObject.ArrayPrototypeSlice.call(arguments);
            // make sure we have access to any <form> passed in to constructor
            let form;
            if (args.length > 0) {
              form = args[0];
              verifyAccess(o, form);
            }

            const rawArgs = form ? [getRef(form, getKey(form))] : [];
            const cls = win['FormData'];
            if (typeof cls === 'function') {
              return new (Function.prototype.bind.apply(
                window['FormData'],
                [null].concat(rawArgs)
              ))();
            }
            return new cls(rawArgs);
          }
        );
      },
      set: function(value) {
        formDataValueOverride = value;
      }
    });
  }

  if ('Notification' in win) {
    let notificationValueOverride;
    Object.defineProperty(o, 'Notification', {
      get: function() {
        if (notificationValueOverride) {
          return notificationValueOverride;
        }
        const notification = SecureNotification(key);
        if ('requestPermission' in win['Notification']) {
          Object.defineProperty(notification, 'requestPermission', {
            enumerable: true,
            value: function(callback) {
              return Notification['requestPermission'](callback);
            }
          });
        }
        if ('permission' in win['Notification']) {
          Object.defineProperty(notification, 'permission', {
            enumerable: true,
            value: Notification['permission']
          });
        }
        return notification;
      },
      set: function(value) {
        notificationValueOverride = value;
      }
    });
  }

  ['Blob', 'File'].forEach(name => {
    if (name in win) {
      let valueOverride;
      Object.defineProperty(o, name, {
        get: function() {
          return (
            valueOverride ||
            function() {
              const cls = win[name];
              const args = Array.prototype.slice.call(arguments);
              let result;

              const scriptTagsRegex = /<script[\s\S]*?>[\s\S]*?<\/script[\s]*?>/gi;
              if (scriptTagsRegex.test(args[0])) {
                throw new error(`${name} creation failed: <script> tags are blocked`);
              }
              if (typeof cls === 'function') {
                //  Function.prototype.bind.apply is being used to invoke the constructor and to pass all the arguments provided by the caller
                // TODO Switch to ES6 when available https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator
                result = new (Function.prototype.bind.apply(cls, [null].concat(args)))();
              } else {
                // For browsers that use a constructor that's not a function, invoke the constructor directly.
                // For example, on Mobile Safari window["Blob"] returns an object called BlobConstructor
                // Invoke constructor with specific arguments, handle up to 3 arguments(Blob accepts 2 param, File accepts 3 param)
                switch (args.length) {
                  case 0:
                    result = new cls();
                    break;
                  case 1:
                    result = new cls(args[0]);
                    break;
                  case 2:
                    result = new cls(args[0], args[1]);
                    break;
                  case 3:
                    result = new cls(args[0], args[1], args[2]);
                    break;
                  default:
                    break;
                }
              }
              return result;
            }
          );
        },
        set: function(value) {
          valueOverride = value;
        }
      });
    }
  });

  addEventTargetMethods(o, win, key);

  // Has to happen last because it depends on the secure getters defined above that require the object to be keyed
  whitelist.forEach(
    // These are direct passthrough's and should never be wrapped in a SecureObject
    name =>
      Object.defineProperty(o, name, {
        enumerable: true,
        writable: true,
        value: win[name]
      })
  );

  if (addPropertiesHook) {
    addPropertiesHook(o, win, key);
  }

  SecureObject.addPrototypeMethodsAndProperties(metadata$$1, o, win, key);

  setRef(o, win, key);
  addToCache(win, o, key);
  registerProxy(o);

  return o;
}

/*
 * Copyright (C) 2013 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function SecureRTCPeerConnection(raw, key) {
  const SecureConstructor = function(configuration) {
    const rtc = new raw(configuration);
    const o = Object.create(null, {
      toString: {
        value: function() {
          return `SecureRTCPeerConnection: ${rtc}{ key: ${JSON.stringify(key)} }`;
        }
      }
    });
    setRef(o, rtc, key);
    // Reference to the original event target functions
    const originalAddEventListener = rtc['addEventListener'];
    const originalDispatchEvent = rtc['dispatchEvent'];
    const originalRemoveEventListener = rtc['removeEventListener'];
    const options = { rawArguments: true };
    // Override the event target functions to handled wrapped arguments
    Object.defineProperties(rtc, {
      addEventListener: {
        writable: true,
        value: function(event, callback, useCapture) {
          if (!callback) {
            return;
          }
          let sCallback = getFromCache(callback, key);
          if (!sCallback) {
            sCallback = function(e) {
              verifyAccess(o, callback, true);
              const se = SecureDOMEvent(e, key);
              callback.call(o, se);
            };
            addToCache(callback, sCallback, key);
            setKey(callback, key);
          }
          originalAddEventListener.call(rtc, event, sCallback, useCapture);
        }
      },
      dispatchEvent: {
        enumerable: true,
        writable: true,
        value: function() {
          const filteredArgs = SecureObject.filterArguments(o, arguments, options);
          let fnReturnedValue = originalDispatchEvent.apply(rtc, filteredArgs);
          if (options && options.afterCallback) {
            fnReturnedValue = options.afterCallback(fnReturnedValue);
          }
          return SecureObject.filterEverything(o, fnReturnedValue, options);
        }
      },
      removeEventListener: {
        writable: true,
        value: function(type, listener, removeOption) {
          const sCallback = getFromCache(listener, key);
          originalRemoveEventListener.call(rtc, type, sCallback, removeOption);
        }
      }
    });
    return rtc;
  };
  SecureConstructor.prototype = raw.prototype;
  return SecureConstructor;
}

// TODO: unused

/*
 * Copyright (C) 2013 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function SecureEngine(engine) {
  const o = Object.create(null, {
    Element: {
      enumerable: true,
      value: engine['Element']
    },
    toString: {
      value: function() {
        return 'SecureEngine';
      }
    }
  });
  Object.freeze(o);
  return o;
}

/*
 * Copyright (C) 2013 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function SecureAura(AuraInstance, key) {
  let o = getFromCache(AuraInstance, key);
  if (o) {
    return o;
  }

  /*
     * Deep traverse an object and unfilter any Locker proxies. Isolate this logic here for the component
     * creation APIs rather than a more general solution to avoid overly aggressive unfiltering that may open
     * new security holes.
     */
  function deepUnfilterArgs(baseObject, members) {
    let value;
    for (const property in members) {
      value = members[property];
      if (value !== undefined && value !== null) {
        if (Array.isArray(value) || isPlainObject(value)) {
          const branchValue = baseObject[property];
          baseObject[property] = deepUnfilterArgs(branchValue, value);
          continue;
        }
      }
      if (isProxy(value)) {
        value = getRef(value, key);
      }
      baseObject[property] = value;
    }
    return baseObject;
  }

  const su = Object.create(null);
  const sls = Object.create(null);
  o = Object.create(null, {
    util: {
      writable: true,
      enumerable: true,
      value: su
    },
    localizationService: {
      writable: true,
      enumerable: true,
      value: sls
    },
    getCallback: {
      value: function(f) {
        // If the results of $A.getCallback() is wired up to an event handler, passed as an attribute or aura event attribute etc it will get
        // filtered and wrapped with the caller's perspective at that time.
        return AuraInstance.getCallback(f);
      }
    },
    toString: {
      value: function() {
        return `SecureAura: ${AuraInstance}{ key: ${JSON.stringify(key)} }`;
      }
    },

    createComponent: {
      enumerable: true,
      writable: true,
      value: function(type, attributes, callback) {
        // copy attributes before modifying so caller does not see unfiltered results
        const attributesCopy = AuraInstance.util.apply({}, attributes, true, true);
        const filteredArgs =
          attributes && AuraInstance.util.isObject(attributes)
            ? deepUnfilterArgs(attributesCopy, attributes)
            : attributes;
        const fnReturnedValue = AuraInstance.createComponent(
          type,
          filteredArgs,
          SecureObject.filterEverything(o, callback)
        );
        return SecureObject.filterEverything(o, fnReturnedValue);
      }
    },

    createComponents: {
      enumerable: true,
      writable: true,
      value: function(components, callback) {
        let filteredComponents = [];
        if (Array.isArray(components)) {
          for (let i = 0; i < components.length; i++) {
            const filteredComponent = [];
            filteredComponent[0] = components[i][0];
            // copy attributes before modifying so caller does not see unfiltered results
            const attributesCopy = AuraInstance.util.apply({}, components[i][1], true, true);
            filteredComponent[1] = deepUnfilterArgs(attributesCopy, components[i][1]);
            filteredComponents.push(filteredComponent);
          }
        } else {
          filteredComponents = components;
        }
        const fnReturnedValue = AuraInstance.createComponents(
          filteredComponents,
          SecureObject.filterEverything(o, callback)
        );
        return SecureObject.filterEverything(o, fnReturnedValue);
      }
    }
  });

  // SecureAura methods and properties
  ['enqueueAction'].forEach(name =>
    Object.defineProperty(
      o,
      name,
      SecureObject.createFilteredMethod(o, AuraInstance, name, { rawArguments: true })
    )
  );

  ['get', 'getComponent', 'getReference', 'getRoot', 'log', 'reportError', 'warning'].forEach(
    name => Object.defineProperty(o, name, SecureObject.createFilteredMethod(o, AuraInstance, name))
  );

  setRef(o, AuraInstance, key);
  Object.seal(o);

  // SecureUtil: creating a proxy for $A.util
  ['getBooleanValue', 'isArray', 'isObject', 'isUndefined', 'isUndefinedOrNull'].forEach(name =>
    Object.defineProperty(
      su,
      name,
      SecureObject.createFilteredMethod(su, AuraInstance['util'], name)
    )
  );
  // These methods in Util deal with raw objects like components, so mark them as such
  ['addClass', 'hasClass', 'removeClass', 'toggleClass', 'isEmpty'].forEach(name =>
    Object.defineProperty(
      su,
      name,
      SecureObject.createFilteredMethod(su, AuraInstance['util'], name, { rawArguments: true })
    )
  );

  setRef(su, AuraInstance['util'], key);
  Object.seal(su);

  // SecureLocalizationService: creating a proxy for $A.localizationService
  [
    'displayDuration',
    'displayDurationInDays',
    'displayDurationInHours',
    'displayDurationInMilliseconds',
    'displayDurationInMinutes',
    'displayDurationInMonths',
    'displayDurationInSeconds',
    'duration',
    'endOf',
    'formatCurrency',
    'formatDate',
    'formatDateTime',
    'formatDateTimeUTC',
    'formatDateUTC',
    'formatNumber',
    'formatPercent',
    'formatTime',
    'formatTimeUTC',
    'getDateStringBasedOnTimezone',
    'getDaysInDuration',
    'getDefaultCurrencyFormat',
    'getDefaultNumberFormat',
    'getDefaultPercentFormat',
    'getHoursInDuration',
    'getLocalizedDateTimeLabels',
    'getMillisecondsInDuration',
    'getMinutesInDuration',
    'getMonthsInDuration',
    'getNumberFormat',
    'getSecondsInDuration',
    'getToday',
    'getYearsInDuration',
    'isAfter',
    'isBefore',
    'isBetween',
    'isPeriodTimeView',
    'isSame',
    'parseDateTime',
    'parseDateTimeISO8601',
    'parseDateTimeUTC',
    'startOf',
    'toISOString',
    'translateFromLocalizedDigits',
    'translateFromOtherCalendar',
    'translateToLocalizedDigits',
    'translateToOtherCalendar',
    'UTCToWallTime',
    'WallTimeToUTC'
  ].forEach(name =>
    Object.defineProperty(
      sls,
      name,
      SecureObject.createFilteredMethod(sls, AuraInstance['localizationService'], name)
    )
  );

  setRef(sls, AuraInstance['localizationService'], key);
  Object.seal(sls);

  addToCache(AuraInstance, o, key);
  registerProxy(o);

  return o;
}

/*
 * Copyright (C) 2013 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function SecureAuraAction(action, key) {
  let o = getFromCache(action, key);
  if (o) {
    return o;
  }

  o = Object.create(null, {
    toString: {
      value: function() {
        return `SecureAction: ${action}{ key: ${JSON.stringify(key)} }`;
      }
    }
  });

  Object.defineProperties(o, {
    getName: SecureObject.createFilteredMethod(o, action, 'getName'),
    setCallback: SecureObject.createFilteredMethod(o, action, 'setCallback', { defaultKey: key }),
    setParams: SecureObject.createFilteredMethod(o, action, 'setParams', { defaultKey: key }),
    setParam: SecureObject.createFilteredMethod(o, action, 'setParam', { defaultKey: key }),
    getParams: SecureObject.createFilteredMethod(o, action, 'getParams'),
    getParam: SecureObject.createFilteredMethod(o, action, 'getParam'),
    getCallback: SecureObject.createFilteredMethod(o, action, 'getCallback'),
    getState: SecureObject.createFilteredMethod(o, action, 'getState'),
    getReturnValue: SecureObject.createFilteredMethod(o, action, 'getReturnValue', {
      defaultKey: key
    }),
    getError: SecureObject.createFilteredMethod(o, action, 'getError'),
    isBackground: SecureObject.createFilteredMethod(o, action, 'isBackground'),
    setBackground: SecureObject.createFilteredMethod(o, action, 'setBackground'),
    setAbortable: SecureObject.createFilteredMethod(o, action, 'setAbortable'),
    setStorable: SecureObject.createFilteredMethod(o, action, 'setStorable')
  });

  setRef(o, action, key);
  addToCache(action, o, key);
  registerProxy(o);

  return Object.seal(o);
}

/*
 * Copyright (C) 2013 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function SecureAuraEvent(event, key) {
  let o = getFromCache(event, key);
  if (o) {
    return o;
  }

  /**
   * Traverse all entries in the baseObject to unwrap any secure wrappers and wrap any functions as
   * SecureFunction. This ensures any non-Lockerized handlers of the event do not choke on the secure
   * wrappers, but any callbacks back into the original Locker have their arguments properly filtered.
   */
  function deepUnfilterMethodArguments(baseObject, members) {
    let value;
    for (const property in members) {
      value = members[property];
      if (Array.isArray(value)) {
        value = deepUnfilterMethodArguments([], value);
      } else if (isPlainObject(value)) {
        value = deepUnfilterMethodArguments({}, value);
      } else if (typeof value !== 'function') {
        if (value) {
          const key = getKey(value);
          if (key) {
            value = getRef(value, key) || value;
          }
        }
        // If value is a plain object, we need to deep unfilter
        if (isPlainObject(value)) {
          value = deepUnfilterMethodArguments({}, value);
        }
      } else {
        value = SecureObject.filterEverything(o, value, { defaultKey: key });
      }
      baseObject[property] = value;
    }
    return baseObject;
  }

  o = Object.create(null, {
    toString: {
      value: function() {
        return `SecureAuraEvent: ${event}{ key: ${JSON.stringify(key)} }`;
      }
    },
    setParams: {
      writable: true,
      enumerable: true,
      value: function(config) {
        const unfiltered = deepUnfilterMethodArguments({}, config);
        event['setParams'](unfiltered);
        return o;
      }
    },
    setParam: {
      writable: true,
      enumerable: true,
      value: function(property, value) {
        const unfiltered = deepUnfilterMethodArguments({}, { value: value }).value;
        event['setParam'](property, unfiltered);
      }
    }
  });

  [
    'fire',
    'getName',
    'getParam',
    'getParams',
    'getPhase',
    'getSource',
    'getSourceEvent',
    'pause',
    'preventDefault',
    'resume',
    'stopPropagation',
    'getType',
    'getEventType'
  ].forEach(name =>
    Object.defineProperty(o, name, SecureObject.createFilteredMethod(o, event, name))
  );

  setRef(o, event, key);
  addToCache(event, o, key);
  registerProxy(o);

  return Object.seal(o);
}

/*
 * Copyright (C) 2013 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

let getPublicMethodNames;
let requireLocker;

function registerAuraAPI(api) {
  if (api) {
    getPublicMethodNames = api.getPublicMethodNames;
    requireLocker = api.requireLocker;
  }
}

/*
 * Copyright (C) 2013 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function SecureAuraComponent(component, key) {
  let o = getFromCache(component, key);
  if (o) {
    return o;
  }

  // special methods that require some extra work
  o = Object.create(null, {
    get: {
      writable: true,
      enumerable: true,
      value: function(name) {
        const path = name.split('.');
        // protection against `cmp.get('c')`
        if (typeof path[1] !== 'string' || path[1] === '') {
          throw new SyntaxError(`Invalid key ${name}`);
        }

        const value = component['get'](name);
        if (!value) {
          return value;
        }

        if (path[0] === 'c') {
          return SecureAuraAction(value, key);
        }
        return SecureObject.filterEverything(o, value);
      }
    },
    getEvent: {
      writable: true,
      enumerable: true,
      value: function(name) {
        const event = component['getEvent'](name);
        if (!event) {
          return event;
        }
        return SecureAuraEvent(event, key);
      }
    },
    toString: {
      value: function() {
        return `SecureComponent: ${component}{ key: ${JSON.stringify(key)} }`;
      }
    }
  });

  Object.defineProperties(o, {
    // these four super* methods are exposed as a temporary solution until we figure how to re-arrange the render flow
    superRender: SecureObject.createFilteredMethod(o, component, 'superRender'),
    superAfterRender: SecureObject.createFilteredMethod(o, component, 'superAfterRender'),
    superRerender: SecureObject.createFilteredMethod(o, component, 'superRerender'),
    superUnrender: SecureObject.createFilteredMethod(o, component, 'superUnrender'),

    // component @platform methods
    isValid: SecureObject.createFilteredMethod(o, component, 'isValid'),
    isInstanceOf: SecureObject.createFilteredMethod(o, component, 'isInstanceOf'),
    addEventHandler: SecureObject.createFilteredMethod(o, component, 'addEventHandler', {
      rawArguments: true
    }),
    addHandler: SecureObject.createFilteredMethod(o, component, 'addHandler'),
    addValueHandler: SecureObject.createFilteredMethod(o, component, 'addValueHandler'),
    addValueProvider: SecureObject.createFilteredMethod(o, component, 'addValueProvider'),
    destroy: SecureObject.createFilteredMethod(o, component, 'destroy'),
    isRendered: SecureObject.createFilteredMethod(o, component, 'isRendered'),
    getGlobalId: SecureObject.createFilteredMethod(o, component, 'getGlobalId'),
    getLocalId: SecureObject.createFilteredMethod(o, component, 'getLocalId'),
    getSuper: SecureObject.createFilteredMethod(o, component, 'getSuper'),
    getReference: SecureObject.createFilteredMethod(o, component, 'getReference'),
    getVersion: SecureObject.createFilteredMethod(o, component, 'getVersion'),
    clearReference: SecureObject.createFilteredMethod(o, component, 'clearReference'),
    autoDestroy: SecureObject.createFilteredMethod(o, component, 'autoDestroy'),
    isConcrete: SecureObject.createFilteredMethod(o, component, 'isConcrete'),
    getConcreteComponent: SecureObject.createFilteredMethod(o, component, 'getConcreteComponent'),
    find: SecureObject.createFilteredMethod(o, component, 'find'),
    set: SecureObject.createFilteredMethod(o, component, 'set', {
      defaultKey: key,
      rawArguments: true
    }),
    getElement: SecureObject.createFilteredMethod(o, component, 'getElement'),
    getElements: SecureObject.createFilteredMethod(o, component, 'getElements'),
    getName: SecureObject.createFilteredMethod(o, component, 'getName'),
    getType: SecureObject.createFilteredMethod(o, component, 'getType'),
    removeEventHandler: SecureObject.createFilteredMethod(o, component, 'removeEventHandler')
  });

  // The shape of the component depends on the methods exposed in the definitions:
  const methodsNames = getPublicMethodNames(component);
  if (methodsNames && methodsNames.length) {
    methodsNames.forEach(methodName =>
      SecureObject.addMethodIfSupported(o, component, methodName, { defaultKey: key })
    );
  }

  setRef(o, component, key);
  addToCache(component, o, key); // backpointer
  registerProxy(o);

  return o;
}

/*
 * Copyright (C) 2013 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function SecureAuraComponentRef(component, key) {
  let o = getFromCache(component, key);
  if (o) {
    return o;
  }

  o = Object.create(null, {
    toString: {
      value: function() {
        return `SecureComponentRef: ${component}{ key: ${JSON.stringify(key)} }`;
      }
    }
  });
  Object.defineProperties(o, {
    addValueHandler: SecureObject.createFilteredMethod(o, component, 'addValueHandler'),
    addValueProvider: SecureObject.createFilteredMethod(o, component, 'addValueProvider'),
    destroy: SecureObject.createFilteredMethod(o, component, 'destroy'),
    getGlobalId: SecureObject.createFilteredMethod(o, component, 'getGlobalId'),
    getLocalId: SecureObject.createFilteredMethod(o, component, 'getLocalId'),
    getEvent: SecureObject.createFilteredMethod(o, component, 'getEvent'),
    isInstanceOf: SecureObject.createFilteredMethod(o, component, 'isInstanceOf'),
    isRendered: SecureObject.createFilteredMethod(o, component, 'isRendered'),
    isValid: SecureObject.createFilteredMethod(o, component, 'isValid'),
    set: SecureObject.createFilteredMethod(o, component, 'set', {
      defaultKey: key,
      rawArguments: true
    }),
    get: {
      writable: true,
      enumerable: true,
      value: function(name) {
        // protection against anything other then `cmp.get('v.something')`
        if (
          typeof name !== 'string' ||
          name.length < 3 ||
          (name.indexOf('v.') !== 0 && name.indexOf('e.') !== 0)
        ) {
          throw new SyntaxError(`Invalid key ${name}`);
        }

        return SecureObject.filterEverything(o, component['get'](name));
      }
    }
  });

  /**
   * Traverse all entries in the baseObject to unwrap any secure wrappers and wrap any functions as
   * SecureFunction. This ensures any non-Lockerized handlers of the event do not choke on the secure
   * wrappers, but any callbacks back into the original Locker have their arguments properly filtered.
   */
  function deepUnfilterMethodArguments(baseObject, members) {
    let value;
    for (const property in members) {
      value = members[property];
      if (Array.isArray(value)) {
        value = deepUnfilterMethodArguments([], value);
      } else if (isPlainObject(value)) {
        value = deepUnfilterMethodArguments({}, value);
      } else if (typeof value !== 'function') {
        if (value) {
          const key = getKey(value);
          if (key) {
            value = getRef(value, key) || value;
          }
        }
        // If value is a plain object, we need to deep unfilter
        if (isPlainObject(value)) {
          value = deepUnfilterMethodArguments({}, value);
        }
      } else {
        value = SecureObject.filterEverything(o, value, { defaultKey: key });
      }
      baseObject[property] = value;
    }
    return baseObject;
  }

  const methodsNames = getPublicMethodNames(component);
  if (methodsNames && methodsNames.length) {
    // If SecureAuraComponentRef is an unlockerized component, then let it
    // have access to raw arguments
    const methodOptions = {
      defaultKey: key,
      unfilterEverything: !requireLocker(component)
        ? function(args) {
            return deepUnfilterMethodArguments([], args);
          }
        : undefined
    };

    methodsNames.forEach(methodName =>
      SecureObject.addMethodIfSupported(o, component, methodName, methodOptions)
    );
  }

  // DCHASMAN TODO Workaround for ui:button redefining addHandler using aura:method!!!
  if (!('addHandler' in o)) {
    SecureObject.addMethodIfSupported(o, component, 'addHandler', { rawArguments: true });
  }

  setRef(o, component, key);
  addToCache(component, o, key);
  registerProxy(o);

  return Object.seal(o);
}

/*
 * Copyright (C) 2013 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function SecureAuraPropertyReferenceValue(prv, key) {
  let o = getFromCache(prv, key);
  if (o) {
    return o;
  }

  o = Object.create(null, {
    toString: {
      value: function() {
        return `SecurePropertyReferenceValue: ${prv} { key: ${JSON.stringify(key)} }`;
      }
    }
  });

  setRef(o, prv, key);
  addToCache(prv, o, key);
  registerProxy(o);

  return Object.seal(o);
}

/*
 * Copyright (C) 2013 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

let AuraAction;
let AuraComponent;
let AuraEvent;
let AuraPropertyReferenceValue;

function registerAuraTypes(types) {
  if (types) {
    AuraAction = types.Action;
    AuraComponent = types.Component;
    AuraEvent = types.Event;
    AuraPropertyReferenceValue = types.PropertyReferenceValue;
  }
}

/*
 * Copyright (C) 2013 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const service = {
  piercing: (component, data, def, context, target, key, value, callback) => {
    if (value === EventTarget.prototype.dispatchEvent && SecureObject.isDOMElementOrNode(target)) {
      /**
       * See if target represents a lockerized module
       * Else look up the key by the class.
       * If found, get the SecureWindow for that key
       */
      let lsKey = getKey(target);
      if (!lsKey) {
        const Ctor = component.constructor;
        lsKey = getKey(Ctor);
        /**
         * For elements not created by interop component, this is the first chance we have
         * had to trust the element. Propagate the key from Ctor to the element
         */
        if (lsKey) {
          trust$1(Ctor, target);
        }
      }
      if (lsKey) {
        // Create a SecureElement for the custom element
        const secureTarget = SecureElement(target, lsKey);
        callback(event => secureTarget.dispatchEvent(event));
      }
    }
  }
};

function registerEngineAPI(api) {
  if (api && api.registerEngineServices) {
    api.registerEngineServices(service);
  }
}

/*
 * Copyright (C) 2017 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// AuraLocker is a facade for Locker. Its role is to:
// - implement methods not present on Locker (extends API).
// - decouple the Locker API from the Aura API.
let isLockerInitialized = false;

const namespaceToKey = new Map();
const engineToSecureEngine = new Map();

function filterTypeHook(raw, key, belongsToLocker) {
  if (raw instanceof AuraAction) {
    return belongsToLocker ? SecureAuraAction(raw, key) : SecureObject(raw, key);
  } else if (raw instanceof AuraComponent) {
    return belongsToLocker ? SecureAuraComponent(raw, key) : SecureAuraComponentRef(raw, key);
  } else if (raw instanceof AuraEvent) {
    return SecureAuraEvent(raw, key);
  } else if (raw instanceof AuraPropertyReferenceValue) {
    return SecureAuraPropertyReferenceValue(raw, key);
  }
  return null;
}

function isUnfilteredTypeHook(raw, key) {
  const namespace = key['namespace'];
  if (namespace === 'runtime_rtc_spark' || namespace === 'runtime_rtc') {
    return window['MediaStream'] && raw instanceof window['MediaStream'];
  }
  return false;
}

function windowAddPropertiesHook(st, raw, key) {
  defineProperty(st, '$A', {
    enumerable: true,
    value: SecureAura(raw['$A'], key)
  });

  // Salesforce API entry points (first phase) - W-3046191 is tracking adding a publish() API
  // enhancement where we will move these to their respective javascript/container architectures
  ['Sfdc', 'sforce'].forEach(name => SecureObject.addPropertyIfSupported(st, raw, name));

  // Add RTC related api only to specific namespaces
  const namespace = key['namespace'];
  if (namespace === 'runtime_rtc_spark' || namespace === 'runtime_rtc') {
    ['RTCPeerConnection', 'webkitRTCPeerConnection'].forEach(name => {
      if (name in raw) {
        defineProperty(st, name, {
          enumerable: true,
          value: SecureRTCPeerConnection(raw[name], key)
        });
      }
    });

    SecureObject.addUnfilteredPropertyIfSupported(st, raw, 'MediaStream');
  }
}

function navigatorAddPropertiesHook(st, raw, key) {
  const namespace = key['namespace'];
  if (namespace === 'runtime_rtc_spark' || namespace === 'runtime_rtc') {
    ['mediaDevices', 'mozGetUserMedia', 'webkitGetUserMedia'].forEach(name => {
      SecureObject.addUnfilteredPropertyIfSupported(st, raw, name);
    });
  }
}

function create$$1(src, key, sourceURL) {
  return {
    globals: getEnv$1(key),
    returnValue: evaluate(src, key, sourceURL)
  };
}

function getKeyForNamespace(namespace) {
  let key = namespaceToKey.get(namespace);

  if (!key) {
    key = freeze({
      namespace: namespace
    });

    namespaceToKey.set(namespace, key);
  }

  return key;
}

function createForClass(src, defDescriptor) {
  const namespace = defDescriptor.getNamespace();
  const name = defDescriptor.getName();
  const sourceURL = `components/${namespace}/${name}.js`;
  const key = getKeyForNamespace(namespace);

  const returnValue = evaluate(src, key, sourceURL);
  // Key this def so we can transfer the key to component instances
  setKey(returnValue, key);
  return returnValue;
}

// @deprecated
function createForDef(src, def) {
  const defDescriptor = def.getDescriptor();
  const namespace = defDescriptor.getNamespace();
  const name = defDescriptor.getName();
  const sourceURL = `components/${namespace}/${name}.js`;
  const key = getKeyForNamespace(namespace);

  // Key this def so we can transfer the key to component instances
  setKey(def, key);

  return evaluate(`(function () {${src}}())`, key, sourceURL);
}

function createForModule(src, defDescriptor) {
  const namespace = defDescriptor.getNamespace();
  const name = defDescriptor.getName();
  const sourceURL = `modules/${namespace}/${name}.js`;
  const key = getKeyForNamespace(namespace);

  // Mute several globals for modules
  src = `(function() {
  const {$A, aura, Sfdc, sforce} = {};

  return ${src}

}())`;

  const returnValue = evaluate(src, key, sourceURL);
  // Key the sanitized definition so we can transfer the key to interop component instances
  setKey(returnValue, key);
  return returnValue;
}

function getEnv$$1(key) {
  return getEnv$1(key);
}

function getEnvForSecureObject(st) {
  const key = getKey(st);
  if (!key) {
    return undefined;
  }

  return getEnv$1(key);
}

function getRaw(value) {
  if (value) {
    const key = getKey(value);
    if (key) {
      value = getRef(value, key) || value;
    }
  }
  return value;
}

function initialize(types, api) {
  if (isLockerInitialized) {
    return;
  }

  registerAuraTypes(types);
  registerAuraAPI(api);
  registerReportAPI(api);
  registerEngineAPI(api);
  registerFilterTypeHook(filterTypeHook);
  registerIsUnfilteredTypeHook(isUnfilteredTypeHook);
  registerAddPropertiesHook$$1(windowAddPropertiesHook);
  registerAddPropertiesHook$1(navigatorAddPropertiesHook);

  isLockerInitialized = true;
}

function isEnabled() {
  return true;
}

// @deprecated
function instanceOf(value, type) {
  return value instanceof type;
}

function runScript(src, namespace) {
  const key = getKeyForNamespace(namespace);
  return evaluate(src, key);
}

function trust$$1(from, thing) {
  return trust$1(from, thing);
}

function unwrap$$1(from, st) {
  return unwrap$1(from, st);
}

function wrapComponent(component) {
  const key = getKey(component);
  if (!key) {
    return component;
  }

  if (typeof component !== 'object') {
    return component;
  }

  return requireLocker(component) ? SecureAuraComponent(component, key) : component;
}

function wrapComponentEvent(component, event) {
  // if the component is not secure, return the event.
  const key = getKey(component);
  if (!key) {
    return event;
  }

  if (typeof component !== 'object' || typeof event !== 'object') {
    return event;
  }

  return event instanceof AuraEvent ? SecureAuraEvent(event, key) : SecureDOMEvent(event, key);
}

function wrapEngine(engine) {
  let secureEngine = engineToSecureEngine.get(engine);
  if (!secureEngine) {
    secureEngine = SecureEngine(engine);
    engineToSecureEngine.set(engine, secureEngine);
  }
  return secureEngine;
}

exports.create = create$$1;
exports.getKeyForNamespace = getKeyForNamespace;
exports.createForClass = createForClass;
exports.createForDef = createForDef;
exports.createForModule = createForModule;
exports.getEnv = getEnv$$1;
exports.getEnvForSecureObject = getEnvForSecureObject;
exports.getRaw = getRaw;
exports.initialize = initialize;
exports.isEnabled = isEnabled;
exports.instanceOf = instanceOf;
exports.runScript = runScript;
exports.trust = trust$$1;
exports.unwrap = unwrap$$1;
exports.wrapComponent = wrapComponent;
exports.wrapComponentEvent = wrapComponentEvent;
exports.wrapEngine = wrapEngine;

Object.defineProperty(exports, '__esModule', { value: true });

})));

} catch (e) {}
try {
/**
 * Copyright (C) 2017 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Bundle from LockerService-Core
 * Generated: 2017-12-20
 * Version: 0.3.6
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.AuraLockerDisabled = global.AuraLockerDisabled || {})));
}(this, (function (exports) { 'use strict';

/* eslint-disable no-unused-vars, prefer-template */
/*
 * Copyright (C) 2013 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// This is a mock for non-compliant browsers, in particular for IE11.

// All methods have the same API as AuraLocker.js and it's norman to
// expect unused variables.

// DO NOT USE ES6 METHODS IN THIS FILE.

function evaluate(src) {
  return (0, eval)('(function(){\n' + src + '\n})()');
}

function create(src, key, sourceURL) {
  return {
    globals: window,
    returnValue: evaluate(src)
  };
}

function createForClass(src, defDescriptor) {
  return evaluate('return (\n' + src + '\n)');
}

// @deprecated
function createForDef(src, def) {
  return evaluate(src);
}

function createForModule(src, defDescriptor) {
  return evaluate('return (\n' + src + '\n)');
}

function getEnv(key) {
  return window;
}

function getEnvForSecureObject(st) {
  return window;
}

function getKeyForNamespace(namespace) {
  /* Do Nothing */
}

function getRaw(value) {
  return value;
}

function initialize(types) {
  /* Do Nothing */
}

function isEnabled() {
  return false;
}

// @deprecated
function instanceOf(value, type) {
  return value instanceof type;
}

function runScript(src, namespace) {
  return evaluate(src);
}

function trust(from, thing) {
  /* Do Nothing */
}

function unwrap(from, st) {
  return st;
}

function wrapComponent(component) {
  return component;
}

function wrapComponentEvent(component, event) {
  return event;
}

function wrapEngine(engine) {
  return engine;
}

exports.create = create;
exports.createForClass = createForClass;
exports.createForDef = createForDef;
exports.createForModule = createForModule;
exports.getEnv = getEnv;
exports.getEnvForSecureObject = getEnvForSecureObject;
exports.getKeyForNamespace = getKeyForNamespace;
exports.getRaw = getRaw;
exports.initialize = initialize;
exports.isEnabled = isEnabled;
exports.instanceOf = instanceOf;
exports.runScript = runScript;
exports.trust = trust;
exports.unwrap = unwrap;
exports.wrapComponent = wrapComponent;
exports.wrapComponentEvent = wrapComponentEvent;
exports.wrapEngine = wrapEngine;

Object.defineProperty(exports, '__esModule', { value: true });

})));

} catch (e) {}

new function() {
var Aura = window["Aura"] || (window["Aura"] = {});
Aura.$Utils$ = {};
Aura.$Errors$ = {};
Aura.$Context$ = {};
Aura.$System$ = {};
Aura.$Style$ = {};
Aura.$Flavors$ = {};
Aura.$Value$ = {};
Aura.$Model$ = {};
Aura.$Component$ = {};
Aura.$Provider$ = {};
Aura.$Library$ = {};
Aura.$Event$ = {};
Aura.$Layouts$ = {};
Aura.$Controller$ = {};
Aura.$Attribute$ = {};
Aura.$Method$ = {};
Aura.$L10n$ = {};
Aura.$Services$ = {};
Aura.$Storage$ = {};
Aura.$Locker$ = {};
Aura.time = window.performance && window.performance.now ? window.performance.now.bind(performance) : function() {
  return Date.now()
};
Aura["bootstrap"] = Aura["bootstrap"] || {};
Aura["bootstrap"]["visibilityStateStart"] = document.visibilityState;
Aura.$bootstrapMark$ = function(mark, value) {
  if(window.console && window.console.timeStamp) {
    window.console.timeStamp(mark)
  }
  this["bootstrap"][mark] = value || this.time()
};
(function bootstrapRobustness() {
  function verifyBootstrap() {
    document.removeEventListener("DOMContentLoaded", verifyBootstrap);
    $A.$clientService$.$setAppBootstrapStatus$();
    var state = $A.$clientService$.$getBootstrapState$();
    var appCacheProgress = state["appcache"];
    var allFilesLoaded;
    if(appCacheProgress === -1) {
      allFilesLoaded = Object.keys(state).reduce(function(prev, curr) {
        return prev && state[curr]
      }, true);
      if(!allFilesLoaded) {
        if(retryCount < max_retries) {
          retryCount++;
          setTimeout(verifyBootstrap, 1E3)
        }else {
          $A.$clientService$.$dumpCachesAndReload$(true, {"cause":"Aura.verifyBootstrap: Failed bootstrap state: " + JSON.stringify(state)})
        }
      }
      return
    }
    if(state["inline.js"] && ($A.$clientService$.$gvpsFromStorage$ === undefined || $A.$clientService$.$gvpsFromStorage$ && Aura["appBootstrapCacheStatus"] === undefined) || typeof appCacheProgress !== "undefined" && appCacheProgress >= 0 && appCacheProgress < 100) {
      setTimeout(verifyBootstrap, 1E3);
      return
    }
    allFilesLoaded = Object.keys(state).reduce(function(prev, curr) {
      return prev && state[curr]
    }, true);
    if(!allFilesLoaded) {
      $A.$clientService$.$dumpCachesAndReload$(true, {"cause":"Aura.verifyBootstrap: Failed bootstrap state: " + JSON.stringify(state)})
    }
  }
  var max_retries = 10;
  var retryCount = 0;
  document.addEventListener("DOMContentLoaded", verifyBootstrap)
})();
function noop() {
}
function Json() {
}
Json.$ApplicationKey$ = {$ABSTRACT$:"ab", $ACCESS$:"xs", $ACTION$:"x", $ACTIONS$:"xx", $ACTIONDEFS$:"ac", $ACTIONTYPE$:"at", $ATTRIBUTES$:"a", $ATTRIBUTEDEFS$:"ad", $BACKGROUND$:"b", $CABOOSE$:"ca", $CLASSNAME$:"cl", $CODE$:"co", $COMPONENTCLASS$:"cc", $COMPONENTDEF$:"c", $CONTROLLERDEF$:"cd", $CREATIONPATH$:"cp", $CSSPRELOADED$:"css", $DEFAULT$:"d", $DEFAULTFLAVOR$:"df", $DEFTYPE$:"dt", $DESCRIPTOR$:"descriptor", $DYNAMICALLYFLAVORABLE$:"dyf", $EVENTDEF$:"ed", $EVENTS$:"e", $FACETS$:"fa", $FLAVOR$:"fl", 
$FLAVORABLE$:"fb", $FLAVOREDSTYLEDEF$:"fst", $FLAVORABLECHILD$:"fc", $FLAVOROVERRIDES$:"fo", $FUNCTIONS$:"f", $HANDLERDEFS$:"hd", $HANDLERS$:"eh", $HASSERVERDEPENDENCIES$:"hs", $HELPERDEF$:"h", $INCLUDES$:"ic", $INCLUDEFACETS$:"if", $INTERFACES$:"i", $LOAD$:"lo", $LOCALID$:"lid", $LOCATIONCHANGEEVENTDEF$:"lc", $LOCATORDEFS$:"ld", $MEMBERS$:"mm", $MINVERSION$:"mv", $MODEL$:"m", $MODELDEF$:"md", $METHODDEFS$:"med", $METHODS$:"me", "NAME":"n", $ORIGINAL$:"o", $PARAMS$:"pa", $PHASE$:"ph", $PROVIDE$:"p", 
$PROVIDERDEF$:"pd", $PUBLICCACHINGENABLED$:"pce", $PUBLICCACHINGEXPIRATION$:"pcex", $REGISTEREVENTDEFS$:"re", $RENDERERDEF$:"rd", $REQUIRED$:"rq", $REQUIREDVERSIONDEFS$:"rv", $REQUIRELOCKER$:"rl", $RETURNTYPE$:"rt", $SERIAL_ID$:"s", $SERIAL_REFID$:"r", $STYLEDEF$:"st", $SUBDEFS$:"sb", $SUPERDEF$:"su", $TOKENS$:"tk", $TYPE$:"t", $VALUE$:"v", $VALUES$:"vv", $VALUEPROVIDER$:"vp"};
Json.prototype.$decode$ = function(json, refSupport) {
  var obj;
  if(aura["util"].$isUndefinedOrNull$(json)) {
    return null
  }
  try {
    obj = JSON.parse(json)
  }catch(e) {
    $A.$reportError$("Unable to parse JSON response: " + json, e);
    return null
  }
  return refSupport ? this.$resolveRefsObject$(obj) : obj
};
Json.prototype.$decodeString$ = function(value) {
  var valueType = typeof value;
  if(valueType === "function") {
    return value
  }else {
    if(valueType === "string") {
      return aura["util"].$globalEval$(value)
    }
  }
  return value
};
Json.prototype.$resolveRefsObject$ = function(obj) {
  var cmpDefCollector = [];
  $A["util"].apply(obj, {"context":{"componentDefs":[], "libraryDefs":[], "eventDefs":[]}}, false, true);
  this.$_resolveRefs$(obj, {}, null, null, cmpDefCollector);
  if(cmpDefCollector.length > 0) {
    var componentDefs = obj["context"]["componentDefs"];
    var lookup = {};
    var i;
    for(i = 0;i < cmpDefCollector.length;i++) {
      lookup[cmpDefCollector[i]["descriptor"]] = true
    }
    for(i = 0;i < componentDefs.length;i++) {
      if(!lookup[componentDefs[i]["descriptor"]]) {
        cmpDefCollector.push(componentDefs[i])
      }
    }
    obj["context"]["componentDefs"] = cmpDefCollector
  }
  return obj
};
Json.prototype.$resolveRefsArray$ = function(arr) {
  $A.assert($A["util"].isArray(arr), "arr needs to be an array");
  var cmpDefCollector = [];
  this.$_resolveRefs$(arr, {}, null, null, cmpDefCollector);
  arr.unshift.apply(arr, cmpDefCollector);
  return arr
};
Json.prototype.$_resolveRefs$ = function(config, cache, parent, property, collector) {
  if(typeof config === "object" && config !== null) {
    var value;
    var key;
    var v;
    var superCollector;
    if(aura["util"].isArray(config)) {
      for(var i = 0;i < config.length;i++) {
        value = config[i];
        if(typeof value === "object" && value !== null) {
          this.$_resolveRefs$(value, cache, config, i, collector)
        }
      }
    }else {
      var serRefId = config[Json.$ApplicationKey$.$SERIAL_REFID$];
      if(serRefId !== undefined) {
        if(cache[serRefId]["descriptor"] && !cache[serRefId]["members"] && !cache[serRefId]["actionDefs"] && !cache[serRefId]["type"] && !cache[serRefId]["actionType"]) {
          parent[property] = {"descriptor":cache[serRefId]["descriptor"]}
        }else {
          parent[property] = cache[serRefId]
        }
      }else {
        var serId = config[Json.$ApplicationKey$.$SERIAL_ID$];
        if(serId !== undefined && config.hasOwnProperty(Json.$ApplicationKey$.$VALUE$)) {
          value = config[Json.$ApplicationKey$.$VALUE$];
          if(typeof value === "object" && value !== null && (value[Json.$ApplicationKey$.$SERIAL_ID$] || value[Json.$ApplicationKey$.$SERIAL_REFID$])) {
            this.$_resolveRefs$(value, cache, parent, property, collector);
            value = parent[property]
          }else {
            if(value["descriptor"] && (value["componentClass"] || value["attributeDefs"])) {
              var newValueDef = {"descriptor":value["descriptor"]};
              cache[serId] = newValueDef;
              for(key in value) {
                v = value[key];
                if(typeof v === "object" && v !== null) {
                  superCollector = [];
                  this.$_resolveRefs$(v, cache, value, key, superCollector);
                  collector.push.apply(collector, superCollector)
                }
              }
              collector.push(value);
              value = newValueDef
            }
            parent[property] = value
          }
          cache[serId] = value
        }else {
          value = config
        }
        for(key in value) {
          v = value[key];
          if(typeof v === "object" && v !== null) {
            this.$_resolveRefs$(v, cache, value, key, collector)
          }
        }
      }
    }
  }
};
Json.prototype.$stringifyReplacer$ = function(key, value) {
  if(typeof value === "function") {
    return value + ""
  }
  if($A["util"].$isComponent$(value)) {
    return null
  }
  return value
};
Json.prototype.$encode$ = function(obj, replacer, whiteSpace) {
  if(typeof JSON !== "undefined") {
    var oldArrayToJSON = Array.prototype.toJSON;
    var oldComponentToJSON = Component.prototype.toJSON;
    try {
      delete Array.prototype.toJSON;
      delete Component.prototype.toJSON;
      if($A["util"].$isUndefinedOrNull$(replacer)) {
        return JSON.stringify(obj, Json.prototype.$stringifyReplacer$, whiteSpace)
      }else {
        return JSON.stringify(obj, replacer, whiteSpace)
      }
    }finally {
      if(oldArrayToJSON) {
        Array.prototype.toJSON = oldArrayToJSON
      }
      if(oldComponentToJSON) {
        Component.prototype.toJSON = oldComponentToJSON
      }
    }
  }
  if(obj === undefined) {
    return"null"
  }
  if(obj === null) {
    return"null"
  }
  if(!$A["util"].$isUndefined$(obj.toJSON)) {
    return arguments.callee(obj.toJSON())
  }
  switch(obj.constructor) {
    case String:
      return'"' + obj.replace(/\"/g, '\\"').replace(/\r|\n|\f/g, "\\n") + '"';
    case Array:
      var buf = [];
      for(var i = 0;i < obj.length;i++) {
        buf.push(arguments.callee(obj[i]))
      }
      return"[" + buf.join(",") + "]";
    case Object:
      var buf2 = [];
      for(var k in obj) {
        if(obj.hasOwnProperty(k)) {
          buf2.push(arguments.callee(k) + ":" + arguments.callee(obj[k]))
        }
      }
      return"{" + buf2.join(",") + "}";
    default:
      return obj.toString()
  }
};
Json.prototype.$orderedEncode$ = function() {
  var toString = Object.prototype.toString;
  var isArray = Array.isArray || function(a) {
    return toString.call(a) === "[object Array]"
  };
  var escMap = {'"':'\\"', "\\":"\\\\", "\b":"\\b", "\f":"\\f", "\n":"\\n", "\r":"\\r", "\t":"\\t"};
  var escFunc = function(m) {
    return escMap[m] || "\\u" + (m.charCodeAt(0) + 65536).toString(16).substr(1)
  };
  var escRE = /[\\"\u0000-\u001F\u2028\u2029]/g;
  return function stringify(value) {
    if(value == null) {
      return"null"
    }else {
      if(typeof value === "number") {
        return isFinite(value) ? value.toString() : "null"
      }else {
        if(typeof value === "boolean") {
          return value.toString()
        }else {
          if(typeof value === "object") {
            if(typeof value.toJSON === "function") {
              return stringify(value.toJSON())
            }else {
              if(isArray(value)) {
                var res = "[";
                for(var i = 0;i < value.length;i++) {
                  res += (i ? ", " : "") + stringify(value[i])
                }
                return res + "]"
              }else {
                if(toString.call(value) === "[object Object]") {
                  var tmp = [];
                  var sortedKeys = Object.keys(value).sort();
                  var len = sortedKeys.length;
                  for(var j = 0;j < len;j++) {
                    var key = sortedKeys[j];
                    if(value[key] !== undefined) {
                      tmp.push(stringify(key) + ":" + stringify(value[key]))
                    }
                  }
                  return"{" + tmp.join(",") + "}"
                }
              }
            }
          }
        }
      }
    }
    return'"' + value.toString().replace(escRE, escFunc) + '"'
  }
}();
Json.prototype["encode"] = Json.prototype.$encode$;
(function(global) {
  function inRange(a, min, max) {
    return min <= a && a <= max
  }
  function includes(array, item) {
    return array.indexOf(item) !== -1
  }
  function ToDictionary(o) {
    if(o === undefined) {
      return{}
    }
    if(o === Object(o)) {
      return o
    }
    throw TypeError("Could not convert argument to dictionary");
  }
  function stringToCodePoints(string) {
    var s = String(string);
    var n = s.length;
    var i = 0;
    for(var u = [];i < n;) {
      var c = s.charCodeAt(i);
      if(c < 55296 || c > 57343) {
        u.push(c)
      }else {
        if(56320 <= c && c <= 57343) {
          u.push(65533)
        }else {
          if(55296 <= c && c <= 56319) {
            if(i === n - 1) {
              u.push(65533)
            }else {
              var d = string.charCodeAt(i + 1);
              if(56320 <= d && d <= 57343) {
                var a = c & 1023;
                var b = d & 1023;
                u.push(65536 + (a << 10) + b);
                i += 1
              }else {
                u.push(65533)
              }
            }
          }
        }
      }
      i += 1
    }
    return u
  }
  function codePointsToString(code_points) {
    var s = "";
    for(var i = 0;i < code_points.length;++i) {
      var cp = code_points[i];
      if(cp <= 65535) {
        s += String.fromCharCode(cp)
      }else {
        cp -= 65536;
        s += String.fromCharCode((cp >> 10) + 55296, (cp & 1023) + 56320)
      }
    }
    return s
  }
  function isASCIIByte(a) {
    return 0 <= a && a <= 127
  }
  function Stream(tokens) {
    this.$tokens$ = [].slice.call(tokens);
    this.$tokens$.reverse()
  }
  function decoderError(fatal, opt_code_point) {
    if(fatal) {
      throw TypeError("Decoder error");
    }
    return opt_code_point || 65533
  }
  function Decoder() {
  }
  function Encoder() {
  }
  function getEncoding(label) {
    label = String(label).trim().toLowerCase();
    if(Object.prototype.hasOwnProperty.call(label_to_encoding, label)) {
      return label_to_encoding[label]
    }
    return null
  }
  function TextDecoder(label, options) {
    if(!(this instanceof TextDecoder)) {
      throw TypeError("Called as a function. Did you forget 'new'?");
    }
    label = label !== undefined ? String(label) : DEFAULT_ENCODING;
    options = ToDictionary(options);
    this.$_encoding$ = null;
    this.$_decoder$ = null;
    this.$_ignoreBOM$ = false;
    this.$_BOMseen$ = false;
    this.$_error_mode$ = "replacement";
    this.$_do_not_flush$ = false;
    var encoding = getEncoding(label);
    if(encoding === null || encoding.name === "replacement") {
      throw RangeError("Unknown encoding: " + label);
    }
    if(!decoders[encoding.name]) {
      throw Error("Decoder not present." + " Did you forget to include encoding-indexes.js?");
    }
    var dec = this;
    dec.$_encoding$ = encoding;
    if(Boolean(options["fatal"])) {
      dec.$_error_mode$ = "fatal"
    }
    if(Boolean(options["ignoreBOM"])) {
      dec.$_ignoreBOM$ = true
    }
    if(!Object.defineProperty) {
      this.encoding = dec.$_encoding$.name.toLowerCase();
      this.$fatal$ = dec.$_error_mode$ === "fatal";
      this.$ignoreBOM$ = dec.$_ignoreBOM$
    }
    return dec
  }
  function TextEncoder(label, options) {
    if(!(this instanceof TextEncoder)) {
      throw TypeError("Called as a function. Did you forget 'new'?");
    }
    options = ToDictionary(options);
    this.$_encoding$ = null;
    this.$_encoder$ = null;
    this.$_do_not_flush$ = false;
    this.$_fatal$ = Boolean(options["fatal"]) ? "fatal" : "replacement";
    var enc = this;
    if(Boolean(options["NONSTANDARD_allowLegacyEncoding"])) {
      label = label !== undefined ? String(label) : DEFAULT_ENCODING;
      var encoding = getEncoding(label);
      if(encoding === null || encoding.name === "replacement") {
        throw RangeError("Unknown encoding: " + label);
      }
      if(!encoders[encoding.name]) {
        throw Error("Encoder not present." + " Did you forget to include encoding-indexes.js?");
      }
      enc.$_encoding$ = encoding
    }else {
      enc.$_encoding$ = getEncoding("utf-8");
      if(label !== undefined && "console" in global) {
        console.warn("TextEncoder constructor called with encoding label, " + "which is ignored.")
      }
    }
    if(!Object.defineProperty) {
      this.encoding = enc.$_encoding$.name.toLowerCase()
    }
    return enc
  }
  function UTF8Decoder(options) {
    var fatal = options.$fatal$;
    var utf8_code_point = 0;
    var utf8_bytes_seen = 0;
    var utf8_bytes_needed = 0;
    var utf8_lower_boundary = 128;
    var utf8_upper_boundary = 191;
    this.$handler$ = function(stream, bite) {
      if(bite === end_of_stream && utf8_bytes_needed !== 0) {
        utf8_bytes_needed = 0;
        return decoderError(fatal)
      }
      if(bite === end_of_stream) {
        return finished
      }
      if(utf8_bytes_needed === 0) {
        if(inRange(bite, 0, 127)) {
          return bite
        }
        if(inRange(bite, 194, 223)) {
          utf8_bytes_needed = 1;
          utf8_code_point = bite - 192
        }else {
          if(inRange(bite, 224, 239)) {
            if(bite === 224) {
              utf8_lower_boundary = 160
            }
            if(bite === 237) {
              utf8_upper_boundary = 159
            }
            utf8_bytes_needed = 2;
            utf8_code_point = bite - 224
          }else {
            if(inRange(bite, 240, 244)) {
              if(bite === 240) {
                utf8_lower_boundary = 144
              }
              if(bite === 244) {
                utf8_upper_boundary = 143
              }
              utf8_bytes_needed = 3;
              utf8_code_point = bite - 240
            }else {
              return decoderError(fatal)
            }
          }
        }
        utf8_code_point = utf8_code_point << 6 * utf8_bytes_needed;
        return null
      }
      if(!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {
        utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
        utf8_lower_boundary = 128;
        utf8_upper_boundary = 191;
        stream.$prepend$(bite);
        return decoderError(fatal)
      }
      utf8_lower_boundary = 128;
      utf8_upper_boundary = 191;
      utf8_bytes_seen += 1;
      utf8_code_point += bite - 128 << 6 * (utf8_bytes_needed - utf8_bytes_seen);
      if(utf8_bytes_seen !== utf8_bytes_needed) {
        return null
      }
      var code_point = utf8_code_point;
      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
      return code_point
    }
  }
  function UTF8Encoder(options) {
    var fatal = options.$fatal$;
    this.$handler$ = function(stream, code_point) {
      if(code_point === end_of_stream) {
        return finished
      }
      if(inRange(code_point, 0, 127)) {
        return code_point
      }
      var count;
      var offset;
      if(inRange(code_point, 128, 2047)) {
        count = 1;
        offset = 192
      }else {
        if(inRange(code_point, 2048, 65535)) {
          count = 2;
          offset = 224
        }else {
          if(inRange(code_point, 65536, 1114111)) {
            count = 3;
            offset = 240
          }
        }
      }
      for(var bytes = [(code_point >> 6 * count) + offset];count > 0;) {
        var temp = code_point >> 6 * (count - 1);
        bytes.push(128 | temp & 63);
        count -= 1
      }
      return bytes
    }
  }
  function convertCodeUnitToBytes(code_unit, utf16be) {
    var byte1 = code_unit >> 8;
    var byte2 = code_unit & 255;
    if(utf16be) {
      return[byte1, byte2]
    }
    return[byte2, byte1]
  }
  function UTF16Decoder(utf16_be, options) {
    var fatal = options.$fatal$;
    var utf16_lead_byte = null;
    var utf16_lead_surrogate = null;
    this.$handler$ = function(stream, bite) {
      if(bite === end_of_stream && (utf16_lead_byte !== null || utf16_lead_surrogate !== null)) {
        return decoderError(fatal)
      }
      if(bite === end_of_stream && utf16_lead_byte === null && utf16_lead_surrogate === null) {
        return finished
      }
      if(utf16_lead_byte === null) {
        utf16_lead_byte = bite;
        return null
      }
      var code_unit;
      if(utf16_be) {
        code_unit = (utf16_lead_byte << 8) + bite
      }else {
        code_unit = (bite << 8) + utf16_lead_byte
      }
      utf16_lead_byte = null;
      if(utf16_lead_surrogate !== null) {
        var lead_surrogate = utf16_lead_surrogate;
        utf16_lead_surrogate = null;
        if(inRange(code_unit, 56320, 57343)) {
          return 65536 + (lead_surrogate - 55296) * 1024 + (code_unit - 56320)
        }
        stream.$prepend$(convertCodeUnitToBytes(code_unit, utf16_be));
        return decoderError(fatal)
      }
      if(inRange(code_unit, 55296, 56319)) {
        utf16_lead_surrogate = code_unit;
        return null
      }
      if(inRange(code_unit, 56320, 57343)) {
        return decoderError(fatal)
      }
      return code_unit
    }
  }
  function UTF16Encoder(utf16_be, options) {
    var fatal = options.$fatal$;
    this.$handler$ = function(stream, code_point) {
      if(code_point === end_of_stream) {
        return finished
      }
      if(inRange(code_point, 0, 65535)) {
        return convertCodeUnitToBytes(code_point, utf16_be)
      }
      var lead = convertCodeUnitToBytes((code_point - 65536 >> 10) + 55296, utf16_be);
      var trail = convertCodeUnitToBytes((code_point - 65536 & 1023) + 56320, utf16_be);
      return lead.concat(trail)
    }
  }
  var end_of_stream = -1;
  Stream.prototype = {$endOfStream$:function() {
    return!this.$tokens$.length
  }, $read$:function() {
    if(!this.$tokens$.length) {
      return end_of_stream
    }
    return this.$tokens$.pop()
  }, $prepend$:function(token) {
    if(Array.isArray(token)) {
      for(var tokens = token;tokens.length;) {
        this.$tokens$.push(tokens.pop())
      }
    }else {
      this.$tokens$.push(token)
    }
  }, push:function(token) {
    if(Array.isArray(token)) {
      for(var tokens = token;tokens.length;) {
        this.$tokens$.unshift(tokens.shift())
      }
    }else {
      this.$tokens$.unshift(token)
    }
  }};
  var finished = -1;
  Decoder.prototype = {$handler$:function(stream, bite) {
  }};
  Encoder.prototype = {$handler$:function(stream, code_point) {
  }};
  var encodings = [{"encodings":[{"labels":["unicode-1-1-utf-8", "utf-8", "utf8"], "name":"UTF-8"}], "heading":"The Encoding"}, {"encodings":[{"labels":["utf-16be"], "name":"UTF-16BE"}, {"labels":["utf-16", "utf-16le"], "name":"UTF-16LE"}], "heading":"Legacy miscellaneous encodings"}];
  var label_to_encoding = {};
  encodings.forEach(function(category) {
    category["encodings"].forEach(function(encoding) {
      encoding["labels"].forEach(function(label) {
        label_to_encoding[label] = encoding
      })
    })
  });
  var encoders = {};
  var decoders = {};
  var DEFAULT_ENCODING = "utf-8";
  if(Object.defineProperty) {
    Object.defineProperty(TextDecoder.prototype, "encoding", {get:function() {
      return this.$_encoding$.name.toLowerCase()
    }});
    Object.defineProperty(TextDecoder.prototype, "fatal", {get:function() {
      return this.$_error_mode$ === "fatal"
    }});
    Object.defineProperty(TextDecoder.prototype, "ignoreBOM", {get:function() {
      return this.$_ignoreBOM$
    }})
  }
  TextDecoder.prototype.$decode$ = function decode(input, options) {
    function serializeStream(stream) {
      if(includes(["UTF-8", "UTF-16LE", "UTF-16BE"], this.$_encoding$.name) && !this.$_ignoreBOM$ && !this.$_BOMseen$) {
        if(stream.length > 0 && stream[0] === 65279) {
          this.$_BOMseen$ = true;
          stream.shift()
        }else {
          if(stream.length > 0) {
            this.$_BOMseen$ = true
          }else {
          }
        }
      }
      return codePointsToString(stream)
    }
    var bytes;
    if(typeof input === "object" && input instanceof ArrayBuffer) {
      bytes = new Uint8Array(input)
    }else {
      if(typeof input === "object" && "buffer" in input && input.buffer instanceof ArrayBuffer) {
        bytes = new Uint8Array(input.buffer, input.byteOffset, input.byteLength)
      }else {
        bytes = new Uint8Array(0)
      }
    }
    options = ToDictionary(options);
    if(!this.$_do_not_flush$) {
      this.$_decoder$ = decoders[this.$_encoding$.name]({$fatal$:this.$_error_mode$ === "fatal"});
      this.$_BOMseen$ = false
    }
    this.$_do_not_flush$ = Boolean(options["stream"]);
    var input_stream = new Stream(bytes);
    var output = [];
    for(var result;true;) {
      var token = input_stream.$read$();
      if(token === end_of_stream) {
        break
      }
      result = this.$_decoder$.$handler$(input_stream, token);
      if(result === finished) {
        break
      }
      if(result !== null) {
        if(Array.isArray(result)) {
          output.push.apply(output, result)
        }else {
          output.push(result)
        }
      }
    }
    if(!this.$_do_not_flush$) {
      do {
        result = this.$_decoder$.$handler$(input_stream, input_stream.$read$());
        if(result === finished) {
          break
        }
        if(result === null) {
          continue
        }
        if(Array.isArray(result)) {
          output.push.apply(output, result)
        }else {
          output.push(result)
        }
      }while(!input_stream.$endOfStream$());
      this.$_decoder$ = null
    }
    return serializeStream.call(this, output)
  };
  if(Object.defineProperty) {
    Object.defineProperty(TextEncoder.prototype, "encoding", {get:function() {
      return this.$_encoding$.name.toLowerCase()
    }})
  }
  TextEncoder.prototype.$encode$ = function encode(opt_string, options) {
    opt_string = opt_string ? String(opt_string) : "";
    options = ToDictionary(options);
    if(!this.$_do_not_flush$) {
      this.$_encoder$ = encoders[this.$_encoding$.name]({$fatal$:this.$_fatal$ === "fatal"})
    }
    this.$_do_not_flush$ = Boolean(options["stream"]);
    var input = new Stream(stringToCodePoints(opt_string));
    var output = [];
    for(var result;true;) {
      var token = input.$read$();
      if(token === end_of_stream) {
        break
      }
      result = this.$_encoder$.$handler$(input, token);
      if(result === finished) {
        break
      }
      if(Array.isArray(result)) {
        output.push.apply(output, result)
      }else {
        output.push(result)
      }
    }
    if(!this.$_do_not_flush$) {
      for(;true;) {
        result = this.$_encoder$.$handler$(input, input.$read$());
        if(result === finished) {
          break
        }
        if(Array.isArray(result)) {
          output.push.apply(output, result)
        }else {
          output.push(result)
        }
      }
      this.$_encoder$ = null
    }
    return new Uint8Array(output)
  };
  encoders["UTF-8"] = function(options) {
    return new UTF8Encoder(options)
  };
  decoders["UTF-8"] = function(options) {
    return new UTF8Decoder(options)
  };
  encoders["UTF-16BE"] = function(options) {
    return new UTF16Encoder(true, options)
  };
  decoders["UTF-16BE"] = function(options) {
    return new UTF16Decoder(true, options)
  };
  encoders["UTF-16LE"] = function(options) {
    return new UTF16Encoder(false, options)
  };
  decoders["UTF-16LE"] = function(options) {
    return new UTF16Decoder(false, options)
  };
  if(!global["TextEncoder"]) {
    TextEncoder.prototype["encode"] = TextEncoder.prototype.$encode$;
    global["TextEncoder"] = TextEncoder
  }
  if(!global["TextDecoder"]) {
    TextDecoder.prototype["decode"] = TextDecoder.prototype.$decode$;
    global["TextDecoder"] = TextDecoder
  }
})(window);
(function(root, factory) {
  root["StackFrame"] = factory()
})(this, function() {
  function _isNumber(n) {
    return!isNaN(parseFloat(n)) && isFinite(n)
  }
  function _capitalize(str) {
    return str[0].toUpperCase() + str.substring(1)
  }
  function _getter(p) {
    return function() {
      return this[p]
    }
  }
  function StackFrame(obj) {
    if(obj instanceof Object) {
      for(var i = 0;i < props.length;i++) {
        if(obj.hasOwnProperty(props[i]) && obj[props[i]] !== undefined) {
          this["set" + _capitalize(props[i])](obj[props[i]])
        }
      }
    }
  }
  var booleanProps = ["isConstructor", "isEval", "isNative", "isToplevel"];
  var numericProps = ["columnNumber", "lineNumber"];
  var stringProps = ["fileName", "functionName", "source"];
  var arrayProps = ["args"];
  var props = booleanProps.concat(numericProps, stringProps, arrayProps);
  StackFrame.prototype["getArgs"] = function() {
    return this.$args$
  };
  StackFrame.prototype["setArgs"] = function(v) {
    if(Object.prototype.toString.call(v) !== "[object Array]") {
      throw new TypeError("Args must be an Array");
    }
    this.$args$ = v
  };
  StackFrame.prototype["getEvalOrigin"] = function() {
    return this.$evalOrigin$
  };
  StackFrame.prototype["setEvalOrigin"] = function(v) {
    if(v instanceof StackFrame) {
      this.$evalOrigin$ = v
    }else {
      if(v instanceof Object) {
        this.$evalOrigin$ = new StackFrame(v)
      }else {
        throw new TypeError("Eval Origin must be an Object or StackFrame");
      }
    }
  };
  StackFrame.prototype.toString = function() {
    var functionName = this["getFunctionName"]() || "{anonymous}";
    var args = "(" + (this["getArgs"]() || []).join(",") + ")";
    var fileName = this["getFileName"]() ? "@" + this["getFileName"]() : "";
    var lineNumber = _isNumber(this["getLineNumber"]()) ? ":" + this["getLineNumber"]() : "";
    var columnNumber = _isNumber(this["getColumnNumber"]()) ? ":" + this["getColumnNumber"]() : "";
    return functionName + args + fileName + lineNumber + columnNumber
  };
  for(var i$$0 = 0;i$$0 < booleanProps.length;i$$0++) {
    StackFrame.prototype["get" + _capitalize(booleanProps[i$$0])] = _getter(booleanProps[i$$0]);
    StackFrame.prototype["set" + _capitalize(booleanProps[i$$0])] = function(p) {
      return function(v) {
        this[p] = Boolean(v)
      }
    }(booleanProps[i$$0])
  }
  for(var j = 0;j < numericProps.length;j++) {
    StackFrame.prototype["get" + _capitalize(numericProps[j])] = _getter(numericProps[j]);
    StackFrame.prototype["set" + _capitalize(numericProps[j])] = function(p) {
      return function(v) {
        if(!_isNumber(v)) {
          throw new TypeError(p + " must be a Number");
        }
        this[p] = Number(v)
      }
    }(numericProps[j])
  }
  for(var k = 0;k < stringProps.length;k++) {
    StackFrame.prototype["get" + _capitalize(stringProps[k])] = _getter(stringProps[k]);
    StackFrame.prototype["set" + _capitalize(stringProps[k])] = function(p) {
      return function(v) {
        this[p] = String(v)
      }
    }(stringProps[k])
  }
  return StackFrame
});
Aura.$Errors$.$StackFrame$ = this["StackFrame"];
(function(root, factory) {
  root["ErrorStackParser"] = factory(root["StackFrame"])
})(this, function ErrorStackParser(StackFrame) {
  function _map(array, fn, thisArg) {
    if(typeof Array.prototype.map === "function") {
      return array.map(fn, thisArg)
    }else {
      var output = new Array(array.length);
      for(var i = 0;i < array.length;i++) {
        output[i] = fn.call(thisArg, array[i])
      }
      return output
    }
  }
  function _filter(array, fn, thisArg) {
    if(typeof Array.prototype.filter === "function") {
      return array.filter(fn, thisArg)
    }else {
      var output = [];
      for(var i = 0;i < array.length;i++) {
        if(fn.call(thisArg, array[i])) {
          output.push(array[i])
        }
      }
      return output
    }
  }
  function _indexOf(array, target) {
    if(typeof Array.prototype.indexOf === "function") {
      return array.indexOf(target)
    }else {
      for(var i = 0;i < array.length;i++) {
        if(array[i] === target) {
          return i
        }
      }
      return-1
    }
  }
  var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+\:\d+/;
  var CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+\:\d+|\(native\))/m;
  var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code\])?$/;
  return{parse:function ErrorStackParser(error) {
    if(typeof error.$stacktrace$ !== "undefined" || typeof error["opera#sourceloc"] !== "undefined") {
      return this.$parseOpera$(error)
    }else {
      if(error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {
        return this.$parseV8OrIE$(error)
      }else {
        if(error.stack) {
          return this.$parseFFOrSafari$(error)
        }else {
          return[]
        }
      }
    }
  }, $extractLocation$:function ErrorStackParser(urlLike) {
    if(urlLike.indexOf(":") === -1) {
      return[urlLike]
    }
    var regExp = /(.+?)(?:\:(\d+))?(?:\:(\d+))?$/;
    var parts = regExp.exec(urlLike.replace(/[\(\)]/g, ""));
    return[parts[1], parts[2] || undefined, parts[3] || undefined]
  }, $parseV8OrIE$:function ErrorStackParser(error) {
    var filtered = _filter(error.stack.split("\n"), function(line) {
      return!!line.match(CHROME_IE_STACK_REGEXP)
    }, this);
    return _map(filtered, function(line) {
      if(line.indexOf("(eval ") > -1) {
        line = line.replace(/eval code/g, "eval").replace(/(\(eval at [^\()]*)|(\)\,.*$)/g, "")
      }
      var tokens = line.replace(/^\s+/, "").replace(/\(eval code/g, "(").split(/\s+/).slice(1);
      var locationParts = this.$extractLocation$(tokens.pop());
      var functionName = tokens.join(" ") || undefined;
      var fileName = _indexOf(["eval", "\x3canonymous\x3e"], locationParts[0]) > -1 ? undefined : locationParts[0];
      return new StackFrame({functionName:functionName, $args$:undefined, fileName:fileName, lineNumber:locationParts[1], columnNumber:locationParts[2], source:line})
    }, this)
  }, $parseFFOrSafari$:function ErrorStackParser(error) {
    var filtered = _filter(error.stack.split("\n"), function(line) {
      return!line.match(SAFARI_NATIVE_CODE_REGEXP)
    }, this);
    return _map(filtered, function(line) {
      if(line.indexOf(" \x3e eval") > -1) {
        line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval\:\d+\:\d+/g, ":$1")
      }
      if(line.indexOf("@") === -1 && line.indexOf(":") === -1) {
        return new StackFrame({functionName:line})
      }else {
        var tokens = line.split("@");
        var locationParts = this.$extractLocation$(tokens.pop());
        var functionName = tokens.join("@") || undefined;
        return new StackFrame({functionName:functionName, $args$:undefined, fileName:locationParts[0], lineNumber:locationParts[1], columnNumber:locationParts[2], source:line})
      }
    }, this)
  }, $parseOpera$:function ErrorStackParser(e) {
    if(!e.$stacktrace$ || e.message.indexOf("\n") > -1 && e.message.split("\n").length > e.$stacktrace$.split("\n").length) {
      return this.$parseOpera9$(e)
    }else {
      if(!e.stack) {
        return this.$parseOpera10$(e)
      }else {
        return this.$parseOpera11$(e)
      }
    }
  }, $parseOpera9$:function ErrorStackParser(e) {
    var lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
    var lines = e.message.split("\n");
    var result = [];
    var i = 2;
    for(var len = lines.length;i < len;i += 2) {
      var match = lineRE.exec(lines[i]);
      if(match) {
        result.push(new StackFrame({functionName:undefined, $args$:undefined, fileName:match[2], lineNumber:match[1], columnNumber:undefined, source:lines[i]}))
      }
    }
    return result
  }, $parseOpera10$:function ErrorStackParser(e) {
    var lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
    var lines = e.$stacktrace$.split("\n");
    var result = [];
    var i = 0;
    for(var len = lines.length;i < len;i += 2) {
      var match = lineRE.exec(lines[i]);
      if(match) {
        result.push(new StackFrame({functionName:match[3] || undefined, $args$:undefined, fileName:match[2], lineNumber:match[1], columnNumber:undefined, source:lines[i]}))
      }
    }
    return result
  }, $parseOpera11$:function ErrorStackParser(error) {
    var filtered = _filter(error.stack.split("\n"), function(line) {
      return!!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/)
    }, this);
    return _map(filtered, function(line) {
      var tokens = line.split("@");
      var locationParts = this.$extractLocation$(tokens.pop());
      var functionCall = tokens.shift() || "";
      var functionName = functionCall.replace(/<anonymous function(: (\w+))?>/, "$2").replace(/\([^\)]*\)/g, "") || undefined;
      var argsRaw;
      if(functionCall.match(/\(([^\)]*)\)/)) {
        argsRaw = functionCall.replace(/^[^\(]+\(([^\)]*)\)$/, "$1")
      }
      var args = argsRaw === undefined || argsRaw === "[arguments not available]" ? undefined : argsRaw.split(",");
      return new StackFrame({functionName:functionName, $args$:args, fileName:locationParts[0], lineNumber:locationParts[1], columnNumber:locationParts[2], source:line})
    }, this)
  }}
});
Aura.$Errors$.$StackParser$ = this["ErrorStackParser"];
var goog = {};
goog.global = this;
goog.$exportProperty$ = function(object, publicName, symbol) {
  object[publicName] = symbol
};
goog.$exportSymbol$ = function(publicPath, opt_object, opt_objectToExportTo) {
  var parts = publicPath.split(".");
  var cur = opt_objectToExportTo || goog.global;
  for(var part = parts.shift();part;part = parts.shift()) {
    if(!parts.length && opt_object !== undefined) {
      cur[part] = opt_object
    }else {
      if(cur[part]) {
        cur = cur[part]
      }else {
        cur = cur[part] = {}
      }
    }
  }
};
Aura.$Context$.$AuraContext$ = function AuraContext(config, initCallback) {
  this.mode = config["mode"];
  this.loaded = config["loaded"];
  if(this.loaded === undefined) {
    this.loaded = {}
  }
  this.$loadedOriginal$ = $A["util"].apply({}, this.loaded);
  this.$fwuid$ = config["fwuid"];
  this.$pathPrefix$ = config["pathPrefix"];
  this.$moduleServices$ = config["services"];
  this.$num$ = 0;
  this.$scriptNonce$ = config["scriptNonce"];
  this.$renderNum$ = 0;
  this.transaction = 0;
  this.$transactionName$ = "";
  this.$lastGlobalId$ = 0;
  this.$componentConfigs$ = {};
  this.$app$ = config["app"];
  this.$cmp$ = config["cmp"];
  this.test = config["test"];
  this.$contextPath$ = config["contextPath"] || "";
  this.$allowedGlobals$ = config["allowedGlobals"];
  this.$globals$ = config["globals"];
  this.$tokens$ = {};
  this.$isModulesEnabled$ = !!config["m"];
  this.$useCompatSource$ = !!config["c"];
  this.$moduleNamespaceAliases$ = config["mna"] || {};
  this.$actionPublicCachingEnabled$ = !!config["apce"];
	this.$lightningOut$ = !!config["lightningOut"];
  if(this.$actionPublicCachingEnabled$) {
    this.$actionPublicCacheKey$ = config["apck"]
  }
  var that = this;
  this.$initGlobalValueProviders$(config["globalValueProviders"], function(gvps) {
    var i;
    var defs;
    that.$globalValueProviders$ = gvps;
    that.$contextGlobals$ = that.$globalValueProviders$.$getValueProvider$("Global");
    that.$currentAction$ = new Action(null, "" + that.$num$, null, null, false, null, false);
    if(config["libraryDefs"]) {
      defs = config["libraryDefs"];
      for(i = 0;i < defs.length;i++) {
        $A.$componentService$.$saveLibraryConfig$(defs[i])
      }
    }
    if(config["componentDefs"]) {
      defs = config["componentDefs"];
      for(i = 0;i < defs.length;i++) {
        if(defs[i]["descriptor"]) {
          $A.$componentService$.$saveComponentConfig$(defs[i])
        }
      }
    }
    if(config["eventDefs"]) {
      defs = config["eventDefs"];
      for(i = 0;i < defs.length;i++) {
        $A.$eventService$.$saveEventConfig$(defs[i])
      }
    }
    that.$joinComponentConfigs$(config["components"], that.$currentAction$.$getId$());
    if(initCallback) {
      initCallback(that)
    }
  })
};
goog.$exportSymbol$("Aura.Context.AuraContext", Aura.$Context$.$AuraContext$);
Aura.$Context$.$AuraContext$.$CLIENT_SESSION_ID$ = [window.$pageStartTime$, Math.round(Aura.time() * 1E6), Math.random().toString(16).substr(2)].join("").substring(0, 32);
Aura.$Context$.$AuraContext$.prototype.$initGlobalValueProviders$ = function(gvps, callback) {
  if($A["util"].isArray(gvps)) {
    var map = {};
    for(var i = 0;i < gvps.length;i++) {
      var gvp = gvps[i];
      var type = gvp["type"];
      var values = gvp["values"];
      map[type] = values
    }
    gvps = map
  }
  if(!gvps) {
    gvps = {}
  }
  $A["util"].$applyNotFromPrototype$(gvps, $A.$globalValueProviders$);
  this.$globalValueProviders$ = new Aura.$Provider$.$GlobalValueProviders$(gvps, callback)
};
goog.$exportProperty$(Aura.$Context$.$AuraContext$.prototype, "initGlobalValueProviders", Aura.$Context$.$AuraContext$.prototype.$initGlobalValueProviders$);
Aura.$Context$.$AuraContext$.prototype.$getMode$ = function() {
  return this.mode
};
goog.$exportProperty$(Aura.$Context$.$AuraContext$.prototype, "getMode", Aura.$Context$.$AuraContext$.prototype.$getMode$);
Aura.$Context$.$AuraContext$.prototype.$getTokens$ = function() {
  return this.$tokens$
};
Aura.$Context$.$AuraContext$.prototype.$setTokens$ = function(tokens) {
  this.$tokens$ = tokens
};
Aura.$Context$.$AuraContext$.prototype.$addGlobalValueProvider$ = function(type, valueProvider) {
  this.$globalValueProviders$.$addValueProvider$(type, valueProvider)
};
Aura.$Context$.$AuraContext$.prototype.$getGlobalValueProvider$ = function(type) {
  return this.$globalValueProviders$.$getValueProvider$(type)
};
Aura.$Context$.$AuraContext$.prototype.$encodeForServer$ = function(includeDynamic, includeCacheKeyForCacheableXHR) {
  var contextToSend = {"mode":this.mode, "fwuid":this.$fwuid$};
  if(this.$app$) {
    contextToSend["app"] = this.$app$
  }else {
    contextToSend["cmp"] = this.$cmp$
  }
  if(this.test) {
    contextToSend["test"] = this.test
  }
  if(includeDynamic) {
    contextToSend["loaded"] = this.loaded;
    contextToSend["dn"] = $A.$services$.$component$.$getDynamicNamespaces$();
    contextToSend["globals"] = this.$globalValueProviders$.$getValueProvider$("$Global").$serializeForServer$()
  }else {
    contextToSend["loaded"] = this.$loadedOriginal$
  }
  if(includeCacheKeyForCacheableXHR) {
    contextToSend["apck"] = this.$actionPublicCacheKey$
  }
  if(this.$isModulesEnabled$) {
    contextToSend["m"] = 1
  }
  if(this.$useCompatSource$) {
    contextToSend["c"] = 1
  }
  return $A["util"].$json$.$encode$(contextToSend)
};
Aura.$Context$.$AuraContext$.prototype.$merge$ = function(otherContext) {
  var i;
  var defs;
  if(otherContext["mode"] !== this.$getMode$()) {
    throw new $A.$auraError$("[Mode mismatch] Expected '" + this.$getMode$() + "' instead tried to merge mode '" + otherContext["mode"] + "'", null, $A.severity.$QUIET$);
  }
  if($A["util"].$isUndefinedOrNull$(this.$fwuid$)) {
    this.$fwuid$ = otherContext["fwuid"]
  }
  if(otherContext["fwuid"] !== this.$fwuid$) {
    throw new $A.$auraError$("framework mismatch", null, $A.severity.$QUIET$);
  }
  $A.$clientService$.$enableAccessChecks$ = otherContext["enableAccessChecks"];
  this.$moduleServices$ = otherContext["services"];
  try {
    this.$globalValueProviders$.$merge$(otherContext["globalValueProviders"])
  }finally {
    if(otherContext["libraryDefs"]) {
      defs = otherContext["libraryDefs"];
      for(i = 0;i < defs.length;i++) {
        $A.$componentService$.$saveLibraryConfig$(defs[i])
      }
    }
    if(otherContext["componentDefs"]) {
      defs = otherContext["componentDefs"];
      for(i = 0;i < defs.length;i++) {
        if(defs[i]["descriptor"]) {
          $A.$componentService$.$saveComponentConfig$(defs[i])
        }
      }
    }
    if(otherContext["eventDefs"]) {
      defs = otherContext["eventDefs"];
      for(i = 0;i < defs.length;i++) {
        $A.$eventService$.$saveEventConfig$(defs[i])
      }
    }
    if(otherContext["moduleDefs"]) {
      $A.$componentService$.$initModuleDefs$(otherContext["moduleDefs"])
    }
    this.$joinComponentConfigs$(otherContext["components"], "" + this.$getNum$());
    this.$joinLoaded$(otherContext["loaded"])
  }
};
goog.$exportProperty$(Aura.$Context$.$AuraContext$.prototype, "merge", Aura.$Context$.$AuraContext$.prototype.$merge$);
Aura.$Context$.$AuraContext$.prototype.$getNum$ = function() {
  return this.$num$
};
goog.$exportProperty$(Aura.$Context$.$AuraContext$.prototype, "getNum", Aura.$Context$.$AuraContext$.prototype.$getNum$);
Aura.$Context$.$AuraContext$.prototype.$incrementNum$ = function() {
  this.$num$ = this.$num$ + 1;
  this.$lastGlobalId$ = 0;
  return this.$num$
};
Aura.$Context$.$AuraContext$.prototype.$incrementRender$ = function() {
  this.$renderNum$ = this.$renderNum$ + 1;
  return this.$renderNum$
};
Aura.$Context$.$AuraContext$.prototype.$incrementTransaction$ = function() {
  this.transaction = this.transaction + 1;
  return this.transaction
};
goog.$exportProperty$(Aura.$Context$.$AuraContext$.prototype, "incrementTransaction", Aura.$Context$.$AuraContext$.prototype.$incrementTransaction$);
Aura.$Context$.$AuraContext$.prototype.$getTransaction$ = function() {
  return this.transaction
};
Aura.$Context$.$AuraContext$.prototype.$updateTransactionName$ = function(_transactionName) {
  if(_transactionName) {
    this.$transactionName$ = this.$trasactionName$ !== "" ? this.$transactionName$ + "-" + _transactionName : _transactionName
  }
};
Aura.$Context$.$AuraContext$.prototype.$getTransactionName$ = function() {
  return this.$transactionName$
};
Aura.$Context$.$AuraContext$.prototype.$clearTransactionName$ = function() {
  this.$transactionName$ = ""
};
Aura.$Context$.$AuraContext$.prototype.$getNextGlobalId$ = function() {
  this.$lastGlobalId$ = this.$lastGlobalId$ + 1;
  return this.$lastGlobalId$
};
Aura.$Context$.$AuraContext$.prototype.$containsComponentConfig$ = function(creationPath) {
  return this.$componentConfigs$.hasOwnProperty(creationPath)
};
Aura.$Context$.$AuraContext$.prototype.$getComponentConfig$ = function(creationPath) {
  var componentConfigs = this.$componentConfigs$;
  var ret = componentConfigs[creationPath];
  return ret
};
Aura.$Context$.$AuraContext$.prototype.$removeComponentConfig$ = function(creationPath) {
  if(creationPath in this.$componentConfigs$) {
    delete this.$componentConfigs$[creationPath]
  }
};
Aura.$Context$.$AuraContext$.prototype.$getApp$ = function() {
  return this.$app$
};
goog.$exportProperty$(Aura.$Context$.$AuraContext$.prototype, "getApp", Aura.$Context$.$AuraContext$.prototype.$getApp$);
Aura.$Context$.$AuraContext$.prototype.$joinComponentConfigs$ = function(otherComponentConfigs, actionId) {
  var cP;
  var idx;
  var config;
  var def;
  if(otherComponentConfigs) {
    for(idx = 0;idx < otherComponentConfigs.length;idx++) {
      config = otherComponentConfigs[idx];
      def = config["componentDef"];
      if(def && def["descriptor"]) {
        $A.$componentService$.$saveComponentConfig$(def)
      }
      cP = config["creationPath"];
      this.$componentConfigs$[actionId + cP] = config
    }
  }
};
Aura.$Context$.$AuraContext$.prototype.$internalClear$ = function(actionId, logit) {
  var count = 0;
  var removed = 0;
  var error = "";
  var prefix = actionId + "/";
  var len = prefix.length;
  var ccs = this.$componentConfigs$;
  for(var k in ccs) {
    if(ccs.hasOwnProperty(k) && (k === actionId || k.substr(0, len) === prefix)) {
      removed += 1;
      if(logit) {
        $A.log("config not consumed: " + k, ccs[k]);
        delete ccs[k];
        if(error !== "") {
          error = error + ", "
        }
        error = error + k
      }
    }else {
      count += 1
    }
  }
  if(error !== "") {
    $A.$warning$("unused configs for " + actionId + ": " + error)
  }
  if(count === 0) {
    this.$componentConfigs$ = {}
  }else {
    if(logit) {
      $A.log("leftover configs ", ccs);
      throw new $A.$auraError$("leftover configs", null, $A.severity.$QUIET$);
    }
  }
  return removed
};
Aura.$Context$.$AuraContext$.prototype.$finishComponentConfigs$ = function(actionId) {
  this.$internalClear$(actionId, true)
};
Aura.$Context$.$AuraContext$.prototype.$clearComponentConfigs$ = function(actionId) {
  return this.$internalClear$(actionId, false)
};
goog.$exportProperty$(Aura.$Context$.$AuraContext$.prototype, "clearComponentConfigs", Aura.$Context$.$AuraContext$.prototype.$clearComponentConfigs$);
Aura.$Context$.$AuraContext$.prototype.$joinLoaded$ = function(loaded) {
  if(this.loaded === undefined) {
    this.loaded = {}
  }
  if(loaded) {
    for(var i in loaded) {
      if(loaded.hasOwnProperty(i) && !$A["util"].$isFunction$(i)) {
        var newL = loaded[i];
        if(newL === "deleted") {
          delete this.loaded[i]
        }else {
          this.loaded[i] = newL
        }
      }
    }
  }
};
Aura.$Context$.$AuraContext$.prototype.$addLoaded$ = function(pair) {
  if(pair && !this.loaded[pair["key"]]) {
    this.loaded[pair["key"]] = pair["value"]
  }
};
Aura.$Context$.$AuraContext$.prototype.$findLoaded$ = function(descriptor, loaded) {
  var cmpDescriptor = "COMPONENT@" + descriptor;
  var appDescriptor = "APPLICATION@" + descriptor;
  loaded = loaded || this.loaded;
  if(loaded[cmpDescriptor]) {
    return{"key":cmpDescriptor, "value":loaded[cmpDescriptor]}
  }else {
    if(loaded[appDescriptor]) {
      return{"key":appDescriptor, "value":loaded[appDescriptor]}
    }
  }
  return null
};
Aura.$Context$.$AuraContext$.prototype.$getLoaded$ = function() {
  return this.loaded
};
goog.$exportProperty$(Aura.$Context$.$AuraContext$.prototype, "getLoaded", Aura.$Context$.$AuraContext$.prototype.$getLoaded$);
Aura.$Context$.$AuraContext$.prototype.$resetLoaded$ = function() {
  this.loaded = $A["util"].apply({}, this.$loadedOriginal$)
};
Aura.$Context$.$AuraContext$.prototype.$setCurrentAction$ = function(action) {
  var previous = this.$currentAction$;
  this.$currentAction$ = action;
  return previous
};
goog.$exportProperty$(Aura.$Context$.$AuraContext$.prototype, "setCurrentAction", Aura.$Context$.$AuraContext$.prototype.$setCurrentAction$);
Aura.$Context$.$AuraContext$.prototype.$getCurrentAction$ = function() {
  return this.$currentAction$
};
goog.$exportProperty$(Aura.$Context$.$AuraContext$.prototype, "getCurrentAction", Aura.$Context$.$AuraContext$.prototype.$getCurrentAction$);
Aura.$Context$.$AuraContext$.prototype.$getPathPrefix$ = function() {
  return this.$pathPrefix$
};
goog.$exportProperty$(Aura.$Context$.$AuraContext$.prototype, "getPathPrefix", Aura.$Context$.$AuraContext$.prototype.$getPathPrefix$);
Aura.$Context$.$AuraContext$.prototype.$getContextPath$ = function() {
  return this.$contextPath$
};
goog.$exportProperty$(Aura.$Context$.$AuraContext$.prototype, "getContextPath", Aura.$Context$.$AuraContext$.prototype.$getContextPath$);
Aura.$Context$.$AuraContext$.prototype.$setContextPath$ = function(path) {
  this.$contextPath$ = path
};
goog.$exportProperty$(Aura.$Context$.$AuraContext$.prototype, "setContextPath", Aura.$Context$.$AuraContext$.prototype.$setContextPath$);
Aura.$Context$.$AuraContext$.prototype.$isActionPublicCachingEnabled$ = function() {
  return this.$actionPublicCachingEnabled$
};
goog.$exportProperty$(Aura.$Context$.$AuraContext$.prototype, "isActionPublicCachingEnabled", Aura.$Context$.$AuraContext$.prototype.$isActionPublicCachingEnabled$);
Aura.$Context$.$AuraContext$.prototype.$getActionPublicCacheKey$ = function() {
  return this.$actionPublicCacheKey$
};
goog.$exportProperty$(Aura.$Context$.$AuraContext$.prototype, "getActionPublicCacheKey", Aura.$Context$.$AuraContext$.prototype.$getActionPublicCacheKey$);
Aura.$Context$.$AuraContext$.prototype.$isCompat$ = function() {
  return this.$useCompatSource$
};
Aura.$Utils$.$Style$ = function Style() {
  this.head = null
};
goog.$exportSymbol$("Aura.Utils.Style", Aura.$Utils$.$Style$);
Aura.$Utils$.$Style$.prototype.$getHead$ = function() {
  var ret = this.head;
  if(!ret) {
    this.head = document.getElementsByTagName("head")[0];
    ret = this.head
  }
  return ret
};
Aura.$Utils$.$Style$.prototype.apply = function(styleText) {
  var styleElement = document.createElement("style");
  styleElement.setAttribute("type", "text/css");
  if(styleElement.styleSheet) {
    styleElement.styleSheet.cssText = styleText
  }else {
    if(styleElement.textContent !== undefined) {
      styleElement.textContent = styleText
    }else {
      if(styleElement.innerText !== undefined) {
        styleElement.innerText = styleText
      }else {
        styleElement.innerHTML = styleText
      }
    }
  }
  this.$getHead$().appendChild(styleElement);
  return styleElement
};
Aura.$Utils$.$Style$.prototype.$include$ = function(href) {
  var styleElement = document.createElement("link");
  styleElement.setAttribute("href", href);
  styleElement.setAttribute("rel", "stylesheet");
  styleElement.setAttribute("type", "text/css");
  this.$getHead$().appendChild(styleElement);
  return styleElement
};
goog.$exportProperty$(Aura.$Utils$.$Style$.prototype, "include", Aura.$Utils$.$Style$.prototype.$include$);
Aura.$Utils$.$Style$.prototype.$getCSSProperty$ = function(el, cssprop) {
  if(window.getComputedStyle) {
    var style = window.getComputedStyle(el);
    return style && style.getPropertyValue(cssprop)
  }
  return el.currentStyle && el.currentStyle[cssprop]
};
goog.$exportProperty$(Aura.$Utils$.$Style$.prototype, "getCSSProperty", Aura.$Utils$.$Style$.prototype.$getCSSProperty$);
Aura.$Utils$.$Bitset$ = function Bitset(str) {
  if(typeof str !== "string") {
    str = ""
  }
  Aura.$Utils$.$Bitset$.$init$();
  this.data = str.split("");
  this.trim()
};
goog.$exportSymbol$("Aura.Utils.Bitset", Aura.$Utils$.$Bitset$);
Aura.$Utils$.$Bitset$.prototype.$testBit$ = function(n) {
  var i = Math.floor(n / 6);
  if(i >= this.data.length) {
    return false
  }else {
    return(Aura.$Utils$.$Bitset$.$codes$[this.data[i]] & 32 >> n % 6) !== 0
  }
};
goog.$exportProperty$(Aura.$Utils$.$Bitset$.prototype, "testBit", Aura.$Utils$.$Bitset$.prototype.$testBit$);
Aura.$Utils$.$Bitset$.prototype.$setBit$ = function(n) {
  var i = Math.floor(n / 6);
  this.$pad$(i);
  this.data[i] = Aura.$Utils$.$Bitset$.$alphabet$[Aura.$Utils$.$Bitset$.$codes$[this.data[i]] | 32 >> n % 6]
};
Aura.$Utils$.$Bitset$.prototype.$clearBit$ = function(n) {
  var i = Math.floor(n / 6);
  if(i < this.data.length) {
    this.data[i] = Aura.$Utils$.$Bitset$.$alphabet$[Aura.$Utils$.$Bitset$.$codes$[this.data[i]] & (255 ^ 32 >> n % 6)];
    this.trim()
  }
};
Aura.$Utils$.$Bitset$.prototype.toString = function() {
  return this.data.join("")
};
Aura.$Utils$.$Bitset$.prototype.trim = function() {
  for(var i = this.data.length - 1;i >= 0;i--) {
    if(this.data[i] !== Aura.$Utils$.$Bitset$.$alphabet$[0]) {
      break
    }
  }
  this.data.splice(i + 1, this.data.length)
};
Aura.$Utils$.$Bitset$.prototype.$pad$ = function(n) {
  var size = this.data.length;
  for(var i = 0;i <= n - size;i++) {
    this.data.push(Aura.$Utils$.$Bitset$.$alphabet$[0])
  }
};
Aura.$Utils$.$Bitset$.prototype.length = function() {
  return this.data.length
};
Aura.$Utils$.$Bitset$.$initialized$ = false;
Aura.$Utils$.$Bitset$.$init$ = function() {
  if(!Aura.$Utils$.$Bitset$.$initialized$) {
    Aura.$Utils$.$Bitset$.$initialized$ = true;
    Aura.$Utils$.$Bitset$.$alphabet$ = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+", "/"];
    Aura.$Utils$.$Bitset$.$codes$ = [];
    for(var i = 0;i < Aura.$Utils$.$Bitset$.$alphabet$.length;i++) {
      Aura.$Utils$.$Bitset$.$codes$[Aura.$Utils$.$Bitset$.$alphabet$[i]] = i
    }
  }
};
Aura.$Utils$.$NumberFormat$ = function NumberFormat(format, symbols) {
  this.$originalFormat$ = format;
  this.$symbols$ = symbols || {"decimalSeparator":$A.get("$Locale.decimal"), "groupingSeparator":$A.get("$Locale.grouping"), "currency":$A.get("$Locale.currency"), "currencyCode":$A.get("$Locale.currencyCode"), "zeroDigit":$A.get("$Locale.zero")};
  this.$zeroCharCodeOffset$ = this.$symbols$["zeroDigit"].charCodeAt(0) - Aura.$Utils$.$NumberFormat$.ZERO.charCodeAt(0);
  this.$hasCurrency$ = false;
  this.$multiplier$ = 0;
  this.$minDigits$ = 1;
  this.$groupingDigits$ = -1;
  this.$minFractionDigits$ = 0;
  this.$maxFractionDigits$ = 0;
  this.prefix = null;
  this.$suffix$ = null;
  this.$hasNegativePattern$ = false;
  this.$negativePrefix$ = null;
  this.$negativeSuffix$ = null;
  var parsePhase = 0;
  var prefixEnd = 0;
  var suffixStart = format.length;
  var zeros = 0;
  var leftNumber = false;
  var rightNumbers = 0;
  var group = -1;
  var decimal = false;
  var posPattern;
  var negPattern;
  var split = format.indexOf(";");
  if(split !== -1) {
    posPattern = format.substring(0, split);
    negPattern = format.substring(split + 1)
  }else {
    posPattern = format
  }
  for(var i = 0;i < posPattern.length;i++) {
    var c = posPattern.charAt(i);
    switch(parsePhase) {
      case 0:
        if(c === "#" || c === Aura.$Utils$.$NumberFormat$.ZERO || c === "." || c === ",") {
          parsePhase = 1;
          prefixEnd = i;
          i--;
          continue
        }else {
          this.$checkForSpecialChar$(c)
        }
        break;
      case 1:
        switch(c) {
          case "#":
            if(zeros > 0 || decimal) {
              rightNumbers++
            }else {
              leftNumber = true
            }
            if(group >= 0 && !decimal) {
              group++
            }
            break;
          case Aura.$Utils$.$NumberFormat$.ZERO:
            if(rightNumbers > 0) {
              this.parseError("'0's must be sequential")
            }
            zeros++;
            if(group >= 0 && !decimal) {
              group++
            }
            break;
          case ",":
            if(!leftNumber && !zeros) {
              this.parseError("there must be a number before the grouping separator")
            }
            if(decimal) {
              this.parseError("grouping separator found after the decimal separator")
            }
            group = 0;
            break;
          case ".":
            if(decimal) {
              this.parseError("too many decimal separators")
            }
            this.$minDigits$ = zeros;
            zeros = 0;
            decimal = true;
            break;
          default:
            suffixStart = i--;
            parsePhase = 2;
            continue
        }
        break;
      case 2:
        this.$checkForSpecialChar$(c);
        break
    }
  }
  if(group === 0) {
    this.parseError("grouping cannot be 0")
  }
  this.$groupingDigits$ = group;
  if(!decimal) {
    this.$minDigits$ = zeros;
    this.$minFractionDigits$ = 0;
    this.$maxFractionDigits$ = 0
  }else {
    this.$minFractionDigits$ = zeros;
    this.$maxFractionDigits$ = this.$minFractionDigits$ + rightNumbers
  }
  if(this.$minDigits$ === this.$minFractionDigits$ === 0) {
    this.$minDigits$ = 1
  }
  var innerPattern = posPattern;
  if(prefixEnd) {
    this.prefix = posPattern.substring(0, prefixEnd);
    innerPattern = innerPattern.substring(prefixEnd)
  }
  if(suffixStart < posPattern.length) {
    this.$suffix$ = posPattern.substring(suffixStart);
    innerPattern = innerPattern.substring(0, suffixStart)
  }
  if(negPattern) {
    this.$hasNegativePattern$ = true;
    var inner = negPattern.indexOf(innerPattern);
    if(inner === -1) {
      this.parseError("negative pattern doesn't contain identical number format")
    }
    if(inner !== 0) {
      this.$negativePrefix$ = negPattern.substring(0, inner)
    }
    if(inner + innerPattern.length < negPattern.length) {
      this.$negativeSuffix$ = negPattern.substring(inner + innerPattern.length)
    }
  }
  this.$replaceCurrencies$()
};
goog.$exportSymbol$("Aura.Utils.NumberFormat", Aura.$Utils$.$NumberFormat$);
Aura.$Utils$.$NumberFormat$.ZERO = "0";
Aura.$Utils$.$NumberFormat$.prototype.parseError = function(s) {
  throw new Error("Invalid pattern: " + this.$originalFormat$ + "\n" + s);
};
Aura.$Utils$.$NumberFormat$.prototype.$checkForSpecialChar$ = function(c) {
  var mult;
  switch(c) {
    case "\u00a4":
      this.$hasCurrency$ = true;
      break;
    case "%":
      mult = 2;
      break;
    case "\u2030":
      mult = 3;
      break;
    case "\u2031":
      mult = 4;
      break
  }
  if(mult) {
    if(this.$multiplier$ !== 0) {
      this.parseError("too many percentage symbols")
    }else {
      this.$multiplier$ = mult
    }
  }
};
Aura.$Utils$.$NumberFormat$.prototype.$replaceCurrencies$ = function() {
  if(this.$hasCurrency$) {
    this.prefix = this.$replaceCurrency$(this.prefix);
    this.$suffix$ = this.$replaceCurrency$(this.$suffix$);
    this.$negativePrefix$ = this.$replaceCurrency$(this.$negativePrefix$);
    this.$negativeSuffix$ = this.$replaceCurrency$(this.$negativeSuffix$)
  }
};
Aura.$Utils$.$NumberFormat$.prototype.$replaceCurrency$ = function(str) {
  if(str) {
    return str.replace(/\u00a4\u00a4/g, this.$symbols$["currencyCode"]).replace(/\u00a4/g, this.$symbols$["currency"])
  }
  return str
};
Aura.$Utils$.$NumberFormat$.prototype.$translateDigits$ = function(charArray) {
  if(this.$zeroCharCodeOffset$) {
    for(var i = 0;i < charArray.length;i++) {
      charArray[i] = String.fromCharCode(charArray[i].charCodeAt(0) + this.$zeroCharCodeOffset$)
    }
  }
  return charArray
};
Aura.$Utils$.$NumberFormat$.prototype.$format$ = function(number) {
  var ns;
  if($A["util"].$isString$(number)) {
    ns = number
  }else {
    if(!$A["util"].$isFiniteNumber$(number)) {
      throw new Error("Unable to format " + number);
    }
    ns = String(number)
  }
  var charArray = ns.split("");
  var negative = false;
  if(charArray[0] === "-") {
    negative = true;
    charArray.shift()
  }
  var decimalPos = charArray.indexOf(".");
  if(decimalPos === -1) {
    decimalPos = charArray.length
  }else {
    charArray.splice(decimalPos, 1)
  }
  for(decimalPos += this.$multiplier$;decimalPos > charArray.length;) {
    charArray.push(Aura.$Utils$.$NumberFormat$.ZERO)
  }
  for(;charArray[0] === Aura.$Utils$.$NumberFormat$.ZERO;) {
    charArray.shift();
    decimalPos--
  }
  if(this.$maxFractionDigits$ < charArray.length - decimalPos) {
    var rounderIndex = decimalPos + this.$maxFractionDigits$;
    if(rounderIndex >= 0) {
      var round = charArray[rounderIndex] >= "5";
      for(charArray = charArray.slice(0, rounderIndex);round && rounderIndex > 0;) {
        var c = charArray[--rounderIndex];
        if(c !== "9") {
          charArray[rounderIndex] = String.fromCharCode(c.charCodeAt(0) + 1);
          round = false
        }else {
          charArray[rounderIndex] = Aura.$Utils$.$NumberFormat$.ZERO
        }
      }
      if(round) {
        charArray.unshift("1");
        decimalPos++
      }
    }else {
      charArray = [];
      if(-decimalPos > this.$minFractionDigits$) {
        decimalPos = -this.$minFractionDigits$
      }
    }
  }
  var prefix = this.prefix;
  var suffix = this.$suffix$;
  if(negative && this.$hasNegativePattern$) {
    prefix = this.$negativePrefix$;
    suffix = this.$negativeSuffix$
  }
  var result = [];
  if(negative && !this.$hasNegativePattern$) {
    result.push("-")
  }
  if(prefix) {
    result.push(prefix)
  }
  var zeroPad = this.$minDigits$ - decimalPos;
  for(var i = 0;i < zeroPad;i++) {
    charArray.unshift(Aura.$Utils$.$NumberFormat$.ZERO);
    decimalPos++
  }
  if(this.$groupingDigits$ <= 0 || decimalPos <= this.$groupingDigits$) {
    result = result.concat(this.$translateDigits$(charArray.slice(0, decimalPos)))
  }else {
    var dist = decimalPos % this.$groupingDigits$ || this.$groupingDigits$;
    result = result.concat(this.$translateDigits$(charArray.slice(0, dist)));
    for(var intPart = charArray.slice(dist, decimalPos);intPart.length > 0;) {
      result.push(this.$symbols$["groupingSeparator"]);
      result = result.concat(this.$translateDigits$(intPart.splice(0, this.$groupingDigits$)))
    }
  }
  var fracLength = charArray.length - decimalPos;
  if(fracLength > 0 || this.$minFractionDigits$ > 0) {
    result.push(this.$symbols$["decimalSeparator"]);
    if(fracLength > 0) {
      result = result.concat(this.$translateDigits$(charArray.slice(decimalPos)))
    }
    for(i = fracLength;i < this.$minFractionDigits$;i++) {
      result.push(this.$symbols$["zeroDigit"])
    }
    for(i = fracLength;i > this.$minFractionDigits$ && result[result.length - 1] === "0";i--) {
      result.pop()
    }
    if(result[result.length - 1] === this.$symbols$["decimalSeparator"]) {
      result.pop()
    }
  }
  if(suffix) {
    result.push(suffix)
  }
  return result.join("")
};
goog.$exportProperty$(Aura.$Utils$.$NumberFormat$.prototype, "format", Aura.$Utils$.$NumberFormat$.prototype.$format$);
Aura.$Utils$.$Mutex$ = function Mutex() {
  this.$queue$ = [];
  this.$lockAvailable$ = true
};
goog.$exportSymbol$("Aura.Utils.Mutex", Aura.$Utils$.$Mutex$);
Aura.$Utils$.$Mutex$.$SET_MUTEX_WAIT$ = 15;
Aura.$Utils$.$Mutex$.$RETRY_WAIT$ = 15;
Aura.$Utils$.$Mutex$.$MAX_LOCK_TIME$ = 8E3;
Aura.$Utils$.$Mutex$.$CLIENT_ID$ = Aura.$Context$.$AuraContext$.$CLIENT_SESSION_ID$;
Aura.$Utils$.$Mutex$.$GLOBAL_KEY$ = "global";
Aura.$Utils$.$Mutex$.$MUTEX_X_KEY$ = "__MUTEX_X";
Aura.$Utils$.$Mutex$.$MUTEX_Y_KEY$ = "__MUTEX_Y";
Aura.$Utils$.$Mutex$.prototype.$getClientId$ = function() {
  return Aura.$Utils$.$Mutex$.$CLIENT_ID$
};
goog.$exportProperty$(Aura.$Utils$.$Mutex$.prototype, "getClientId", Aura.$Utils$.$Mutex$.prototype.$getClientId$);
Aura.$Utils$.$Mutex$.prototype.$lock$ = function() {
  var xargs = Array.prototype.slice.call(arguments);
  var key = typeof arguments[0] === "string" ? xargs.shift() : Aura.$Utils$.$Mutex$.$GLOBAL_KEY$;
  var callback = xargs.shift();
  var timeout = xargs.shift() || Aura.$Utils$.$Mutex$.$MAX_LOCK_TIME$;
  $A.assert(typeof callback === "function", "Mutex needs a function to execute");
  if(this.$lockAvailable$ && !this.$queue$.length) {
    this.$lockAvailable$ = false;
    window.requestAnimationFrame(this.$_lockPriv$.bind(this, key, callback, timeout))
  }else {
    this.$queue$.push({key:key, $callback$:callback, timeout:timeout})
  }
};
goog.$exportProperty$(Aura.$Utils$.$Mutex$.prototype, "lock", Aura.$Utils$.$Mutex$.prototype.$lock$);
Aura.$Utils$.$Mutex$.prototype.$_lockPriv$ = function(key, callback, timeout) {
  this.$_setX$(key, function() {
    if(!this.$_isLockAvailable$(key, timeout)) {
      this.$_retry$(key, callback, timeout);
      return
    }
    this.$_setY$(key, function() {
      if(this.$_getX$(key) !== Aura.$Utils$.$Mutex$.$CLIENT_ID$) {
        setTimeout(function() {
          if(!this.$hasLock$(key)) {
            this.$_retry$(key, callback, timeout)
          }else {
            this.$_execute$(key, callback)
          }
        }.bind(this), Math.random() * Aura.$Utils$.$Mutex$.$RETRY_WAIT$)
      }else {
        this.$_execute$(key, callback)
      }
    })
  })
};
Aura.$Utils$.$Mutex$.prototype.$hasLock$ = function(key) {
  return this.$_getY$(key) === Aura.$Utils$.$Mutex$.$CLIENT_ID$
};
Aura.$Utils$.$Mutex$.prototype.$_execute$ = function(key, callback) {
  setTimeout(function() {
    callback(this.$_clearLock$.bind(this, key))
  }.bind(this), 0)
};
Aura.$Utils$.$Mutex$.prototype.$_clearLock$ = function(key) {
  window.localStorage.removeItem(key + Aura.$Utils$.$Mutex$.$MUTEX_Y_KEY$);
  var lockTask = this.$queue$.shift();
  if(lockTask) {
    window.requestAnimationFrame(this.$_lockPriv$.bind(this, lockTask.key, lockTask.$callback$, lockTask.timeout))
  }else {
    this.$lockAvailable$ = true
  }
};
Aura.$Utils$.$Mutex$.prototype.$_retry$ = function(key, callback, timeout) {
  window.setTimeout(function() {
    this.$_lockPriv$(key, callback, timeout)
  }.bind(this), Math.random() * Aura.$Utils$.$Mutex$.$RETRY_WAIT$)
};
Aura.$Utils$.$Mutex$.prototype.$_isLockAvailable$ = function(key, timeout) {
  var item = window.localStorage.getItem(key + Aura.$Utils$.$Mutex$.$MUTEX_Y_KEY$);
  var token = item && item.split("|");
  var mutex_y_TS = token && parseInt(token[1], 10);
  if(!token || Date.now() > mutex_y_TS + timeout) {
    return true
  }
};
Aura.$Utils$.$Mutex$.prototype.$_getX$ = function(key) {
  var item = window.localStorage.getItem(key + Aura.$Utils$.$Mutex$.$MUTEX_X_KEY$);
  return item && item.split("|")[0]
};
Aura.$Utils$.$Mutex$.prototype.$_setX$ = function(key, callback) {
  window.localStorage.setItem(key + Aura.$Utils$.$Mutex$.$MUTEX_X_KEY$, Aura.$Utils$.$Mutex$.$CLIENT_ID$ + "|" + Date.now());
  window.setTimeout(callback.bind(this), Math.random() * Aura.$Utils$.$Mutex$.$SET_MUTEX_WAIT$)
};
Aura.$Utils$.$Mutex$.prototype.$_getY$ = function(key) {
  var item = window.localStorage.getItem(key + Aura.$Utils$.$Mutex$.$MUTEX_Y_KEY$);
  return item && item.split("|")[0]
};
Aura.$Utils$.$Mutex$.prototype.$_setY$ = function(key, callback) {
  window.localStorage.setItem(key + Aura.$Utils$.$Mutex$.$MUTEX_Y_KEY$, Aura.$Utils$.$Mutex$.$CLIENT_ID$ + "|" + Date.now());
  window.setTimeout(callback.bind(this), Math.random() * Aura.$Utils$.$Mutex$.$SET_MUTEX_WAIT$)
};
Aura.$Utils$.$DocLevelHandler$ = function DocLevelHandler(eventName, callback, component) {
  this.$eventName$ = eventName;
  this.$component$ = component;
  this.enabled = false;
  var that = this;
  this.$callback$ = function(eventObj) {
    if(that.$component$.$isValid$() && that.$component$.$isRendered$()) {
      callback(eventObj)
    }
  }
};
goog.$exportSymbol$("Aura.Utils.DocLevelHandler", Aura.$Utils$.$DocLevelHandler$);
Aura.$Utils$.$DocLevelHandler$.prototype.$setEnabled$ = function(enable) {
  if(enable) {
    if(!this.enabled) {
      this.enabled = true;
      $A["util"].$on$(document.body, this.$eventName$, this.$callback$)
    }
  }else {
    if(this.enabled) {
      this.enabled = false;
      $A["util"].$removeOn$(document.body, this.$eventName$, this.$callback$)
    }
  }
};
goog.$exportProperty$(Aura.$Utils$.$DocLevelHandler$.prototype, "setEnabled", Aura.$Utils$.$DocLevelHandler$.prototype.$setEnabled$);
var SizeEstimator = function SizeEstimator() {
};
SizeEstimator.$CHARACTER_SIZE$ = 2;
SizeEstimator.$NUMBER_SIZE$ = 8;
SizeEstimator.$BOOLEAN_SIZE$ = 4;
SizeEstimator.$POINTER_SIZE$ = 8;
SizeEstimator.prototype.hasOwnProperty = Object.prototype.hasOwnProperty;
SizeEstimator.prototype.$estimateSize$ = function(value) {
  if(value === null || value === undefined) {
    return 0
  }
  var type = typeof value;
  if(type === "object") {
    try {
      return $A["util"].$json$.$encode$(value).length
    }catch(e) {
      $A.log("Error during size estimate, using 0: " + e);
      return 0
    }
  }
  switch(type) {
    case "string":
      return this.$sizeOfString$(value);
    case "number":
      return SizeEstimator.$NUMBER_SIZE$;
    case "boolean":
      return SizeEstimator.$BOOLEAN_SIZE$;
    default:
      return SizeEstimator.$POINTER_SIZE$
  }
};
SizeEstimator.prototype.$sizeOfString$ = function(value) {
  return value.length * SizeEstimator.$CHARACTER_SIZE$
};
Aura.$Utils$.$SizeEstimator$ = SizeEstimator;
Aura.$Utils$.$SecureFilters$ = function() {
  function jsSlashEncoder(charStr) {
    var code = charStr.charCodeAt(0);
    var hex = code.toString(16).toUpperCase();
    if(code < 128) {
      if(hex.length === 1) {
        return"\\x0" + hex
      }else {
        return"\\x" + hex
      }
    }else {
      switch(hex.length) {
        case 2:
          return"\\u00" + hex;
        case 3:
          return"\\u0" + hex;
        case 4:
          return"\\u" + hex;
        default:
          return"\\uFFFD"
      }
    }
  }
  var secureFilters = {};
  var QUOT = /\x22/g;
  var APOS = /\x27/g;
  var AST = /\*/g;
  var TILDE = /~/g;
  var BANG = /!/g;
  var LPAREN = /\(/g;
  var RPAREN = /\)/g;
  var CDATA_CLOSE = /\]\](?:>|\\x3E|\\u003E)/gi;
  var JS_NOT_WHITELISTED = /[^,\-\.0-9A-Z_a-z]/g;
  var JSON_NOT_WHITELISTED = /[^\x22,\-\.0-9:A-Z\[\x5C\]_a-z{}]/g;
  var HTML_CONTROL = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x9F]/g;
  var HTML_NOT_WHITELISTED = /[^\t\n\v\f\r ,\.0-9A-Z_a-z\-\u00A0-\uFFFF]/g;
  var CSS_NOT_WHITELISTED = /[^a-zA-Z0-9\uD800-\uDFFF]/g;
  secureFilters.$html$ = function(val) {
    var str = String(val);
    str = str.replace(HTML_CONTROL, " ");
    return str.replace(HTML_NOT_WHITELISTED, function(match) {
      var code = match.charCodeAt(0);
      switch(code) {
        case 34:
          return"\x26quot;";
        case 38:
          return"\x26amp;";
        case 60:
          return"\x26lt;";
        case 62:
          return"\x26gt;";
        default:
          if(code < 100) {
            var dec = code.toString(10);
            return"\x26#" + dec + ";"
          }else {
            var hex = code.toString(16).toUpperCase();
            return"\x26#x" + hex + ";"
          }
      }
    })
  };
  secureFilters.$js$ = function(val) {
    var str = String(val);
    return str.replace(JS_NOT_WHITELISTED, jsSlashEncoder)
  };
  secureFilters.$jsAttr$ = function(val) {
    return secureFilters.$html$(secureFilters.$js$(val))
  };
  secureFilters.uri = function(val) {
    var encode = encodeURIComponent(String(val));
    return encode.replace(BANG, "%21").replace(QUOT, "%27").replace(APOS, "%27").replace(LPAREN, "%28").replace(RPAREN, "%29").replace(AST, "%2A").replace(TILDE, "%7E")
  };
  secureFilters.$jsObj$ = function(val) {
    return JSON.stringify(val).replace(JSON_NOT_WHITELISTED, jsSlashEncoder).replace(CDATA_CLOSE, "\\x5D\\x5D\\x3E")
  };
  secureFilters.$css$ = function(val) {
    var str = String(val);
    return str.replace(CSS_NOT_WHITELISTED, function(match) {
      var code = match.charCodeAt(0);
      if(code === 0) {
        return"\\fffd "
      }else {
        var hex = code.toString(16).toLowerCase();
        return"\\" + hex + " "
      }
    })
  };
  secureFilters.style = function(val) {
    return secureFilters.$html$(secureFilters.$css$(val))
  };
  return secureFilters
}();
Aura.$Utils$.$Util$ = function Util() {
  this.$trashcan$ = document.createDocumentFragment();
  this.$trash$ = [];
  this.$json$ = new Json;
  this["json"] = this.$json$;
  this.style = new Aura.$Utils$.$Style$;
  this["style"] = this.style;
  this["Bitset"] = Aura.$Utils$.$Bitset$;
  this["NumberFormat"] = Aura.$Utils$.$NumberFormat$;
  this.$objToString$ = Object.prototype.toString;
  this.$trashedComponentQueue$ = [];
  this.$dataAttributeCache$ = {};
  this.$debugToolWindow$ = undefined;
  this.$sizeEstimator$ = new Aura.$Utils$.$SizeEstimator$;
  this.$Mutex$ = new Aura.$Utils$.$Mutex$;
  this["Mutex"] = this.$Mutex$
};
goog.$exportSymbol$("Aura.Utils.Util", Aura.$Utils$.$Util$);
Aura.$Utils$.$Util$.prototype.$isIE$ = navigator.userAgent.indexOf("MSIE") !== -1 || navigator.userAgent.indexOf("Trident/") !== -1;
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "isIE", Aura.$Utils$.$Util$.prototype.$isIE$);
Promise.prototype.$then$ = Promise.prototype["then"];
Aura.$Utils$.$Util$.prototype.$isLocalStorageEnabled$ = function() {
  if(this.$localStorageEnabled$ === undefined) {
    this.$localStorageEnabled$ = false;
    try {
      if(window.localStorage) {
        window.localStorage.setItem("__AURA_LOCAL_STORAGE_ENABLED_TEST", "");
        window.localStorage.removeItem("__AURA_LOCAL_STORAGE_ENABLED_TEST");
        this.$localStorageEnabled$ = true
      }
    }catch(ignore) {
    }
  }
  return this.$localStorageEnabled$
};
Aura.$Utils$.$Util$.prototype.$isSessionStorageEnabled$ = function() {
  if(this.$sessionStorageEnabled$ === undefined) {
    this.$sessionStorageEnabled$ = false;
    try {
      if(window.sessionStorage) {
        window.sessionStorage.setItem("__AURA_SESSION_STORAGE_ENABLED_TEST", "");
        window.sessionStorage.removeItem("__AURA_SESSION_STORAGE_ENABLED_TEST");
        this.$sessionStorageEnabled$ = true
      }
    }catch(ignore) {
    }
  }
  return this.$sessionStorageEnabled$
};
Aura.$Utils$.$Util$.prototype["setCookie"] = function(key, value, duration) {
  $A.assert(typeof key === "string", "key must be a string");
  $A.assert(typeof value === "string", "value must be a string");
  $A.assert(duration === undefined || typeof duration === "number", "duration must be a number");
  duration = duration || 1E3 * 60 * 60 * 24 * 7;
  var expiration = new Date((new Date).getTime() + duration);
  document.cookie = key + "\x3d" + value + "; expires\x3d" + expiration.toUTCString()
};
Aura.$Utils$.$Util$.prototype.$getCookie$ = function(key) {
  $A.assert(typeof key === "string", "key must be a string");
  var cookies = "; " + document.cookie + ";";
  key = "; " + key + "\x3d";
  var begin = cookies.indexOf(key);
  if(begin === -1) {
    return undefined
  }
  var end = cookies.indexOf(";", begin + key.length);
  var value = cookies.substring(begin + key.length, end);
  return value
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "getCookie", Aura.$Utils$.$Util$.prototype.$getCookie$);
Aura.$Utils$.$Util$.prototype.$clearCookie$ = function(key) {
  $A.assert(typeof key === "string", "key must be a string");
  document.cookie = key + "\x3dtrue; expires\x3dThu, 01 Jan 1970 00:00:00 GMT"
};
Aura.$Utils$.$Util$.prototype.$isIOSWebView$ = function() {
  if(this.$_isIOSWebView$ === undefined) {
    var ua = window.navigator.userAgent;
    this.$_isIOSWebView$ = /(iPad|iPhone|iPod);.*CPU.*OS 7_\d.*AppleWebKit/i.test(ua) && ua.indexOf("Safari") === -1
  }
  return this.$_isIOSWebView$
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "isIOSWebView", Aura.$Utils$.$Util$.prototype.$isIOSWebView$);
Aura.$Utils$.$Util$.prototype.$globalEval$ = function(src, sourceURL) {
  sourceURL = sourceURL ? "\n//# sourceURL\x3d" + sourceURL : "";
  return(0, eval)("(function(){ return (\n" + src + "\n)})();" + sourceURL)
};
Aura.$Utils$.$Util$.prototype.isArray = typeof Array.isArray === "function" ? Array.isArray : function(arg) {
  return Object.prototype.toString.call(arg) === "[object Array]"
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "isArray", Aura.$Utils$.$Util$.prototype.isArray);
Aura.$Utils$.$Util$.prototype.$isObject$ = function(obj) {
  return typeof obj === "object" && obj !== null && !Array.isArray(obj)
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "isObject", Aura.$Utils$.$Util$.prototype.$isObject$);
Aura.$Utils$.$Util$.prototype.$isPlainObject$ = function(o) {
  function isObjectObject(x) {
    return typeof x === "object" && x !== null && Object.prototype.toString.call(x) === "[object Object]"
  }
  if(isObjectObject(o) === false) {
    return false
  }
  if(typeof o.constructor !== "function") {
    return false
  }
  try {
    var p = o.constructor.prototype;
    if(isObjectObject(p) === false) {
      return false
    }
    if(p.hasOwnProperty("isPrototypeOf") === false) {
      return false
    }
  }catch(e) {
  }
  return true
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "isPlainObject", Aura.$Utils$.$Util$.prototype.$isPlainObject$);
Aura.$Utils$.$Util$.prototype.$isError$ = function(obj) {
  return!!obj && this.$objToString$.apply(obj) === "[object Error]"
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "isError", Aura.$Utils$.$Util$.prototype.$isError$);
Aura.$Utils$.$Util$.prototype.$isFunction$ = function(obj) {
  return!!obj && this.$objToString$.apply(obj) === "[object Function]"
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "isFunction", Aura.$Utils$.$Util$.prototype.$isFunction$);
Aura.$Utils$.$Util$.prototype.$isString$ = function(obj) {
  return typeof obj === "string"
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "isString", Aura.$Utils$.$Util$.prototype.$isString$);
Aura.$Utils$.$Util$.prototype.$isNumber$ = function(obj) {
  return typeof obj === "number"
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "isNumber", Aura.$Utils$.$Util$.prototype.$isNumber$);
Aura.$Utils$.$Util$.prototype.$isFiniteNumber$ = function(obj) {
  return this.$isNumber$(obj) && isFinite(obj)
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "isFiniteNumber", Aura.$Utils$.$Util$.prototype.$isFiniteNumber$);
Aura.$Utils$.$Util$.prototype.$isBoolean$ = function(obj) {
  return typeof obj === "boolean"
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "isBoolean", Aura.$Utils$.$Util$.prototype.$isBoolean$);
Aura.$Utils$.$Util$.prototype.$isUndefined$ = function(obj) {
  return obj === undefined
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "isUndefined", Aura.$Utils$.$Util$.prototype.$isUndefined$);
Aura.$Utils$.$Util$.prototype.$isUndefinedOrNull$ = function(obj) {
  return obj === undefined || obj === null
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "isUndefinedOrNull", Aura.$Utils$.$Util$.prototype.$isUndefinedOrNull$);
Aura.$Utils$.$Util$.prototype.$isEmpty$ = function(obj) {
  if(obj === undefined || obj === null || obj === "") {
    return true
  }
  if(Array.isArray(obj)) {
    return obj.length === 0
  }else {
    if(typeof obj === "object" && Object.prototype.toString.call(obj) === "[object Object]") {
      return Object.keys(obj).length === 0
    }
  }
  return false
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "isEmpty", Aura.$Utils$.$Util$.prototype.$isEmpty$);
Aura.$Utils$.$Util$.prototype.$getBooleanValue$ = function(val) {
  return val !== undefined && val !== null && val !== false && val !== 0 && val !== "false" && val !== "" && val !== "f"
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "getBooleanValue", Aura.$Utils$.$Util$.prototype.$getBooleanValue$);
Aura.$Utils$.$Util$.prototype.$createHtmlElement$ = function(tagName, attributes) {
  var node = document.createElement(tagName);
  for(var attributeName in attributes) {
    var value = attributes[attributeName];
    if(!this.$isUndefinedOrNull$(value)) {
      if(this.$isString$(value) && value.indexOf("/auraFW") === 0) {
        value = $A.getContext().$getContextPath$() + value
      }
      node.setAttribute(attributeName, value)
    }
  }
  return node
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "createHtmlElement", Aura.$Utils$.$Util$.prototype.$createHtmlElement$);
Aura.$Utils$.$Util$.prototype.$clearNode$ = function(node) {
  for(var last = node.lastChild;last;) {
    node.removeChild(last);
    last = node.lastChild
  }
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "clearNode", Aura.$Utils$.$Util$.prototype.$clearNode$);
Aura.$Utils$.$Util$.prototype.$sanitizeDOM$ = function(dirty, config) {
  return DOMPurify["sanitize"](dirty, config)
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "sanitizeDOM", Aura.$Utils$.$Util$.prototype.$sanitizeDOM$);
Aura.$Utils$.$Util$.prototype.$sanitizeHtml$ = Aura.$Utils$.$SecureFilters$.$html$;
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "sanitizeHtml", Aura.$Utils$.$Util$.prototype.$sanitizeHtml$);
Aura.$Utils$.$Util$.prototype.$sanitizeJs$ = Aura.$Utils$.$SecureFilters$.$js$;
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "sanitizeJs", Aura.$Utils$.$Util$.prototype.$sanitizeJs$);
Aura.$Utils$.$Util$.prototype.$sanitizeJsAttr$ = Aura.$Utils$.$SecureFilters$.$jsAttr$;
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "sanitizeJsAttr", Aura.$Utils$.$Util$.prototype.$sanitizeJsAttr$);
Aura.$Utils$.$Util$.prototype.$sanitizeUri$ = Aura.$Utils$.$SecureFilters$.uri;
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "sanitizeUri", Aura.$Utils$.$Util$.prototype.$sanitizeUri$);
Aura.$Utils$.$Util$.prototype.$sanitizeJsObj$ = Aura.$Utils$.$SecureFilters$.$jsObj$;
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "sanitizeJsObj", Aura.$Utils$.$Util$.prototype.$sanitizeJsObj$);
Aura.$Utils$.$Util$.prototype.$sanitizeCSS$ = Aura.$Utils$.$SecureFilters$.$css$;
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "sanitizeCSS", Aura.$Utils$.$Util$.prototype.$sanitizeCSS$);
Aura.$Utils$.$Util$.prototype.$sanitizeStyle$ = Aura.$Utils$.$SecureFilters$.style;
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "sanitizeStyle", Aura.$Utils$.$Util$.prototype.$sanitizeStyle$);
Aura.$Utils$.$Util$.prototype.$getElement$ = function(id) {
  return document.getElementById(id)
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "getElement", Aura.$Utils$.$Util$.prototype.$getElement$);
Aura.$Utils$.$Util$.prototype.copy = function(value) {
  if(this.isArray(value)) {
    return value.slice()
  }
  if(this.$isObject$(value)) {
    var copy = {};
    this.apply(copy, value, true);
    return copy
  }
  return value
};
Aura.$Utils$.$Util$.prototype.$equals$ = function(expected, actual) {
  if(expected === actual) {
    return true
  }
  if(!expected || !actual) {
    return false
  }
  if(this.$isObject$(expected)) {
    if(!this.$isObject$(actual)) {
      return false
    }
    for(var x in expected) {
      if(expected.hasOwnProperty(x)) {
        if(!actual.hasOwnProperty(x)) {
          return false
        }
        if(!this.$equals$(expected[x], actual[x])) {
          return false
        }
      }
    }
    return true
  }
  if(this.isArray(expected)) {
    if(!this.isArray(actual) || expected.length !== actual.length) {
      return false
    }
    for(var i = 0;i < expected.length;i++) {
      if(!this.$equals$(expected[i], actual[i])) {
        return false
      }
    }
    return true
  }
  return false
};
Aura.$Utils$.$Util$.prototype.$compareValues$ = function(expected, actual) {
  var result = {"match":true, "reasons":[]};
  if(this.isArray(expected)) {
    if(!this.isArray(actual)) {
      result["reasons"].push({index:-1, reason:"Actual was not an Array."});
      result["match"] = false
    }else {
      var length = Math.max(expected.length, actual.length);
      for(var i = 0;i < length;i++) {
        if(expected[i] !== actual[i]) {
          result["reasons"].push({index:i, reason:"Mismatch at position " + i + "."});
          result["match"] = false
        }
      }
    }
  }else {
    if(this.$isObject$(expected)) {
      if(!this.$isObject$(actual)) {
        result["reasons"].push({index:-1, reason:"Actual was not an Object."});
        result["match"] = false
      }
      var keyMap = {};
      for(var expectedKey in expected) {
        keyMap[expectedKey] = true;
        if(expected[expectedKey] !== actual[expectedKey]) {
          result["reasons"].push({index:expectedKey, reason:"Mismatch at key " + expectedKey + "."});
          result["match"] = false
        }
      }
      for(var actualKey in actual) {
        if(keyMap[actualKey]) {
          continue
        }
        result["reasons"].push({index:actualKey, reason:"Found new key " + actualKey + "."});
        result["match"] = false
      }
    }else {
      if(expected !== actual) {
        result["reasons"].push({index:-1, reason:"Literal value mismatch."});
        result["match"] = false
      }
    }
  }
  return result
};
Aura.$Utils$.$Util$.prototype.$hasClass$ = function(element, className) {
  var oldClass = "";
  if(this.$isComponent$(element)) {
    if(element.$isInstanceOf$("ui:elementInterface") || element.$isInstanceOf$("ui:visible")) {
      oldClass = element.get("v.class")
    }else {
      if(element.$isInstanceOf$("aura:html")) {
        oldClass = element.get("v.HTMLAttributes.class")
      }else {
        element = element.$getElement$()
      }
    }
  }
  if(element && element.tagName) {
    oldClass = element["className"]
  }
  return(" " + oldClass + " ").indexOf(" " + className + " ") > -1
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "hasClass", Aura.$Utils$.$Util$.prototype.$hasClass$);
Aura.$Utils$.$Util$.prototype.$addClass$ = function(element, newClass) {
  this.$setClass$(element, newClass, false)
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "addClass", Aura.$Utils$.$Util$.prototype.$addClass$);
Aura.$Utils$.$Util$.prototype.$removeClass$ = function(element, newClass) {
  this.$setClass$(element, newClass, true)
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "removeClass", Aura.$Utils$.$Util$.prototype.$removeClass$);
Aura.$Utils$.$Util$.prototype.$toggleClass$ = function(element, className, condition) {
  if(condition === undefined) {
    condition = !this.$hasClass$(element, className)
  }
  if(condition) {
    this.$addClass$(element, className);
    return true
  }else {
    this.$removeClass$(element, className);
    return false
  }
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "toggleClass", Aura.$Utils$.$Util$.prototype.$toggleClass$);
Aura.$Utils$.$Util$.prototype.$swapClass$ = function(element, oldClass, newClass) {
  oldClass = this.isArray(oldClass) ? oldClass : [oldClass];
  newClass = this.isArray(newClass) ? newClass : [newClass];
  for(var i = 0;i < oldClass.length;i++) {
    this.$removeClass$(element, oldClass[i])
  }
  for(i = 0;i < newClass.length;i++) {
    this.$addClass$(element, newClass[i])
  }
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "swapClass", Aura.$Utils$.$Util$.prototype.$swapClass$);
Aura.$Utils$.$Util$.prototype.$setClass$ = function(element, newClass, remove) {
  var constructedClass = "";
  if(this.$isComponent$(element)) {
    var attribute = null;
    if(element.$isInstanceOf$("ui:elementInterface") || element.$isInstanceOf$("ui:visible")) {
      attribute = "v.class"
    }else {
      if(element.$isInstanceOf$("aura:html")) {
        attribute = "v.HTMLAttributes.class"
      }else {
        element = element.$getElement$()
      }
    }
    if(attribute) {
      var useShadowClass = false;
      var oldClass = element.$getShadowAttribute$(attribute);
      if(oldClass != undefined) {
        useShadowClass = true
      }else {
        oldClass = element.get(attribute) || ""
      }
      constructedClass = this.$buildClass$(oldClass, newClass, remove);
      if(oldClass !== constructedClass) {
        if(useShadowClass) {
          element.$setShadowAttribute$(attribute, constructedClass ? " " + constructedClass : "")
        }else {
          element.set(attribute, constructedClass)
        }
      }
    }
  }
  if(element && element.tagName) {
    if(element.tagName === "svg") {
      constructedClass = this.$buildClass$(element.getAttribute("class") || "", newClass, remove);
      if(element.getAttribute("class") !== constructedClass) {
        element.setAttribute("class", constructedClass)
      }
    }else {
      constructedClass = this.$buildClass$(element["className"] || "", newClass, remove);
      if(element["className"] !== constructedClass) {
        element["className"] = constructedClass
      }
    }
  }
};
Aura.$Utils$.$Util$.prototype.$buildClass$ = function(oldClass, newClass, remove) {
  if(this.$isUndefinedOrNull$(oldClass)) {
    oldClass = ""
  }
  if(this.$isUndefinedOrNull$(newClass)) {
    return oldClass
  }
  newClass = this.trim(newClass);
  oldClass = this.trim(oldClass);
  var found = (" " + oldClass + " ").indexOf(" " + newClass + " ") > -1;
  if(remove) {
    if(!found) {
      return oldClass
    }
    return this.trim((" " + oldClass + " ").split(" " + newClass + " ").join(" "))
  }else {
    if(oldClass) {
      if(!found) {
        return oldClass + " " + newClass
      }else {
        return oldClass
      }
    }else {
      return newClass
    }
  }
};
Aura.$Utils$.$Util$.prototype.$buildFlavorClass$ = function(cmp, flavor) {
  if($A["util"].$isFunction$(cmp.$getDef$)) {
    cmp = cmp.$getDef$()
  }
  $A.assert(!this.$isUndefinedOrNull$(cmp.$getStyleDef$()), "Missing StyleDef for component " + cmp.$getDescriptor$() + " (required for flavors)");
  if(this.$isEmpty$(flavor)) {
    return""
  }
  var base = cmp.$getStyleDef$().$getClassName$();
  var split = flavor.split(",");
  var clz = "";
  var i = 0;
  for(var len = split.length;i < len;i++) {
    if(i !== 0) {
      clz += " "
    }
    clz += base + "--" + this.trim(split[i])
  }
  return clz
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "buildFlavorClass", Aura.$Utils$.$Util$.prototype.$buildFlavorClass$);
Aura.$Utils$.$Util$.prototype.$createElementsFromMarkup$ = function(markup) {
  if(!this.$isUndefinedOrNull$(markup)) {
    var tmpNode = document.createElement("span");
    tmpNode.innerHTML = markup;
    return this.$toArray$(tmpNode.childNodes)
  }
  return[]
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "createElementsFromMarkup", Aura.$Utils$.$Util$.prototype.$createElementsFromMarkup$);
Aura.$Utils$.$Util$.prototype.$insertFirst$ = function(newEl, referenceEl) {
  if(this.isArray(newEl)) {
    if(newEl.length === 1) {
      this.$insertFirst$(newEl[0], referenceEl);
      return
    }
    var frag = document.createDocumentFragment();
    this.appendChild(newEl, frag);
    this.$insertFirst$(frag, referenceEl);
    return
  }
  var firstChild = referenceEl.firstChild;
  if(firstChild) {
    referenceEl.insertBefore(newEl, firstChild)
  }else {
    referenceEl.appendChild(newEl)
  }
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "insertFirst", Aura.$Utils$.$Util$.prototype.$insertFirst$);
Aura.$Utils$.$Util$.prototype.insertBefore = function(newEl, referenceEl) {
  if(this.isArray(newEl)) {
    if(newEl.length === 1) {
      this.insertBefore(newEl[0], referenceEl);
      return
    }
    var frag = document.createDocumentFragment();
    this.appendChild(newEl, frag);
    this.insertBefore(frag, referenceEl);
    return
  }
  var parent = referenceEl.parentNode;
  if(parent) {
    parent.insertBefore(newEl, referenceEl)
  }
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "insertBefore", Aura.$Utils$.$Util$.prototype.insertBefore);
Aura.$Utils$.$Util$.prototype.$insertAfter$ = function(newEl, referenceEl) {
  if(this.isArray(newEl)) {
    if(newEl.length === 1) {
      this.$insertAfter$(newEl[0], referenceEl);
      return
    }
    var frag = document.createDocumentFragment();
    this.appendChild(newEl, frag);
    this.$insertAfter$(frag, referenceEl);
    return
  }
  var parent = referenceEl.parentNode;
  if(parent) {
    if(parent.lastChild === referenceEl) {
      parent.appendChild(newEl)
    }else {
      parent.insertBefore(newEl, referenceEl.nextSibling)
    }
  }
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "insertAfter", Aura.$Utils$.$Util$.prototype.$insertAfter$);
Aura.$Utils$.$Util$.prototype.appendChild = function(newEl, referenceEl) {
  if(referenceEl.canHaveChildren === false) {
    return
  }
  if(this.isArray(newEl)) {
    if(newEl.length === 1) {
      referenceEl.appendChild(newEl[0]);
      return
    }
    var frag = document.createDocumentFragment();
    var len = newEl.length;
    for(var i = 0;i < len;i++) {
      if(newEl[i]) {
        frag.appendChild(newEl[i])
      }
    }
    newEl = frag
  }
  referenceEl.appendChild(newEl)
};
Aura.$Utils$.$Util$.prototype.$removeElement$ = function(element) {
  if(!element) {
    return
  }
  if(element.$__customElement$ && element.parentElement) {
    element.parentElement.removeChild(element);
    return
  }
  if(!(element.parentNode === this.$trashcan$)) {
    if(element.parentNode) {
      if(element.nodeType !== 3 && element.nodeType !== 8) {
        $A.assert(this.$isUndefined$(element["aura_deleted"]), "Element was reused after delete");
        element["aura_deleted"] = true
      }
      this.$trashcan$.appendChild(element)
    }else {
      this.$trash$.push(element)
    }
    if(!this.$gcPending$) {
      this.$gcPending$ = true;
      var that = this;
      setTimeout(function() {
        for(var trashcan = that.$trashcan$;trashcan.hasChildNodes();) {
          var node = trashcan.lastChild;
          if(node.nodeType !== 3 && node.nodeType !== 8) {
            try {
              delete node["aura_deleted"]
            }catch(e) {
              node.removeAttribute("aura_deleted")
            }
          }
          trashcan.removeChild(node)
        }
        var i = 0;
        for(var len = that.$trash$.length;i < len;i++) {
          that.$trash$[i] = null
        }
        that.$trash$ = [];
        that.$gcPending$ = false
      }, 1E3)
    }
  }
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "removeElement", Aura.$Utils$.$Util$.prototype.$removeElement$);
Aura.$Utils$.$Util$.prototype.$generateUrl$ = function(url, params, encoded) {
  if(this.$isString$(url) && this.$isObject$(params)) {
    var hashPairs;
    var map = {};
    var pieces = url.split("?");
    var query = pieces[1] || "";
    if(query.length > 1) {
      hashPairs = query.split("#");
      if(hashPairs.length > 1) {
        query = hashPairs[0]
      }
    }else {
      hashPairs = pieces[0].split("#");
      if(hashPairs.length > 1) {
        pieces[0] = hashPairs[0]
      }
    }
    var pairs = query.split("\x26");
    for(var i = 0;i < pairs.length;i++) {
      if(pairs[i] > "") {
        var pair = pairs[i].split("\x3d");
        map[pair[0]] = pair[1]
      }
    }
    for(var k1 in params) {
      if(params.hasOwnProperty(k1)) {
        var v1 = params[k1];
        if(v1 > "") {
          map[k1] = encoded ? params[k1] : encodeURIComponent(params[k1])
        }else {
          delete map[k1]
        }
      }
    }
    pairs = [];
    for(var k2 in map) {
      if(map.hasOwnProperty(k2)) {
        var v2 = map[k2];
        pairs.push(k2 + "\x3d" + v2)
      }
    }
    query = pairs.join("\x26");
    pieces[1] = query;
    if(hashPairs.length > 1) {
      hashPairs.shift();
      return pieces.join("?") + "#" + hashPairs.join("#")
    }else {
      return pieces.join("?")
    }
  }
  return url
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "generateUrl", Aura.$Utils$.$Util$.prototype.$generateUrl$);
Aura.$Utils$.$Util$.prototype.trim = function(value) {
  return(value || "").replace(/^\s+|\s+$/g, "")
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "trim", Aura.$Utils$.$Util$.prototype.trim);
Aura.$Utils$.$Util$.prototype.$format$ = function(formatString, arg1, arg2, argN) {
  $A.assert($A["util"].$isString$(formatString), "$A.util.format(): 'formatString' must be a String.");
  var formatArguments = Array.prototype.slice.call(arguments, 1);
  return formatString.replace(/\{(\d+)\}/gm, function(match, index) {
    var substitution = formatArguments[index];
    if(substitution === undefined) {
      return match
    }
    return substitution + ""
  })
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "format", Aura.$Utils$.$Util$.prototype.$format$);
Aura.$Utils$.$Util$.prototype.truncate = function(st, len, ellipsis, truncateByWord) {
  ellipsis = !!ellipsis;
  truncateByWord = !!truncateByWord;
  if(!st || !len) {
    return""
  }
  st = st.toString();
  if(len > 0 && st.length > len) {
    if(ellipsis) {
      len = len - 3 < 1 ? 1 : len - 3
    }
    if(truncateByWord === false) {
      return this.trim(st.substring(0, len)) + (ellipsis ? "..." : "")
    }else {
      st = st.substring(0, len + 1);
      var st2 = st.replace(/\w+$/, "");
      if(st2.length === 0 || st2.length > len) {
        st2 = st.substring(0, len)
      }
      return this.trim(st2) + (ellipsis ? "..." : "")
    }
  }else {
    return st
  }
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "truncate", Aura.$Utils$.$Util$.prototype.truncate);
Aura.$Utils$.$Util$.prototype.$createTimeoutCallback$ = function(callback, toleranceMillis) {
  function timeoutCallback() {
    var currentDuration = new Date - rtime;
    $A.assert(currentDuration >= 0);
    if(currentDuration < toleranceMillis) {
      setTimeout(timeoutCallback, toleranceMillis - currentDuration)
    }else {
      timeout = false;
      rtime = null;
      callback()
    }
  }
  $A.assert(!$A["util"].$isUndefinedOrNull$(callback) && $A["util"].$isFunction$(callback), "Invalid callback");
  $A.assert(toleranceMillis > 0, "Must use a positive tolerance period.");
  var rtime = null;
  var timeout = false;
  return function() {
    rtime = new Date;
    if(timeout === false) {
      timeout = true;
      setTimeout(timeoutCallback, toleranceMillis)
    }
  }
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "createTimeoutCallback", Aura.$Utils$.$Util$.prototype.$createTimeoutCallback$);
Aura.$Utils$.$Util$.prototype.$on$ = function() {
  if(window["addEventListener"]) {
    return function(element, eventName, handler, useCapture, timeout) {
      var originalHandler = handler;
      if(timeout) {
        handler = this.$createTimeoutCallback$(handler, timeout)
      }
      if(element) {
        originalHandler.$registeredAuraHandler$ = handler;
        element["addEventListener"](eventName, handler, useCapture)
      }
    }
  }else {
    var preventDefault = function() {
      this.returnValue = false
    };
    var stopPropagation = function() {
      this.cancelBubble = true
    };
    return function(element, eventName, handler, useCapture, timeout) {
      if(!element) {
        return
      }
      var originalHandler = handler;
      var handlerCache = element["handlerCache"];
      if(!handlerCache) {
        element["handlerCache"] = handlerCache = {}
      }
      var handlers = handlerCache[eventName];
      if(handlers) {
        for(var n = 0;n < handlers.length;n++) {
          if(handlers[n] === handler) {
            return
          }
        }
        handlers.push(handler)
      }else {
        handlerCache[eventName] = [handler]
      }
      if(timeout) {
        handler = $A["util"].$createTimeoutCallback$(handler, timeout)
      }
      var newHandler = function(event) {
        event.currentTarget = element;
        event.target = event.srcElement;
        event.which = event.keyCode;
        event.preventDefault = preventDefault;
        event.stopPropagation = stopPropagation;
        handler.call(element, event || window.event);
        event.currentTarget = event.target = event.which = event.preventDefault = event.stopPropagation = null
      };
      originalHandler.$registeredAuraHandler$ = newHandler;
      element["attachEvent"]("on" + eventName, newHandler, false)
    }
  }
}();
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "on", Aura.$Utils$.$Util$.prototype.$on$);
Aura.$Utils$.$Util$.prototype.$removeOn$ = function(element, eventName, listener, useCapture) {
  $A.assert(element, "try to remove an event listener from a no-longer-exist DOM element");
  if(this.$isUndefined$(listener)) {
    return
  }
  if(listener.$registeredAuraHandler$) {
    listener = listener.$registeredAuraHandler$
  }
  if(window["removeEventListener"]) {
    element.removeEventListener(eventName, listener, useCapture)
  }else {
    if(window["detachEvent"]) {
      element.detachEvent("on" + eventName, listener)
    }else {
      $A.assert(false, "user agent must support either removeEventListener or detachEvent to remove an event handler.")
    }
  }
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "removeOn", Aura.$Utils$.$Util$.prototype.$removeOn$);
Aura.$Utils$.$Util$.prototype.$formToMap$ = function(form) {
  var map = {};
  for(var i = 0;i < form.length;i++) {
    var element = form[i];
    var name = element.name;
    var value = null;
    if(name) {
      if(element.tagName === "INPUT") {
        var type = element.type;
        if(type === "button" || type === "submit") {
        }else {
          if(type === "checkbox") {
            if(element.checked) {
              value = element.value
            }
          }else {
            if(type === "radio") {
              if(element.checked && element.value && element.value !== "") {
                value = element.value
              }
            }else {
              value = element.value
            }
          }
        }
      }else {
        if(element.tagName === "SELECT") {
          value = this.$getSelectValue$(element)
        }else {
          if(element.tagName === "TEXTAREA") {
            value = element.value
          }
        }
      }
      if(value !== null && value !== undefined) {
        this.$addValueToMap$(map, name, value)
      }
    }
  }
  return map
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "formToMap", Aura.$Utils$.$Util$.prototype.$formToMap$);
Aura.$Utils$.$Util$.prototype.$getSelectValue$ = function(select) {
  if(select.options.length === 0) {
    return null
  }
  if(!select.multiple) {
    return select.options[select.selectedIndex].value
  }else {
    var list = [];
    var options = select.options;
    for(var i = 0;i < options.length;i++) {
      var option = options[i];
      if(option.selected) {
        list[list.length] = option.value
      }
    }
    return list
  }
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "getSelectValue", Aura.$Utils$.$Util$.prototype.$getSelectValue$);
Aura.$Utils$.$Util$.prototype.$addValueToMap$ = function(inputMap, key, value) {
  if(key.indexOf(".") > 0) {
    var inputName = key.substring(0, key.indexOf("."));
    var subMapKey = key.substring(key.indexOf(".") + 1, key.length);
    this.$addMapValueToMap$(inputMap, inputName, value, subMapKey);
    return
  }else {
    var ix = key.indexOf("00N");
    if(ix === 0 || ix === 2) {
      this.$addMapValueToMap$(inputMap, "properties", value, key);
      return
    }
  }
  var oldVal = inputMap[key];
  if(!oldVal) {
    inputMap[key] = value
  }else {
    if(!this.isArray(oldVal)) {
      var valArray = [];
      valArray[0] = oldVal;
      valArray[1] = value;
      inputMap[key] = valArray
    }else {
      oldVal.push(value)
    }
  }
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "addValueToMap", Aura.$Utils$.$Util$.prototype.$addValueToMap$);
Aura.$Utils$.$Util$.prototype.$addMapValueToMap$ = function(inputMap, key, value, subMapKey) {
  var subMap = inputMap[key];
  if(!subMap) {
    subMap = {};
    inputMap[key] = subMap
  }
  subMap[subMapKey] = value
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "addMapValueToMap", Aura.$Utils$.$Util$.prototype.$addMapValueToMap$);
Aura.$Utils$.$Util$.prototype.$isSubDef$ = function(def, qname) {
  for(;def;) {
    if(def.$getDescriptor$().$getQualifiedName$() === qname) {
      return true
    }
    def = def.$getSuperDef$()
  }
  return false
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "isSubDef", Aura.$Utils$.$Util$.prototype.$isSubDef$);
Aura.$Utils$.$Util$.prototype.apply = function(baseObject, members, forceCopy, deepCopy) {
  if(members) {
    var value = null;
    for(var property in members) {
      var setValue = forceCopy || !baseObject.hasOwnProperty(property);
      if(setValue || deepCopy) {
        value = members[property];
        if(deepCopy && value != undefined) {
          var branchValue = null;
          if(this.isArray(value)) {
            branchValue = baseObject[property] || []
          }else {
            if(this.$isPlainObject$(value)) {
              branchValue = baseObject[property] || {}
            }
          }
          if(branchValue) {
            baseObject[property] = this.apply(branchValue, value, forceCopy, deepCopy);
            continue
          }
        }
        if(setValue) {
          baseObject[property] = value
        }
      }
    }
  }
  return baseObject
};
Aura.$Utils$.$Util$.prototype.$applyNotFromPrototype$ = function(baseObject, members, forceCopy, deepCopy) {
  if(members) {
    var value = null;
    for(var property in members) {
      if(!members.hasOwnProperty(property)) {
        continue
      }
      var setValue = forceCopy || !baseObject.hasOwnProperty(property);
      if(setValue || deepCopy) {
        value = members[property];
        if(deepCopy && value != undefined) {
          var branchValue = null;
          if(this.isArray(value)) {
            branchValue = baseObject[property] || []
          }else {
            if(this.$isPlainObject$(value)) {
              branchValue = baseObject[property] || {}
            }
          }
          if(branchValue) {
            baseObject[property] = this.$applyNotFromPrototype$(branchValue, value, forceCopy, deepCopy);
            continue
          }
        }
        if(setValue) {
          baseObject[property] = value
        }
      }
    }
  }
  return baseObject
};
Aura.$Utils$.$Util$.prototype.$CAMEL_CASE_TO_HYPHENS_REGEX$ = /([A-Z])/g;
Aura.$Utils$.$Util$.prototype.$camelCaseToHyphens$ = function(str) {
  return str.replace(this.$CAMEL_CASE_TO_HYPHENS_REGEX$, "-$1").toLowerCase()
};
Aura.$Utils$.$Util$.prototype.$hyphensToCamelCase$ = function(str) {
  function hyphensToCamelCaseHelper(s, group) {
    return group.toUpperCase()
  }
  return str.replace(/-([a-z])/gi, hyphensToCamelCaseHelper)
};
Aura.$Utils$.$Util$.prototype.$toCamelCase$ = function(str) {
  return str.replace(/(?:^\w|[A-Z]|\b\w|\s+|[^\w]+)/g, function(match, index) {
    if(/\s+|[^\w]+/.test(match)) {
      return""
    }
    return index === 0 ? match.toLowerCase() : match.toUpperCase()
  })
};
Aura.$Utils$.$Util$.prototype.$noData$ = {"embed":true, "object":"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000", "applet":true, "#text":true};
Aura.$Utils$.$Util$.prototype.$acceptsData$ = function(element) {
  if(!this.$isHTMLElement$(element)) {
    return false
  }
  if(element.nodeName) {
    var match = this.$noData$[element.nodeName.toLowerCase()];
    if(match) {
      return!(match === true || element.getAttribute("classid") !== match)
    }
  }
  return true
};
Aura.$Utils$.$Util$.prototype.$getElementAttributeValue$ = function(element, attributeName) {
  var attrValue = element.getAttribute(attributeName);
  if($A["util"].$isUndefinedOrNull$(attrValue)) {
    attrValue = element.attributes[attributeName];
    if(!$A["util"].$isUndefinedOrNull$(attrValue)) {
      attrValue = attrValue.nodeValue
    }else {
      if(!$A["util"].$isUndefinedOrNull$(element[attributeName])) {
        attrValue = element[attributeName]
      }else {
        attrValue = null
      }
    }
  }
  return attrValue
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "getElementAttributeValue", Aura.$Utils$.$Util$.prototype.$getElementAttributeValue$);
Aura.$Utils$.$Util$.prototype.$getDataAttribute$ = function(element, key) {
  if(!this.$acceptsData$(element) || this.$isUndefined$(key)) {
    return null
  }
  key = this.$getDataAttributeName$(key);
  return element.getAttribute(key)
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "getDataAttribute", Aura.$Utils$.$Util$.prototype.$getDataAttribute$);
Aura.$Utils$.$Util$.prototype.$setDataAttribute$ = function(element, key, value) {
  if(!this.$acceptsData$(element) || this.$isUndefined$(key)) {
    return null
  }
  key = this.$getDataAttributeName$(key);
  if(!this.$isUndefined$(value)) {
    return element.setAttribute(key, value)
  }
  return element.removeAttribute(key)
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "setDataAttribute", Aura.$Utils$.$Util$.prototype.$setDataAttribute$);
Aura.$Utils$.$Util$.prototype.$getDataAttributeName$ = function(key) {
  var name = this.$dataAttributeCache$[key];
  if(!name) {
    name = "data-" + this.$camelCaseToHyphens$(key);
    this.$dataAttributeCache$[key] = name
  }
  return name
};
Aura.$Utils$.$Util$.prototype.$hasDataAttribute$ = function(element, key) {
  return!this.$isUndefinedOrNull$(this.$getDataAttribute$(element, key))
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "hasDataAttribute", Aura.$Utils$.$Util$.prototype.$hasDataAttribute$);
Aura.$Utils$.$Util$.prototype.$isHTMLElement$ = function(obj) {
  if(typeof HTMLElement === "object") {
    return obj instanceof HTMLElement
  }else {
    return obj && obj.nodeType === 1 && typeof obj.nodeName === "string"
  }
};
Aura.$Utils$.$Util$.prototype.$isSVGElement$ = function(obj) {
  if(obj.$correspondingUseElement$) {
    return obj.$correspondingUseElement$ instanceof SVGElement || obj instanceof SVGElement
  }
  return obj instanceof SVGElement
};
Aura.$Utils$.$Util$.prototype.$attachToDocumentBody$ = function(element) {
  if(element) {
    var body = document.getElementsByTagName("body")[0];
    body.appendChild(element)
  }
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "attachToDocumentBody", Aura.$Utils$.$Util$.prototype.$attachToDocumentBody$);
Aura.$Utils$.$Util$.prototype.$stringEndsWith$ = function(fullstr, substr) {
  var lastIndex = fullstr.lastIndexOf(substr);
  return lastIndex !== -1 && lastIndex + substr.length === fullstr.length
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "stringEndsWith", Aura.$Utils$.$Util$.prototype.$stringEndsWith$);
if(Function.prototype.bind) {
  Aura.$Utils$.$Util$.bind = function(method) {
    var args = Array.prototype.slice.call(arguments, 1);
    return Function.prototype.bind.apply(method, args)
  }
}else {
  Aura.$Utils$.$Util$.bind = function(method) {
    var args = Array.prototype.slice.call(arguments, 1);
    var that = args.shift();
    var util = this instanceof Aura.$Utils$.$Util$ ? this : new Aura.$Utils$.$Util$;
    if(!util.$isFunction$(method)) {
      throw new TypeError("$A.util.bind called on non-function.");
    }
    if(arguments.length === 1) {
      return method
    }
    return function() {
      var remainingArgs = Array.prototype.slice.call(arguments);
      var combined = util.$merge$([], args, remainingArgs);
      return method.apply(that, combined)
    }
  }
}
Aura.$Utils$.$Util$.prototype.bind = Aura.$Utils$.$Util$.bind;
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "bind", Aura.$Utils$.$Util$.prototype.bind);
Aura.$Utils$.$Util$.prototype.$lookup$ = function(object) {
  var properties = Array.prototype.slice.call(arguments, 1);
  var util = this instanceof Aura.$Utils$.$Util$ ? this : new Aura.$Utils$.$Util$;
  return util.reduce(properties, function(current, property) {
    return current && current[property]
  }, object)
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "lookup", Aura.$Utils$.$Util$.prototype.$lookup$);
Aura.$Utils$.$Util$.prototype.$merge$ = function(first) {
  var arrays = Array.prototype.slice.call(arguments, 1);
  var util = this instanceof Aura.$Utils$.$Util$ ? this : new Aura.$Utils$.$Util$;
  if(!arrays) {
    return first
  }
  if(!util.isArray(first)) {
    throw"Merge takes only arrays as arguments.";
  }
  util.forEach(arrays, function(array) {
    if(!util.isArray(array)) {
      throw"Merge takes only arrays as arguments.";
    }
  });
  util.forEach(arrays, function(array) {
    util.forEach(array, function(element) {
      first.push(element)
    })
  });
  return first
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "merge", Aura.$Utils$.$Util$.prototype.$merge$);
if(Array.prototype.forEach) {
  Aura.$Utils$.$Util$.forEach = function(array, method, that) {
    array.forEach(method, that)
  }
}else {
  Aura.$Utils$.$Util$.forEach = function(array, method, that) {
    var util = this instanceof Aura.$Utils$.$Util$ ? this : new Aura.$Utils$.$Util$;
    if(!util.isArray(array)) {
      throw new TypeError("$A.util.forEach called on non-array.");
    }
    if(!util.$isFunction$(method)) {
      throw new TypeError("$A.util.forEach called with non-function callback.");
    }
    var index;
    for(index = 0;index < array.length;index++) {
      method.call(that, array[index], index)
    }
  }
}
Aura.$Utils$.$Util$.prototype.forEach = Aura.$Utils$.$Util$.forEach;
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "forEach", Aura.$Utils$.$Util$.prototype.forEach);
if(Array.prototype.map) {
  Aura.$Utils$.$Util$.map = function(array, method, that) {
    return array.map(method, that)
  }
}else {
  Aura.$Utils$.$Util$.map = function(array, method, that) {
    var util = this instanceof Aura.$Utils$.$Util$ ? this : new Aura.$Utils$.$Util$;
    if(!util.isArray(array)) {
      throw new TypeError("$A.util.map called on non-array.");
    }
    if(!util.$isFunction$(method)) {
      throw new TypeError("$A.util.map called with non-function callback.");
    }
    var index;
    var result = [];
    for(index = 0;index < array.length;index++) {
      result.push(method.call(that, array[index], index))
    }
    return result
  }
}
Aura.$Utils$.$Util$.prototype.map = Aura.$Utils$.$Util$.map;
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "map", Aura.$Utils$.$Util$.prototype.map);
if(Array.prototype.reduce) {
  Aura.$Utils$.$Util$.reduce = function(array, method, initial) {
    return array.reduce(method, initial)
  }
}else {
  Aura.$Utils$.$Util$.reduce = function(array, method, initial) {
    var util = this instanceof Aura.$Utils$.$Util$ ? this : new Aura.$Utils$.$Util$;
    if(!util.isArray(array)) {
      throw new TypeError("$A.util.reduce called on non-array.");
    }
    if(!util.$isFunction$(method)) {
      throw new TypeError("$A.util.reduce called with non-function callback.");
    }
    var index;
    var result = initial;
    for(index = 0;index < array.length;index++) {
      result = method.call(this, result, array[index], index)
    }
    return result
  }
}
Aura.$Utils$.$Util$.prototype.reduce = Aura.$Utils$.$Util$.reduce;
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "reduce", Aura.$Utils$.$Util$.prototype.reduce);
if(Array.prototype.every) {
  Aura.$Utils$.$Util$.every = function(array, predicate, that) {
    return array.every(predicate, that)
  }
}else {
  Aura.$Utils$.$Util$.every = function(array, predicate, that) {
    var util = this instanceof Aura.$Utils$.$Util$ ? this : new Aura.$Utils$.$Util$;
    if(!util.isArray(array)) {
      throw new TypeError("$A.util.every called on non-array.");
    }
    if(!util.$isFunction$(predicate)) {
      throw new TypeError("$A.util.every called with non-function predicate.");
    }
    var index;
    for(index = 0;index < array.length;index++) {
      if(!predicate.call(that, array[index], index)) {
        return false
      }
    }
    return true
  }
}
Aura.$Utils$.$Util$.prototype.every = Aura.$Utils$.$Util$.every;
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "every", Aura.$Utils$.$Util$.prototype.every);
if(Array.prototype.some) {
  Aura.$Utils$.$Util$.some = function(array, predicate, that) {
    return array.some(predicate, that)
  }
}else {
  Aura.$Utils$.$Util$.some = function(array, predicate, that) {
    var util = this instanceof Aura.$Utils$.$Util$ ? this : new Aura.$Utils$.$Util$;
    if(!util.isArray(array)) {
      throw new TypeError("$A.util.some called on non-array.");
    }
    if(!util.$isFunction$(predicate)) {
      throw new TypeError("$A.util.some called with non-function predicate.");
    }
    var index;
    for(index = 0;index < array.length;index++) {
      if(predicate.call(that, array[index], index)) {
        return true
      }
    }
    return false
  }
}
Aura.$Utils$.$Util$.prototype.some = Aura.$Utils$.$Util$.some;
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "some", Aura.$Utils$.$Util$.prototype.some);
if(Array.prototype.filter) {
  Aura.$Utils$.$Util$.filter = function(array, predicate, that) {
    return array.filter(predicate, that)
  }
}else {
  Aura.$Utils$.$Util$.filter = function(array, predicate, that) {
    var util = this instanceof Aura.$Utils$.$Util$ ? this : new Aura.$Utils$.$Util$;
    if(!util.isArray(array)) {
      throw new TypeError("$A.util.filter called on non-array.");
    }
    if(!util.$isFunction$(predicate)) {
      throw new TypeError("$A.util.filter called with non-function predicate.");
    }
    var index;
    var result = [];
    for(index = 0;index < array.length;index++) {
      if(predicate.call(that, array[index], index)) {
        result.push(array[index])
      }
    }
    return result
  }
}
Aura.$Utils$.$Util$.prototype.filter = Aura.$Utils$.$Util$.filter;
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "filter", Aura.$Utils$.$Util$.prototype.filter);
Aura.$Utils$.$Util$.prototype.$destroyAsync$ = function(cmp) {
  if(this.$componentGCProcessing$) {
    if(cmp && cmp.$finishDestroy$) {
      cmp.$finishDestroy$()
    }
  }else {
    this.$trashedComponentQueue$.push(cmp);
    if(!this.$componentGCPending$) {
      this.$componentGCPending$ = true;
      var that = this;
      setTimeout(function() {
        try {
          that.$componentGCProcessing$ = true;
          that.$emptyComponentTrash$()
        }finally {
          that.$componentGCProcessing$ = false
        }
      }, 3E3)
    }
  }
};
Aura.$Utils$.$Util$.prototype.$instanceOf$ = function(instance, constructor) {
  if(instance === null || instance === undefined || constructor === null || constructor === undefined) {
    return false
  }
  if(instance instanceof constructor) {
    return true
  }
  if(instance.$superclass$) {
    for(var superCtor = instance.$superclass$.constructor;superCtor;) {
      if(superCtor === constructor) {
        return true
      }
      superCtor = superCtor.$superclass$ ? superCtor.constructor : undefined
    }
  }
  return false
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "instanceOf", Aura.$Utils$.$Util$.prototype.$instanceOf$);
Aura.$Utils$.$Util$.prototype.$emptyComponentTrash$ = function() {
  var length = this.$trashedComponentQueue$.length;
  if(length > 0) {
    for(var i = 0;i < length;i++) {
      var cmp = this.$trashedComponentQueue$[i];
      if(cmp && cmp.$finishDestroy$) {
        cmp.$finishDestroy$()
      }
    }
    this.$trashedComponentQueue$ = []
  }
  this.$componentGCPending$ = false
};
Aura.$Utils$.$Util$.prototype.contains = function(container, element) {
  $A.assert($A["util"].$isHTMLElement$(container) || $A["util"].$isSVGElement$(container), "$A.util.conatins(): 'container' must be HTMLElement or SVGElement: " + container);
  for($A.assert($A["util"].$isHTMLElement$(element) || $A["util"].$isSVGElement$(element), "$A.util.conatins(): 'element' must be HTMLElement or SVGElement: " + element);element;) {
    if(element === container) {
      return true
    }
    element = element.parentNode
  }
  return false
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "contains", Aura.$Utils$.$Util$.prototype.contains);
Aura.$Utils$.$Util$.prototype.$squash$ = function(event, preventDefault) {
  event = event || window.event;
  if(event.stopPropagation) {
    event.stopPropagation()
  }
  event.cancelBubble = true;
  if(preventDefault) {
    if(event.preventDefault) {
      event.preventDefault()
    }
    event.returnValue = false
  }
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "squash", Aura.$Utils$.$Util$.prototype.$squash$);
Aura.$Utils$.$Util$.prototype.$stripTags$ = function(input, tags) {
  if(this.$isUndefinedOrNull$(input) || this.$isEmpty$(input)) {
    return""
  }
  var div = document.createElement("div");
  div.innerHTML = input;
  if(!this.isArray(tags)) {
    tags = [tags]
  }
  for(var j = 0;j < tags.length;j++) {
    var elems = div.getElementsByTagName(tags[j]);
    for(var i = elems.length;i--;) {
      elems[i].parentNode.removeChild(elems[i])
    }
  }
  var result = div.innerHTML;
  this.$removeElement$(div);
  return result
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "stripTags", Aura.$Utils$.$Util$.prototype.$stripTags$);
Aura.$Utils$.$Util$.prototype.$getWindowSize$ = function() {
  return{width:window.innerWidth || document.body.clientWidth || 0, height:window.innerHeight || document.body.clientHeight || 0}
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "getWindowSize", Aura.$Utils$.$Util$.prototype.$getWindowSize$);
Aura.$Utils$.$Util$.prototype.$isComponent$ = function(obj) {
  return obj instanceof Component
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "isComponent", Aura.$Utils$.$Util$.prototype.$isComponent$);
Aura.$Utils$.$Util$.prototype.$isExpression$ = function(obj) {
  return obj instanceof PropertyReferenceValue || obj instanceof FunctionCallValue
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "isExpression", Aura.$Utils$.$Util$.prototype.$isExpression$);
Aura.$Utils$.$Util$.prototype.$isValue$ = function(obj) {
  return obj instanceof PropertyReferenceValue || obj instanceof FunctionCallValue || obj instanceof PassthroughValue
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "isValue", Aura.$Utils$.$Util$.prototype.$isValue$);
Aura.$Utils$.$Util$.prototype.$isAction$ = function(obj) {
  return obj instanceof Action
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "isAction", Aura.$Utils$.$Util$.prototype.$isAction$);
Aura.$Utils$.$Util$.prototype.$isEvent$ = function(obj) {
  return obj instanceof Aura.$Event$.$Event$
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "isEvent", Aura.$Utils$.$Util$.prototype.$isEvent$);
Aura.$Utils$.$Util$.prototype.$supportsTouchEvents$ = function() {
  if($A["util"].$isUndefined$(this.$supportsTouchEvents$.$cache$)) {
    this.$supportsTouchEvents$.$cache$ = (($A.get("$Browser.formFactor") !== "DESKTOP" || $A.get("$Browser.isIOS") || $A.get("$Browser.isAndroid")) && "ontouchstart" in window || $A.get("$Browser.isWindowsPhone") && (window["navigator"]["pointerEnabled"] || window["navigator"]["msPointerEnabled"]) || $A.get("$Browser.formFactor") !== "DESKTOP" && (window["navigator"]["msMaxTouchPoints"] > 0 || window["navigator"]["maxTouchPoints"] > 0)) && $A.getContext().$getMode$() !== "PTEST" && $A.getContext().$getMode$() !== 
    "CADENCE" && $A.getContext().$getMode$() !== "SELENIUM" && $A.getContext().$getMode$() !== "STATS" && $A.getContext().$getMode$() !== "SELENIUMDEBUG"
  }
  return this.$supportsTouchEvents$.$cache$
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "supportsTouchEvents", Aura.$Utils$.$Util$.prototype.$supportsTouchEvents$);
Aura.$Utils$.$Util$.prototype.$estimateSize$ = function(obj) {
  return this.$sizeEstimator$.$estimateSize$(obj)
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "estimateSize", Aura.$Utils$.$Util$.prototype.$estimateSize$);
Aura.$Utils$.$Util$.prototype.$toArray$ = function(collection) {
  if(this.$isUndefinedOrNull$(collection)) {
    return[]
  }
  try {
    return Array.prototype.slice.call(collection)
  }catch(e) {
    var length = collection.length;
    var newCollection = new Array(length);
    for(var c = 0;c < length;c++) {
      newCollection[c] = collection[c]
    }
    return newCollection
  }
};
Aura.$Utils$.$Util$.prototype.$setText$ = function(node, text) {
  if(node.textContent !== undefined) {
    node.textContent = text
  }else {
    if(node.innerText !== undefined) {
      node.innerText = text
    }
  }
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "setText", Aura.$Utils$.$Util$.prototype.$setText$);
Aura.$Utils$.$Util$.prototype.postMessage = function(targetWindow, argsArray) {
  if(targetWindow && targetWindow["postMessage"]) {
    targetWindow["postMessage"].apply(targetWindow, argsArray)
  }
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "postMessage", Aura.$Utils$.$Util$.prototype.postMessage);
Aura.$Utils$.$Util$.prototype.$getComponentHierarchy$ = function(component) {
  if(this.$isUndefinedOrNull$(component)) {
    return""
  }
  var ret = ["[" + component.$getType$() + "]"];
  for(var owner = component.$getOwner$();!this.$isUndefinedOrNull$(owner) && owner !== owner.$getOwner$();) {
    ret.push("[" + owner.$getType$() + "]");
    owner = owner.$getOwner$()
  }
  if(!this.$isUndefinedOrNull$(owner)) {
    ret.push("[" + owner.$getType$() + "]")
  }
  return ret.reverse().join("\x3e")
};
Aura.$Utils$.$Util$.prototype.$hasSourceURL$ = function() {
  if(this.$sourceURLsupported$ === undefined) {
    try {
      this.$globalEval$("(undefined).x", "testSourceURL.js")
    }catch(e) {
      this.$sourceURLsupported$ = e.stack.indexOf("testSourceURL.js") > -1
    }
  }
  return this.$sourceURLsupported$
};
Aura.$Utils$.$Util$.prototype.$getDebugToolComponent$ = function() {
  if(!this.$isUndefinedOrNull$(this.$debugToolWindow$)) {
    var debugElem = this.$debugToolWindow$.document.getElementById("__aura_debug_tool");
    if(!this.$isUndefinedOrNull$(debugElem)) {
      return this.$debugToolWindow$["aura"].$componentService$.$getAttributeProviderForElement$(debugElem)
    }
  }
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "getDebugToolComponent", Aura.$Utils$.$Util$.prototype.$getDebugToolComponent$);
Aura.$Utils$.$Util$.prototype.$getDebugToolsAuraInstance$ = function() {
  if(!this.$isUndefinedOrNull$(this.$debugToolWindow$)) {
    return this.$debugToolWindow$["aura"]
  }else {
    return $A
  }
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "getDebugToolsAuraInstance", Aura.$Utils$.$Util$.prototype.$getDebugToolsAuraInstance$);
Aura.$Utils$.$Util$.prototype.$setDebugToolWindow$ = function(debugWindow) {
  if(!this.$isUndefinedOrNull$(debugWindow)) {
    this.$debugToolWindow$ = debugWindow
  }
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "setDebugToolWindow", Aura.$Utils$.$Util$.prototype.$setDebugToolWindow$);
Aura.$Utils$.$Util$.prototype.$getUrl$ = function() {
  if(this.$isUndefinedOrNull$(opener)) {
    return window.location.href
  }else {
    return opener.location.href
  }
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "getUrl", Aura.$Utils$.$Util$.prototype.$getUrl$);
Aura.$Utils$.$Util$.prototype.$getText$ = function(node) {
  $A.assert(!this.$isUndefinedOrNull$(node), "node cannot be undefined or null");
  var t = node.textContent;
  if(t === undefined) {
    t = node.innerText || ""
  }
  if(t === "") {
    if(node.nodeType === 3) {
      return node.nodeValue
    }
    if(node.tagName === "STYLE" && !this.$isUndefinedOrNull$(node.styleSheet)) {
      return node.styleSheet.cssText || ""
    }
  }
  return t
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "getText", Aura.$Utils$.$Util$.prototype.$getText$);
Aura.$Utils$.$Util$.prototype.$includeScript$ = function(url, callback) {
  if(this.$isUndefined$(this.$includeScript$.$cache$)) {
    this.$includeScript$.$cache$ = {}
  }
  var cache = this.$includeScript$.$cache$;
  var script = cache[url];
  if(script) {
    if(script.state === "LOADED") {
      callback.call()
    }else {
      script.$queue$.push(callback)
    }
  }else {
    cache[url] = {state:"LOADING", $queue$:[callback]};
    var s = document.createElement("script");
    s.src = url;
    s.onload = function() {
      cache[url].state = "LOADED";
      for(var queue = cache[url].$queue$;queue.length > 0;) {
        queue.shift().call()
      }
    };
    document.head.appendChild(s).parentNode.removeChild(s)
  }
};
goog.$exportProperty$(Aura.$Utils$.$Util$.prototype, "includeScript", Aura.$Utils$.$Util$.prototype.$includeScript$);
function Logger() {
  this.$subscribers$ = [];
  this.$INFO$ = "INFO";
  this.$WARNING$ = "WARNING";
  this.$ASSERT$ = "ASSERT";
  this.$ERROR$ = "ERROR";
  this.$subscriptions$ = {};
  this.$subscriptions$[this.$INFO$] = 0;
  this.$subscriptions$[this.$WARNING$] = 0;
  this.$subscriptions$[this.$ASSERT$] = 0;
  this.$subscriptions$[this.$ERROR$] = 0
}
goog.$exportSymbol$("Logger", Logger);
Logger.prototype.info = function(info, error) {
  this.log(this.$INFO$, info, error)
};
goog.$exportProperty$(Logger.prototype, "info", Logger.prototype.info);
Logger.prototype.$warning$ = function(warning, error) {
  this.log(this.$WARNING$, warning, error)
};
goog.$exportProperty$(Logger.prototype, "warning", Logger.prototype.$warning$);
Logger.prototype.assert = function(condition, assertMessage) {
  if(!condition) {
    var message = "Assertion Failed!: " + assertMessage + " : " + condition;
    this.log(this.$ASSERT$, message)
  }
};
goog.$exportProperty$(Logger.prototype, "assert", Logger.prototype.assert);
Logger.prototype.error = function(msg, e) {
  $A.$deprecated$("Logger.error is no longer supported.", null, "2017/09/20", "2017/10/20", "Logger.error");
  var logMsg = msg || "";
  if(!e) {
    e = undefined
  }else {
    if(!(e instanceof Error) && !$A["util"].$isError$(e)) {
      if($A["util"].$isObject$(e) && e.message) {
        var stk = e.stack;
        e = new Error("caught " + e.message);
        if(stk) {
          e.stack = stk
        }
      }else {
        e = new Error("caught " + $A["util"].$json$.$encode$(e))
      }
    }
  }
  if(e && !$A["util"].$isUndefinedOrNull$(e.message) && e.message !== "") {
    if(logMsg.length) {
      logMsg = logMsg + " : " + e.message
    }else {
      logMsg = e.message
    }
  }
  var stack = this.$getStackTrace$(e, 1);
  if(stack && !e) {
    e = new $A.$auraError$(msg);
    e.name = Error.prototype.name;
    e.stack = stack;
    e.$stackTrace$ = e.stack
  }
  if(!$A.$initialized$) {
    $A["hasErrors"] = true
  }
  this.log(this.$ERROR$, logMsg, e)
};
goog.$exportProperty$(Logger.prototype, "error", Logger.prototype.error);
Logger.prototype.$reportError$ = function(e, action, level, foreground) {
  if(!e || e["reported"]) {
    return
  }
  if(!level || !this.$isValidLevel$(level)) {
    level = this.$ERROR$
  }
  var errorAction = action || e.action;
  var actionDescriptor = undefined;
  if(errorAction && errorAction.$getDef$) {
    var actionDef = errorAction.$getDef$();
    if(actionDef) {
      actionDescriptor = actionDef.$getDescriptor$()
    }
  }
  if(!(e instanceof $A.$auraError$)) {
    e = new $A.$auraError$(null, e)
  }
  if(!e["component"] || !e["stacktraceIdGen"]) {
    var component = e.$findComponentFromStackTrace$();
    e.$setComponent$(component)
  }
  var reportAction = $A.get("c.aura://ComponentController.reportFailedAction");
  if(!foreground) {
    reportAction.$setCaboose$()
  }
  reportAction.$setParams$({"failedAction":actionDescriptor || e["component"], "failedId":e.id && e.id.toString(), "clientError":e.toString(), "clientStack":(e.$stackTrace$ || e.stack || "").toString().substr(0, Aura.$Utils$.$Logger$.$MAX_STACKTRACE_SIZE$), "componentStack":e["componentStack"] || "", "stacktraceIdGen":e["stacktraceIdGen"], "level":level});
  reportAction.$setCallback$(this, function() {
  });
  $A.$clientService$.$enqueueAction$(reportAction);
  e["reported"] = true
};
Logger.prototype.$isExternalError$ = function(e) {
  if(!e) {
    return false
  }
  var errorframes = this.$generateStackFrames$(e);
  var i = 0;
  for(var len = errorframes.length;i < len;i++) {
    var fileName = errorframes[i].fileName;
    if(!fileName) {
      continue
    }
    if(i === 0 && fileName.indexOf("chrome-extension://") > -1) {
      return true
    }
    if(this.$isAuraFile$(fileName)) {
      return false
    }
  }
  return true
};
Logger.prototype.$isExternalRaisedError$ = function(e) {
  if(!e) {
    return false
  }
  var errorframes = this.$generateStackFrames$(e);
  var fileName = errorframes[0] && errorframes[0].fileName;
  return!this.$isAuraFile$(fileName)
};
Logger.prototype.$generateStackFrames$ = function(e) {
  if(e instanceof $A.$auraError$) {
    return e.$stackFrames$
  }
  return Aura.$Errors$.$StackParser$.parse(e)
};
Logger.prototype.$isAuraFile$ = function(fileName) {
  if(!fileName) {
    return false
  }
  return fileName.match(/aura_[^\.]+\.js$/gi) || fileName.match("engine.js") || fileName.match("engine.min.js") || fileName.indexOf("/components/") > -1 || fileName.indexOf("/libraries/") > -1 || fileName.indexOf("/jslibrary/") > -1 || fileName.indexOf("/auraFW/resources/") > -1 || fileName.match("appcore.js") || fileName.match("app.js")
};
Logger.prototype.log = function(level, message, error) {
  if(this.$hasSubscriptions$(level)) {
    this.$notify$(level, message, error)
  }
};
Logger.prototype.$notify$ = function(level, msg, error) {
  var subsLength = this.$subscribers$.length;
  for(var i = 0;i < subsLength;i++) {
    var sub = this.$subscribers$[i];
    if(sub.$level$ === level) {
      sub.$fn$.apply(undefined, [level, msg, error])
    }
  }
};
Logger.prototype.$getStackTrace$ = function(e, remove) {
  $A.$deprecated$("Logger.getStackTrace is no longer supported.", null, "2017/09/20", "2017/10/20", "Logger.getStackTrace");
  if(e && e instanceof $A.$auraError$) {
    return e.$stackTrace$
  }
  var stack = undefined;
  if(!remove) {
    remove = 0
  }
  if(!e || !e.stack) {
    try {
      throw new Error("foo");
    }catch(f) {
      e = f;
      remove += 2
    }
  }
  if(e) {
    stack = e.stack
  }
  var chromeStart = "Error: " + e.message;
  if(stack && stack.indexOf(chromeStart) === 0) {
    stack = stack.substring(chromeStart.length + 1)
  }
  if(stack) {
    var ret = stack.replace(/(?:\n@:0)?\s+$/m, "");
    ret = ret.replace(new RegExp("^\\(", "gm"), "{anonymous}(");
    ret = ret.split("\n");
    if(remove !== 0) {
      ret.splice(0, remove)
    }
    return ret.join("\n")
  }
  return null
};
goog.$exportProperty$(Logger.prototype, "getStackTrace", Logger.prototype.$getStackTrace$);
Logger.prototype.$stringVersion$ = function(logMsg, error, trace) {
  var stringVersion = !$A["util"].$isUndefinedOrNull$(logMsg) ? logMsg : "";
  if(!$A["util"].$isUndefinedOrNull$(error) && !$A["util"].$isUndefinedOrNull$(error.message)) {
    stringVersion += " : " + error.message
  }
  if(!$A["util"].$isUndefinedOrNull$(trace)) {
    stringVersion += "\nStack: " + trace.join("\n")
  }
  return stringVersion
};
goog.$exportProperty$(Logger.prototype, "stringVersion", Logger.prototype.$stringVersion$);
Logger.prototype.$subscribe$ = function(level, callback) {
  level = level.toUpperCase();
  this.$validateSubscriber$(level, callback);
  this.$subscribers$.push({$level$:level, $fn$:callback});
  this.$subscriptions$[level] += 1
};
goog.$exportProperty$(Logger.prototype, "subscribe", Logger.prototype.$subscribe$);
Logger.prototype.$unsubscribe$ = function(level, callback) {
  level = level.toUpperCase();
  this.$validateSubscriber$(level, callback);
  var subsLength = this.$subscribers$.length;
  for(var i = subsLength - 1;i >= 0;i--) {
    var sub = this.$subscribers$[i];
    if(sub.$level$ === level && sub.$fn$ === callback) {
      this.$subscribers$.splice(i, 1);
      this.$subscriptions$[level] -= 1
    }
  }
};
goog.$exportProperty$(Logger.prototype, "unsubscribe", Logger.prototype.$unsubscribe$);
Logger.prototype.$isValidLevel$ = function(level) {
  return level === this.$INFO$ || level === this.$WARNING$ || level === this.$ASSERT$ || level === this.$ERROR$
};
Logger.prototype.$validateSubscriber$ = function(level, callback) {
  if(!this.$isValidLevel$(level)) {
    throw new Error("Please specify valid log level: 'INFO', 'WARNING', 'ASSERT', 'ERROR'");
  }
  if(typeof callback !== "function") {
    throw new Error("Logging callback must be a function");
  }
};
Logger.prototype.$hasSubscriptions$ = function(level) {
  level = level.toUpperCase();
  return this.$isValidLevel$(level) && this.$subscriptions$[level] > 0
};
Logger.prototype.$devDebugConsoleLog$ = function(level, message, error) {
  var stringVersion = null;
  var trace;
  var logMsg = level + ": " + (message || "");
  if(message) {
    stringVersion = level + ": " + message
  }
  if(error && error.message) {
    stringVersion += " : " + error.message
  }
  if(error || level === "ERROR") {
    trace = $A.$logger$.$getStackTrace$(error)
  }
  if(window["console"]) {
    var console = window["console"];
    var filter = level === "WARNING" ? "warn" : level.toLowerCase();
    if(console[filter]) {
      console[filter]("%s", message);
      if(error) {
        if(error["component"]) {
          console[filter]("%s", "Failing component: " + error["component"])
        }
        if(error["componentStack"]) {
          console[filter]("%s", "Failing component stack: " + error["componentStack"])
        }
        console[filter]("%o", error)
      }
      if((filter === "error" || filter === "warn") && trace) {
        if($A["util"].$isString$(trace)) {
          console[filter]("%s", trace)
        }else {
          for(var j = 0;j < trace.length;j++) {
            console[filter]("%s", trace[j])
          }
        }
      }
    }else {
      if(console["group"]) {
        console["group"](logMsg);
        console["debug"](message);
        if(error) {
          console["debug"](error)
        }
        if(trace) {
          console["group"]("stack");
          for(var i = 0;i < trace.length;i++) {
            console["debug"](trace[i])
          }
          console["groupEnd"]()
        }
        console["groupEnd"]()
      }else {
        stringVersion = $A.$logger$.$stringVersion$(logMsg, error, trace);
        if(console["debug"]) {
          console["debug"](stringVersion)
        }else {
          if(console["log"]) {
            console["log"](stringVersion)
          }
        }
      }
    }
  }
};
Aura.$Utils$.$Logger$ = Logger;
Aura.$Utils$.$Logger$.$MAX_STACKTRACE_SIZE$ = 25E3;
Aura.$Utils$.$Override$ = function Override(instance, orig, proto, replace, restore) {
  $A.assert($A["util"].$isObject$(instance) || instance === null, "Override: instance must be an object or null");
  $A.assert($A["util"].$isFunction$(orig), "Override: orig argument must be a function");
  $A.assert(proto === true || proto === false, "Override: Proto argument must be supplied");
  $A.assert($A["util"].$isFunction$(replace), "Override: replace must be a function");
  $A.assert($A["util"].$isFunction$(restore), "Override: restore must be a function");
  $A.assert(!instance === proto, "OverrideMapDef: instance argument must match !proto");
  this.$instance$ = instance;
  this.$orig$ = orig;
  this.$proto$ = proto;
  this.replace = replace;
  this.restore = restore;
  this.$chain$ = [];
  this.$currentInstance$ = instance
};
Aura.$Utils$.$Override$.prototype.$install$ = function(fn, scope, priority) {
  var obj = {};
  var i;
  var posn;
  obj.scope = scope;
  obj.$fn$ = fn;
  obj.$priority$ = priority;
  if(this.$chain$.length === 0) {
    var bound;
    if(this.$proto$) {
      var that = this;
      bound = function() {
        var config = {"self":this};
        config.$that$ = that;
        config.$walkIndex$ = 0;
        that.$continuation$.apply(config, arguments)
      }
    }else {
      bound = this.start.bind(this)
    }
    this.replace(bound)
  }
  for(i = 0;i < this.$chain$.length;i++) {
    if(this.$chain$.$priority$ > priority) {
      posn = i;
      break
    }
  }
  if(posn !== undefined) {
    this.$chain$.splice(posn, 0, obj)
  }else {
    this.$chain$.push(obj)
  }
};
Aura.$Utils$.$Override$.prototype.$uninstall$ = function(fn) {
  var i;
  for(i = 0;i < this.$chain$.length;i++) {
    if(this.$chain$[i].$fn$ === fn) {
      this.$chain$.splice(i, 1);
      break
    }
  }
  if(this.$chain$.length === 0) {
    var bound;
    if(this.$instance$) {
      bound = this.$orig$.bind(this.$instance$)
    }
    this.restore(this.$orig$, bound);
    return true
  }
  return false
};
Aura.$Utils$.$Override$.prototype.start = function() {
  var config = {"self":this.$instance$};
  config.$that$ = this;
  config.$walkIndex$ = 0;
  return this.$continuation$.apply(config, arguments)
};
Aura.$Utils$.$Override$.prototype.$continuation$ = function() {
  var next;
  var keepGoing = true;
  var config = this;
  var that = config.$that$;
  if(config.$walkIndex$ < that.$chain$.length) {
    next = that.$chain$[config.$walkIndex$++];
    keepGoing = config.$walkIndex$ < that.$chain$.length || that.$last$
  }else {
    next = that.$last$;
    keepGoing = false
  }
  if(keepGoing) {
    config["scope"] = config;
    config["fn"] = that.$continuation$
  }else {
    config["scope"] = config["self"];
    config["fn"] = that.$orig$
  }
  Array.prototype.unshift.call(arguments, config);
  return next.$fn$.apply(next.scope, arguments)
};
function AuraError(message, innerError, severity) {
  function getStackFrames(e) {
    var remove = 0;
    if(!e || !e.stack) {
      try {
        throw new Error("foo");
      }catch(f) {
        e = f;
        remove += 3
      }
    }
    return Aura.$Errors$.$StackParser$.parse(e).slice(remove)
  }
  function getStackTrace(frames) {
    var filtered = [];
    var nonFrameworkStackFrameExist = false;
    var isNonFrameworkStackFrame = false;
    for(var i = 0;i < frames.length;i++) {
      isNonFrameworkStackFrame = !frames[i].fileName || frames[i].fileName.match(/aura_[^\.]+\.js$/gi) === null;
      if(!nonFrameworkStackFrameExist) {
        filtered.push(frames[i]);
        nonFrameworkStackFrameExist = isNonFrameworkStackFrame
      }else {
        if(isNonFrameworkStackFrame) {
          filtered.push(frames[i])
        }
      }
    }
    return filtered.join("\n")
  }
  this["component"] = "";
  this["componentStack"] = "";
  this.action = null;
  if(message == null) {
    message = ""
  }
  this.name = innerError ? innerError.name : "AuraError";
  this.message = message + (innerError ? " [" + (innerError.message || innerError.toString()) + "]" : "");
  this.$stackFrames$ = getStackFrames(innerError);
  this.$stackTrace$ = getStackTrace(this.$stackFrames$);
  this.severity = innerError ? innerError.severity || severity : severity;
  this["handled"] = innerError ? innerError["handled"] || false : false;
  this["reported"] = innerError ? innerError["reported"] || false : false;
  this["name"] = this.name;
  this["message"] = this.message;
  this["stackTrace"] = this.$stackTrace$;
  this["severity"] = this.severity;
  this["data"] = null;
  this["stackFrames"] = this.$stackFrames$;
  this["stacktraceIdGen"] = "";
  this["id"] = "";
  if(typeof $A !== "undefined" && $A.$clientService$) {
    var currentAccess = $A.$clientService$.$getCurrentAccessName$();
    if(currentAccess) {
      this.$setComponent$(currentAccess);
      this["componentStack"] = $A.$clientService$.$getAccessStackHierarchy$()
    }
  }
}
Aura.$Errors$.$MurmurHash3$ = {$mul32$:function(m, n) {
  var nlo = n & 65535;
  var nhi = n - nlo;
  return(nhi * m | 0) + (nlo * m | 0) | 0
}, $hashString$:function(data) {
  var c1 = 3432918353;
  var c2 = 461845907;
  var h1 = 0;
  var len = data.length;
  for(var i = 1;i < len;i += 2) {
    var k1 = data.charCodeAt(i - 1) | data.charCodeAt(i) << 16;
    k1 = this.$mul32$(k1, c1);
    k1 = (k1 & 131071) << 15 | k1 >>> 17;
    k1 = this.$mul32$(k1, c2);
    h1 ^= k1;
    h1 = (h1 & 524287) << 13 | h1 >>> 19;
    h1 = h1 * 5 + 3864292196 | 0
  }
  if(len % 2 === 1) {
    k1 = data.charCodeAt(len - 1);
    k1 = this.$mul32$(k1, c1);
    k1 = (k1 & 131071) << 15 | k1 >>> 17;
    k1 = this.$mul32$(k1, c2);
    h1 ^= k1
  }
  h1 ^= len << 1;
  h1 ^= h1 >>> 16;
  h1 = this.$mul32$(h1, 2246822507);
  h1 ^= h1 >>> 13;
  h1 = this.$mul32$(h1, 3266489909);
  h1 ^= h1 >>> 16;
  return h1
}};
Aura.$Errors$.$GenerateErrorId$ = function(hashGen) {
  return Aura.$Errors$.$MurmurHash3$.$hashString$(hashGen)
};
Aura.$Errors$.$GenerateErrorIdHashGen$ = function(componentName, stackFrames) {
  var hashGen = componentName;
  for(var i = 0;i < stackFrames.length;i++) {
    var frame = stackFrames[i];
    if(!frame.fileName || frame.fileName.match(/aura_[^\.]+\.js$/gi) === null) {
      hashGen = hashGen + "$" + frame.functionName;
      break
    }
  }
  return hashGen
};
AuraError.prototype = new Error;
AuraError.prototype.constructor = AuraError;
AuraError.prototype.toString = function() {
  return this.message || Error.prototype.toString()
};
AuraError.prototype.$setStackTrace$ = function(trace) {
  this.$stackTrace$ = trace
};
AuraError.prototype.$findComponentFromStackTrace$ = function() {
  for(var i = 0;i < this.$stackFrames$.length;i++) {
    var frame = this.$stackFrames$[i];
    var fileName = frame.fileName;
    if(fileName && fileName.match(/aura_[^\.]+\.js$/gi) === null) {
      var pathParts = fileName.replace(".js", "").split("/");
      if(pathParts[pathParts.length - 3] === "components") {
        return"markup://" + pathParts.slice(-2).join(":")
      }
      if(pathParts[pathParts.length - 4] === "libraries") {
        pathParts = pathParts.slice(-3);
        return"js://" + pathParts[0] + ":" + pathParts[1] + "." + pathParts[2]
      }
      if(pathParts[pathParts.length - 2] === "components") {
        var moduleName = pathParts[pathParts.length - 1];
        pathParts = moduleName.split(/-(.+)/);
        return pathParts[0] + ":" + $A["util"].$hyphensToCamelCase$(pathParts[1])
      }
    }
  }
  return""
};
AuraError.prototype.$setComponent$ = function(component) {
  this["component"] = component;
  this["stacktraceIdGen"] = Aura.$Errors$.$GenerateErrorIdHashGen$(component, this.$stackFrames$);
  this["id"] = Aura.$Errors$.$GenerateErrorId$(this["stacktraceIdGen"])
};
Aura.$Errors$.$AuraError$ = AuraError;
Aura.$Errors$.$AuraFriendlyError$ = function AuraFriendlyError() {
  Aura.$Errors$.$AuraError$.apply(this, arguments);
  this.name = "AuraFriendlyError"
};
Aura.$Errors$.$AuraFriendlyError$.prototype = new Aura.$Errors$.$AuraError$;
Aura.$Errors$.$AuraFriendlyError$.prototype.constructor = Aura.$Errors$.$AuraFriendlyError$;
Aura.$Errors$.$AuraFriendlyError$.prototype.toString = function() {
  var ret = Error.prototype.toString.apply(this);
  if(this["data"]) {
    ret = ret + "\n\t[custom data: " + JSON.stringify(this["data"]) + "]"
  }
  return ret
};
function DefDescriptor(descriptor) {
  var prefix = DefDescriptor.normalize(descriptor).split("://");
  var namespace = prefix[1].split(/[:.]/);
  var hasNamespace = namespace.length > 1;
  var separator = hasNamespace ? prefix[1].indexOf(":") > -1 ? ":" : "." : "";
  this.prefix = prefix[0];
  this.$namespace$ = hasNamespace ? namespace[0] : "";
  this.name = namespace[hasNamespace ? 1 : 0];
  this.$fullName$ = this.$namespace$ + separator + this.name;
  this.$qualifiedName$ = this.prefix + "://" + this.$fullName$
}
goog.$exportSymbol$("DefDescriptor", DefDescriptor);
DefDescriptor.$DESCRIPTOR$ = "descriptor";
DefDescriptor.normalize = function(descriptor) {
  if(descriptor && descriptor.hasOwnProperty(DefDescriptor.$DESCRIPTOR$)) {
    descriptor = descriptor[DefDescriptor.$DESCRIPTOR$]
  }
  if(!descriptor) {
    throw new $A.$auraError$("DefDescriptor.normalize(): 'descriptor' must be a valid config Object or String.", null, $A.severity.$QUIET$);
  }
  if((descriptor + "").indexOf("://") < 0) {
    descriptor = "markup://" + descriptor
  }
  return descriptor
};
DefDescriptor.prototype.$getQualifiedName$ = function() {
  return this.$qualifiedName$
};
goog.$exportProperty$(DefDescriptor.prototype, "getQualifiedName", DefDescriptor.prototype.$getQualifiedName$);
DefDescriptor.prototype.$getFullName$ = function() {
  return this.$fullName$
};
goog.$exportProperty$(DefDescriptor.prototype, "getFullName", DefDescriptor.prototype.$getFullName$);
DefDescriptor.prototype.$getNamespace$ = function() {
  return this.$namespace$
};
goog.$exportProperty$(DefDescriptor.prototype, "getNamespace", DefDescriptor.prototype.$getNamespace$);
DefDescriptor.prototype.getName = function() {
  return this.name
};
goog.$exportProperty$(DefDescriptor.prototype, "getName", DefDescriptor.prototype.getName);
DefDescriptor.prototype.$getPrefix$ = function() {
  return this.prefix
};
goog.$exportProperty$(DefDescriptor.prototype, "getPrefix", DefDescriptor.prototype.$getPrefix$);
DefDescriptor.prototype.toString = function() {
  return this.$getQualifiedName$()
};
goog.$exportProperty$(DefDescriptor.prototype, "toString", DefDescriptor.prototype.toString);
Aura.$System$.$DefDescriptor$ = DefDescriptor;
function StyleDef(config) {
  this.code = config[Json.$ApplicationKey$.$CODE$];
  this.className = config[Json.$ApplicationKey$.$CLASSNAME$];
  this.$descriptor$ = new DefDescriptor(config[Json.$ApplicationKey$.$DESCRIPTOR$]);
  this.$preloaded$ = $A["util"].$isUndefinedOrNull$(this.code)
}
StyleDef.prototype.apply = function() {
  var element = this.element;
  var code = this.code;
  if(!element && code) {
    element = aura["util"].style.apply(code);
    this.element = element
  }
  delete this.code
};
StyleDef.prototype.remove = function() {
};
StyleDef.prototype.$getClassName$ = function() {
  return this.className
};
StyleDef.prototype.$getDescriptor$ = function() {
  return this.$descriptor$
};
goog.$exportSymbol$("StyleDef.prototype.getDescriptor", StyleDef.prototype.$getDescriptor$);
StyleDef.prototype.$isPreloaded$ = function() {
  return this.$preloaded$
};
Aura.$Style$.$StyleDef$ = StyleDef;
function FlavorDefaultDef(config) {
  this.map = {};
  if(!$A["util"].$isUndefinedOrNull$(config["removeAll"])) {
    this.$removeAll$ = config["removeAll"]
  }else {
    for(var key in config) {
      if(config.hasOwnProperty(key)) {
        this.map[key] = {$flavor$:config[key]["flavor"]}
      }
    }
  }
}
FlavorDefaultDef.prototype.$getFlavor$ = function(componentDescriptor) {
  if(!$A["util"].$isUndefinedOrNull$(this.$removeAll$)) {
    if(this.$removeAll$ === "*" || this.$removeAll$ === componentDescriptor.$getNamespace$()) {
      return"{!remove}"
    }
  }
  var entry = this.map[componentDescriptor.$getQualifiedName$()];
  if(entry) {
    return entry.$flavor$
  }
  return null
};
Aura.$Flavors$.$FlavorDefaultDef$ = FlavorDefaultDef;
function FlavorsDef(config) {
  this.$flavors$ = [];
  this.$cache$ = {};
  var flavorDefaultDefs = config["flavorDefaultDefs"];
  for(var i = flavorDefaultDefs.length - 1;i >= 0;i--) {
    this.$flavors$.push(new FlavorDefaultDef(flavorDefaultDefs[i]))
  }
}
FlavorsDef.prototype.$getFlavor$ = function(componentDescriptor) {
  var qn = componentDescriptor.$getQualifiedName$();
  if($A["util"].$isUndefined$(this.$cache$[qn])) {
    var found;
    var i = 0;
    for(var len = this.$flavors$.length;i < len && !found;i++) {
      found = this.$flavors$[i].$getFlavor$(componentDescriptor)
    }
    this.$cache$[qn] = found || null
  }
  return this.$cache$[qn]
};
Aura.$Flavors$.$FlavorsDef$ = FlavorsDef;
function PropertyReferenceValue(path, valueProvider) {
  var isArray = $A["util"].isArray(path);
  this.path = isArray ? path : path.split(".");
  this.$expression$ = isArray ? path.join(".") : path;
  this.$isGlobal$ = this.$expression$.charAt(0) === "$";
  this.$valueProvider$ = this.$isGlobal$ ? null : valueProvider;
  this.$context$ = this.$isGlobal$ ? null : valueProvider instanceof PassthroughValue ? valueProvider : $A.$clientService$.$currentAccess$;
  this.$lastResult$ = null;
  this.$isValid$ = true
}
goog.$exportSymbol$("PropertyReferenceValue", PropertyReferenceValue);
PropertyReferenceValue.prototype.evaluate = function(valueProvider) {
  if(this.$isValid$) {
    if(this.$isGlobal$) {
      this.$lastResult$ = aura.get(this.$expression$);
      return this.$lastResult$
    }
    if(!valueProvider) {
      valueProvider = this.$valueProvider$
    }
    $A.$clientService$.$setCurrentAccess$(this.$context$);
    try {
      var result = valueProvider.get(this.$expression$);
      this.$lastResult$ = result;
      return result
    }finally {
      $A.$clientService$.$releaseCurrentAccess$()
    }
  }
};
PropertyReferenceValue.prototype.set = function(value) {
  if(this.$isValid$) {
    if(this.$isGlobal$) {
      return aura.set(this.$expression$, value)
    }
    $A.$clientService$.$setCurrentAccess$(this.$context$);
    try {
      var result = this.$valueProvider$.set(this.$expression$, value);
      return result
    }finally {
      $A.$clientService$.$releaseCurrentAccess$()
    }
  }
};
PropertyReferenceValue.prototype.$addChangeHandler$ = function(cmp, key, method, rebind) {
  if(this.$isGlobal$) {
    $A.$expressionService$.$addExpressionListener$(this, key, cmp);
    return
  }
  var valueProvider = this.$valueProvider$;
  var expression = this.$expression$;
  if(valueProvider.$addValueHandler$ && (valueProvider !== cmp || expression !== key)) {
    if(!method) {
      method = function PropertyReferenceValue$changeHandler(event) {
        if(!cmp.$isValid$()) {
          return
        }
        $A.$renderingService$.$addDirtyValue$(key, cmp);
        if(rebind) {
          cmp.set(key, event.$getParam$("value"), true)
        }
        cmp.$fireChangeEvent$(key, event.$getParam$("oldValue"), event.$getParam$("value"), event.$getParam$("index"))
      }
    }
    method.id = cmp.$getGlobalId$();
    method.key = key;
    var config = {"event":"change", "value":expression, "method":method, "cmp":cmp};
    this.$valueProvider$.$addValueHandler$(config)
  }
};
goog.$exportProperty$(PropertyReferenceValue.prototype, "addChangeHandler", PropertyReferenceValue.prototype.$addChangeHandler$);
PropertyReferenceValue.prototype.$removeChangeHandler$ = function(cmp, key) {
  if(this.$isGlobal$) {
    $A.$expressionService$.$removeExpressionListener$(this, key, cmp);
    return
  }
  var valueProvider = this.$valueProvider$;
  var expression = this.$expression$;
  if(!valueProvider) {
    return
  }
  for(;valueProvider instanceof PassthroughValue;) {
    expression = valueProvider.getExpression(expression);
    valueProvider = valueProvider.$getComponent$()
  }
  if(valueProvider && valueProvider.$removeValueHandler$ && (valueProvider !== cmp || this.$expression$ !== key)) {
    valueProvider.$removeValueHandler$({"event":"change", "value":this.$expression$, "id":cmp.$getGlobalId$(), "key":key})
  }
};
goog.$exportProperty$(PropertyReferenceValue.prototype, "removeChangeHandler", PropertyReferenceValue.prototype.$removeChangeHandler$);
PropertyReferenceValue.prototype.getExpression = function() {
  return this.$expression$
};
PropertyReferenceValue.prototype.$getIsGlobal$ = function() {
  return this.$isGlobal$
};
PropertyReferenceValue.prototype.$getReference$ = function(path) {
  if(!path) {
    return this
  }
  var valueProvider = this.$valueProvider$;
  for(var expression = this.$expression$;valueProvider instanceof PassthroughValue;) {
    expression = valueProvider.getExpression(expression);
    valueProvider = valueProvider.$getComponent$()
  }
  return valueProvider ? valueProvider.$getReference$(expression + "." + path) : null
};
PropertyReferenceValue.prototype.$equals$ = function(target) {
  return target instanceof PropertyReferenceValue && target.$valueProvider$ === this.$valueProvider$ && target.$expression$ === this.$expression$
};
PropertyReferenceValue.prototype.$isDirty$ = function() {
  var valueProvider = this.$valueProvider$;
  for(var expression = this.$expression$;valueProvider instanceof PassthroughValue;) {
    expression = valueProvider.getExpression(expression);
    valueProvider = valueProvider.$getComponent$()
  }
  return $A.$renderingService$.$isDirtyValue$(expression, valueProvider)
};
goog.$exportProperty$(PropertyReferenceValue.prototype, "isDirty", PropertyReferenceValue.prototype.$isDirty$);
PropertyReferenceValue.prototype.$destroy$ = function() {
  this.$valueProvider$ = this.$context$ = null;
  this.$isValid$ = false
};
goog.$exportProperty$(PropertyReferenceValue.prototype, "destroy", PropertyReferenceValue.prototype.$destroy$);
PropertyReferenceValue.prototype.toString = function() {
  return"{!" + this.$expression$ + "}"
};
goog.$exportProperty$(PropertyReferenceValue.prototype, "toString", PropertyReferenceValue.prototype.toString);
PropertyReferenceValue.prototype.toJSON = function() {
  return this.evaluate()
};
Aura.$Value$.$PropertyReferenceValue$ = PropertyReferenceValue;
function FunctionCallValue(config, valueProvider) {
  this.$valueProvider$ = valueProvider;
  this.$byValue$ = config["byValue"];
  this.code = (0, eval)("(" + config["code"] + ")");
  this.$context$ = $A.$clientService$.$currentAccess$;
  this.$args$ = [];
  for(var i = 0;i < config["args"].length;i++) {
    this.$args$.push(valueFactory.create(config["args"][i], this.$valueProvider$))
  }
}
goog.$exportSymbol$("FunctionCallValue", FunctionCallValue);
FunctionCallValue.prototype.$expressionFunctions$ = new ExpressionFunctions;
FunctionCallValue.prototype.$isDirty$ = function() {
  for(var i = 0;i < this.$args$.length;i++) {
    var arg = this.$args$[i];
    if(aura["util"].$isExpression$(arg) && arg.$isDirty$()) {
      return true
    }
  }
  return false
};
goog.$exportProperty$(FunctionCallValue.prototype, "isDirty", FunctionCallValue.prototype.$isDirty$);
FunctionCallValue.prototype.evaluate = function(valueProvider) {
  $A.$clientService$.$setCurrentAccess$(this.$context$);
  try {
    var result = this.code.call(null, valueProvider || this.$valueProvider$, this.$expressionFunctions$);
    if(!this.hasOwnProperty("result")) {
      this["result"] = result
    }
    return result
  }finally {
    $A.$clientService$.$releaseCurrentAccess$()
  }
};
FunctionCallValue.prototype.$addChangeHandler$ = function(cmp, key, fcv) {
  if(this.$byValue$) {
    return
  }
  for(var i = 0;i < this.$args$.length;i++) {
    var arg = this.$args$[i];
    if(aura["util"].$isExpression$(arg)) {
      if(arg instanceof PropertyReferenceValue) {
        arg.$addChangeHandler$(cmp, key, fcv ? fcv : this.$getChangeHandler$(cmp, key, this))
      }else {
        arg.$addChangeHandler$(cmp, key, fcv || this)
      }
    }
  }
};
goog.$exportProperty$(FunctionCallValue.prototype, "addChangeHandler", FunctionCallValue.prototype.$addChangeHandler$);
FunctionCallValue.prototype.$getChangeHandler$ = function(cmp, key, fcv) {
  return function FunctionCallValue$getChangeHandler(event) {
    var result = fcv.evaluate();
    if(fcv["result"] !== result) {
      fcv["result"] = result;
      $A.$renderingService$.$addDirtyValue$(key, cmp);
      cmp.$fireChangeEvent$(key, event.$getParam$("oldValue"), event.$getParam$("value"), event.$getParam$("index"))
    }
  }
};
FunctionCallValue.prototype.$removeChangeHandler$ = function(cmp, key) {
  if(this.$byValue$) {
    return
  }
  for(var i = 0;i < this.$args$.length;i++) {
    var arg = this.$args$[i];
    if(aura["util"].$isExpression$(arg)) {
      arg.$removeChangeHandler$(cmp, key)
    }
  }
};
goog.$exportProperty$(FunctionCallValue.prototype, "removeChangeHandler", FunctionCallValue.prototype.$removeChangeHandler$);
FunctionCallValue.prototype.$destroy$ = function() {
  this.$args$ = this.code = this.$valueProvider$ = null
};
goog.$exportProperty$(FunctionCallValue.prototype, "destroy", FunctionCallValue.prototype.$destroy$);
FunctionCallValue.prototype.toString = function() {
  return this.code.toString()
};
goog.$exportProperty$(FunctionCallValue.prototype, "toString", FunctionCallValue.prototype.toString);
Aura.$Value$.$FunctionCallValue$ = FunctionCallValue;
function PassthroughValue(primaryProviders, component) {
  this.$primaryProviders$ = primaryProviders;
  this.$component$ = component;
  this.$references$ = {};
  this.$handlers$ = {}
}
goog.$exportSymbol$("PassthroughValue", PassthroughValue);
PassthroughValue.prototype.$addValueHandler$ = function(config) {
  var path = config.value.split(".");
  if(!this.$primaryProviders$.hasOwnProperty(path[0])) {
    this.$component$.$addValueHandler$(config);
    return
  }
  var provider = this.$primaryProviders$[path[0]];
  if($A["util"].$isExpression$(provider)) {
    var reference = path.length > 1 ? provider.$getReference$(path.slice(1).join(".")) : provider;
    if(reference) {
      reference.$addChangeHandler$(config["cmp"], reference.getExpression(), config["method"]);
      return
    }
  }
  var event = config["event"];
  var handlers = this.$handlers$[event];
  if(!handlers) {
    handlers = this.$handlers$[event] = {}
  }
  var expression = config["value"];
  if($A["util"].$isExpression$(expression)) {
    expression = expression.getExpression()
  }
  if(!handlers[expression]) {
    handlers[expression] = []
  }
  for(var i = 0;i < handlers[expression].length;i++) {
    if(handlers[expression][i] === config["method"] || config["id"] && config["key"] && handlers[expression][i]["id"] === config["id"] && handlers[expression][i]["key"] === config["key"]) {
      return
    }
  }
  handlers[expression].push(config["method"])
};
goog.$exportProperty$(PassthroughValue.prototype, "addValueHandler", PassthroughValue.prototype.$addValueHandler$);
PassthroughValue.prototype.$deIndex$ = function() {
  for(var valueProvider = this.$getComponent$();valueProvider instanceof PassthroughValue;) {
    valueProvider = valueProvider.$getComponent$()
  }
  if(!valueProvider) {
    return
  }
  valueProvider.$deIndex$.apply(valueProvider, arguments)
};
goog.$exportProperty$(PassthroughValue.prototype, "deIndex", PassthroughValue.prototype.$deIndex$);
PassthroughValue.prototype.$fireChangeEvent$ = function(key, oldValue, value, index) {
  var handlers = this.$handlers$["change"];
  var observers = [];
  var keypath = key + ".";
  for(var handler in handlers) {
    if(handler === key || handler.indexOf(keypath) === 0 || key.indexOf(handler + ".") === 0) {
      observers = observers.concat(handlers[handler])
    }
  }
  if(observers.length) {
    var eventDef = $A.get("e").$getEventDef$("aura:valueChange");
    var dispatcher = {};
    dispatcher[eventDef.$getDescriptor$().$getQualifiedName$()] = {"default":observers};
    var changeEvent = new Aura.$Event$.$Event$({"eventDef":eventDef, "eventDispatcher":dispatcher});
    changeEvent.$setParams$({"expression":key, "value":value, "oldValue":oldValue, "index":index});
    changeEvent.$fire$()
  }
};
goog.$exportProperty$(PassthroughValue.prototype, "fireChangeEvent", PassthroughValue.prototype.$fireChangeEvent$);
PassthroughValue.prototype.get = function(key) {
  var path = key.split(".");
  if(this.$primaryProviders$.hasOwnProperty(path[0])) {
    var value = null;
    if(path.length > 1) {
      value = $A.$expressionService$.$resolve$(key, this.$primaryProviders$)
    }else {
      value = this.$primaryProviders$[key]
    }
    for(;$A["util"].$isExpression$(value);) {
      value = value.evaluate()
    }
    return value
  }else {
    return this.$component$.get(key)
  }
};
goog.$exportProperty$(PassthroughValue.prototype, "get", PassthroughValue.prototype.get);
PassthroughValue.prototype.$getComponent$ = function() {
  return this.$component$
};
goog.$exportProperty$(PassthroughValue.prototype, "getComponent", PassthroughValue.prototype.$getComponent$);
PassthroughValue.prototype.$getPrimaryProviderKeys$ = function() {
  return Object.keys(this.$primaryProviders$)
};
goog.$exportProperty$(PassthroughValue.prototype, "getPrimaryProviderKeys", PassthroughValue.prototype.$getPrimaryProviderKeys$);
PassthroughValue.prototype.$getDef$ = function() {
  for(var valueProvider = this;valueProvider instanceof PassthroughValue;) {
    valueProvider = valueProvider.$getComponent$()
  }
  return valueProvider.$getDef$()
};
PassthroughValue.prototype.getExpression = function(expression) {
  var path = $A["util"].isArray(expression) ? expression : expression.split(".");
  if(this.$primaryProviders$.hasOwnProperty(path[0])) {
    var provider = this.$primaryProviders$[path[0]];
    if(provider instanceof PassthroughValue) {
      return provider.getExpression(path)
    }
    if(provider instanceof PropertyReferenceValue) {
      path.splice(0, 1, provider.getExpression());
      return path.join(".")
    }
  }
  return expression
};
PassthroughValue.prototype.$getReference$ = function(key) {
  key = aura.$expressionService$.normalize(key);
  var path = key.split(".");
  if(this.$primaryProviders$.hasOwnProperty(path[0])) {
    if(!this.$references$.hasOwnProperty(key)) {
      this.$references$[key] = new PropertyReferenceValue(key, this)
    }
    return this.$references$[key]
  }else {
    return this.$component$.$getReference$(key)
  }
};
goog.$exportProperty$(PassthroughValue.prototype, "getReference", PassthroughValue.prototype.$getReference$);
PassthroughValue.prototype.index = function() {
  for(var valueProvider = this.$getComponent$();valueProvider instanceof PassthroughValue;) {
    valueProvider = valueProvider.$getComponent$()
  }
  if(!valueProvider) {
    return
  }
  valueProvider.index.apply(valueProvider, arguments)
};
goog.$exportProperty$(PassthroughValue.prototype, "index", PassthroughValue.prototype.index);
PassthroughValue.prototype.$removeValueHandler$ = function(config) {
  var path = config.value.split(".");
  if(!this.$primaryProviders$.hasOwnProperty(path[0])) {
    this.$component$.$removeValueHandler$(config);
    return
  }
  var provider = this.$primaryProviders$[path[0]];
  if($A["util"].$isExpression$(provider)) {
    var reference = provider.$getReference$(path.slice(1).join("."));
    if(reference) {
      reference.$removeChangeHandler$($A.$getCmp$(config["id"]), reference.getExpression());
      return
    }
  }
  var event = config["event"];
  var handlers = this.$handlers$[event];
  if(handlers) {
    var expression = config["value"];
    if($A["util"].$isExpression$(expression)) {
      expression = expression.getExpression()
    }
    if(handlers[expression]) {
      for(var i = 0;i < handlers[expression].length;i++) {
        var method = handlers[expression][i];
        if(method === config["method"] || config["id"] && config["key"] && method["id"] === config["id"] && method["key"] === config["key"]) {
          handlers[expression].splice(i--, 1)
        }
      }
    }
  }
};
goog.$exportProperty$(PassthroughValue.prototype, "removeValueHandler", PassthroughValue.prototype.$removeValueHandler$);
PassthroughValue.prototype.set = function(key, value, ignoreChanges) {
  $A.assert($A["util"].$isString$(key), "PassthroughValue.prototype.set should be called with a valid key!\n" + "[key]: " + key + "\n" + "[primaryProviders]: " + this.$primaryProviders$ + "\n" + "[falls back component]: " + this.$component$ + "\n");
  var path = key.split(".");
  if(this.$primaryProviders$.hasOwnProperty(path[0])) {
    var provider = this.$primaryProviders$[path[0]];
    var fullPath = this.getExpression(key);
    var target = this.$primaryProviders$;
    var subKey = path.slice(1).join(".");
    key = path[path.length - 1];
    if(path.length > 1 && $A["util"].$isExpression$(provider)) {
      var reference = provider.$getReference$(subKey);
      if(reference) {
        reference.set(value);
        return undefined
      }
    }
    if(path.length > 1) {
      target = $A.$expressionService$.$resolve$(path.slice(0, path.length - 1), target)
    }
    if(!target) {
      return undefined
    }
    var oldValue = target[key];
    target[key] = value;
    if(!ignoreChanges) {
      for(var valueProvider = this.$component$;valueProvider instanceof PassthroughValue;) {
        valueProvider = valueProvider.$getComponent$()
      }
      valueProvider.$fireChangeEvent$(fullPath, oldValue, value, fullPath);
      valueProvider.$markDirty$(fullPath);
      this.$fireChangeEvent$(key, oldValue, value, key)
    }
    return value
  }
  return this.$component$.set(key, value, ignoreChanges)
};
goog.$exportProperty$(PassthroughValue.prototype, "set", PassthroughValue.prototype.set);
PassthroughValue.prototype.$isValid$ = function() {
  for(var valueProvider = this.$getComponent$();valueProvider instanceof PassthroughValue;) {
    valueProvider = valueProvider.$getComponent$()
  }
  if($A["util"].$isComponent$(valueProvider)) {
    return valueProvider.$isValid$()
  }
  return false
};
var valueFactory = {create:function create(valueConfig, component) {
  if(!valueConfig) {
    return valueConfig
  }
  if(aura["util"].$isPlainObject$(valueConfig)) {
    if(valueConfig["exprType"] === "PROPERTY") {
      var isGlobal = valueConfig["path"].charAt(0) === "$";
      if(valueConfig["byValue"]) {
        return(isGlobal ? $A : component).get(valueConfig["path"])
      }
      if(isGlobal) {
        return $A.$expressionService$.$getReference$(valueConfig["path"], component)
      }else {
        if($A["util"].$isComponent$(component)) {
          return component.$getReference$(valueConfig["path"], component)
        }
      }
      return new PropertyReferenceValue(valueConfig["path"], component)
    }else {
      if(valueConfig["exprType"] === "FUNCTION") {
        return new FunctionCallValue(valueConfig, component, valueConfig["target"])
      }else {
        var childConfig = {};
        for(var key in valueConfig) {
          childConfig[key] = valueFactory.create(valueConfig[key], component)
        }
        valueConfig = childConfig
      }
    }
  }else {
    if(aura["util"].$isString$(valueConfig) && valueConfig.charAt(0) === "{" && component) {
      if(valueConfig.charAt(1) === "!" || valueConfig.charAt(1) === "#") {
        $A.log("Aura ValueFactory: String expressions are no longer supported.")
      }
    }
  }
  return valueConfig
}};
Aura.$Value$.$ValueFactory$ = valueFactory;
function ExpressionFunctions() {
}
goog.$exportSymbol$("ExpressionFunctions", ExpressionFunctions);
ExpressionFunctions.prototype.$eq$ = function(a, b) {
  if(a === undefined || a === null) {
    return b === undefined || b === null
  }
  return a === b
};
goog.$exportProperty$(ExpressionFunctions.prototype, "eq", ExpressionFunctions.prototype.$eq$);
ExpressionFunctions.prototype.$ne$ = function(a, b) {
  if(a === undefined || a === null) {
    return b !== undefined && b !== null
  }
  return a !== b
};
goog.$exportProperty$(ExpressionFunctions.prototype, "ne", ExpressionFunctions.prototype.$ne$);
ExpressionFunctions.prototype.add = function(a, b) {
  if(a === undefined || a === null) {
    if(typeof b === "string") {
      return b
    }else {
      if(b === undefined || b === null) {
        return""
      }
    }
  }
  if(b === undefined || b === null) {
    if(typeof a === "string") {
      return a
    }
  }
  return a + b
};
goog.$exportProperty$(ExpressionFunctions.prototype, "add", ExpressionFunctions.prototype.add);
ExpressionFunctions.prototype.empty = Aura.$Utils$.$Util$.prototype.$isEmpty$;
goog.$exportProperty$(ExpressionFunctions.prototype, "empty", ExpressionFunctions.prototype.empty);
ExpressionFunctions.prototype.$format$ = function() {
  if(arguments.length === 0) {
    return""
  }
  var a0 = arguments[0];
  if(a0 === undefined || a0 === null || !$A["util"].$isFunction$(a0.toString)) {
    return""
  }
  if(arguments.length === 1) {
    return a0 + ""
  }
  var formatArguments = [];
  for(var i = 0;i < arguments.length;i++) {
    var ai = arguments[i];
    formatArguments[i] = ai === undefined || ai === null ? "" : ai
  }
  return $A["util"].$format$.apply($A["util"], formatArguments)
};
goog.$exportProperty$(ExpressionFunctions.prototype, "format", ExpressionFunctions.prototype.$format$);
ExpressionFunctions.prototype.$token$ = function(token) {
  try {
    return $A.$getToken$(token)
  }catch(e) {
    var message = e["message"] || "ExpressionFunctions token error";
    $A.$warning$(message, e)
  }
  return""
};
goog.$exportProperty$(ExpressionFunctions.prototype, "token", ExpressionFunctions.prototype.$token$);
ExpressionFunctions.prototype.join = function(separator) {
  var params = [];
  for(var i = 1;i < arguments.length;i++) {
    if(!this.empty(arguments[i])) {
      params.push(arguments[i])
    }
  }
  return params.join(separator)
};
goog.$exportProperty$(ExpressionFunctions.prototype, "join", ExpressionFunctions.prototype.join);
Aura.$Value$.$ExpressionFunctions$ = ExpressionFunctions;
function ValueDef(config) {
  this.name = config["name"]
}
ValueDef.prototype.getName = function() {
  return this.name
};
Aura.$Model$.$ValueDef$ = ValueDef;
function ModelDef(config) {
  this.$descriptor$ = new DefDescriptor(config["descriptor"]);
  this.$members$ = [];
  for(var i = 0;i < config["members"].length;i++) {
    var m = config["members"][i];
    this.$members$.push(new ValueDef(m))
  }
}
goog.$exportSymbol$("ModelDef", ModelDef);
ModelDef.prototype.$getDescriptor$ = function() {
  return this.$descriptor$
};
ModelDef.prototype.$newInstance$ = function(config) {
  return new Model(this, config)
};
ModelDef.prototype.$getMembers$ = function() {
  return this.$members$
};
Aura.$Model$.$ModelDef$ = ModelDef;
function Model(def, data) {
  this.$def$ = def;
  this.data = $A["util"].apply({}, data, true, true);
  if(def) {
    var members = def.$getMembers$();
    for(var i = 0;i < members.length;i++) {
      var name = members[i].getName();
      if(!this.data.hasOwnProperty(name)) {
        this.data[name] = null
      }
    }
  }
}
Model.prototype.get = function(key) {
  var value = undefined;
  if(key.indexOf(".") < 0) {
    value = this.data[key]
  }else {
    value = aura.$expressionService$.$resolve$(key, this.data)
  }
  if(aura["util"].$isExpression$(value)) {
    value = value.evaluate()
  }
  return value
};
Model.prototype.set = function(key, value) {
  var oldValue;
  var target = this.data;
  var step = key;
  if(key.indexOf(".") >= 0) {
    var path = key.split(".");
    target = aura.$expressionService$.$resolve$(path.slice(0, path.length - 1), target);
    $A.assert(target, "Model.set: unable to resolve '" + key + "'.");
    step = path[path.length - 1]
  }
  oldValue = target[step];
  if(oldValue instanceof PropertyReferenceValue) {
    oldValue.set(value)
  }else {
    target[step] = value
  }
};
Model.prototype.$destroy$ = function() {
  for(var x in this.data) {
    if(this.data.hasOwnProperty(x)) {
      this.data[x] = undefined
    }
  }
};
Aura.$Model$.$Model$ = Model;
function ComponentClassRegistry() {
  this.$classExporter$ = {};
  this.$classConstructors$ = {}
}
ComponentClassRegistry.prototype.$customConstructorMap$ = {"aura$text":TextComponent, "aura$html":HtmlComponent, "aura$expression":ExpressionComponent, "aura$if":IfComponent, "aura$iteration":IterationComponent, "aura$component":BaseComponent};
ComponentClassRegistry.prototype.$hasComponentClass$ = function(descriptor) {
  return descriptor in this.$classExporter$ || descriptor in this.$classConstructors$
};
ComponentClassRegistry.prototype.$addComponentClass$ = function(descriptor, exporter) {
  $A.assert($A["util"].$isString$(descriptor), "Component class descriptor is invalid: " + descriptor);
  $A.assert($A["util"].$isFunction$(exporter), "Component class exporter is not a function: " + descriptor);
  if(!this.$hasComponentClass$(descriptor)) {
    this.$classExporter$[descriptor] = exporter
  }
};
goog.$exportSymbol$("ComponentClassRegistry.prototype.addComponentClass", ComponentClassRegistry.prototype.$addComponentClass$);
ComponentClassRegistry.prototype.$getComponentClass$ = function(descriptor, def) {
  var storedConstructor = this.$classConstructors$[descriptor];
  if(!storedConstructor) {
    var exporter = this.$classExporter$[descriptor];
    if(exporter) {
      var componentProperties = exporter();
      storedConstructor = this.$buildComponentClass$(componentProperties);
      this.$classConstructors$[descriptor] = storedConstructor;
      this.$classExporter$[descriptor] = null
    }else {
      if(def && def.$interop$) {
        return this.$buildInteropComponentClass$(descriptor, def)
      }
    }
  }
  return storedConstructor
};
goog.$exportSymbol$("ComponentClassRegistry.prototype.getComponentClass", ComponentClassRegistry.prototype.$getComponentClass$);
ComponentClassRegistry.prototype.$buildInteropComponentClass$ = function(descriptor, def) {
  var interopClass = Aura.$Component$.$InteropComponent$;
  if(typeof def.$interopClass$ !== "function") {
    interopClass = Aura.$Component$.$InteropModule$
  }
  var interopCmpClass = this.$buildConstructor$({"interopClass":def.$interopClass$}, def.$interopClassName$, interopClass);
  this.$classConstructors$[descriptor] = interopCmpClass;
  return interopCmpClass
};
ComponentClassRegistry.prototype.$buildComponentClass$ = function(componentProperties) {
  this.$buildInheritance$(componentProperties);
  this.$buildLibraries$(componentProperties);
  var componentConstructor = this.$buildConstructor$(componentProperties);
  return componentConstructor
};
ComponentClassRegistry.prototype.$buildInheritance$ = function(componentProperties) {
  var superDescriptor = componentProperties["meta"]["extends"];
  var superConstructor = this.$getComponentClass$(superDescriptor);
  componentProperties["controller"] = componentProperties["controller"] || {};
  var superController = superConstructor && superConstructor.prototype["controller"];
  if(superController) {
    componentProperties["controller"] = Object.assign(Object.create(superController), componentProperties["controller"])
  }
  componentProperties["helper"] = componentProperties["helper"] || {};
  var superHelper = superConstructor && superConstructor.prototype["helper"];
  if(superHelper) {
    componentProperties["helper"] = Object.assign(Object.create(superHelper), componentProperties["helper"])
  }
};
ComponentClassRegistry.prototype.$buildLibraries$ = function(componentProperties) {
  var componentImports = componentProperties["meta"]["imports"];
  if(componentImports) {
    var helper = componentProperties["helper"];
    for(var property in componentImports) {
      var descriptor = componentImports[property];
      var library = $A.$componentService$.$getLibrary$(descriptor);
      if(!library) {
        try {
          library = $A.$componentService$.$evaluateModuleDef$(descriptor)
        }catch(e) {
        }
      }
      helper[property] = library
    }
    componentProperties["helper"] = helper
  }
};
ComponentClassRegistry.prototype.$buildConstructor$ = function(componentProperties, name, Ctor) {
  var componentConstructor;
  var className = name || componentProperties["meta"]["name"];
  Ctor = Ctor || this.$customConstructorMap$[className] || Component;
  var createConstructor = $A["util"].$globalEval$("function(Ctor) {return function " + className + "(config) { Ctor.call(this, config); }}");
  componentConstructor = createConstructor(Ctor);
  componentConstructor.prototype = Object.create(Ctor.prototype);
  componentConstructor.prototype.constructor = componentConstructor;
  var constructorPrototype = componentConstructor.prototype;
  for(var key in componentProperties) {
    if(constructorPrototype[key] === undefined) {
      constructorPrototype[key] = componentProperties[key]
    }
  }
  return componentConstructor
};
Aura.$Component$.$ComponentClassRegistry$ = ComponentClassRegistry;
function ComponentDefStorage() {
}
ComponentDefStorage.prototype.$STORAGE_NAME$ = "ComponentDefStorage";
ComponentDefStorage.prototype.$EVICTION_TARGET_LOAD$ = 0.75;
ComponentDefStorage.prototype.$EVICTION_HEADROOM$ = 0.1;
ComponentDefStorage.prototype.$BROKEN_GRAPH_COOKIE$ = "auraBrokenDefGraph";
ComponentDefStorage.prototype.$MUTEX_KEY$ = ComponentDefStorage.prototype.$STORAGE_NAME$;
ComponentDefStorage.prototype.$mutexUnlock$ = undefined;
ComponentDefStorage.prototype.$queue$ = undefined;
ComponentDefStorage.prototype.$defsToStore$ = undefined;
ComponentDefStorage.prototype.$useDefStore$ = undefined;
ComponentDefStorage.prototype.$storage$ = undefined;
ComponentDefStorage.prototype.$useDefinitionStorage$ = function() {
  if(this.$useDefStore$ === undefined) {
    this.$setupDefinitionStorage$()
  }
  return this.$useDefStore$
};
ComponentDefStorage.prototype.$setupDefinitionStorage$ = function() {
  if(this.$useDefStore$ === undefined) {
    this.$useDefStore$ = false;
    var actionStorage = $A.$clientService$.$getActionStorage$();
    if(actionStorage.$isStoragePersistent$()) {
      var storage = $A.$storageService$.$getStorage$(this.$STORAGE_NAME$);
      var removeStorage = false;
      if(!storage) {
        removeStorage = true;
        storage = $A.$storageService$.$initStorage$({"name":this.$STORAGE_NAME$, "persistent":true, "secure":false, "maxSize":4096E3, "expiration":10886400, "debugLogging":true, "clearOnInit":false})
      }
      if(storage.$isPersistent$()) {
        this.$storage$ = storage;
        this.$storage$.$suspendSweeping$();
        this.$useDefStore$ = true
      }else {
        if(removeStorage) {
          $A.$storageService$.$deleteStorage$(this.$STORAGE_NAME$)
        }
      }
    }
  }
};
ComponentDefStorage.prototype.$getStorage$ = function() {
  if(this.$useDefinitionStorage$()) {
    return this.$storage$
  }
};
ComponentDefStorage.prototype.$storeDefs$ = function(cmpConfigs, libConfigs, evtConfigs, moduleConfigs, context) {
  if(!this.$useDefinitionStorage$() || !cmpConfigs.length && !libConfigs.length && !evtConfigs.length && !moduleConfigs.length) {
    return Promise["resolve"]()
  }
  var toStore = {};
  var descriptor;
  var encodedConfig;
  var i;
  for(i = 0;i < cmpConfigs.length;i++) {
    descriptor = cmpConfigs[i]["descriptor"];
    cmpConfigs[i]["uuid"] = context.$findLoaded$(descriptor);
    encodedConfig = $A["util"].$json$.$encode$(cmpConfigs[i]);
    toStore[descriptor] = encodedConfig
  }
  for(i = 0;i < libConfigs.length;i++) {
    descriptor = libConfigs[i]["descriptor"];
    encodedConfig = $A["util"].$json$.$encode$(libConfigs[i]);
    toStore[descriptor] = encodedConfig
  }
  for(i = 0;i < evtConfigs.length;i++) {
    descriptor = evtConfigs[i]["descriptor"];
    encodedConfig = $A["util"].$json$.$encode$(evtConfigs[i]);
    toStore[descriptor] = encodedConfig
  }
  for(i = 0;i < moduleConfigs.length;i++) {
    descriptor = moduleConfigs[i]["descriptor"];
    encodedConfig = $A["util"].$json$.$encode$(moduleConfigs[i]);
    toStore[descriptor] = encodedConfig
  }
  if(this.$defsToStore$) {
    $A["util"].apply(this.$defsToStore$, toStore, false, false);
    return Promise["resolve"]()
  }
  this.$defsToStore$ = toStore;
  var that = this;
  return this.$enqueue$(function(resolve, reject) {
    var values = that.$defsToStore$;
    that.$defsToStore$ = undefined;
    return that.$storage$.$setAll$(values).$then$(function resolve() {
      $A.log("ComponentDefStorage: successfully stored " + Object.keys(toStore).length + " defs")
    }, function reject(e) {
      $A.$warning$("ComponentDefStorage: error storing " + Object.keys(toStore).length + " defs", e);
      that.$setBrokenGraphCookie$();
      throw e;
    }).$then$(resolve, reject)
  })
};
ComponentDefStorage.prototype.$removeDefs$ = function(descriptors) {
  if(!this.$useDefinitionStorage$() || !descriptors.length) {
    return Promise["resolve"]()
  }
  var that = this;
  return this.$storage$.$removeAll$(descriptors).$then$(function() {
    $A.log("ComponentDefStorage: Successfully removed " + descriptors.length + " descriptors")
  }, function(e) {
    $A.log("ComponentDefStorage: Error removing  " + descriptors.length + " descriptors", e);
    that.$setBrokenGraphCookie$();
    throw e;
  })
};
ComponentDefStorage.prototype.$getAll$ = function() {
  if(!this.$useDefinitionStorage$()) {
    return Promise["resolve"]({})
  }
  if(this.$getBrokenGraphCookie$()) {
    var metricsPayload = {"cause":"getAll", "error":"broken def graph cookie"};
    return this.clear(metricsPayload)
  }
  return this.$storage$.$getAll$([], true).$then$(function(items) {
    var result = {};
    for(var key in items) {
      var config = $A["util"].$json$.$decode$(items[key]);
      if(config === null) {
        throw new $A.$auraError$("Error decoding definition from storage: " + key, null, $A.severity.$QUIET$);
      }
      result[key] = config
    }
    return result
  })
};
ComponentDefStorage.prototype.$restoreAll$ = function(context) {
  return this.$getAll$().$then$(function(items) {
    var libCount = 0;
    var cmpCount = 0;
    var evtCount = 0;
    var moduleDefs = [];
    for(var key in items) {
      var config = items[key];
      if(config[Json.$ApplicationKey$.$TYPE$]) {
        if(!$A.$eventService$.$getEventDef$(config)) {
          $A.$eventService$.$saveEventConfig$(config)
        }
        evtCount++
      }else {
        if(config["includes"]) {
          if(!$A.$componentService$.$hasLibrary$(config["descriptor"])) {
            $A.$componentService$.$saveLibraryConfig$(config)
          }
          libCount++
        }else {
          if(config[Json.$ApplicationKey$["NAME"]] && config[Json.$ApplicationKey$.$CODE$]) {
            moduleDefs.push(config)
          }else {
            if(config["uuid"]) {
              context.$addLoaded$(config["uuid"])
            }
            if(!$A.$componentService$.$getComponentDef$(config)) {
              $A.$componentService$.$saveComponentConfig$(config)
            }
            cmpCount++
          }
        }
      }
    }
    if(moduleDefs.length > 0) {
      $A.$componentService$.$initModuleDefs$(moduleDefs)
    }
    $A.log("ComponentDefStorage: restored " + cmpCount + " components, " + libCount + " libraries, " + evtCount + " events, " + moduleDefs.length + " modules from storage into registry")
  }).$then$(undefined, function(e) {
    $A.$warning$("ComponentDefStorage: error during restore from storage, no component, library or event defs restored", e);
    throw e;
  })
};
ComponentDefStorage.prototype.$enqueue$ = function(execute) {
  function executeQueue() {
    if(!that.$queue$) {
      return
    }
    var next = that.$queue$.pop();
    if(next) {
      $A.log("ComponentDefStorage.enqueue: " + (that.$queue$.length + 1) + " items in queue, running next");
      $A["util"].$Mutex$.$lock$(that.$MUTEX_KEY$, function(unlock) {
        that.$mutexUnlock$ = unlock;
        next["execute"](next["resolve"], next["reject"])
      })
    }else {
      that.$queue$ = undefined
    }
  }
  var that = this;
  var promise = new Promise(function(resolve, reject) {
    if(that.$queue$) {
      that.$queue$.push({"execute":execute, "resolve":resolve, "reject":reject});
      return
    }
    that.$queue$ = [{"execute":execute, "resolve":resolve, "reject":reject}];
    executeQueue()
  });
  promise.$then$(function() {
    try {
      that.$mutexUnlock$()
    }catch(ignore) {
    }
    executeQueue()
  }, function() {
    try {
      that.$mutexUnlock$()
    }catch(ignore) {
    }
    executeQueue()
  });
  return promise
};
ComponentDefStorage.prototype.clear = function(metricsPayload) {
  if(!this.$useDefinitionStorage$()) {
    this.$clearBrokenGraphCookie$();
    return Promise["resolve"]()
  }
  var that = this;
  return new Promise(function(resolve, reject) {
    metricsPayload = $A["util"].apply({}, metricsPayload);
    metricsPayload["evicted"] = "all";
    $A.$metricsService$.$transactionStart$("aura", "performance:evictedDefs", {"context":{"attributes":metricsPayload}});
    $A.$clientService$.$runWhenXHRIdle$(function() {
      $A.$warning$("ComponentDefStorage.clear: clearing all defs and actions");
      $A.$context$.$resetLoaded$();
      that.$enqueue$(function(enqueueResolve) {
        var errorDuringClear = false;
        var actionClear;
        var actionStorage = $A.$clientService$.$getActionStorage$();
        if(actionStorage.$isStoragePersistent$()) {
          actionClear = actionStorage.clear().$then$(undefined, function(e) {
            $A.$warning$("ComponentDefStorage.clear: failure clearing actions store", e);
            metricsPayload["actionsError"] = true;
            errorDuringClear = true
          })
        }else {
          actionClear = Promise["resolve"]()
        }
        var defClear = that.$storage$.clear().$then$(undefined, function(e) {
          $A.$warning$("ComponentDefStorage.clear: failure clearing cmp def store", e);
          metricsPayload["componentDefStorageError"] = true;
          errorDuringClear = true
        });
        var promise = Promise.all([actionClear, defClear]).$then$(function() {
          $A.$metricsService$.$transactionEnd$("aura", "performance:evictedDefs");
          if(!errorDuringClear) {
            that.$clearBrokenGraphCookie$()
          }
        });
        enqueueResolve(promise)
      }).$then$(resolve, reject)
    })
  })
};
ComponentDefStorage.prototype.$getBrokenGraphCookie$ = function() {
  var cookie = $A["util"].$getCookie$(this.$BROKEN_GRAPH_COOKIE$);
  return cookie === "true"
};
ComponentDefStorage.prototype.$setBrokenGraphCookie$ = function() {
  var duration = 1E3 * 60 * 60 * 24 * 7;
  $A["util"]["setCookie"](this.$BROKEN_GRAPH_COOKIE$, "true", duration)
};
ComponentDefStorage.prototype.$clearBrokenGraphCookie$ = function() {
  $A["util"].$clearCookie$(this.$BROKEN_GRAPH_COOKIE$)
};
Aura.$Component$.$ComponentDefStorage$ = ComponentDefStorage;
function Component(config, localCreation) {
  var context = $A.getContext();
  this.$concreteComponentId$ = config["concreteComponentId"];
  this.$containerComponentId$ = config["containerComponentId"];
  this.$shouldAutoDestroy$ = true;
  this.$rendered$ = false;
  this.$inUnrender$ = false;
  this.$localId$ = config["localId"];
  this.$valueProviders$ = {};
  this.$eventValueProvider$ = undefined;
  this.$docLevelHandlers$ = undefined;
  this.$references$ = {};
  this.$handlers$ = {};
  this.$localIndex$ = {};
  this.$destroyed$ = 0;
  this.version = config["version"];
  this.$owner$ = $A.$clientService$.$getCurrentAccessGlobalId$();
  this.name = "";
  this.type = "";
  this.$_marker$ = null;
  var act = config["skipCreationPath"] ? null : context.$getCurrentAction$();
  var forcedPath = false;
  if(act) {
    var currentPath = act.$topPath$();
    if(config["creationPath"]) {
      this.$creationPath$ = act.$forceCreationPath$(config["creationPath"]);
      forcedPath = true
    }else {
      if(!context.$containsComponentConfig$(currentPath) && !!localCreation) {
        this.$creationPath$ = "client created"
      }else {
        this.$creationPath$ = act.$getCurrentPath$()
      }
    }
  }
  try {
    this.$setupGlobalId$(config["globalId"], localCreation);
    var partialConfig;
    if(this.$creationPath$ && this.$creationPath$ !== "client created") {
      partialConfig = context.$getComponentConfig$(this.$creationPath$);
      context.$removeComponentConfig$(this.$creationPath$)
    }
    if(partialConfig) {
      this.$validatePartialConfig$(config, partialConfig);
      this.$partialConfig$ = partialConfig
    }
    if(config["rendering"]) {
      this.$rendering$ = config["rendering"]
    }else {
      if(partialConfig && partialConfig["rendering"]) {
        this.$rendering$ = this.$partialConfig$["rendering"]
      }
    }
    $A.$componentService$.$indexComponent$(this);
    this.$setupComponentDef$(this.$partialConfig$ || config);
    this.$isRootComponent$ = $A["util"].$isUndefinedOrNull$(this["meta"] && this["meta"]["extends"]) && this.$isInstanceOf$("aura:rootComponent");
    var configAttributes = {"values":{}};
    if(config["attributes"]) {
      $A["util"].apply(configAttributes["values"], config["attributes"]["values"], true);
      configAttributes["valueProvider"] = config["attributes"]["valueProvider"] || config["valueProvider"]
    }
    if(partialConfig && partialConfig["attributes"]) {
      $A["util"].apply(configAttributes["values"], partialConfig["attributes"]["values"], true)
    }
    if(!configAttributes["facetValueProvider"]) {
      configAttributes["facetValueProvider"] = this
    }
    this.$attributeValueProvider$ = configAttributes["valueProvider"];
    this.$facetValueProvider$ = configAttributes["facetValueProvider"];
    this.$setupModel$(config["model"]);
    this.$setupValueProviders$(config["valueProviders"]);
    this.$setupAttributes$(configAttributes);
    this.$injectComponent$(config, localCreation);
    this.$setupMethods$(config);
    this.$setupComponentEvents$(this, configAttributes);
    this.$setupSuper$(configAttributes, localCreation);
    this.$setupApplicationEventHandlers$();
    this.$doIndex$(this);
    this.$setupValueEventHandlers$(this);
    this.$setupFlavors$(config, configAttributes);
    this.$partialConfig$ = undefined;
    if(forcedPath && act && this.$creationPath$) {
      act.$releaseCreationPath$(this.$creationPath$)
    }
    if(this.$getDef$().$hasInit$()) {
      this.$fire$("init")
    }
  }catch(e) {
    if(e instanceof $A.$auraError$) {
      if(!e["component"]) {
        e.$setComponent$(config && config["componentDef"] && config["componentDef"]["descriptor"])
      }
      throw e;
    }else {
      var creationError = new $A.$auraError$("Component class instance initialization error", e);
      creationError.$setComponent$(config && config["componentDef"] && config["componentDef"]["descriptor"]);
      throw creationError;
    }
  }
}
goog.$exportSymbol$("Component", Component);
Component.prototype.$setContainerComponentId$ = function(containerComponentId) {
  this.$containerComponentId$ = containerComponentId
};
Component.$currentComponentId$ = 0;
Component.prototype.$nextGlobalId$ = function(localCreation) {
  if(!localCreation) {
    var context = $A.getContext();
    var currentAction = context.$getCurrentAction$();
    var id;
    var suffix;
    if(currentAction) {
      id = currentAction.$getNextGlobalId$();
      suffix = currentAction.$getId$()
    }else {
      id = context.$getNextGlobalId$();
      suffix = "g"
    }
    return suffix ? id + ":" + suffix : id
  }else {
    return Component.$currentComponentId$++ + ":c"
  }
};
Component.prototype.$setupGlobalId$ = function(globalId, localCreation) {
  globalId = globalId || this.$nextGlobalId$(localCreation);
  if($A.$componentService$.get(globalId)) {
    $A.log("Component.setupGlobalId: globalId already in use: '" + globalId + "'.")
  }
  this.$globalId$ = globalId
};
Component.prototype.getName = function() {
  if(!this.name) {
    this.name = $A["util"].$toCamelCase$(this.$getType$())
  }
  return this.name
};
goog.$exportProperty$(Component.prototype, "getName", Component.prototype.getName);
Component.prototype.$getType$ = function() {
  if(!this.type) {
    this.type = this.$getDef$().$getDescriptor$().$getFullName$()
  }
  return this.type
};
goog.$exportProperty$(Component.prototype, "getType", Component.prototype.$getType$);
Component.prototype.$getDef$ = function() {
  return this.$componentDef$
};
goog.$exportProperty$(Component.prototype, "getDef", Component.prototype.$getDef$);
Component.prototype.index = function(localId, globalId) {
  var index = this.$localIndex$;
  var existing = index[localId];
  if(existing) {
    if(!$A["util"].isArray(existing)) {
      if(existing !== globalId) {
        index[localId] = [existing, globalId]
      }else {
        $A.$warning$("Component.index():'Invalid redundant use of component.index().'")
      }
    }else {
      var found = false;
      for(var i = 0;i < existing.length;i++) {
        if(existing[i] === globalId) {
          found = true;
          $A.$warning$("Component.index():'Invalid redundant use of component.index().'");
          break
        }
      }
      if(!found) {
        existing.push(globalId)
      }
    }
  }else {
    index[localId] = globalId
  }
  return null
};
goog.$exportProperty$(Component.prototype, "index", Component.prototype.index);
Component.prototype.$deIndex$ = function(localId, globalId) {
  if(this.$localIndex$) {
    if(globalId) {
      var index = this.$localIndex$[localId];
      if(index) {
        if($A["util"].isArray(index)) {
          for(var i = 0;i < index.length;i++) {
            if(index[i] === globalId) {
              index.splice(i--, 1)
            }
          }
          if(index.length === 0) {
            delete this.$localIndex$[localId]
          }
        }else {
          if(index === globalId) {
            delete this.$localIndex$[localId]
          }
        }
      }
    }else {
      delete this.$localIndex$[localId]
    }
  }
  return null
};
goog.$exportProperty$(Component.prototype, "deIndex", Component.prototype.$deIndex$);
Component.prototype.find = function(name) {
  if($A["util"].$isObject$(name)) {
    var type = name["instancesOf"];
    var instances = [];
    this.$findInstancesOf$(type, instances, this);
    return instances
  }else {
    var index = this.$localIndex$;
    if(index) {
      var globalId = index[name];
      if(globalId) {
        if($A["util"].isArray(globalId)) {
          var ret = [];
          var found;
          for(var i = 0;i < globalId.length;i++) {
            found = $A.$componentService$.get(globalId[i]);
            if(found !== null && found !== undefined) {
              ret.push(found)
            }
          }
          return ret
        }
        return $A.$componentService$.get(globalId)
      }
    }
  }
};
goog.$exportProperty$(Component.prototype, "find", Component.prototype.find);
Component.prototype.$findInstancesOf$ = function(type, ret, cmp) {
  cmp = cmp || this.$getSuperest$();
  var body = null;
  if(cmp.$getDef$().$getAttributeDefs$().$getDef$("body")) {
    body = cmp.get("v.body")
  }else {
    if(cmp.$isInstanceOf$("aura:expression")) {
      var value = cmp.get("v.value");
      if($A["util"].isArray(value)) {
        body = value
      }
    }
  }
  if(body) {
    for(var i = 0;i < body.length;i++) {
      cmp = body[i];
      if(cmp.$findInstanceOf$) {
        var inst = cmp.$findInstanceOf$(type);
        if(inst) {
          ret.push(inst)
        }else {
          cmp.$findInstancesOf$(type, ret)
        }
      }
    }
  }
};
Component.prototype.$getSuperest$ = function() {
  var superComponent = this.$getSuper$();
  if(superComponent) {
    return superComponent.$getSuperest$() || superComponent
  }else {
    return this
  }
};
Component.prototype.$findInstanceOf$ = function(type) {
  if(this.$getType$() === type) {
    return this
  }else {
    var superComponent = this.$getSuper$();
    if(superComponent) {
      return superComponent.$findInstanceOf$(type)
    }else {
      return null
    }
  }
};
Component.prototype.$isInstanceOf$ = function(name) {
  return this.$componentDef$.$isInstanceOf$(name)
};
goog.$exportProperty$(Component.prototype, "isInstanceOf", Component.prototype.$isInstanceOf$);
Component.prototype.$implementsDirectly$ = function(type) {
  return this.$componentDef$.$implementsDirectly$(type)
};
Component.prototype.$addEventHandler$ = function(event, handler, phase, includeFacets) {
  if(this.$destroyed$) {
    return
  }
  if($A["util"].$isExpression$(handler)) {
    var reference = handler;
    handler = $A.$eventService$.$expressionHandler$.bind($A.$eventService$, handler);
    handler.$reference$ = reference
  }
  if(!$A["util"].$isFunction$(handler)) {
    throw new Error("Component.addEventHandler: 'handler' must be a valid Function or a reference to a controller action, e.g., 'cmp.getReference(\"c.myAction\");'");
  }
  var def = this.$componentDef$.$getEventDef$(event) || $A.$eventService$.$getEventDef$(event);
  if(def && def.type === "APPLICATION") {
    $A.$eventService$.$addEventHandler$(this, def, handler, phase, includeFacets);
    return
  }
  phase = AuraEventService.$validatePhase$(phase, AuraEventService.$Phase$.$BUBBLE$);
  var dispatcher = this.$getEventDispatcher$();
  var handlers = dispatcher[event];
  if(!handlers) {
    handlers = dispatcher[event] = {}
  }
  var phaseHandlers = handlers[phase];
  if(!phaseHandlers) {
    handlers[phase] = phaseHandlers = []
  }
  if(includeFacets) {
    handler.$includeFacets$ = true
  }
  for(var i = 0;i < phaseHandlers.length;i++) {
    if(phaseHandlers[i] === handler || phaseHandlers[i].$reference$ && phaseHandlers[i].$reference$ === handler.$reference$) {
      return
    }
  }
  phaseHandlers.push(handler)
};
goog.$exportProperty$(Component.prototype, "addEventHandler", Component.prototype.$addEventHandler$);
Component.prototype.$addHandler$ = function(eventName, valueProvider, actionExpression, insert, phase, includeFacets) {
  if(this.$destroyed$) {
    return
  }
  var dispatcher = this.$getEventDispatcher$();
  if(!phase) {
    phase = "bubble"
  }
  var handlers = dispatcher[eventName];
  if(!handlers) {
    handlers = dispatcher[eventName] = {}
  }
  var phasedHandlers = handlers[phase];
  if(!phasedHandlers) {
    handlers[phase] = phasedHandlers = []
  }
  var actionCaller = this.$getActionCaller$(valueProvider, actionExpression);
  if($A["util"].$getBooleanValue$(includeFacets)) {
    actionCaller.$includeFacets$ = true
  }
  if(insert === true) {
    phasedHandlers.unshift(actionCaller)
  }else {
    phasedHandlers.push(actionCaller)
  }
};
goog.$exportProperty$(Component.prototype, "addHandler", Component.prototype.$addHandler$);
Component.prototype.$removeEventHandler$ = function(event, handler, phase) {
  var def = this.$componentDef$.$getEventDef$(event) || $A.$eventService$.$getEventDef$(event);
  if(def && def.type === "APPLICATION") {
    $A.$eventService$.$removeEventHandler$(this, def, handler, phase);
    return
  }
  phase = AuraEventService.$validatePhase$(phase, AuraEventService.$Phase$.$BUBBLE$);
  var dispatcher = this.$getEventDispatcher$();
  var handlers = null;
  if(dispatcher !== null) {
    handlers = dispatcher[event]
  }
  if(handlers !== null) {
    var phaseHandlers = handlers[phase];
    if(phaseHandlers) {
      for(var i = 0;i < phaseHandlers.length;i++) {
        if(phaseHandlers[i] === handler || phaseHandlers[i].$reference$ === handler) {
          phaseHandlers.splice(i, 1);
          break
        }
      }
    }
  }
};
goog.$exportProperty$(Component.prototype, "removeEventHandler", Component.prototype.$removeEventHandler$);
Component.prototype.$addValueHandler$ = function(config) {
  var value = config["value"];
  if($A["util"].$isExpression$(value) && value.getExpression() === "this") {
    var eventQName = this.$componentDef$.$getEventDef$(config["event"], true).$getDescriptor$().$getQualifiedName$();
    this.$addHandler$(eventQName, this, config["action"], false, "default");
    return
  }
  if(config["action"] && !config["method"]) {
    config["method"] = this.$getActionCaller$(this, config["action"].getExpression())
  }
  var component = this.$getConcreteComponent$();
  var event = config["event"];
  var handlers = component.$handlers$[event];
  if(!handlers) {
    handlers = component.$handlers$[event] = {}
  }
  var expression = config["value"];
  if($A["util"].$isExpression$(expression)) {
    expression = expression.getExpression()
  }
  if(!handlers[expression]) {
    handlers[expression] = []
  }
  for(var i = 0;i < handlers[expression].length;i++) {
    if(handlers[expression][i] === config["method"] || config["id"] && config["key"] && handlers[expression][i]["id"] === config["id"] && handlers[expression][i]["key"] === config["key"]) {
      return
    }
  }
  handlers[expression].push(config["method"])
};
goog.$exportProperty$(Component.prototype, "addValueHandler", Component.prototype.$addValueHandler$);
Component.prototype.$removeValueHandler$ = function(config) {
  var component = this.$getConcreteComponent$();
  var event = config["event"];
  var handlers = component.$handlers$[event];
  if(handlers) {
    var expression = config["value"];
    if($A["util"].$isExpression$(expression)) {
      expression = expression.getExpression()
    }
    if(handlers[expression]) {
      for(var i = 0;i < handlers[expression].length;i++) {
        var method = handlers[expression][i];
        if(method === config["method"] || config["id"] && config["key"] && method["id"] === config["id"] && method["key"] === config["key"]) {
          handlers[expression].splice(i--, 1)
        }
      }
    }
  }
};
goog.$exportProperty$(Component.prototype, "removeValueHandler", Component.prototype.$removeValueHandler$);
Component.prototype.$addDocumentLevelHandler$ = function(eventName, callback, autoEnable) {
  var dlh = new Aura.$Utils$.$DocLevelHandler$(eventName, callback, this);
  if(!this.$docLevelHandlers$) {
    this.$docLevelHandlers$ = {}
  }
  $A.assert(this.$docLevelHandlers$[eventName] === undefined, "Same doc level event set twice");
  this.$docLevelHandlers$[eventName] = dlh;
  dlh.$setEnabled$(autoEnable);
  return dlh
};
goog.$exportProperty$(Component.prototype, "addDocumentLevelHandler", Component.prototype.$addDocumentLevelHandler$);
Component.prototype.$removeDocumentLevelHandler$ = function(dlh) {
  if(dlh && dlh.$setEnabled$) {
    dlh.$setEnabled$(false);
    this.$docLevelHandlers$[dlh.$eventName$] = undefined
  }
};
goog.$exportProperty$(Component.prototype, "removeDocumentLevelHandler", Component.prototype.$removeDocumentLevelHandler$);
Component.prototype.$destroy$ = function() {
  if(arguments.length) {
    $A.$deprecated$("Component.destroy() no longer supports asynchronous destruction.", "Please remove any arguments passed to destroy().", "2017/02/07", "2018/02/07")
  }
  if(this.$destroyed$) {
    return
  }
  if(this.$concreteComponentId$) {
    var concrete = this.$getConcreteComponent$();
    if(concrete && concrete !== this && !concrete.$destroyed$) {
      concrete.$destroy$();
      return
    }
  }
  this.$destroyed$ = -1;
  this.$fire$("destroy");
  if(this.$docLevelHandlers$ !== undefined) {
    for(var handler in this.$docLevelHandlers$) {
      if(this.$docLevelHandlers$.hasOwnProperty(handler)) {
        this.$docLevelHandlers$[handler].$setEnabled$(false)
      }
    }
    this.$docLevelHandlers$ = undefined
  }
  $A.$renderingService$.$unrender$(this);
  if(this.$_marker$) {
    $A.$renderingService$.$removeMarkerReference$(this.$_marker$, this.$getGlobalId$());
    $A.$renderingService$.$removeElement$(this.$_marker$, this.$getContainer$());
    this.$_marker$ = null
  }
  this.elements = undefined;
  this.$allElements$ = undefined;
  if(this.$attributeSet$ && !this.$superComponent$) {
    var expressions = this.$attributeSet$.$destroy$();
    for(var x in expressions) {
      expressions[x].$removeChangeHandler$(this, "v." + x)
    }
    this.$attributeSet$ = null
  }
  var references = this.$references$;
  for(var key in references) {
    if(references[key]) {
      for(var access in references[key]) {
        references[key][access].$destroy$();
        delete references[key][access]
      }
    }
    delete references[key]
  }
  if(this.$model$) {
    this.$model$.$destroy$()
  }
  $A.$eventService$.$removeHandlersByComponentId$(this.$globalId$);
  var componentDef = this.$getDef$();
  var handlerDefs = componentDef.$getAppHandlerDefs$();
  if(handlerDefs) {
    for(var i = 0;i < handlerDefs.length;i++) {
      var handlerDef = handlerDefs[i];
      var handlerConfig = {};
      handlerConfig["globalId"] = this.$globalId$;
      handlerConfig["event"] = handlerDef["eventDef"].$getDescriptor$().$getQualifiedName$();
      $A.$eventService$.$removeHandler$(handlerConfig)
    }
  }
  var eventDispatcher = this.$getEventDispatcher$();
  if(eventDispatcher) {
    for(var event in eventDispatcher) {
      var vals = eventDispatcher[event];
      if(vals) {
        for(var phase in vals) {
          var arr = vals[phase];
          if(arr) {
            for(var j = 0;j < arr.length;j++) {
              delete arr[j]
            }
          }
        }
        delete eventDispatcher[event]
      }
    }
    this.$eventValueProvider$ = null
  }
  this.$doDeIndex$();
  $A.$componentService$.$deIndex$(this.$globalId$);
  this.$attributeValueProvider$ = null;
  if(this.$superComponent$) {
    this.$superComponent$.$destroy$()
  }
  var vp = this.$valueProviders$;
  if(vp) {
    for(var k in vp) {
      var v = vp[k];
      if(v && v !== this) {
        vp[k] = null
      }
    }
  }
  this.$destroyed$ = 1
};
goog.$exportProperty$(Component.prototype, "destroy", Component.prototype.$destroy$);
Component.prototype.$superRender$ = function() {
  if(this.$superComponent$) {
    return this.$superComponent$["render"]()
  }
};
goog.$exportProperty$(Component.prototype, "superRender", Component.prototype.$superRender$);
Component.prototype.$superAfterRender$ = function() {
  if(this.$superComponent$) {
    this.$superComponent$["afterRender"]()
  }
};
goog.$exportProperty$(Component.prototype, "superAfterRender", Component.prototype.$superAfterRender$);
Component.prototype.$superRerender$ = function() {
  if(this.$superComponent$) {
    return this.$superComponent$["rerender"]()
  }
};
goog.$exportProperty$(Component.prototype, "superRerender", Component.prototype.$superRerender$);
Component.prototype.$superUnrender$ = function() {
  if(this.$superComponent$) {
    this.$superComponent$["unrender"]()
  }
};
goog.$exportProperty$(Component.prototype, "superUnrender", Component.prototype.$superUnrender$);
Component.prototype.$isRendered$ = function() {
  return this.$rendered$
};
goog.$exportProperty$(Component.prototype, "isRendered", Component.prototype.$isRendered$);
Component.prototype.$setUnrendering$ = function(unrendering) {
  this.$inUnrender$ = unrendering
};
Component.prototype.$isUnrendering$ = function() {
  return this.$inUnrender$
};
Component.prototype.$setRendered$ = function(rendered) {
  this.$rendered$ = rendered
};
Component.prototype.$getRenderer$ = function() {
  return this["renderer"]
};
goog.$exportProperty$(Component.prototype, "getRenderer", Component.prototype.$getRenderer$);
Component.prototype.$getRenderable$ = function() {
  return this["renderer"].$renderable$
};
goog.$exportProperty$(Component.prototype, "getRenderable", Component.prototype.$getRenderable$);
Component.prototype.$getGlobalId$ = function() {
  return this.$concreteComponentId$ || this.$globalId$
};
goog.$exportProperty$(Component.prototype, "getGlobalId", Component.prototype.$getGlobalId$);
Component.prototype.$getLocalId$ = function() {
  return this.$localId$
};
goog.$exportProperty$(Component.prototype, "getLocalId", Component.prototype.$getLocalId$);
Component.prototype.$getRendering$ = function() {
  var concrete = this.$getConcreteComponent$();
  if(this !== concrete) {
    return concrete.$getRendering$()
  }else {
    return this.$rendering$
  }
};
goog.$exportProperty$(Component.prototype, "getRendering", Component.prototype.$getRendering$);
Component.prototype.$getSuper$ = function() {
  return this.$superComponent$
};
goog.$exportProperty$(Component.prototype, "getSuper", Component.prototype.$getSuper$);
Component.prototype.$associateElement$ = function(element) {
  if(!this.$isConcrete$()) {
    var concrete = this.$getConcreteComponent$();
    concrete.$associateElement$(element)
  }else {
    if(!this.elements) {
      this.elements = []
    }
    if(!this.$allElements$) {
      this.$allElements$ = []
    }
    this.$allElements$.push(element);
    if(!element.$aura_marker$) {
      this.elements.push(element);
      this.$associateRenderedBy$(this, element)
    }
  }
};
goog.$exportProperty$(Component.prototype, "associateElement", Component.prototype.$associateElement$);
Component.prototype.$disassociateElements$ = function() {
  if(!this.$isConcrete$()) {
    var concrete = this.$getConcreteComponent$();
    concrete.$disassociateElements$()
  }else {
    if(this.elements) {
      this.elements.length = 0
    }
    if(this.$allElements$) {
      this.$allElements$.length = 0
    }
  }
};
goog.$exportProperty$(Component.prototype, "disassociateElements", Component.prototype.$disassociateElements$);
Component.prototype.$getElements$ = function() {
  if(!this.$isConcrete$()) {
    var concrete = this.$getConcreteComponent$();
    return concrete.$getElements$()
  }else {
    return this.elements && this.elements.slice(0) || []
  }
};
goog.$exportProperty$(Component.prototype, "getElements", Component.prototype.$getElements$);
Component.prototype.$getElement$ = function() {
  var elements = this.$getElements$();
  if(elements) {
    for(var i = 0;i < elements.length;i++) {
      if(elements[i]) {
        return elements[i]
      }
    }
  }
  return null
};
goog.$exportProperty$(Component.prototype, "getElement", Component.prototype.$getElement$);
Component.prototype.$getReference$ = function(key) {
  if(this.$destroyed$ === 1) {
    return null
  }
  key = $A.$expressionService$.normalize(key);
  var access = $A.$clientService$.$currentAccess$;
  var accessId = access && access.$getGlobalId$();
  if(!this.$references$.hasOwnProperty(key)) {
    this.$references$[key] = {}
  }
  if(!this.$references$[key].hasOwnProperty(accessId)) {
    this.$references$[key][accessId] = new PropertyReferenceValue(key, this)
  }
  return this.$references$[key][accessId]
};
goog.$exportProperty$(Component.prototype, "getReference", Component.prototype.$getReference$);
Component.prototype.$clearReference$ = function(key) {
  if(!this.$destroyed$) {
    key = $A.$expressionService$.normalize(key);
    $A.assert(key.indexOf(".") > -1, "Unable to clear reference for key '" + key + "'. No value provider was specified. Did you mean 'v." + key + "'?");
    var path = key.split(".");
    var valueProvider = this.$getValueProvider$(path.shift(), this);
    $A.assert(valueProvider, "Unknown value provider for key '" + key + "'.");
    $A.assert(valueProvider.$clearReference$, "Value provider does not implement clearReference() method.");
    var subPath = path.join(".");
    var value = valueProvider.$clearReference$(subPath);
    if($A["util"].$isExpression$(value)) {
      value.$removeChangeHandler$(this, key)
    }
  }
};
goog.$exportProperty$(Component.prototype, "clearReference", Component.prototype.$clearReference$);
Component.prototype.get = function(key) {
  if(this.$destroyed$ === 1) {
    return undefined
  }
  key = $A.$expressionService$.normalize(key);
  var path = key.split(".");
  var root = path.shift();
  var valueProvider = this.$getValueProvider$(root, this);
  if(path.length) {
    if(!valueProvider) {
      $A.assert(false, "Unable to get value for key '" + key + "'. No value provider was found for '" + root + "'.")
    }
    var value;
    if($A["util"].$isFunction$(valueProvider.get)) {
      value = valueProvider.get(path.join("."), this)
    }else {
      value = $A.$expressionService$.$resolve$(path, valueProvider)
    }
    return value
  }else {
    return valueProvider
  }
};
goog.$exportProperty$(Component.prototype, "get", Component.prototype.get);
Component.prototype.$getShadowAttribute$ = function(key) {
  if(key.indexOf("v.") !== 0) {
    return null
  }
  return this.$attributeSet$.$getShadowValue$(key.substr(2))
};
Component.prototype.set = function(key, value, ignoreChanges) {
  if(this.$destroyed$ !== 1) {
    key = $A.$expressionService$.normalize(key);
    $A.assert(key.indexOf(".") > -1, "Unable to set value for key '" + key + "'. No value provider was specified. Did you mean 'v." + key + "'?");
    var path = key.split(".");
    var root = path.shift();
    var valueProvider = this.$getValueProvider$(root, this);
    if(!valueProvider) {
      $A.assert(false, "Unable to set value for key '" + key + "'. No value provider was found for '" + root + "'.")
    }
    if(!valueProvider.set) {
      $A.assert(false, "Unable to set value for key '" + key + "'. Value provider does not implement 'set(key, value)'.")
    }
    var subPath = path.join(".");
    var oldValue = valueProvider.get(subPath, this);
    if($A["util"].isArray(oldValue) && oldValue.length) {
      var containsOnlyComponents = true;
      for(var i = 0;i < oldValue.length && containsOnlyComponents;i++) {
        containsOnlyComponents = $A["util"].$isComponent$(oldValue[i])
      }
      if(containsOnlyComponents) {
        this.$trackComponentReplacement$(oldValue, key)
      }
    }
    var returnValue = valueProvider.set(subPath, value, this);
    if($A["util"].$isExpression$(value)) {
      value.$addChangeHandler$(this, key);
      if(!ignoreChanges) {
        value = value.evaluate()
      }
    }
    var changed = $A["util"].isArray(value) || $A["util"].$isObject$(value) || oldValue !== value;
    if(changed && !ignoreChanges) {
      $A.$renderingService$.$addDirtyValue$(key, this);
      var index = path.length > 1 ? path[path.length - 1] : undefined;
      this.$fireChangeEvent$(key, oldValue, value, index)
    }
    return returnValue
  }
};
goog.$exportProperty$(Component.prototype, "set", Component.prototype.set);
Component.prototype.$trackComponentReplacement$ = function(prevCmps, key) {
  var potentialLeak = [];
  for(var i = 0;i < prevCmps.length;i++) {
    if(prevCmps[i].$isValid$() && !prevCmps[i].$isRendered$() && prevCmps[i].$autoDestroy$()) {
      potentialLeak.push(prevCmps[i])
    }
  }
  if(potentialLeak.length) {
    var owner = this;
    var handler = function() {
      var actualLeak = [];
      for(var j = 0;j < potentialLeak.length;j++) {
        if(potentialLeak[j].$isValid$() && !potentialLeak[j].$isRendered$() && potentialLeak[j].$autoDestroy$()) {
          actualLeak.push(potentialLeak[j])
        }
      }
      if(actualLeak.length) {
        $A.$warning$(["[Performance degradation] ", actualLeak.length + " component(s) in " + owner.$getType$() + ' ["' + owner.$getGlobalId$() + '"] ', 'have been created and removed before being rendered when calling cmp.set("' + key + '").\n', "More info: https://sfdc.co/performance-aura-component-set\n", "Component hierarchy: " + $A["util"].$getComponentHierarchy$(owner)].join(""))
      }
    };
    $A.$eventService$.$addHandlerOnce$({"event":"aura:doneRendering", "globalId":"componentService", "handler":handler})
  }
};
Component.prototype.$setShadowAttribute$ = function(key, value) {
  if(key.indexOf("v.") === 0) {
    var oldValue = this.get(key);
    var attribute = key.substr(2);
    this.$attributeSet$.$setShadowValue$(attribute, value);
    var newValue = this.get(key);
    if(oldValue !== newValue) {
      $A.$renderingService$.$addDirtyValue$(key, this);
      this.$fireChangeEvent$(key, oldValue, newValue)
    }
  }
};
Component.prototype.$markDirty$ = function(reason) {
  if(!this.$destroyed$) {
    $A.$renderingService$.$addDirtyValue$(reason || "Component.markDirty()", this)
  }
};
goog.$exportProperty$(Component.prototype, "markDirty", Component.prototype.$markDirty$);
Component.prototype.$markClean$ = function(value) {
  $A.$renderingService$.$removeDirtyValue$(value, this)
};
goog.$exportProperty$(Component.prototype, "markClean", Component.prototype.$markClean$);
Component.prototype.$fireChangeEvent$ = function(key, oldValue, newValue, index) {
  if(!this.$destroyed$) {
    var component = this.$concreteComponentId$ ? this.$getConcreteComponent$() : this;
    var handlers = component.$handlers$ && component.$handlers$["change"];
    var observers = [];
    var keypath = key + ".";
    for(var handler in handlers) {
      if(handler === key || handler.indexOf(keypath) === 0 || key.indexOf(handler + ".") === 0) {
        observers = observers.concat(handlers[handler])
      }
    }
    if(observers.length) {
      var eventDef = $A.$eventService$.$getEventDef$("aura:valueChange");
      var dispatcher = {};
      dispatcher[eventDef.$getDescriptor$().$getQualifiedName$()] = {"default":observers};
      var changeEvent = new Aura.$Event$.$Event$({"eventDef":eventDef, "eventDispatcher":dispatcher});
      changeEvent.$setParams$({"expression":key, "value":newValue, "oldValue":oldValue, "index":index});
      changeEvent.$fire$()
    }
  }
};
Component.prototype.$autoDestroy$ = function(destroy) {
  if(!$A["util"].$isUndefinedOrNull$(destroy)) {
    this.$shouldAutoDestroy$ = !!destroy
  }else {
    return this.$shouldAutoDestroy$
  }
};
goog.$exportProperty$(Component.prototype, "autoDestroy", Component.prototype.$autoDestroy$);
Component.prototype.$getConcreteComponent$ = function() {
  return this.$concreteComponentId$ && $A.$componentService$.get(this.$concreteComponentId$) || this
};
goog.$exportProperty$(Component.prototype, "getConcreteComponent", Component.prototype.$getConcreteComponent$);
Component.prototype.$isConcrete$ = function() {
  return!this.$concreteComponentId$
};
goog.$exportProperty$(Component.prototype, "isConcrete", Component.prototype.$isConcrete$);
Component.prototype.$getAttributeValueProvider$ = function() {
  return this.$attributeValueProvider$ || this
};
goog.$exportProperty$(Component.prototype, "getAttributeValueProvider", Component.prototype.$getAttributeValueProvider$);
Component.prototype.$setAttributeValueProvider$ = function(avp) {
  this.$attributeValueProvider$ = avp;
  if(avp) {
    this.$owner$ = avp.$globalId$;
    avp.index(this.$localId$, this.$globalId$)
  }
};
goog.$exportProperty$(Component.prototype, "setAttributeValueProvider", Component.prototype.$setAttributeValueProvider$);
Component.prototype.$getComponentValueProvider$ = function() {
  for(var valueProvider = this.$attributeValueProvider$ || this.$facetValueProvider$;!$A["util"].$isComponent$(valueProvider) && $A["util"].$isFunction$(valueProvider.$getComponent$);) {
    valueProvider = valueProvider.$getComponent$()
  }
  return valueProvider
};
goog.$exportProperty$(Component.prototype, "getComponentValueProvider", Component.prototype.$getComponentValueProvider$);
Component.prototype.$getOwner$ = function() {
  if($A["util"].$isUndefinedOrNull$(this.$owner$)) {
    this.$owner$ = this.$getAttributeValueProvider$().$globalId$
  }
  return $A.$componentService$.get(this.$owner$)
};
goog.$exportProperty$(Component.prototype, "getOwner", Component.prototype.$getOwner$);
Component.prototype.$getContainer$ = function() {
  return $A.$getComponent$(this.$containerComponentId$)
};
Component.prototype.$addValueProvider$ = function(key, valueProvider) {
  if(!this.$destroyed$) {
    $A.assert($A["util"].$isString$(key), "Component.addValueProvider(): 'key' must be a valid String.");
    $A.assert(",v,m,c,e,this,globalid,def,super,null,version,".indexOf("," + key.toLowerCase() + ",") === -1, "Component.addValueProvider(): '" + key + "' is a reserved valueProvider.");
    $A.assert(!$A["util"].$isUndefinedOrNull$(valueProvider), "Component.addValueProvider(): 'valueProvider' is required.");
    this.$valueProviders$[key] = valueProvider
  }
};
goog.$exportProperty$(Component.prototype, "addValueProvider", Component.prototype.$addValueProvider$);
Component.prototype.$removeValueProvider$ = function(key) {
  if(!this.$destroyed$) {
    $A.assert($A["util"].$isString$(key), "Component.removeValueProvider(): 'key' must be a valid String.");
    $A.assert(",v,m,c,e,this,globalid,def,super,null,version,".indexOf("," + key.toLowerCase() + ",") === -1, "Component.removeValueProvider(): '" + key + "' is a reserved valueProvider and can not be removed.");
    this.$valueProviders$[key] = null
  }
};
Component.prototype.$getModel$ = function() {
  return this.$model$
};
goog.$exportProperty$(Component.prototype, "getModel", Component.prototype.$getModel$);
Component.prototype.$getEvent$ = function(name) {
  var eventDef = this.$getDef$().$getEventDef$(name);
  if(!eventDef || this.$destroyed$ === 1) {
    return null
  }
  if(!$A.$clientService$.$allowAccess$(eventDef, this)) {
    var message = "Access Check Failed! Component.getEvent():'" + name + "' of component '" + this + "' is not visible to '" + $A.$clientService$.$currentAccess$ + "'.";
    if($A.$clientService$.$enableAccessChecks$) {
      if($A.$clientService$.$logAccessFailures$) {
        $A.error(null, new $A.$auraError$(message))
      }
      return null
    }else {
      if($A.$clientService$.$logAccessFailures$) {
        $A.$warning$(message)
      }
    }
  }
  return new Aura.$Event$.$Event$({"name":name, "eventDef":eventDef, "component":this.$getConcreteComponent$()})
};
goog.$exportProperty$(Component.prototype, "getEvent", Component.prototype.$getEvent$);
Component.prototype.$getEventByDescriptor$ = function(descriptor) {
  var name = this.$getDef$().$getEventNameByDescriptor$(descriptor);
  if(name === null) {
    return null
  }
  return this.$getEvent$(name)
};
Component.prototype.$fire$ = function(name) {
  var dispatcher = this.$getEventDispatcher$();
  if(!dispatcher) {
    return
  }
  var eventDef = this.$componentDef$.$getEventDef$(name, true);
  var eventQName = eventDef.$getDescriptor$().$getQualifiedName$();
  var handlers = dispatcher[eventQName];
  if(handlers) {
    var event = new Aura.$Event$.$Event$({"eventDef":eventDef, "eventDispatcher":dispatcher});
    event.$setParams$({value:this});
    event.$fire$()
  }
};
Component.prototype.$isDirty$ = function(expression) {
  if(!expression) {
    return $A.$renderingService$.$hasDirtyValue$(this)
  }
  return $A.$renderingService$.$isDirtyValue$(expression, this)
};
goog.$exportProperty$(Component.prototype, "isDirty", Component.prototype.$isDirty$);
Component.prototype.$isValid$ = function() {
  return!this.$destroyed$
};
goog.$exportProperty$(Component.prototype, "isValid", Component.prototype.$isValid$);
Component.prototype.toString = function() {
  if(!this.$_description$) {
    this.$_description$ = this.$getDef$() + " {" + this.$globalId$ + "}" + (this.$getLocalId$() ? " {" + this.$getLocalId$() + "}" : "")
  }
  var attributesOutput = [];
  var attributeSet = this.$attributeSet$;
  if(attributeSet) {
    for(var key in attributeSet.$values$) {
      attributesOutput.push(" " + key + ' \x3d "' + attributeSet.$values$[key] + '"')
    }
  }
  return this.$_description$ + attributesOutput.join(",")
};
goog.$exportProperty$(Component.prototype, "toString", Component.prototype.toString);
Component.prototype.toJSON = function() {
  return{"globalId":this.$globalId$, "isValid":this.$isValid$()}
};
Component.prototype.$getHandledEvents$ = function() {
  var ret = {};
  var concrete = this.$getConcreteComponent$();
  var eventDispatcher = concrete.$getEventDispatcher$();
  if(eventDispatcher) {
    for(var name in eventDispatcher) {
      if(eventDispatcher.hasOwnProperty(name)) {
        var eventHandlerConfig = eventDispatcher.hasOwnProperty(name) && eventDispatcher[name];
        for(var phase in eventHandlerConfig) {
          if(eventHandlerConfig.hasOwnProperty(phase) && eventHandlerConfig[phase].length) {
            ret[name.toLowerCase()] = true;
            break
          }
        }
      }
    }
  }
  return ret
};
goog.$exportProperty$(Component.prototype, "getHandledEvents", Component.prototype.$getHandledEvents$);
Component.prototype.$hasEventHandler$ = function(eventName) {
  if(eventName) {
    var handledEvents = this.$getHandledEvents$();
    return handledEvents[eventName.toLowerCase()]
  }
  return false
};
goog.$exportProperty$(Component.prototype, "hasEventHandler", Component.prototype.$hasEventHandler$);
Component.prototype.$getFacets$ = function() {
  if(!this.$_cachedFacetNames$) {
    var facetNames = [];
    var attributeDefs = this.$getDef$().$getAttributeDefs$();
    var values = attributeDefs.$getValues$();
    if(values) {
      var valueNames = attributeDefs.$getNames$();
      var attributeDef;
      var c = 0;
      for(var length = valueNames.length;c < length;c++) {
        attributeDef = values[valueNames[c]];
        if(attributeDef.$getTypeDefDescriptor$() === "aura://Aura.Component[]") {
          facetNames.push(attributeDef.$getDescriptor$().getName())
        }
      }
    }
    this.$_cachedFacetNames$ = facetNames
  }
  var names = this.$_cachedFacetNames$;
  var facets = [];
  var i = 0;
  for(var len = names.length;i < len;i++) {
    facets.push(this.get("v." + names[i]))
  }
  return facets
};
goog.$exportProperty$(Component.prototype, "getFacets", Component.prototype.$getFacets$);
Component.prototype.$isFlavorable$ = function() {
  return this.$flavorable$
};
goog.$exportProperty$(Component.prototype, "isFlavorable", Component.prototype.$isFlavorable$);
Component.prototype.$getFlavor$ = function() {
  return this.$flavor$ || this.$getDef$().$getDefaultFlavor$()
};
goog.$exportProperty$(Component.prototype, "getFlavor", Component.prototype.$getFlavor$);
Component.prototype.$render$ = function() {
  if(this.$destroyed$) {
    return null
  }
  var render = this["renderer"] && this["renderer"]["render"];
  if(render) {
    $A.$clientService$.$setCurrentAccess$(this);
    try {
      var secureThis = $A.$lockerService$.$wrapComponent$(this);
      var result = render(secureThis, this["helper"]);
      if(secureThis !== this) {
        result = $A.$lockerService$.$unwrap$(this, result)
      }
      return result
    }finally {
      $A.$clientService$.$releaseCurrentAccess$()
    }
  }else {
    return this.$superRender$()
  }
};
goog.$exportProperty$(Component.prototype, "render", Component.prototype.$render$);
Component.prototype.$afterRender$ = function() {
  if(this.$destroyed$) {
    return
  }
  var afterRender = this["renderer"] && this["renderer"]["afterRender"];
  if(afterRender) {
    $A.$clientService$.$setCurrentAccess$(this);
    try {
      afterRender($A.$lockerService$.$wrapComponent$(this), this["helper"])
    }finally {
      $A.$clientService$.$releaseCurrentAccess$()
    }
  }else {
    this.$superAfterRender$()
  }
};
goog.$exportProperty$(Component.prototype, "afterRender", Component.prototype.$afterRender$);
Component.prototype.$rerender$ = function() {
  if(this.$destroyed$) {
    return null
  }
  var rerender = this["renderer"] && this["renderer"]["rerender"];
  if(rerender) {
    $A.$clientService$.$setCurrentAccess$(this);
    try {
      var secureThis = $A.$lockerService$.$wrapComponent$(this);
      var result = rerender(secureThis, this["helper"]);
      if(secureThis !== this) {
        result = $A.$lockerService$.$unwrap$(this, result)
      }
      return result
    }finally {
      $A.$clientService$.$releaseCurrentAccess$()
    }
  }else {
    return this.$superRerender$()
  }
};
goog.$exportProperty$(Component.prototype, "rerender", Component.prototype.$rerender$);
Component.prototype.$unrender$ = function() {
  if(this.$destroyed$ === 1) {
    return
  }
  $A.$renderingService$.$cleanComponent$(this.$globalId$);
  var unrender = this["renderer"] && this["renderer"]["unrender"];
  if(unrender) {
    $A.$clientService$.$setCurrentAccess$(this);
    try {
      unrender($A.$lockerService$.$wrapComponent$(this), this["helper"])
    }finally {
      $A.$clientService$.$releaseCurrentAccess$()
    }
  }else {
    if(this.$isRootComponent$) {
      $A.$renderingService$.$unrenderFacet$(this)
    }
    this.$superUnrender$()
  }
};
goog.$exportProperty$(Component.prototype, "unrender", Component.prototype.$unrender$);
Component.prototype.$getVersion$ = function() {
  if(this.$destroyed$) {
    return null
  }
  var ret = this.$getVersionInternal$();
  return ret ? ret : this.get("version")
};
goog.$exportProperty$(Component.prototype, "getVersion", Component.prototype.$getVersion$);
Component.prototype.$getVersionInternal$ = function() {
  return $A.$clientService$.$getAccessVersion$(this.$getType$().split(":")[0])
};
Component.prototype.$getValueProvider$ = function(key) {
  $A.assert($A["util"].$isString$(key), "Component.getValueProvider(): 'key' must be a valid String.");
  return this.$valueProviders$[key] || this.$valueProviders$[key.toLowerCase()]
};
Component.prototype.$setupValueProviders$ = function(customValueProviders) {
  if(!this.$attributeSet$) {
    this.$attributeSet$ = this.$isConcrete$() ? new AttributeSet(this.$componentDef$.$attributeDefs$) : this.$getConcreteComponent$().$attributeSet$
  }
  var vp = this.$valueProviders$;
  vp["v"] = this.$attributeSet$;
  vp["m"] = this.$model$;
  vp["c"] = this.$createActionValueProvider$();
  vp["e"] = this.$createEventValueProvider$();
  vp["this"] = this;
  vp["globalid"] = this.$getGlobalId$();
  vp["def"] = this.$componentDef$;
  vp["style"] = this.$createStyleValueProvider$();
  vp["super"] = this.$superComponent$;
  vp["null"] = null;
  vp["version"] = this.version ? this.version : this.$getVersionInternal$();
  if(customValueProviders) {
    for(var key in customValueProviders) {
      this.$addValueProvider$(key, customValueProviders[key])
    }
  }
};
Component.prototype.$createActionValueProvider$ = function() {
  var controllerDef = this.$componentDef$.$getControllerDef$();
  if(controllerDef || this["controller"]) {
    return new ActionValueProvider(this, controllerDef)
  }
};
Component.prototype.$createStyleValueProvider$ = function() {
  return new StyleValueProvider(this)
};
Component.prototype.$setupComponentDef$ = function(config) {
  var componentDef = $A.$componentService$.$getDef$(config["componentDef"]);
  $A.assert(componentDef, "componentDef is required");
  this.$componentDef$ = componentDef;
  if(config["original"]) {
    this.$replaceComponentClass$(componentDef.$getDescriptor$().$getQualifiedName$())
  }
  $A.$lockerService$.$trust$(this.$componentDef$, this)
};
Component.prototype.$createComponentStack$ = function(facets, valueProvider) {
  var facetStack = {};
  for(var i = 0;i < facets.length;i++) {
    var facet = facets[i];
    var facetName = facet["descriptor"];
    var facetConfig = facet["value"];
    if(!$A["util"].isArray(facetConfig)) {
      facetConfig = [facetConfig]
    }
    var action = $A.getContext().$getCurrentAction$();
    if(action) {
      action.$pushCreationPath$(facetName)
    }
    var components = [];
    for(var index = 0;index < facetConfig.length;index++) {
      var config = facetConfig[index];
      if($A["util"].$isComponent$(config)) {
        components.push(config);
        config.$setContainerComponentId$(this.$globalId$)
      }else {
        if(config && config["componentDef"]) {
          if(action) {
            action.$setCreationPathIndex$(index)
          }
          $A.$clientService$.$setCurrentAccess$(valueProvider);
          try {
            var facetConfigAttr = {"values":{}};
            var facetConfigClone = $A["util"].apply({}, config);
            if(facetConfigClone["attributes"]) {
              $A["util"].apply(facetConfigAttr["values"], config["attributes"]["values"], true)
            }else {
              facetConfigClone["attributes"] = {}
            }
            facetConfigAttr["valueProvider"] = config["attributes"] && config["attributes"]["valueProvider"] || valueProvider;
            facetConfigClone["attributes"] = facetConfigAttr;
            facetConfigClone["containerComponentId"] = this.$globalId$;
            components.push($A.$componentService$.$createComponentPriv$(facetConfigClone))
          }finally {
            $A.$clientService$.$releaseCurrentAccess$()
          }
        }else {
          throw new $A.$auraError$("Component.createComponentStack: invalid config. Expected component definition, found '" + config + "'.", null, $A.severity.$QUIET$);
        }
      }
    }
    if(action) {
      action.$popCreationPath$(facetName)
    }
    facetStack[facetName] = components
  }
  return facetStack
};
Component.prototype.$setupSuper$ = function(configAttributes) {
  var superDef = this.$componentDef$.$getSuperDef$();
  if(superDef) {
    var superConfig = {};
    var superAttributes = {};
    superConfig["componentDef"] = {"descriptor":superDef.$getDescriptor$().toString()};
    superConfig["concreteComponentId"] = this.$concreteComponentId$ || this.$globalId$;
    $A.$pushCreationPath$("super");
    $A.$clientService$.$setCurrentAccess$(this);
    try {
      if(configAttributes) {
        superAttributes["values"] = {};
        var facets = this.$componentDef$.$getFacets$();
        if(facets) {
          for(var i = 0;i < facets.length;i++) {
            var facetDef = AttributeSet.$getDef$(facets[i]["descriptor"], this.$componentDef$);
            if(!$A.$clientService$.$allowAccess$(facetDef[0], facetDef[1])) {
              var message = "Access Check Failed! Component.setupSuper():'" + facets[i]["descriptor"] + "' of component '" + this + "' is not visible to '" + $A.$clientService$.$currentAccess$ + "'.";
              if($A.$clientService$.$enableAccessChecks$) {
                if($A.$clientService$.$logAccessFailures$) {
                  $A.error(null, new $A.$auraError$(message))
                }
                continue
              }else {
                if($A.$clientService$.$logAccessFailures$) {
                  $A.$warning$(message)
                }
              }
            }
            superAttributes["values"][facets[i]["descriptor"]] = facets[i]["value"]
          }
        }
        superAttributes["events"] = configAttributes["events"];
        superAttributes["valueProvider"] = configAttributes["facetValueProvider"]
      }
      superConfig["attributes"] = superAttributes;
      this.$setSuperComponent$($A.$componentService$.$createComponentPriv$(superConfig))
    }finally {
      $A.$clientService$.$releaseCurrentAccess$();
      $A.$popCreationPath$("super")
    }
  }
};
Component.prototype.$setSuperComponent$ = function(component) {
  if(component) {
    this.$superComponent$ = component
  }
};
Component.prototype.$isCollectionOfAuraComponentDefs$ = function(facetValueConfig) {
  if($A["util"].isArray(facetValueConfig)) {
    for(var i = 0;i < facetValueConfig.length;i++) {
      var facetItem = facetValueConfig[i];
      if(!facetItem["componentDef"] || !facetItem["componentDef"]["descriptor"]) {
        return false
      }
    }
    return true
  }else {
    return false
  }
};
Component.prototype.$setupAttributes$ = function(config, localCreation) {
  var configValues = config && config["values"] || {};
  if(!configValues.hasOwnProperty("body")) {
    configValues["body"] = []
  }
  var attributes = {};
  var attributeDefs = this.$componentDef$.$attributeDefs$;
  var attributeNames = attributeDefs.$getNames$();
  var setByDefault = {};
  var partialAttributes = this.$partialConfig$ && this.$partialConfig$["attributes"] && this.$partialConfig$["attributes"]["values"];
  if(!this.$concreteComponentId$) {
    for(var x = 0;x < attributeNames.length;x++) {
      var name = attributeNames[x];
      var defaultDef = attributeDefs.$getDef$(name);
      var defaultValue = defaultDef.$getDefault$();
      if(defaultValue !== undefined) {
        if(!configValues.hasOwnProperty(name) || $A["util"].$equals$(configValues[name], defaultValue)) {
          setByDefault[name] = true;
          if(defaultDef.$getTypeDefDescriptor$() === "aura://Aura.Component[]" || defaultDef.$getTypeDefDescriptor$() === "aura://Aura.ComponentDefRef[]") {
            defaultValue = $A["util"].apply([], defaultValue, true, true);
            for(var facet = 0;facet < defaultValue.length;facet++) {
              if(defaultValue[facet]["attributes"] && !defaultValue[facet]["attributes"]["valueProvider"]) {
                defaultValue[facet]["attributes"]["valueProvider"] = this
              }
            }
            configValues[defaultDef.$getDescriptor$().getName()] = defaultValue
          }else {
            configValues[defaultDef.$getDescriptor$().getName()] = valueFactory.create(defaultValue, this)
          }
        }
      }
      if(!setByDefault[name] && partialAttributes && partialAttributes[name] === configValues[name]) {
        setByDefault[name] = true
      }
    }
  }
  for(var attribute in configValues) {
    var value = configValues[attribute];
    var attributeDef = attributeDefs.$getDef$(attribute);
    if(!attributeDef) {
      continue
    }
    if($A.$componentService$.$isConfigDescriptor$(value)) {
      value = value["value"]
    }
    var attributeType = attributeDef.$getTypeDefDescriptor$();
    var isFacet = attributeType === "aura://Aura.Component[]" || attributeType === "aura://Object" && this.$isCollectionOfAuraComponentDefs$(value);
    var isDefRef = attributeType === "aura://Aura.ComponentDefRef[]";
    if(!setByDefault[attribute]) {
      var def = AttributeSet.$getDef$(attribute, this.$getDef$());
      if(!$A.$clientService$.$allowAccess$(def[0], def[1])) {
        var message = "Access Check Failed! Component.setupAttributes():'" + attribute + "' of component '" + this + "' is not visible to '" + $A.$clientService$.$currentAccess$ + "'.";
        if($A.$clientService$.$enableAccessChecks$) {
          if($A.$clientService$.$logAccessFailures$) {
            $A.error(null, new $A.$auraError$(message))
          }
          continue
        }else {
          if($A.$clientService$.$logAccessFailures$) {
            $A.$warning$(message)
          }
        }
      }
    }
    if(isFacet) {
      if($A["util"].$isUndefinedOrNull$(value)) {
        continue
      }
      var attributeValueProvider = config && config["valueProvider"] || this.$getAttributeValueProvider$();
      value = valueFactory.create(value, config["valueProvider"]);
      if($A["util"].$isExpression$(value)) {
        value.$addChangeHandler$(this, "v." + attribute);
        value = value.evaluate()
      }
      if($A["util"].$isString$(value)) {
        value = [$A.$componentService$.$createComponentPriv$({"componentDef":{"descriptor":"markup://aura:text"}, "attributes":{"values":{"value":value}}})]
      }
      var facetStack = this.$createComponentStack$([{"descriptor":attribute, value:value}], attributeValueProvider, localCreation);
      if(attribute === "body") {
        attributes[attribute] = this.$concreteComponentId$ && this.$getConcreteComponent$().$attributeSet$.$values$["body"] || {};
        attributes[attribute][this.$globalId$] = facetStack["body"] || []
      }else {
        attributes[attribute] = facetStack[attribute]
      }
    }else {
      if(isDefRef) {
        if($A["util"].$isUndefinedOrNull$(value)) {
          continue
        }
        if(!$A["util"].isArray(value)) {
          var reference = valueFactory.create(value, config["valueProvider"]);
          if($A["util"].$isExpression$(reference)) {
            reference.$addChangeHandler$(this, "v." + attribute, null, true);
            value = reference.evaluate()
          }else {
            value = [value];
            $A.$warning$("Component.setupAttributes: CDR[] WAS NOT AN ARRAY")
          }
        }
        var cdrs = [];
        for(var i = 0;i < value.length;i++) {
          var cdrObj = value[i];
          var cdr = {"attributes":{"values":{}}};
          cdr["componentDef"] = cdrObj["componentDef"];
          cdr["localId"] = cdrObj["localId"];
          cdr["flavor"] = cdrObj["flavor"];
          if(cdrObj["attributes"]) {
            $A["util"].apply(cdr["attributes"]["values"], cdrObj["attributes"]["values"])
          }
          cdr["attributes"]["valueProvider"] = cdrObj["attributes"] && cdrObj["attributes"]["valueProvider"] || config["valueProvider"];
          cdrs.push(cdr)
        }
        if(attribute === "body") {
          attributes[attribute] = this.$concreteComponentId$ && this.$getConcreteComponent$().$attributeSet$.$values$["body"] || {};
          attributes[attribute][this.$globalId$] = cdrs
        }else {
          attributes[attribute] = cdrs
        }
      }else {
        attributes[attribute] = valueFactory.create(value, config["valueProvider"] || this);
        if($A["util"].$isExpression$(attributes[attribute])) {
          attributes[attribute].$addChangeHandler$(this, "v." + attribute)
        }
      }
    }
  }
  if(this.$concreteComponentId$) {
    var concreteComponent = this.$getConcreteComponent$();
    concreteComponent.$attributeSet$.$merge$(attributes, null, this);
    this.$attributeSet$ = concreteComponent.$attributeSet$
  }else {
    this.$attributeSet$.$initialize$(attributes, this)
  }
};
Component.prototype.$validatePartialConfig$ = function(config, partialConfig) {
  var partialConfigO = partialConfig["original"];
  var partialConfigCD;
  var configCD = config["componentDef"]["descriptor"];
  if(!configCD) {
    configCD = config["componentDef"]
  }else {
    if(configCD.$getQualifiedName$) {
      configCD = configCD.$getQualifiedName$()
    }
  }
  if(partialConfig["componentDef"]) {
    if(partialConfig["componentDef"]["descriptor"]) {
      partialConfigCD = partialConfig["componentDef"]["descriptor"]
    }else {
      partialConfigCD = partialConfig["componentDef"]
    }
  }
  if(partialConfigO !== undefined && partialConfigCD !== configCD) {
    if(partialConfigO !== configCD) {
      $A.log("Configs at error");
      $A.log(config);
      $A.log(partialConfig);
      throw new $A.$auraError$("Mismatch at " + this.$globalId$ + " client expected " + configCD + " but got original " + partialConfigO + " providing " + partialConfigCD + " from server " + " for creationPath \x3d " + this.$creationPath$, null, $A.severity.$QUIET$);
    }
  }else {
    if(partialConfigCD) {
      if(partialConfigCD !== configCD) {
        $A.log("Configs at error");
        $A.log(config);
        $A.log(partialConfig);
        throw new $A.$auraError$("Mismatch at " + this.$globalId$ + " client expected " + configCD + " but got " + partialConfigCD + " from server " + " for creationPath \x3d " + this.$creationPath$, null, $A.severity.$QUIET$);
      }
    }
  }
};
Component.prototype.$getMethodHandler$ = function(methodDef, methodEventDef) {
  var component = this;
  var methodName = methodDef.$getDescriptor$().name;
  var actionTarget = methodDef.action || "c." + methodName;
  return function Component$getMethodHandler() {
    if(!$A.$clientService$.$allowAccess$(methodDef, component)) {
      var message = "Access Check Failed! Component.method():'" + methodDef.$getDescriptor$().toString() + "' is not visible to '" + $A.$clientService$.$currentAccess$ + "'.";
      if($A.$clientService$.$enableAccessChecks$) {
        if($A.$clientService$.$logAccessFailures$) {
          $A.error(null, new $A.$auraError$(message))
        }
        return undefined
      }else {
        if($A.$clientService$.$logAccessFailures$) {
          $A.$warning$(message)
        }
      }
    }
    var action = component.get(actionTarget);
    if(action) {
      var methodEvent = new Aura.$Event$.$Event$({"eventDef":methodEventDef});
      var params = {"name":methodName, "arguments":null};
      if(methodDef.attributes && methodDef.attributes.$getNames$().length > 0) {
        params["arguments"] = {};
        var counter = 0;
        var attributeNames = methodDef.attributes.$getNames$();
        for(var a = 0;a < attributeNames.length;a++) {
          var attributeName = attributeNames[a];
          params["arguments"][attributeName] = arguments[counter] === undefined ? methodDef.attributes.$getDef$(attributeName).$getDefault$() : arguments[counter];
          counter++
        }
        for(var i = counter;i < arguments.length;i++) {
          params["argument_" + i] = arguments[i]
        }
      }else {
        params["arguments"] = $A["util"].$toArray$(arguments)
      }
      methodEvent.$setParams$(params);
      methodEvent.$fired$ = true;
      action.$runDeprecated$(methodEvent);
      return action.returnValue
    }
    return undefined
  }
};
Component.prototype.$getActionCaller$ = function(valueProvider, actionExpression) {
  if(!valueProvider && $A["util"].$isExpression$(actionExpression)) {
    valueProvider = actionExpression.$valueProvider$
  }
  var actionCaller = function Component$getActionCaller(event) {
    if(valueProvider.$destroyed$ === 1 && event.$getDef$().$getDescriptor$().getName() !== "valueDestroy") {
      return
    }
    var clientAction;
    actionExpression = valueFactory.create(actionExpression, valueProvider);
    if($A["util"].$isExpression$(actionExpression)) {
      clientAction = actionExpression.evaluate()
    }else {
      clientAction = valueProvider.get(actionExpression)
    }
    if(clientAction && $A["util"].$isString$(clientAction)) {
      clientAction = valueProvider.$getConcreteComponent$().get(clientAction)
    }
    if($A["util"].$isAction$(clientAction)) {
      clientAction.$runDeprecated$(event)
    }else {
      if($A["util"].$isEvent$(clientAction)) {
        clientAction.$sourceEvent$ = event;
        clientAction.$fire$()
      }else {
        $A.assert(false, "no client action by name " + actionExpression)
      }
    }
  };
  actionCaller["valueProvider"] = valueProvider;
  actionCaller["actionExpression"] = actionExpression;
  return actionCaller
};
Component.prototype.$createEventValueProvider$ = function() {
  if(!this.$eventValueProvider$ && !this.$destroyed$) {
    this.$eventValueProvider$ = new EventValueProvider(this)
  }
  return this.$eventValueProvider$
};
Component.prototype.$getEventDispatcher$ = function() {
  if(!this.$eventValueProvider$) {
    if(!this.$destroyed$) {
      this.$createEventValueProvider$()
    }else {
      return null
    }
  }
  return this.$eventValueProvider$.$events$
};
goog.$exportProperty$(Component.prototype, "getEventDispatcher", Component.prototype.$getEventDispatcher$);
Component.prototype.$setupComponentEvents$ = function(cmp, config) {
  var dispatcher;
  if(!this.$concreteComponentId$) {
    var events = this.$componentDef$.$getAllEvents$();
    var len = events.length;
    if(len > 0) {
      dispatcher = this.$getEventDispatcher$();
      if(dispatcher !== null) {
        for(var i = 0;i < events.length;i++) {
          dispatcher[events[i]] = {}
        }
      }
    }
    var def = this.$componentDef$;
    var keys = def.$getAllEvents$();
    var values = config["events"] || config["values"];
    if(values) {
      var valueProvider = config["valueProvider"];
      for(var j = 0;j < keys.length;j++) {
        var key = keys[j];
        var eventValue = values[key];
        if(eventValue) {
          $A.assert(!this.$concreteComponentId$, "Event handler for " + key + " defined on super component " + this.$globalId$);
          cmp.$addHandler$(key, valueProvider || this, eventValue["value"] || eventValue, false, "bubble")
        }
      }
    }
  }
  var cmpHandlers = this.$componentDef$.$getCmpHandlerDefs$();
  if(cmpHandlers) {
    for(var k = 0;k < cmpHandlers.length;k++) {
      var cmpHandler = cmpHandlers[k];
      cmp.$addHandler$(cmpHandler["name"], cmp, cmpHandler["action"], false, cmpHandler["phase"], cmpHandler["includeFacets"])
    }
  }
};
Component.prototype.$setupApplicationEventHandlers$ = function() {
  var handlerDefs = this.$componentDef$.$getAppHandlerDefs$();
  if(handlerDefs) {
    for(var i = 0;i < handlerDefs.length;i++) {
      var handlerDef = handlerDefs[i];
      $A.$eventService$.$addEventHandler$(this, handlerDef["eventDef"], valueFactory.create(handlerDef["action"], this), handlerDef["phase"], handlerDef["includeFacets"])
    }
  }
};
Component.prototype.$setupValueEventHandlers$ = function(cmp) {
  var handlerDefs = this.$componentDef$.$getValueHandlerDefs$();
  if(handlerDefs) {
    for(var i = 0;i < handlerDefs.length;i++) {
      var handlerDef = handlerDefs[i];
      var handlerConfig = {};
      handlerConfig["action"] = valueFactory.create(handlerDef["action"], cmp);
      handlerConfig["value"] = valueFactory.create(handlerDef["value"], cmp);
      handlerConfig["event"] = handlerDef["name"];
      cmp.$addValueHandler$(handlerConfig)
    }
  }
};
Component.prototype.$setupMethods$ = function() {
  var defs = this.$componentDef$.$methodDefs$;
  if(defs) {
    var methodEventDef = $A.$eventService$.$getEventDef$("aura:methodCall");
    var methodDef;
    for(var i = 0;i < defs.length;i++) {
      methodDef = new Aura.$Method$.$MethodDef$(defs[i]);
      this[methodDef.$getDescriptor$().name] = this.$getMethodHandler$(methodDef, methodEventDef)
    }
  }
};
Component.prototype.$setupModel$ = function(config) {
  var def = this.$componentDef$.$getModelDef$();
  if(def) {
    if(!config && this.$partialConfig$) {
      config = this.$partialConfig$["model"]
    }
    this.$model$ = def.$newInstance$(config || {})
  }
};
Component.prototype.$setupFlavors$ = function(config, configAttributes) {
  if(config["flavorable"]) {
    this.$flavorable$ = true
  }
  if(config["flavor"]) {
    this.$flavor$ = valueFactory.create(config["flavor"], configAttributes["valueProvider"])
  }
};
Component.prototype.$doIndex$ = function(cmp) {
  var localId = this.$localId$;
  if(!$A["util"].$isUndefinedOrNull$(localId)) {
    var valueProvider = cmp.$getAttributeValueProvider$();
    if(valueProvider instanceof PassthroughValue) {
      valueProvider = valueProvider.$getComponent$()
    }
    if(!valueProvider) {
      throw new Error("No attribute value provider defined for component " + cmp);
    }
    if(valueProvider === this) {
      valueProvider = this.$getOwner$()
    }
    if(valueProvider instanceof PassthroughValue) {
      valueProvider = valueProvider.$getComponent$()
    }
    if(!valueProvider) {
      throw new Error("No owner specified for component " + cmp);
    }
    valueProvider.index(localId, this.$globalId$)
  }
};
Component.prototype.$doDeIndex$ = function() {
  var localId = this.$localId$;
  if(localId) {
    var valueProvider = this.$getAttributeValueProvider$();
    if(valueProvider instanceof PassthroughValue) {
      valueProvider = valueProvider.$getComponent$()
    }
    if(valueProvider === this) {
      valueProvider = this.$getOwner$()
    }
    if(valueProvider instanceof PassthroughValue) {
      valueProvider = valueProvider.$getComponent$()
    }
    if(!$A["util"].$isUndefinedOrNull$(valueProvider)) {
      valueProvider.$deIndex$(localId, this.$globalId$)
    }
  }
};
Component.prototype.$replaceComponentClass$ = function(descriptor) {
  var classConstructor = $A.$componentService$.$getComponentClass$(descriptor);
  if(classConstructor && this["constructor"] !== classConstructor) {
    this["constructor"] = classConstructor;
    this["controller"] = classConstructor.prototype["controller"];
    this["helper"] = classConstructor.prototype["helper"];
    this["renderer"] = classConstructor.prototype["renderer"];
    this["provider"] = classConstructor.prototype["provider"]
  }
};
Component.prototype.$injectComponent$ = function(config, localCreation) {
  if((this.$componentDef$.$isAbstract$() || this["provider"]) && !this.$concreteComponentId$) {
    var context = $A.getContext();
    var act = context.$getCurrentAction$();
    if(act) {
      act.$reactivatePath$()
    }
    if(this["provider"]) {
      $A.$clientService$.$setCurrentAccess$(this);
      try {
        var providedConfig = this.$provide$(localCreation);
        this.$setProvided$(providedConfig["componentDef"], providedConfig["attributes"])
      }finally {
        $A.$clientService$.$releaseCurrentAccess$()
      }
    }else {
      $A.assert(this.$partialConfig$, "Abstract component without provider def cannot be instantiated : " + this.$componentDef$);
      this.$setProvided$($A.$componentService$.$getDef$(this.$partialConfig$["componentDef"]), null)
    }
    this.$setupModel$(config["model"]);
    this.$valueProviders$["m"] = this.$model$;
    this.$valueProviders$["c"] = this.$createActionValueProvider$()
  }
};
Component.prototype.$provide$ = function(localCreation) {
  var provideMethod = this["provider"] && this["provider"]["provide"];
  $A.assert(provideMethod, "Provide method not found");
  var providedConfig = provideMethod(this, localCreation);
  if(!providedConfig || $A["util"].$isString$(providedConfig)) {
    providedConfig = {"componentDef":providedConfig}
  }
  if(providedConfig["componentDef"]) {
    var def = $A.$componentService$.$getDef$(providedConfig["componentDef"]);
    providedConfig["componentDef"] = def
  }else {
    providedConfig["componentDef"] = this.$getDef$()
  }
  return providedConfig
};
Component.prototype.$setProvided$ = function(realComponentDef, attributes) {
  $A.assert(realComponentDef instanceof ComponentDef, "No definition for provided component: " + this.$componentDef$);
  $A.assert(!realComponentDef.$isAbstract$(), "Provided component cannot be abstract: " + realComponentDef);
  $A.assert(!realComponentDef.$hasRemoteDependencies$() || realComponentDef.$hasRemoteDependencies$() && this.$partialConfig$, "Client provided component cannot have server dependencies: " + realComponentDef);
  if(this.$componentDef$ === realComponentDef && !attributes) {
    return
  }
  this.$componentDef$ = realComponentDef;
  this.$attributeSet$.$merge$(attributes, realComponentDef.$getAttributeDefs$(), this);
  this.$replaceComponentClass$(realComponentDef.$getDescriptor$().$getQualifiedName$())
};
Component.prototype.$associateRenderedBy$ = function(cmp, element) {
  if(!$A["util"].$hasDataAttribute$(element, $A.$componentService$.$renderedBy$)) {
    $A["util"].$setDataAttribute$(element, $A.$componentService$.$renderedBy$, cmp.$globalId$)
  }
};
Component.prototype.$getLocator$ = function(targetCmp, includeMetadata) {
  return $A.$expressionService$.$resolveLocator$(this, targetCmp, includeMetadata)
};
Aura.$Component$.$Component$ = Component;
function BaseComponent(config, localCreation) {
  var context = $A.getContext();
  this.$concreteComponentId$ = config["concreteComponentId"];
  this.$containerComponentId$ = config["containerComponentId"];
  this.$shouldAutoDestroy$ = true;
  this.$rendered$ = false;
  this.$inUnrender$ = false;
  this.$localId$ = config["localId"];
  this.$valueProviders$ = {};
  this.$eventValueProvider$ = undefined;
  this.$docLevelHandlers$ = undefined;
  this.$references$ = {};
  this.$handlers$ = {};
  this.$localIndex$ = {};
  this.$destroyed$ = 0;
  this.version = config["version"];
  this.$owner$ = $A.$clientService$.$getCurrentAccessGlobalId$();
  this.name = "";
  this.$isRootComponent$ = true;
  var act = config["skipCreationPath"] ? null : context.$getCurrentAction$();
  var forcedPath = false;
  if(act) {
    var currentPath = act.$topPath$();
    if(config["creationPath"]) {
      this.$creationPath$ = act.$forceCreationPath$(config["creationPath"]);
      forcedPath = true
    }else {
      if(!context.$containsComponentConfig$(currentPath) && !!localCreation) {
        this.$creationPath$ = "client created"
      }else {
        this.$creationPath$ = act.$getCurrentPath$()
      }
    }
  }
  this.$setupGlobalId$(config["globalId"], localCreation);
  var partialConfig;
  if(this.$creationPath$ && this.$creationPath$ !== "client created") {
    partialConfig = context.$getComponentConfig$(this.$creationPath$);
    context.$removeComponentConfig$(this.$creationPath$)
  }
  if(partialConfig) {
    this.$validatePartialConfig$(config, partialConfig);
    this.$partialConfig$ = partialConfig
  }
  if(config["rendering"]) {
    this.$rendering$ = config["rendering"]
  }else {
    if(partialConfig && partialConfig["rendering"]) {
      this.$rendering$ = this.$partialConfig$["rendering"]
    }
  }
  $A.$componentService$.$indexComponent$(this);
  this.$setupComponentDef$(this.$partialConfig$ || config);
  var configAttributes = {"values":{}};
  if(config["attributes"]) {
    for(var key in config["attributes"]["values"]) {
      configAttributes["values"][key] = config["attributes"]["values"][key]
    }
    configAttributes["valueProvider"] = config["attributes"]["valueProvider"] || config["valueProvider"]
  }
  if(partialConfig && partialConfig["attributes"]) {
    $A["util"].apply(configAttributes["values"], partialConfig["attributes"]["values"], true)
  }
  if(!configAttributes["facetValueProvider"]) {
    configAttributes["facetValueProvider"] = this
  }
  this.$attributeValueProvider$ = configAttributes["valueProvider"];
  this.$facetValueProvider$ = configAttributes["facetValueProvider"];
  this.$setupValueProviders$(config["valueProviders"]);
  this.$setupAttributes$(configAttributes);
  this.$partialConfig$ = undefined;
  if(forcedPath && act && this.$creationPath$) {
    act.$releaseCreationPath$(this.$creationPath$)
  }
}
BaseComponent.prototype = Object.create(Component.prototype);
BaseComponent.prototype.$superRender$ = function() {
};
BaseComponent.prototype.$superAfterRender$ = function() {
};
BaseComponent.prototype.$superRerender$ = function() {
};
BaseComponent.prototype.$superUnrender$ = function() {
};
BaseComponent.prototype.$getSuper$ = function() {
};
BaseComponent.prototype.$getSuperest$ = function() {
  return this
};
BaseComponent.prototype.$setupValueProviders$ = function(customValueProviders) {
  var vp = this.$valueProviders$;
  vp["v"] = this.$attributeSet$ = $A.$componentService$.get(this.$concreteComponentId$).$attributeSet$;
  vp["m"] = this.$model$;
  vp["this"] = this;
  vp["globalid"] = this.$concreteComponentId$;
  vp["def"] = this.$componentDef$;
  vp["super"] = this.$superComponent$;
  vp["null"] = null;
  vp["version"] = this.version ? this.version : this.$getVersionInternal$();
  if(customValueProviders) {
    for(var key in customValueProviders) {
      this.$addValueProvider$(key, customValueProviders[key])
    }
  }
};
BaseComponent.prototype.$setupComponentDef$ = function() {
  this.$componentDef$ = $A.$componentService$.$getComponentDef$({"descriptor":"markup://aura:component"});
  $A.$lockerService$.$trust$(this.$componentDef$, this)
};
BaseComponent.prototype["renderer"] = {"render":function(component) {
  var rendering = component.$getRendering$();
  return rendering || $A.$renderingService$.$renderFacet$(component, component.$attributeSet$.$getBody$(component.$globalId$))
}, "afterRender":function(component) {
  $A.$afterRender$(component.$attributeSet$.$getBody$(component.$globalId$))
}, "rerender":function(component) {
  return $A.$renderingService$.$rerenderFacet$(component, component.$attributeSet$.$getBody$(component.$globalId$))
}, "unrender":function(component) {
  $A.$renderingService$.$unrenderFacet$(component, component.$attributeSet$.$getBody$(component.$globalId$))
}};
Aura.$Component$.$BaseComponent$ = BaseComponent;
function ExpressionComponent(config, localCreation) {
  var context = $A.getContext();
  this.$concreteComponentId$ = config["concreteComponentId"];
  this.$containerComponentId$ = config["containerComponentId"];
  this.$shouldAutoDestroy$ = true;
  this.$rendered$ = false;
  this.$inUnrender$ = false;
  this.$localId$ = config["localId"];
  this.$valueProviders$ = {};
  this.$eventValueProvider$ = undefined;
  this.$docLevelHandlers$ = undefined;
  this.$references$ = {};
  this.$handlers$ = {};
  this.$localIndex$ = {};
  this.$destroyed$ = 0;
  this.version = config["version"];
  this.$owner$ = $A.$clientService$.$getCurrentAccessGlobalId$();
  this.name = "";
  var act = config["skipCreationPath"] ? null : context.$getCurrentAction$();
  var forcedPath = false;
  if(act) {
    var currentPath = act.$topPath$();
    if(config["creationPath"]) {
      this.$creationPath$ = act.$forceCreationPath$(config["creationPath"]);
      forcedPath = true
    }else {
      if(!context.$containsComponentConfig$(currentPath) && !!localCreation) {
        this.$creationPath$ = "client created"
      }else {
        this.$creationPath$ = act.$getCurrentPath$()
      }
    }
  }
  this.$setupGlobalId$(config["globalId"], localCreation);
  var partialConfig;
  if(this.$creationPath$ && this.$creationPath$ !== "client created") {
    partialConfig = context.$getComponentConfig$(this.$creationPath$);
    context.$removeComponentConfig$(this.$creationPath$)
  }
  if(partialConfig) {
    this.$validatePartialConfig$(config, partialConfig);
    this.$partialConfig$ = partialConfig
  }
  if(config["rendering"]) {
    this.$rendering$ = config["rendering"]
  }else {
    if(partialConfig && partialConfig["rendering"]) {
      this.$rendering$ = this.$partialConfig$["rendering"]
    }
  }
  $A.$componentService$.$indexComponent$(this);
  this.$setupComponentDef$(this.$partialConfig$ || config);
  this.$isRootComponent$ = true;
  var configAttributes = {"values":{}};
  if(config["attributes"]) {
    for(var key in config["attributes"]["values"]) {
      configAttributes["values"][key] = config["attributes"]["values"][key]
    }
    configAttributes["valueProvider"] = config["attributes"]["valueProvider"] || config["valueProvider"]
  }
  if(partialConfig && partialConfig["attributes"]) {
    $A["util"].apply(configAttributes["values"], partialConfig["attributes"]["values"], true)
  }
  if(!configAttributes["facetValueProvider"]) {
    configAttributes["facetValueProvider"] = this
  }
  this.$attributeValueProvider$ = configAttributes["valueProvider"];
  this.$facetValueProvider$ = configAttributes["facetValueProvider"];
  this.$setupValueProviders$(config["valueProviders"]);
  this.$setupAttributes$(configAttributes, localCreation);
  this.$doIndex$(this);
  this.$partialConfig$ = undefined;
  if(forcedPath && act && this.$creationPath$) {
    act.$releaseCreationPath$(this.$creationPath$)
  }
}
ExpressionComponent.prototype = Object.create(Component.prototype);
ExpressionComponent.prototype.$superRender$ = function() {
};
ExpressionComponent.prototype.$superAfterRender$ = function() {
};
ExpressionComponent.prototype.$superRerender$ = function() {
};
ExpressionComponent.prototype.$superUnrender$ = function() {
};
ExpressionComponent.prototype.$getSuper$ = function() {
};
ExpressionComponent.prototype.$getSuperest$ = function() {
  return this
};
ExpressionComponent.prototype.$setContainerComponentId$ = function(containerComponentId) {
  this.$containerComponentId$ = containerComponentId;
  if(this.$isValid$()) {
    var enableAccessChecks = $A.$clientService$.$enableAccessChecks$;
    try {
      $A.$clientService$.$enableAccessChecks$ = false;
      var facetValue = this.get("v.value");
      if($A["util"].isArray(facetValue)) {
        for(var fidx = 0;fidx < facetValue.length;fidx++) {
          if($A["util"].$isComponent$(facetValue[fidx])) {
            for(;facetValue instanceof PassthroughValue;) {
              facetValue = facetValue.$getComponent$()
            }
            facetValue[fidx].$setContainerComponentId$(this.$globalId$)
          }
        }
      }else {
        if($A["util"].$isComponent$(facetValue)) {
          facetValue.$setContainerComponentId$(this.$globalId$)
        }
      }
    }finally {
      $A.$clientService$.$enableAccessChecks$ = enableAccessChecks
    }
  }
};
ExpressionComponent.prototype.$setupValueProviders$ = function(customValueProviders) {
  var vp = this.$valueProviders$;
  vp["v"] = this.$attributeSet$ = new AttributeSet(this.$componentDef$.$attributeDefs$);
  if(customValueProviders) {
    for(var key in customValueProviders) {
      this.$addValueProvider$(key, customValueProviders[key])
    }
  }
};
ExpressionComponent.prototype.$setupComponentDef$ = function() {
  this.$componentDef$ = $A.$componentService$.$getComponentDef$({"descriptor":"markup://aura:expression"});
  $A.$lockerService$.$trust$(this.$componentDef$, this)
};
ExpressionComponent.prototype.$isInstanceOf$ = function(type) {
  return type === "aura:expression" || type === "aura:rootComponent"
};
ExpressionComponent.prototype["renderer"] = {"render":function(component) {
  var value = component.$attributeSet$.$getValue$("value");
  if($A["util"].$isUndefinedOrNull$(value)) {
    value = ""
  }
  if(!$A["util"].$isComponent$(value) && !$A["util"].isArray(value)) {
    var owner = component.$getOwner$();
    $A.$clientService$.$setCurrentAccess$(owner);
    try {
      value = component.$_lastRenderedTextNode$ = $A.$createComponentFromConfig$({"descriptor":"markup://aura:text", "attributes":{value:value}});
      value.$setContainerComponentId$(component.$globalId$)
    }finally {
      $A.$clientService$.$releaseCurrentAccess$()
    }
    $A.$lockerService$.$trust$(owner, value)
  }
  return $A.$renderingService$.$renderFacet$(component, value)
}, "rerender":function(component) {
  var ret = [];
  if(component.$isRendered$()) {
    var value = component.$attributeSet$.$getValue$("value");
    if(!($A["util"].$isComponent$(value) || $A["util"].isArray(value))) {
      if($A["util"].$isUndefinedOrNull$(value)) {
        value = ""
      }
      if(component.$_lastRenderedTextNode$ && component.$_lastRenderedTextNode$.$isValid$()) {
        component.$_lastRenderedTextNode$.set("v.value", value, true);
        value = component.$_lastRenderedTextNode$;
        return $A.$rerender$(value)
      }else {
        value = component.$_lastRenderedTextNode$ = $A.$createComponentFromConfig$({"descriptor":"markup://aura:text", "attributes":{"value":value}});
        value.$setContainerComponentId$(component.$globalId$)
      }
    }else {
      if(component.$_lastRenderedTextNode$) {
        component.$_lastRenderedTextNode$.$destroy$();
        delete component.$_lastRenderedTextNode$
      }
    }
    ret = $A.$renderingService$.$rerenderFacet$(component, value)
  }
  return ret
}, "unrender":function(component) {
  $A.$renderingService$.$unrenderFacet$(component);
  if(component.$_lastRenderedTextNode$) {
    component.$_lastRenderedTextNode$.$destroy$();
    delete component.$_lastRenderedTextNode$
  }
}, "afterRender":function(component) {
  var value = component.$attributeSet$.$getValue$("value");
  if($A["util"].$isComponent$(value) || $A["util"].isArray(value)) {
    $A.$afterRender$(value)
  }
}};
Aura.$Component$.$ExpressionComponent$ = ExpressionComponent;
function HtmlComponent(config, localCreation) {
  var context = $A.getContext();
  this.$concreteComponentId$ = config["concreteComponentId"];
  this.$containerComponentId$ = config["containerComponentId"];
  this.$shouldAutoDestroy$ = true;
  this.$rendered$ = false;
  this.$inUnrender$ = false;
  this.$localId$ = config["localId"];
  this.$valueProviders$ = {};
  this.$docLevelHandlers$ = undefined;
  this.$references$ = {};
  this.$handlers$ = {};
  this.$localIndex$ = {};
  this.$destroyed$ = 0;
  this.version = config["version"];
  this.$owner$ = $A.$clientService$.$getCurrentAccessGlobalId$();
  this.name = "";
  var act = config["skipCreationPath"] ? null : context.$getCurrentAction$();
  var forcedPath = false;
  if(act) {
    var currentPath = act.$topPath$();
    if(config["creationPath"]) {
      this.$creationPath$ = act.$forceCreationPath$(config["creationPath"]);
      forcedPath = true
    }else {
      if(!context.$containsComponentConfig$(currentPath) && !!localCreation) {
        this.$creationPath$ = "client created"
      }else {
        this.$creationPath$ = act.$getCurrentPath$()
      }
    }
  }
  this.$setupGlobalId$(config["globalId"], localCreation);
  var partialConfig;
  if(this.$creationPath$ && this.$creationPath$ !== "client created") {
    partialConfig = context.$getComponentConfig$(this.$creationPath$);
    context.$removeComponentConfig$(this.$creationPath$)
  }
  if(partialConfig) {
    this.$validatePartialConfig$(config, partialConfig);
    this.$partialConfig$ = partialConfig
  }
  if(config["rendering"]) {
    this.$rendering$ = config["rendering"]
  }else {
    if(partialConfig && partialConfig["rendering"]) {
      this.$rendering$ = this.$partialConfig$["rendering"]
    }
  }
  $A.$componentService$.$indexComponent$(this);
  this.$setupComponentDef$(this.$partialConfig$ || config);
  this.$isRootComponent$ = true;
  var configAttributes = {"values":{}};
  if(config["attributes"]) {
    for(var key in config["attributes"]["values"]) {
      configAttributes["values"][key] = config["attributes"]["values"][key]
    }
    configAttributes["valueProvider"] = config["attributes"]["valueProvider"] || config["valueProvider"]
  }
  if(partialConfig && partialConfig["attributes"]) {
    $A["util"].apply(configAttributes["values"], partialConfig["attributes"]["values"], true)
  }
  if(!configAttributes["facetValueProvider"]) {
    configAttributes["facetValueProvider"] = this
  }
  this.$attributeValueProvider$ = configAttributes["valueProvider"];
  this.$facetValueProvider$ = configAttributes["facetValueProvider"];
  this.$setupValueProviders$(config["valueProviders"]);
  this.$setupAttributes$(configAttributes);
  this.$doIndex$(this);
  this.$setupFlavors$(config, configAttributes);
  this.$partialConfig$ = undefined;
  if(forcedPath && act && this.$creationPath$) {
    act.$releaseCreationPath$(this.$creationPath$)
  }
  var tag = this.$attributeSet$.$getValue$("tag");
  if(!$A["util"].$isUndefinedOrNull$(tag)) {
    this.$componentDef$.$getHelper$().$validateTagName$(tag)
  }
}
goog.$exportSymbol$("HtmlComponent", HtmlComponent);
HtmlComponent.prototype = Object.create(Component.prototype);
HtmlComponent.prototype.$superRender$ = function() {
};
HtmlComponent.prototype.$superAfterRender$ = function() {
};
HtmlComponent.prototype.$superRerender$ = function() {
};
HtmlComponent.prototype.$superUnrender$ = function() {
};
HtmlComponent.prototype.$getSuper$ = function() {
};
HtmlComponent.prototype.$getSuperest$ = function() {
  return this
};
HtmlComponent.prototype.$setupComponentDef$ = function() {
  this.$componentDef$ = $A.$componentService$.$getComponentDef$({"descriptor":"markup://aura:html"});
  $A.$lockerService$.$trust$(this.$componentDef$, this);
  var owner = this.$getOwner$();
  for(var ownerName = owner.$getType$();ownerName === "aura:iteration" || ownerName === "aura:if";) {
    owner = owner.$getOwner$();
    ownerName = owner.$getType$()
  }
  $A.$lockerService$.$trust$(owner, this)
};
HtmlComponent.prototype.$setupValueProviders$ = function(customValueProviders) {
  var vp = this.$valueProviders$;
  vp["v"] = this.$attributeSet$ = new AttributeSet(this.$componentDef$.$attributeDefs$);
  vp["this"] = this;
  vp["globalid"] = this.$globalId$;
  vp["def"] = this.$componentDef$;
  vp["null"] = null;
  vp["version"] = this.version ? this.version : this.$getVersionInternal$();
  if(customValueProviders) {
    for(var key in customValueProviders) {
      this.$addValueProvider$(key, customValueProviders[key])
    }
  }
};
HtmlComponent.prototype.$isInstanceOf$ = function(type) {
  return type === "aura:html" || type === "aura:rootComponent"
};
HtmlComponent.prototype["renderer"] = {"render":function(component, helper) {
  var tag = component.$attributeSet$.$getValue$("tag");
  if($A["util"].$isUndefinedOrNull$(tag)) {
    throw new Error("Undefined tag attribute for " + component.$getGlobalId$());
  }
  helper.$validateTagName$(tag);
  var HTMLAttributes = component.$attributeSet$.$getValue$("HTMLAttributes");
  var element = document.createElement(tag);
  for(var attribute in HTMLAttributes) {
    helper.$createHtmlAttribute$(component, element, attribute, HTMLAttributes[attribute])
  }
  $A["util"].$setDataAttribute$(element, $A.$componentService$.$renderedBy$, this.$globalId$);
  helper.$processJavascriptHref$(element);
  if(helper.$canHaveBody$(component)) {
    var body = component.$attributeSet$.$getBody$(component.$globalId$);
    $A.$renderingService$.$renderFacet$(component, body, element)
  }
  var owner = component.$getOwner$();
  for(var ownerName = owner.$getType$();ownerName === "aura:iteration" || ownerName === "aura:if";) {
    owner = owner.$getOwner$();
    ownerName = owner.$getType$()
  }
  $A.$lockerService$.$trust$(owner, element);
  return element
}, "rerender":function(component, helper) {
  var element = component.$getElement$();
  if(!element) {
    return
  }
  var skipMap = {"height":true, "width":true, "class":true};
  var HTMLAttributes = component.$attributeSet$.$getValue$("HTMLAttributes");
  if(HTMLAttributes) {
    for(var name in HTMLAttributes) {
      var lowerName = name.toLowerCase();
      if(skipMap[lowerName] || lowerName.indexOf("on") === 0) {
        continue
      }
      var value = HTMLAttributes[name];
      if($A["util"].$isExpression$(value)) {
        value = value.evaluate()
      }
      if(helper.$SPECIAL_BOOLEANS$.hasOwnProperty(lowerName)) {
        value = $A["util"].$getBooleanValue$(value)
      }
      var oldValue = element[helper.$caseAttribute$(lowerName)];
      if(value !== oldValue) {
        helper.$createHtmlAttribute$(component, element, lowerName, value);
        if($A["util"].$isExpression$(oldValue)) {
          oldValue.$removeChangeHandler$(component, "HTMLAttributes." + name)
        }
      }
    }
    var className = HTMLAttributes["class"];
    if($A["util"].$isExpression$(className)) {
      className = className.evaluate()
    }
    if($A["util"].$isUndefinedOrNull$(className)) {
      className = ""
    }
    if(!$A["util"].$isUndefinedOrNull$(element.getAttribute("data-aura-class"))) {
      className += " " + element.getAttribute("data-aura-class")
    }
    if(element["className"] !== className) {
      element["className"] = className
    }
  }
  helper.$processJavascriptHref$(element);
  if(helper.$canHaveBody$(component)) {
    $A.$renderingService$.$rerenderFacet$(component, component.$attributeSet$.$getBody$(component.$globalId$), element)
  }
}, "afterRender":function(component, helper) {
  if(helper.$canHaveBody$(component)) {
    $A.$afterRender$(component.$attributeSet$.$getBody$(component.$globalId$))
  }
}, "unrender":function(component, helper) {
  var HTMLAttributes = component.$attributeSet$.$getValue$("HTMLAttributes");
  for(var attribute in HTMLAttributes) {
    helper.$destroyHtmlAttribute$(component, attribute, HTMLAttributes[attribute])
  }
  $A.$renderingService$.$unrenderFacet$(component, component.$attributeSet$.$getBody$(component.$globalId$))
}};
HtmlComponent.prototype["helper"] = {$SPECIAL_BOOLEANS$:{"checked":true, "selected":true, "disabled":true, "readonly":true, "multiple":true, "ismap":true, "defer":true, "declare":true, "noresize":true, "nowrap":true, "noshade":true, "compact":true, "autocomplete":true, "required":true}, $SPECIAL_CASINGS$:{"readonly":"readOnly", "colspan":"colSpan", "rowspan":"rowSpan", "bgcolor":"bgColor", "tabindex":"tabIndex", "usemap":"useMap", "accesskey":"accessKey", "maxlength":"maxLength", "for":"htmlFor", 
"class":"className", "frameborder":"frameBorder"}, $BODYLESS_TAGS$:{"area":true, "base":true, "br":true, "col":true, "command":true, "embed":true, "hr":true, "img":true, "input":true, "keygen":true, "link":true, "meta":true, "param":true, "source":true, "track":true, "wbr":true}, $ALLOWED_TAGS$:{"a":true, "abbr":true, "acronym":true, "address":true, "area":true, "article":true, "aside":true, "audio":true, "b":true, "bdi":true, "bdo":true, "big":true, "blockquote":true, "body":true, "br":true, "button":true, 
"caption":true, "canvas":true, "center":true, "cite":true, "code":true, "col":true, "colgroup":true, "command":true, "datalist":true, "dd":true, "del":true, "details":true, "dfn":true, "dir":true, "div":true, "dl":true, "dt":true, "em":true, "fieldset":true, "figure":true, "figcaption":true, "footer":true, "form":true, "h1":true, "h2":true, "h3":true, "h4":true, "h5":true, "h6":true, "head":true, "header":true, "hgroup":true, "hr":true, "html":true, "i":true, "iframe":true, "img":true, "input":true, 
"ins":true, "keygen":true, "kbd":true, "label":true, "legend":true, "li":true, "link":true, "map":true, "mark":true, "menu":true, "meta":true, "meter":true, "nav":true, "ol":true, "optgroup":true, "option":true, "output":true, "p":true, "pre":true, "progress":true, "q":true, "rp":true, "rt":true, "ruby":true, "s":true, "samp":true, "script":true, "section":true, "select":true, "small":true, "source":true, "span":true, "strike":true, "strong":true, "style":true, "sub":true, "summary":true, "sup":true, 
"table":true, "tbody":true, "td":true, "textarea":true, "tfoot":true, "th":true, "thead":true, "time":true, "title":true, "tr":true, "track":true, "tt":true, "u":true, "ul":true, "var":true, "video":true, "wbr":true}, $NAMES$:{"domHandler":"fcDomHandler", "hashHandler":"fcHashHandler"}, $validateTagName$:function(tagName) {
  if(!this.$ALLOWED_TAGS$.hasOwnProperty(tagName) && !this.$ALLOWED_TAGS$.hasOwnProperty(tagName.toLowerCase())) {
    throw new Error("The HTML tag '" + tagName + "' is not allowed.");
  }
}, $caseAttribute$:function(attribute) {
  return this.$SPECIAL_CASINGS$[attribute] || attribute
}, $addNamedClickHandler$:function(element, handler, handlerName) {
  var previousHandler = element[handlerName];
  if($A["util"].$isFunction$(previousHandler)) {
    $A["util"].$removeOn$(element, "click", previousHandler)
  }
  $A["util"].$on$(element, "click", handler);
  element[handlerName] = handler;
  return previousHandler
}, $domEventHandler$:function(event) {
  var eventName = "on" + event.type;
  var element = event.currentTarget;
  var ownerComponent = $A.$componentService$.$getRenderingComponentForElement$(element);
  if(!ownerComponent) {
    return
  }
  var htmlAttributes = ownerComponent.get("v.HTMLAttributes");
  var valueExpression = htmlAttributes[eventName];
  var onclickExpression;
  if(eventName === "ontouchend" || eventName === "onpointerup" || eventName === "onMSPointerUp") {
    onclickExpression = htmlAttributes["onclick"];
    if(!$A["util"].$isEmpty$(onclickExpression)) {
      if($A["util"].$isEmpty$(valueExpression)) {
        valueExpression = onclickExpression
      }
    }
  }
  if($A["util"].$isExpression$(valueExpression)) {
    var action = valueExpression.evaluate();
    if(action) {
      this.$dispatchAction$(action, event, ownerComponent)
    }
  }
}, $dispatchAction$:function(action, event) {
  $A.$run$(function() {
    action.$runDeprecated$(event)
  })
}, $canHaveBody$:function(component) {
  var tag = component.$attributeSet$.$getValue$("tag");
  if($A["util"].$isUndefinedOrNull$(tag)) {
    throw new Error("Undefined tag attribute for " + component.$getGlobalId$());
  }
  return!this.$BODYLESS_TAGS$[tag.toLowerCase()]
}, $createHtmlAttribute$:function(component, element, name, attribute) {
  var value;
  var lowerName = name.toLowerCase();
  if(lowerName.indexOf("on") === 0) {
    var eventName = lowerName.substring(2);
    if(eventName === "click") {
      this.$addNamedClickHandler$(element, $A.$getCallback$(this.$domEventHandler$.bind(this)), this.$NAMES$.$domHandler$)
    }else {
      $A["util"].$on$(element, eventName, $A.$getCallback$(this.$domEventHandler$.bind(this)))
    }
  }else {
    var isSpecialBoolean = this.$SPECIAL_BOOLEANS$.hasOwnProperty(lowerName);
    if($A["util"].$isExpression$(attribute)) {
      attribute.$addChangeHandler$(component, "HTMLAttributes." + name);
      value = attribute.evaluate()
    }else {
      value = attribute
    }
    if(isSpecialBoolean) {
      value = $A["util"].$getBooleanValue$(value)
    }
    var isString = $A["util"].$isString$(value);
    if(isString && value.indexOf("/auraFW") === 0) {
      value = $A.getContext().$getContextPath$() + value
    }
    if(lowerName === "href" && element.tagName === "A" && value && $A["util"].$supportsTouchEvents$()) {
      var HTMLAttributes = component.$attributeSet$.$getValue$("HTMLAttributes");
      var target = HTMLAttributes["target"];
      if($A["util"].$isExpression$(target)) {
        target = target.evaluate()
      }
      this.$addNamedClickHandler$(element, function() {
        if(isString && value.indexOf("#") === 0) {
          $A.$run$(function() {
            $A.$historyService$.set(value.substring(1))
          })
        }
      }, this.$NAMES$.$hashHandler$);
      if(target) {
        element.setAttribute("target", target)
      }
      element.setAttribute("href", value)
    }else {
      if(!$A["util"].$isUndefinedOrNull$(value) && (lowerName === "role" || lowerName.lastIndexOf("aria-", 0) === 0)) {
        element.setAttribute(name, value)
      }else {
        if(isSpecialBoolean) {
          var casedName = this.$caseAttribute$(lowerName);
          if(value === false) {
            element.removeAttribute(casedName);
            if(casedName === "checked") {
              element.removeAttribute("defaultChecked")
            }
          }else {
            element.setAttribute(casedName, name);
            if(casedName === "checked") {
              element.setAttribute("defaultChecked", true)
            }
          }
          if($A["util"].$isUndefinedOrNull$(value)) {
            value = ""
          }
          element[casedName] = value
        }else {
          if($A["util"].$isIE$ && element.tagName === "INPUT" && lowerName === "type") {
            try {
              element.setAttribute("type", value)
            }catch(e) {
              return undefined
            }
          }else {
            if(!$A["util"].$isUndefined$(value) && !($A["util"].$isIE$ && element.tagName === "INPUT" && lowerName === "value" && value === null)) {
              var casedAttribute = this.$caseAttribute$(lowerName);
              lowerName = name.toLowerCase();
              if(lowerName === "style" && $A["util"].$isIE$) {
                element.style.cssText = value
              }else {
                if(lowerName === "type" || lowerName === "href" || lowerName === "style" || lowerName.indexOf("data-") === 0) {
                  element.setAttribute(casedAttribute, value)
                }else {
                  if(lowerName === "srcdoc" && element.tagName === "IFRAME" && !$A["util"].$isUndefinedOrNull$(value)) {
                    var message;
                    if(!$A.get("$Global")["srcdoc"]) {
                      message = "The '" + name + "' attribute is not supported, and will not be set for " + element + " in " + component;
                      $A.$warning$(message)
                    }else {
                      message = "The '" + name + "' attribute has been set for " + element + " in " + component;
                      element[casedAttribute] = value
                    }
                    $A.$logger$.$reportError$(new $A.$auraError$(message), null, "WARNING")
                  }else {
                    if($A["util"].$isUndefinedOrNull$(value)) {
                      value = ""
                    }
                    element[casedAttribute] = value
                  }
                }
              }
            }else {
              if($A["util"].$isIE$ && element.tagName === "INPUT" && lowerName === "value" && value === null) {
                element.value = ""
              }
            }
          }
        }
      }
    }
  }
}, $destroyHtmlAttribute$:function(component, name, attribute) {
  if($A["util"].$isExpression$(attribute)) {
    attribute.$removeChangeHandler$(component, "HTMLAttributes." + name)
  }
}, $processJavascriptHref$:function(element) {
  if(element.tagName === "A") {
    var href = element.getAttribute("href");
    if(!href) {
      element.setAttribute("href", "javascript:void(0);")
    }
    if($A.$lockerService$.isEnabled()) {
      element.addEventListener("click", this.$inlineJavasciptCSPViolationPreventer$)
    }
  }
}, $inlineJavasciptCSPViolationPreventer$:function(event) {
  var hrefTarget = this.href;
  if(hrefTarget && /javascript:\s*void\(/.test(hrefTarget.toLowerCase())) {
    event.preventDefault()
  }
}};
Aura.$Component$.$HtmlComponent$ = HtmlComponent;
function IfComponent(config, localCreation) {
  var context = $A.getContext();
  this.$concreteComponentId$ = config["concreteComponentId"];
  this.$containerComponentId$ = config["containerComponentId"];
  this.$shouldAutoDestroy$ = true;
  this.$rendered$ = false;
  this.$inUnrender$ = false;
  this.$localId$ = config["localId"];
  this.$valueProviders$ = {};
  this.$eventValueProvider$ = undefined;
  this.$docLevelHandlers$ = undefined;
  this.$references$ = {};
  this.$handlers$ = {};
  this.$localIndex$ = {};
  this.$destroyed$ = 0;
  this.version = config["version"];
  this.$owner$ = $A.$clientService$.$getCurrentAccessGlobalId$();
  this.name = "";
  this.$isRootComponent$ = true;
  var act = config["skipCreationPath"] ? null : context.$getCurrentAction$();
  var forcedPath = false;
  if(act) {
    var currentPath = act.$topPath$();
    if(config["creationPath"]) {
      this.$creationPath$ = act.$forceCreationPath$(config["creationPath"]);
      forcedPath = true
    }else {
      if(!context.$containsComponentConfig$(currentPath) && !!localCreation) {
        this.$creationPath$ = "client created"
      }else {
        this.$creationPath$ = act.$getCurrentPath$()
      }
    }
  }
  this.$setupGlobalId$(config["globalId"], localCreation);
  var partialConfig;
  if(this.$creationPath$ && this.$creationPath$ !== "client created") {
    partialConfig = context.$getComponentConfig$(this.$creationPath$);
    context.$removeComponentConfig$(this.$creationPath$)
  }
  if(partialConfig) {
    this.$validatePartialConfig$(config, partialConfig);
    this.$partialConfig$ = partialConfig
  }
  if(config["rendering"]) {
    this.$rendering$ = config["rendering"]
  }else {
    if(partialConfig && partialConfig["rendering"]) {
      this.$rendering$ = this.$partialConfig$["rendering"]
    }
  }
  $A.$componentService$.$indexComponent$(this);
  this.$setupComponentDef$(this.$partialConfig$ || config);
  var configAttributes = {"values":{}};
  if(config["attributes"]) {
    for(var key in config["attributes"]["values"]) {
      configAttributes["values"][key] = config["attributes"]["values"][key]
    }
    configAttributes["valueProvider"] = config["attributes"]["valueProvider"] || config["valueProvider"]
  }
  if(partialConfig && partialConfig["attributes"]) {
    $A["util"].apply(configAttributes["values"], partialConfig["attributes"]["values"], true)
  }
  if(!configAttributes["facetValueProvider"]) {
    configAttributes["facetValueProvider"] = this
  }
  this.$attributeValueProvider$ = configAttributes["valueProvider"];
  this.$facetValueProvider$ = configAttributes["facetValueProvider"];
  this.$setupValueProviders$(config["valueProviders"]);
  this.$setupAttributes$(configAttributes);
  this.$injectComponent$(config, localCreation);
  this.$doIndex$(this);
  this.$setupValueEventHandlers$(this);
  this.$partialConfig$ = undefined;
  if(forcedPath && act && this.$creationPath$) {
    act.$releaseCreationPath$(this.$creationPath$)
  }
  this.$_destroying$ = false;
  this.$fire$("init")
}
IfComponent.prototype = Object.create(Component.prototype);
IfComponent.prototype.$setupModel$ = function() {
};
IfComponent.prototype.$superRender$ = function() {
};
IfComponent.prototype.$superAfterRender$ = function() {
};
IfComponent.prototype.$superRerender$ = function() {
};
IfComponent.prototype.$superUnrender$ = function() {
};
IfComponent.prototype.$getSuper$ = function() {
};
IfComponent.prototype.$getModel$ = function() {
};
IfComponent.prototype.$getSuperest$ = function() {
  return this
};
IfComponent.prototype.$setupComponentDef$ = function() {
  this.$componentDef$ = $A.$componentService$.$getComponentDef$({"descriptor":"markup://aura:if"});
  $A.$lockerService$.$trust$(this.$componentDef$, this)
};
IfComponent.prototype.$setupValueProviders$ = function(customValueProviders) {
  var vp = this.$valueProviders$;
  vp["v"] = this.$attributeSet$ = new AttributeSet(this.$componentDef$.$attributeDefs$);
  vp["c"] = this.$createActionValueProvider$();
  vp["this"] = this;
  vp["globalid"] = this.$globalid$;
  if(customValueProviders) {
    for(var key in customValueProviders) {
      this.$addValueProvider$(key, customValueProviders[key])
    }
  }
};
IfComponent.prototype.$isInstanceOf$ = function(type) {
  return type === "aura:if" || type === "aura:rootComponent"
};
IfComponent.prototype["controller"] = {"init":function(cmp, evt, helper) {
  var bodyTemplate = cmp.$attributeSet$.$getBody$(cmp.$globalId$);
  var isTrue = $A["util"].$getBooleanValue$(cmp.$attributeSet$.$getValue$("isTrue"));
  var template = cmp.$attributeSet$.$getValue$("template");
  if(bodyTemplate.length && !template.length) {
    cmp.set("v.template", bodyTemplate, true);
    cmp.set("v.body", [], true)
  }
  var body = helper.$createBody$(cmp, isTrue);
  cmp.set("v.body", body, true);
  cmp.$_truth$ = isTrue
}, "handleTheTruth":function(cmp, evt, helper) {
  var isTrue = $A["util"].$getBooleanValue$(cmp.$attributeSet$.$getValue$("isTrue"));
  if(cmp.$_truth$ !== isTrue) {
    helper.$clearUnrenderedBody$(cmp);
    cmp.set("v.body", helper.$createBody$(cmp, isTrue, true));
    cmp.$_truth$ = isTrue
  }
}};
IfComponent.prototype["helper"] = {$createBody$:function(cmp, isTrue) {
  var body = [];
  var facet = isTrue ? cmp.$attributeSet$.$getValue$("template") : cmp.$attributeSet$.$getValue$("else");
  $A.$pushCreationPath$("body");
  var i = 0;
  for(var length = facet.length;i < length;i++) {
    $A.$setCreationPathIndex$(i);
    var cdr = facet[i];
    if(!cdr["attributes"]["valueProvider"]) {
      cdr["attributes"]["valueProvider"] = cmp.$getAttributeValueProvider$()
    }
    if(!cdr["containerComponentId"]) {
      cdr["containerComponentId"] = cmp.$getGlobalId$()
    }
    body.push($A.$componentService$.$createComponentFromConfig$(cdr))
  }
  $A.$popCreationPath$("body");
  return body
}, $clearUnrenderedBody$:function(cmp) {
  var hasUnrenderBody = false;
  var currentBody = cmp.$attributeSet$.$getBody$(cmp.$globalId$);
  for(var i = 0;i < currentBody.length;i++) {
    var child = currentBody[i];
    if(!child.$isRendered$()) {
      hasUnrenderBody = true;
      child.$destroy$()
    }
  }
  if(hasUnrenderBody) {
    var owner = cmp.$getOwner$();
    $A.$warning$(["[Performance degradation] ", 'markup://aura:if ["' + cmp.$getGlobalId$() + '"] in ', owner.$getType$() + ' ["' + owner.$getGlobalId$() + '"] ', "needed to clear unrendered body.\n", "More info: https://developer.salesforce.com/docs/atlas.en-us.lightning.meta/lightning/perf_warnings_if.htm\n", "Component hierarchy: " + $A["util"].$getComponentHierarchy$(owner)].join(""))
  }
}};
IfComponent.prototype["provider"] = {"provide":function(component) {
  return component
}};
IfComponent.prototype["renderer"] = Aura.$Component$.$BaseComponent$.prototype["renderer"];
Aura.$Component$.$IfComponent$ = IfComponent;
function IterationComponent(config, localCreation) {
  var context = $A.getContext();
  this.$concreteComponentId$ = config["concreteComponentId"];
  this.$containerComponentId$ = config["containerComponentId"];
  this.$shouldAutoDestroy$ = true;
  this.$rendered$ = false;
  this.$inUnrender$ = false;
  this.$localId$ = config["localId"];
  this.$valueProviders$ = {};
  this.$eventValueProvider$ = undefined;
  this.$docLevelHandlers$ = undefined;
  this.$references$ = {};
  this.$handlers$ = {};
  this.$localIndex$ = {};
  this.$destroyed$ = 0;
  this.version = config["version"];
  this.$owner$ = $A.$clientService$.$getCurrentAccessGlobalId$();
  this.name = "";
  this.$isRootComponent$ = true;
  var act = config["skipCreationPath"] ? null : context.$getCurrentAction$();
  var forcedPath = false;
  if(act) {
    var currentPath = act.$topPath$();
    if(config["creationPath"]) {
      this.$creationPath$ = act.$forceCreationPath$(config["creationPath"]);
      forcedPath = true
    }else {
      if(!context.$containsComponentConfig$(currentPath) && !!localCreation) {
        this.$creationPath$ = "client created"
      }else {
        this.$creationPath$ = act.$getCurrentPath$()
      }
    }
  }
  this.$setupGlobalId$(config["globalId"], localCreation);
  var partialConfig;
  if(this.$creationPath$ && this.$creationPath$ !== "client created") {
    partialConfig = context.$getComponentConfig$(this.$creationPath$);
    context.$removeComponentConfig$(this.$creationPath$)
  }
  if(partialConfig) {
    this.$validatePartialConfig$(config, partialConfig);
    this.$partialConfig$ = partialConfig
  }
  if(config["rendering"]) {
    this.$rendering$ = config["rendering"]
  }else {
    if(partialConfig && partialConfig["rendering"]) {
      this.$rendering$ = this.$partialConfig$["rendering"]
    }
  }
  $A.$componentService$.$indexComponent$(this);
  this.$setupComponentDef$(this.$partialConfig$ || config);
  var configAttributes = {"values":{}};
  if(config["attributes"]) {
    for(var key in config["attributes"]["values"]) {
      configAttributes["values"][key] = config["attributes"]["values"][key]
    }
    configAttributes["valueProvider"] = config["attributes"]["valueProvider"] || config["valueProvider"]
  }
  if(partialConfig && partialConfig["attributes"]) {
    $A["util"].apply(configAttributes["values"], partialConfig["attributes"]["values"], true)
  }
  if(!configAttributes["facetValueProvider"]) {
    configAttributes["facetValueProvider"] = this
  }
  this.$attributeValueProvider$ = configAttributes["valueProvider"];
  this.$facetValueProvider$ = configAttributes["facetValueProvider"];
  this.$setupValueProviders$(config["valueProviders"]);
  this.$setupAttributes$(configAttributes);
  this.$injectComponent$(config, localCreation);
  this.$setupComponentEvents$(this, configAttributes);
  this.$doIndex$(this);
  this.$setupValueEventHandlers$(this);
  this.$partialConfig$ = undefined;
  if(forcedPath && act && this.$creationPath$) {
    act.$releaseCreationPath$(this.$creationPath$)
  }
  this.$_destroying$ = false;
  this.$fire$("init")
}
IterationComponent.prototype = Object.create(Component.prototype);
IterationComponent.prototype.$setupModel$ = function() {
};
IterationComponent.prototype.$superRender$ = function() {
};
IterationComponent.prototype.$superAfterRender$ = function() {
};
IterationComponent.prototype.$superRerender$ = function() {
};
IterationComponent.prototype.$superUnrender$ = function() {
};
IterationComponent.prototype.$getSuper$ = function() {
};
IterationComponent.prototype.$getSuperest$ = function() {
  return this
};
IterationComponent.prototype.$setupComponentDef$ = function() {
  this.$componentDef$ = $A.$componentService$.$getComponentDef$({"descriptor":"markup://aura:iteration"});
  $A.$lockerService$.$trust$(this.$componentDef$, this)
};
IterationComponent.prototype.$setupValueProviders$ = function(customValueProviders) {
  var vp = this.$valueProviders$;
  vp["v"] = this.$attributeSet$ = new AttributeSet(this.$componentDef$.$attributeDefs$);
  vp["c"] = this.$createActionValueProvider$();
  vp["e"] = this.$createEventValueProvider$();
  vp["this"] = this;
  vp["globalid"] = this.$globalId$;
  vp["def"] = this.$componentDef$;
  vp["null"] = null;
  vp["version"] = this.version ? this.version : this.$getVersionInternal$();
  if(customValueProviders) {
    for(var key in customValueProviders) {
      this.$addValueProvider$(key, customValueProviders[key])
    }
  }
};
IterationComponent.prototype.$isInstanceOf$ = function(type) {
  return type === "aura:iteration" || type === "aura:rootComponent"
};
IterationComponent.prototype["controller"] = {"rangeChange":function(component, evt, helper) {
  helper.$updateBody$(component)
}, "itemsChange":function(component, evt, helper) {
  helper.$updateBody$(component)
}, "templateChange":function(component, evt, helper) {
  helper.$createBody$(component, false)
}, "init":function(component, evt, helper) {
  var bodyTemplate = component.$attributeSet$.$getBody$(component.$globalId$);
  var template = component.$attributeSet$.$getValue$("template");
  if(bodyTemplate.length && !template.length) {
    component.set("v.body", [], true);
    component.set("v.template", bodyTemplate, true)
  }
  helper.$createBody$(component, true)
}};
IterationComponent.prototype["helper"] = {$createBody$:function(component, localCreation) {
  component.set("v.loaded", false);
  component.$_itemInfo$ = [];
  var helper = this;
  this.$buildBody$(component, function createBodyItem(cmp, template, item, index, itemVar, indexVar, templateValueProvider, forceServer, callback) {
    this.$buildTemplate$(cmp, template, item, index, itemVar, indexVar, templateValueProvider, localCreation, forceServer, callback)
  }, function createBodyComplete(cmp, components) {
    cmp.set("v.body", components, true);
    cmp.set("v.loaded", true);
    cmp.get("e.iterationComplete").$fire$({"operation":"Initialize"});
    var queued = cmp.$_queueUpdate$;
    cmp.$_queueUpdate$ = false;
    if(queued) {
      helper.$updateBody$(cmp)
    }
  })
}, $clearUnrenderedBody$:function(component) {
  var currentBody = component.$attributeSet$.$getBody$(component.$globalId$);
  var cleanedCmps = 0;
  if(currentBody.length) {
    for(var i = 0;i < currentBody.length;i++) {
      if(currentBody[i].$isValid$() && !currentBody[i].$isRendered$()) {
        currentBody[i].$destroy$();
        component.$_itemInfo$.splice(i - cleanedCmps, 1);
        cleanedCmps++
      }
    }
    if(cleanedCmps) {
      var owner = component.$getOwner$();
      $A.$warning$(["[Performance degradation] ", "markup://aura:iteration [id:" + component.$getGlobalId$() + "] ", "in ", owner.$getType$() + ' ["' + owner.$getGlobalId$() + '"] ', "had multiple items set in the same Aura cycle.\n", "More info: https://developer.salesforce.com/docs/atlas.en-us.lightning.meta/lightning/perf_warnings_iteration.htm\n", "Component hierarchy: " + $A["util"].$getComponentHierarchy$(owner)].join(""))
    }
  }
}, $updateBody$:function(component) {
  if(component.$attributeSet$.$getValue$("loaded") === false) {
    component.$_queueUpdate$ = true;
    return component.$_queueUpdate$
  }
  this.$clearUnrenderedBody$(component);
  component.set("v.loaded", false);
  var itemInfo = component.$_itemInfo$.slice();
  var helper = this;
  component.$_itemInfo$.length = 0;
  this.$buildBody$(component, function updateBodyItem(cmp, template, item, index, itemVar, indexVar, templateValueProvider, forceServer, callback) {
    var found = false;
    var components = null;
    for(var i = 0;i < itemInfo.length;i++) {
      if(itemInfo[i].item === item) {
        components = itemInfo[i].$components$;
        if(itemInfo[i].index !== index) {
          for(var j = 0;j < components.length;j++) {
            var avp = components[j].$getAttributeValueProvider$();
            if(avp) {
              avp.set(indexVar, index);
              avp.set(itemVar, cmp.$getReference$("v.items[" + index + "]"), true)
            }
          }
        }
        found = true;
        itemInfo.splice(i, 1);
        this.$trackItem$(cmp, item, index, components);
        callback(components);
        break
      }
    }
    if(!found) {
      this.$buildTemplate$(cmp, template, item, index, itemVar, indexVar, templateValueProvider, false, forceServer, callback)
    }
  }, function updateBodyComplete(cmp, components) {
    cmp.set("v.body", components);
    cmp.set("v.loaded", true);
    cmp.get("e.iterationComplete").$fire$({"operation":"Update"});
    var queued = cmp.$_queueUpdate$;
    cmp.$_queueUpdate$ = false;
    if(queued) {
      helper.$updateBody$(cmp)
    }
  })
}, $buildBody$:function(component, itemHandler, completeHandler) {
  function getCollector(index) {
    return function iteration$getCollector(itemComponents) {
      collector[index] = itemComponents;
      if(++currentCall === expectedCalls) {
        var components = [];
        for(var j = 0;j < collector.length;j++) {
          components = components.concat(collector[j])
        }
        completeHandler(component, components)
      }
    }
  }
  var items = component.$attributeSet$.$getValue$("items");
  var template = component.$attributeSet$.$getValue$("template");
  var startIndex = this.$getStart$(component);
  var endIndex = this.$getEnd$(component);
  var expectedCalls = endIndex - startIndex;
  var collector = [];
  var currentCall = 0;
  if(items && items.length && template && template.length && expectedCalls > 0) {
    var itemVar = component.$attributeSet$.$getValue$("var");
    var indexVar = component.$attributeSet$.$getValue$("indexVar");
    var forceServer = component.$attributeSet$.$getValue$("forceServer");
    var templateValueProvider = component.$getComponentValueProvider$();
    $A.$pushCreationPath$("body");
    for(var i = startIndex;i < endIndex;i++) {
      $A.$setCreationPathIndex$(i);
      itemHandler.bind(this)(component, template, items[i], i, itemVar, indexVar, templateValueProvider, forceServer, getCollector(i - startIndex))
    }
    $A.$popCreationPath$("body")
  }else {
    completeHandler(component, [])
  }
}, $buildTemplate$:function(component, template, item, index, itemVar, indexVar, templateValueProvider, localCreation, forceServer, callback) {
  function collector(templateComponents) {
    helper.$trackItem$(component, item, index, templateComponents);
    callback(templateComponents)
  }
  $A.$pushCreationPath$("body");
  var helper = this;
  var componentDefRef = template[0];
  var iterationValueProvider = null;
  if(componentDefRef) {
    $A.$setCreationPathIndex$(0);
    var itemValueProviders = {};
    itemValueProviders[itemVar] = component.$getReference$("v.items[" + index + "]");
    itemValueProviders[indexVar] = index;
    iterationValueProvider = $A.$expressionService$.$createPassthroughValue$(itemValueProviders, componentDefRef["attributes"]["valueProvider"] || templateValueProvider);
    if(localCreation) {
      var components = [];
      for(var i = 0;i < template.length;i++) {
        template[i]["attributes"]["valueProvider"] = iterationValueProvider;
        components.push($A.$createComponentFromConfig$(template[i]))
      }
      collector(components)
    }else {
      $A.$componentService$.$newComponentAsync$(this, collector, template, iterationValueProvider, localCreation, false, forceServer)
    }
  }
  $A.$popCreationPath$("body")
}, $getStart$:function(cmp) {
  return Math.max(0, parseInt(cmp.$attributeSet$.$getValue$("start") || 0, 10))
}, $getEnd$:function(cmp) {
  var items = cmp.$attributeSet$.$getValue$("items");
  if(items && items.length) {
    var end = parseInt(cmp.$attributeSet$.$getValue$("end"), 10);
    return isNaN(end) ? items.length : Math.min(items.length, end)
  }
  return 0
}, $trackItem$:function(component, item, index, components) {
  component.$_itemInfo$.push({item:item, index:index, $components$:components})
}};
IterationComponent.prototype["provider"] = {"provide":function(component) {
  return component
}};
IterationComponent.prototype["renderer"] = {"render":function(component) {
  var rendering = component.$getRendering$();
  return rendering || $A.$renderingService$.$renderFacet$(component, component.get("v.body"))
}, "afterRender":function(component) {
  var body = component.get("v.body");
  $A.$afterRender$(body)
}, "rerender":function(component) {
  var body = component.get("v.body");
  return $A.$renderingService$.$rerenderFacet$(component, body)
}, "unrender":function(component) {
  var body = component.get("v.body");
  $A.$renderingService$.$unrenderFacet$(component, body)
}};
Aura.$Component$.$IterationComponent$ = IterationComponent;
function TextComponent(config, localCreation) {
  this.$concreteComponentId$ = config["concreteComponentId"];
  this.$containerComponentId$ = config["containerComponentId"];
  this.$shouldAutoDestroy$ = true;
  this.$rendered$ = false;
  this.$inUnrender$ = false;
  this.$localId$ = config["localId"];
  this.$valueProviders$ = {};
  this.$eventValueProvider$ = undefined;
  this.$docLevelHandlers$ = undefined;
  this.$references$ = {};
  this.$handlers$ = {};
  this.$localIndex$ = {};
  this.$destroyed$ = false;
  this.version = config["version"];
  this.$owner$ = $A.$clientService$.$getCurrentAccessGlobalId$();
  this.name = "";
  this.$isRootComponent$ = true;
  this.$setupGlobalId$(config["globalId"], localCreation);
  if(config["rendering"]) {
    this.$rendering$ = config["rendering"]
  }
  $A.$componentService$.$indexComponent$(this);
  this.$setupComponentDef$(config);
  var configAttributes = {"values":{}};
  if(config["attributes"]) {
    for(var key in config["attributes"]["values"]) {
      configAttributes["values"][key] = config["attributes"]["values"][key]
    }
    configAttributes["valueProvider"] = config["attributes"]["valueProvider"] || config["valueProvider"]
  }
  if(!configAttributes["facetValueProvider"]) {
    configAttributes["facetValueProvider"] = this
  }
  this.$attributeValueProvider$ = configAttributes["valueProvider"];
  this.$facetValueProvider$ = configAttributes["facetValueProvider"];
  this.$setupValueProviders$(config["valueProviders"]);
  this.$setupAttributes$(configAttributes);
  this.$doIndex$(this)
}
TextComponent.prototype = Object.create(Component.prototype);
TextComponent.prototype.$superRender$ = function() {
};
TextComponent.prototype.$superAfterRender$ = function() {
};
TextComponent.prototype.$superRerender$ = function() {
};
TextComponent.prototype.$superUnrender$ = function() {
};
TextComponent.prototype.$getSuper$ = function() {
};
TextComponent.prototype.$getSuperest$ = function() {
  return this
};
TextComponent.prototype.$setupValueProviders$ = function(customValueProviders) {
  var vp = this.$valueProviders$;
  vp["v"] = this.$attributeSet$ = new AttributeSet(this.$componentDef$.$attributeDefs$);
  vp["this"] = this;
  vp["globalid"] = this.$globalId$;
  vp["def"] = this.$componentDef$;
  vp["null"] = null;
  vp["version"] = this.version ? this.version : this.$getVersionInternal$();
  if(customValueProviders) {
    for(var key in customValueProviders) {
      this.$addValueProvider$(key, customValueProviders[key])
    }
  }
};
TextComponent.prototype.$setupComponentDef$ = function() {
  this.$componentDef$ = $A.$componentService$.$getComponentDef$({"descriptor":"markup://aura:text"});
  $A.$lockerService$.$trust$(this.$componentDef$, this)
};
TextComponent.prototype.$isInstanceOf$ = function(type) {
  return type === "aura:text" || type === "aura:rootComponent"
};
TextComponent.prototype["renderer"] = {"render":function(component) {
  var value = component.$attributeSet$.$getValue$("value");
  var trunc = component.$attributeSet$.$getValue$("truncate");
  if(trunc) {
    var truncateByWord = $A["util"].$getBooleanValue$(component.$attributeSet$.$getValue$("truncateByWord"));
    var ellipsis = $A["util"].$getBooleanValue$(component.$attributeSet$.$getValue$("ellipsis"));
    trunc = 1 * trunc;
    value = $A["util"].truncate(value, trunc, ellipsis, truncateByWord)
  }
  var textNode = document.createTextNode($A["util"].$isUndefinedOrNull$(value) ? "" : value);
  var owner = component.$getOwner$();
  for(var ownerName = owner.$getType$();ownerName === "aura:iteration" || ownerName === "aura:if";) {
    owner = owner.$getOwner$();
    ownerName = owner.$getType$()
  }
  $A.$lockerService$.$trust$(owner, textNode);
  $A.$renderingService$.$setMarker$(component, textNode);
  return textNode
}, "rerender":function(component) {
  var element = component.$getElement$();
  if(element && element.parentNode) {
    var textValue = component.$attributeSet$.$getValue$("value");
    textValue = $A["util"].$isUndefinedOrNull$(textValue) ? "" : textValue;
    if(element.nodeValue !== textValue) {
      element.nodeValue = textValue
    }
  }
}};
Aura.$Component$.$TextComponent$ = TextComponent;
function InteropComponent(config) {
  var cmpDef = $A.$componentService$.$getDef$(config["componentDef"]);
  this.$concreteComponentId$ = config["concreteComponentId"];
  this.$containerComponentId$ = config["containerComponentId"];
  this.$componentDef$ = cmpDef;
  this.$interopClass$ = cmpDef.$interopClass$;
  this.$interopDef$ = cmpDef.$interopDef$;
  this.$_customElement$ = null;
  this.$rendered$ = false;
  this.$inUnrender$ = false;
  this.$shouldAutoDestroy$ = true;
  this.$localIndex$ = {};
  this.$valueProviders$ = {};
  this.$localId$ = config["localId"];
  this.$attributeValueProvider$ = config["attributes"]["valueProvider"];
  this.$owner$ = $A.$clientService$.$getCurrentAccessGlobalId$();
  this.$currentClassMap$ = {};
  this.$attrNameToPropMap$ = this.$componentDef$.$attrNameToPropMap$;
  this.$propNameToAttrMap$ = this.$componentDef$.$propNameToAttrMap$;
  this.$setupGlobalId$(config["globalId"]);
  $A.$componentService$.$indexComponent$(this);
  $A.$lockerService$.$trust$(cmpDef.definition, this);
  if(this.$localId$) {
    this.$doIndex$(this)
  }
  this.attributes = this.$setupAttributes$(config["attributes"]);
  this.$updateReadOnlyBoundProps$ = [];
  this.$setupMethods$()
}
goog.$exportSymbol$("InteropComponent", InteropComponent);
InteropComponent.prototype = Object.create(Component.prototype);
InteropComponent.prototype.constructor = InteropComponent;
InteropComponent.prototype.$bridgeAction$ = function(prv, isEvent, hasNativeAPIExposed, action) {
  var component = this;
  return $A.$getCallback$(function callbackBridge(params) {
    var targetAction = prv && prv.evaluate() || action;
    var event = new Aura.$Event$.$InteropEvent$(component, {"isEvent":isEvent, "params":params, "exposeNativeAPI":!!hasNativeAPIExposed});
    $A.$run$(function() {
      targetAction.$runDeprecated$(event)
    })
  })
};
InteropComponent.prototype.$hasNativeAPIExposed$ = function(eventName) {
  var interopMap = this.$interopClass$["interopMap"];
  var exposeNativeAPI = interopMap && interopMap["exposeNativeEvent"];
  return exposeNativeAPI && exposeNativeAPI[eventName]
};
InteropComponent.prototype.$setupAttributes$ = function(config) {
  var configValues = config && config["values"] || {};
  var attributes = {};
  var self = this;
  var changeHandlerPRVFactory = function(ctx, attr) {
    return function() {
      ctx.$attributeChange$(attr || this.$handler$.key, ctx.get("v." + (attr ? attr : this.$handler$.key)))
    }
  };
  var changeHandlerFCV = function(attr, fcv) {
    this.$attributeChange$(attr, fcv.evaluate())
  };
  for(var attribute in configValues) {
    if(attribute.indexOf("aura:") === 0) {
      continue
    }
    var isEvent = false;
    var value = configValues[attribute];
    var valueConfig = value;
    if($A.$componentService$.$isConfigDescriptor$(value)) {
      valueConfig = value["value"]
    }
    var valueProvider = config["valueProvider"];
    valueConfig = valueFactory.create(valueConfig, valueProvider || this);
    if($A["util"].$isExpression$(valueConfig)) {
      if(valueConfig.$getIsGlobal$ && valueConfig.$getIsGlobal$()) {
        valueConfig = valueConfig.evaluate()
      }else {
        if(valueConfig.getExpression) {
          var key = $A.$expressionService$.normalize(valueConfig.getExpression());
          var provider = key.split(".")[0];
          var isPTV = valueProvider instanceof PassthroughValue;
          $A.assert(isPTV || provider === "c" || provider === "v", "Provider type not supported");
          var valueDescriptor = value["descriptor"];
          var startsWithOn = valueDescriptor && valueDescriptor.indexOf("on") === 0;
          var hasNativeAPIExposed = startsWithOn && this.$hasNativeAPIExposed$(valueDescriptor.substr(2));
          if(provider === "v") {
            if(hasNativeAPIExposed) {
              isEvent = true;
              valueConfig = this.$bridgeAction$(valueConfig, isEvent, hasNativeAPIExposed)
            }else {
              valueConfig.$addChangeHandler$(this, attribute, changeHandlerPRVFactory(this))
            }
          }else {
            if(provider === "c") {
              var definedAttribute = !!this.$interopDef$["props"][valueDescriptor];
              $A.assert(definedAttribute || startsWithOn, "Attribute not defined in the component");
              isEvent = !definedAttribute;
              valueConfig = this.$bridgeAction$(valueConfig, isEvent, hasNativeAPIExposed)
            }else {
              valueConfig.$addChangeHandler$(this, attribute, changeHandlerPRVFactory(this, attribute))
            }
          }
        }else {
          valueConfig.$addChangeHandler$(this, attribute, changeHandlerFCV.bind(self, attribute, valueConfig))
        }
      }
    }else {
      if($A["util"].$isAction$(valueConfig)) {
        isEvent = true;
        valueConfig = this.$bridgeAction$(undefined, isEvent, attribute.indexOf("on") === 0 && this.$hasNativeAPIExposed$(attribute.substr(2)), valueConfig)
      }
    }
    var isAttrInDefinition = !!this.$attrNameToPropMap$[attribute];
    var assertionMessage = '"' + attribute + '" must either be a public property of ' + this.getName() + " or a global HTML attribute";
    $A.assert(isEvent || isAttrInDefinition || this.$isHtmlGlobalAttr$(attribute), assertionMessage);
    attributes[attribute] = valueConfig
  }
  return attributes
};
InteropComponent.prototype.$isHtmlGlobalAttr$ = function(attrName) {
  return InteropComponent.$HTML_GLOBAL_ATTRS$[attrName] || false
};
InteropComponent.prototype.$isReadOnlyProperty$ = function(propName) {
  return this.$interopDef$["props"][propName]["config"] === 1
};
InteropComponent.$HTML_GLOBAL_ATTRS$ = {"accesskey":true, "class":true, "contenteditable":true, "contextmenu":true, "dir":true, "draggable":true, "dropzone":true, "hidden":true, "id":true, "lang":true, "spellcheck":true, "style":true, "tabindex":true, "title":true, "translate":true, "role":true};
InteropComponent.prototype.$getPublicMethodNames$ = function() {
  return Object.keys(this.$interopDef$["methods"])
};
goog.$exportProperty$(InteropComponent.prototype, "getPublicMethodNames", InteropComponent.prototype.$getPublicMethodNames$);
InteropComponent.prototype.$setupMethods$ = function() {
  var self = this;
  this.$getPublicMethodNames$().forEach(function(m) {
    self[m] = function() {
      if(!self.$rendered$) {
        return $A.$warning$("Methods are not available until the component is rendered")
      }
      var elmt = this.$getElement$();
      return elmt[m].apply(elmt, arguments)
    }
  })
};
InteropComponent.prototype.$attributeChange$ = function(key, value) {
  if(this.$rendered$) {
    var element = this.$getElement$();
    var propName = this.$attrNameToPropMap$[key];
    if(!propName && this.$isHtmlGlobalAttr$(key)) {
      this.$setGlobalAttribute$(element, key, value)
    }else {
      if(!this.$isReadOnlyProperty$(propName)) {
        element[propName] = value;
        this.$rehydrateBoundReadOnlyProps$()
      }
    }
  }
};
InteropComponent.prototype.$rehydrateBoundReadOnlyProps$ = function() {
  this.$updateReadOnlyBoundProps$.forEach(function(func) {
    func()
  })
};
InteropComponent.$_classNameCacheMap$ = {};
InteropComponent.prototype.$getMapFromClassName$ = function(className) {
  if(className === undefined || className == null || className === "") {
    return{}
  }
  var SPACE_CHAR = 32;
  var map = InteropComponent.$_classNameCacheMap$[className];
  if(map) {
    return map
  }
  map = {};
  var start = 0;
  var i;
  var len = className.length;
  for(i = 0;i < len;i++) {
    if(className.charCodeAt(i) === SPACE_CHAR) {
      if(i > start) {
        map[className.slice(start, i)] = true
      }
      start = i + 1
    }
  }
  if(i > start) {
    map[className.slice(start, i)] = true
  }
  InteropComponent.$_classNameCacheMap$[className] = map;
  return map
};
InteropComponent.prototype.$updateClassAttribute$ = function(element, value) {
  var currentClassMap = this.$currentClassMap$;
  $A.assert(currentClassMap !== null && typeof currentClassMap === "object", "Current Class Map must be an object.");
  var classMap = this.$getMapFromClassName$(value);
  Object.keys(currentClassMap).forEach(function(className) {
    if(!classMap[className]) {
      element.classList.remove(className)
    }
  });
  Object.keys(classMap).forEach(function(className) {
    if(!currentClassMap[className]) {
      element.classList.add(className)
    }
  });
  this.$currentClassMap$ = classMap
};
InteropComponent.prototype.$setGlobalAttribute$ = function(element, attrName, value) {
  if(attrName === "class") {
    this.$updateClassAttribute$(element, value);
    return
  }
  if(value === true) {
    element.setAttribute(attrName, "")
  }else {
    if(value === false || value === null || value === undefined) {
      element.removeAttribute(attrName)
    }else {
      element.setAttribute(attrName, value)
    }
  }
};
InteropComponent.prototype.get = function(key) {
  key = $A.$expressionService$.normalize(key);
  var path = key.split(".");
  path.shift();
  $A.assert(path.length === 1, "This component does not allow to get nested properties");
  var propValue = $A.$expressionService$.$resolve$(path.join("."), this.attributes);
  if(propValue !== undefined && propValue !== null) {
    if($A["util"].$isExpression$(propValue.value)) {
      propValue = propValue.value.evaluate()
    }
  }else {
    if(!$A["util"].$isExpression$(this.attributes[path[0]])) {
      var propName = this.$attrNameToPropMap$[path[0]];
      var element = this.$getElement$();
      if(propName && element) {
        propValue = element[propName]
      }
    }
  }
  return $A.$componentService$.$moduleEngine$["unwrap"](propValue)
};
goog.$exportProperty$(InteropComponent.prototype, "get", InteropComponent.prototype.get);
InteropComponent.prototype.set = function(key, value) {
  var normalizedKey = $A.$expressionService$.normalize(key);
  var path = normalizedKey.split(".");
  var provider = path.shift();
  $A.assert(provider === "v", "This component does not allow mutations on controller actions");
  $A.assert(path.length === 1, "This component does not allow set on nested properties");
  var expr = path.join(".");
  var attrValue = this.attributes[expr];
  if(attrValue && $A["util"].$isExpression$(attrValue.value)) {
    $A.$warning$("Component " + this.$componentDef$.$interopClassName$ + ' is not the owner of property "' + expr + '" and should not change it directly');
    attrValue.value.set(value)
  }else {
    if(attrValue && attrValue.getExpression) {
      attrValue.set(value)
    }else {
      this.attributes[expr] = value;
      this.$attributeChange$(expr, value)
    }
  }
};
goog.$exportProperty$(InteropComponent.prototype, "set", InteropComponent.prototype.set);
InteropComponent.prototype.$attachOnChangeToElement$ = function(element) {
  function handleInteropChange(event) {
    var detail = event.detail;
    if(detail && event.target === element) {
      Object.keys(detail).forEach(function(propName) {
        var attrName = self.$propNameToAttrMap$[propName];
        if(attrName in self.attributes) {
          self.set("v." + attrName, detail[propName])
        }
      })
    }
  }
  var self = this;
  element.addEventListener("change", handleInteropChange)
};
InteropComponent.prototype.$render$ = function() {
  var element = document.createElement(this.$componentDef$.$elementName$);
  this.$_customElement$ = this.$setupInteropInstance$();
  $A.$lockerService$.$trust$(this, this.$_customElement$);
  return[element]
};
goog.$exportProperty$(InteropComponent.prototype, "render", InteropComponent.prototype.$render$);
InteropComponent.prototype.$setupInteropInstance$ = function() {
  var Ctor = this.$interopClass$;
  var element = $A.$componentService$.$moduleEngine$["createElement"](this.$componentDef$.$elementName$, {"is":Ctor});
  var cmp = this;
  element.$__customElement$ = 1;
  this.$attachOnChangeToElement$(element);
  Object.keys(this.attributes).forEach(function(attrName) {
    var value = cmp.get("v." + attrName);
    var propName = this.$attrNameToPropMap$[attrName];
    if(attrName.indexOf("on") === 0 && !propName) {
      element.addEventListener(attrName.substring(2), value, false)
    }else {
      if(!propName && this.$isHtmlGlobalAttr$(attrName)) {
        this.$setGlobalAttribute$(element, attrName, value)
      }else {
        if(!cmp.$isReadOnlyProperty$(propName)) {
          if(value !== undefined) {
            element[propName] = value
          }
        }else {
          var attribute = this.$propNameToAttrMap$[propName];
          if($A["util"].$isExpression$(this.attributes[attribute])) {
            this.$updateReadOnlyBoundProps$.push(function() {
              cmp.set("v." + attribute, element[propName])
            })
          }
        }
      }
    }
  }.bind(this));
  return element
};
InteropComponent.prototype.$swapInteropElement$ = function(currentElement, newElement) {
  if(currentElement === newElement) {
    return
  }
  this.$disassociateElements$();
  $A.$renderingService$.$moveReferencesToMarker$(currentElement, newElement);
  this.$associateElement$(newElement);
  currentElement.parentElement.replaceChild(newElement, currentElement);
  this.$updateContainerElement$(this.$getContainer$(), currentElement, newElement);
  if(typeof this.$interopClass$ === "function") {
    var cmp = this;
    var lwcCmp = this.$getElement$();
    Object.keys(this.$interopDef$["props"]).forEach(function(propName) {
      if(cmp.$isReadOnlyProperty$(propName)) {
        cmp.set("v." + cmp.$propNameToAttrMap$[propName], lwcCmp[propName])
      }
    })
  }
};
InteropComponent.prototype.$updateContainerElement$ = function(container, currentElement, newElement) {
  if(!container) {
    return
  }
  var concrete = container.$getConcreteComponent$();
  if(concrete.$getType$() === "aura:html") {
    return
  }
  var parentGetElements = concrete.$getElements$();
  if(parentGetElements) {
    if(parentGetElements.indexOf(currentElement) >= 0) {
      concrete.$disassociateElements$();
      var i = 0;
      for(var len = parentGetElements.length;i < len;i++) {
        var element = parentGetElements[i];
        if(element === currentElement) {
          concrete.$associateElement$(newElement);
          $A.$renderingService$.$addAuraClass$(concrete, newElement)
        }else {
          concrete.$associateElement$(element)
        }
      }
    }else {
      if(parentGetElements.indexOf(newElement) >= 0) {
        $A.$renderingService$.$addAuraClass$(concrete, newElement)
      }
    }
  }
  this.$updateContainerElement$(concrete.$getContainer$(), currentElement, newElement)
};
InteropComponent.prototype.$afterRender$ = function() {
  if(this.$destroyed$ || this.elements === undefined) {
    return
  }
  var element = this.elements[0];
  if(document.body.contains(element)) {
    this.$swapInteropElement$(element, this.$_customElement$)
  }else {
    $A.$getCmp$(this.$owner$).$addEventHandler$("markup://aura:valueRender", this.$afterParentRender$.bind(this), "default")
  }
};
goog.$exportProperty$(InteropComponent.prototype, "afterRender", InteropComponent.prototype.$afterRender$);
InteropComponent.prototype.$afterParentRender$ = function() {
  this.$swapInteropElement$(this.elements[0], this.$_customElement$);
  $A.$getCmp$(this.$owner$).$removeEventHandler$("markup://aura:valueRender", this.$afterParentRender$.bind(this), "default")
};
InteropComponent.prototype.$getElement$ = function() {
  return this.$_customElement$
};
goog.$exportProperty$(InteropComponent.prototype, "getElement", InteropComponent.prototype.$getElement$);
InteropComponent.prototype.$unrender$ = function() {
  $A.$renderingService$.$cleanComponent$(this.$globalId$);
  var elements = this.$getElements$();
  if(elements) {
    for(;elements.length;) {
      $A["util"].$removeElement$(elements.pop())
    }
  }
  this.$disassociateElements$()
};
goog.$exportProperty$(InteropComponent.prototype, "unrender", InteropComponent.prototype.$unrender$);
InteropComponent.prototype.$destroy$ = function() {
  var cmp = this;
  var attrs = this.attributes;
  Object.keys(attrs).forEach(function(attrName) {
    var attrValue = attrs[attrName];
    if(attrValue && $A["util"].$isExpression$(attrValue.value)) {
      attrValue.value.$removeChangeHandler$(cmp, attrName)
    }
  });
  this.$doDeIndex$();
  $A.$renderingService$.$unrender$(this);
  $A.$componentService$.$deIndex$(this.$globalId$)
};
goog.$exportProperty$(InteropComponent.prototype, "destroy", InteropComponent.prototype.$destroy$);
InteropComponent.prototype.find = function() {
  return null
};
goog.$exportProperty$(InteropComponent.prototype, "find", InteropComponent.prototype.find);
InteropComponent.prototype.$findInstancesOf$ = function() {
  return[]
};
InteropComponent.prototype.$findInstanceOf$ = function() {
  return null
};
InteropComponent.prototype.$getSuperest$ = function() {
  this.$raiseInvalidInteropApi$("getSuperest", arguments)
};
InteropComponent.prototype.$implementsDirectly$ = function() {
  this.$raiseInvalidInteropApi$("implementsDirectly", arguments)
};
InteropComponent.prototype.$addHandler$ = function() {
  this.$raiseInvalidInteropApi$("addHandler", arguments)
};
goog.$exportProperty$(InteropComponent.prototype, "addHandler", InteropComponent.prototype.$addHandler$);
InteropComponent.prototype.$addValueHandler$ = function() {
  this.$raiseInvalidInteropApi$("addValueHandler", arguments)
};
goog.$exportProperty$(InteropComponent.prototype, "addValueHandler", InteropComponent.prototype.$addValueHandler$);
InteropComponent.prototype.$removeValueHandler$ = function() {
};
InteropComponent.prototype.$getRenderer$ = function() {
};
InteropComponent.prototype.$getReference$ = function() {
};
InteropComponent.prototype.$fire$ = function() {
};
InteropComponent.prototype.$getRendering$ = function() {
  this.$raiseInvalidInteropApi$("getRendering", arguments)
};
goog.$exportProperty$(InteropComponent.prototype, "getRendering", InteropComponent.prototype.$getRendering$);
InteropComponent.prototype.$getSuper$ = function() {
  return null
};
goog.$exportProperty$(InteropComponent.prototype, "getSuper", InteropComponent.prototype.$getSuper$);
InteropComponent.prototype.$getConcreteComponent$ = function() {
  return this
};
goog.$exportProperty$(InteropComponent.prototype, "getConcreteComponent", InteropComponent.prototype.$getConcreteComponent$);
InteropComponent.prototype.$isConcrete$ = function() {
  return true
};
goog.$exportProperty$(InteropComponent.prototype, "isConcrete", InteropComponent.prototype.$isConcrete$);
InteropComponent.prototype.$getEventDispatcher$ = function() {
  this.$raiseInvalidInteropApi$("getEventDispatcher", arguments)
};
goog.$exportProperty$(InteropComponent.prototype, "getEventDispatcher", InteropComponent.prototype.$getEventDispatcher$);
InteropComponent.prototype.$getModel$ = function() {
  this.$raiseInvalidInteropApi$("getModel", arguments)
};
goog.$exportProperty$(InteropComponent.prototype, "getModel", InteropComponent.prototype.$getModel$);
InteropComponent.prototype.$getEvent$ = function() {
  this.$raiseInvalidInteropApi$("getEvent", arguments)
};
goog.$exportProperty$(InteropComponent.prototype, "getEvent", InteropComponent.prototype.$getEvent$);
InteropComponent.prototype.$getEventByDescriptor$ = function() {
  this.$raiseInvalidInteropApi$("getEventByDescriptor", arguments)
};
InteropComponent.prototype.toString = function() {
  return"InteropComponent: " + this.$componentDef$.$getDescriptor$().toString()
};
goog.$exportProperty$(InteropComponent.prototype, "toString", InteropComponent.prototype.toString);
InteropComponent.prototype.$getFacets$ = function() {
  this.$raiseInvalidInteropApi$("getFacets", arguments)
};
goog.$exportProperty$(InteropComponent.prototype, "getFacets", InteropComponent.prototype.$getFacets$);
InteropComponent.prototype.$raiseInvalidInteropApi$ = function(func, args) {
  var error = "Interop component tried calling function [" + func + "]";
  var argsArr = Array.prototype.slice.call(args);
  if(argsArr.length) {
    error += " with arguments [" + argsArr.join(",") + "]"
  }
  if(this.$globalId$ && this.$componentDef$) {
    error += ", " + this.$componentDef$ + " [" + this.$globalId$ + "]"
  }
  var ae = new $A.$auraError$(error, null, $A.severity.$QUIET$);
  ae.$component$ = this.toString();
  throw ae;
};
Aura.$Component$.$InteropComponent$ = InteropComponent;
function InteropModule(config) {
  var cmpDef = $A.$componentService$.$getDef$(config["componentDef"]);
  this.$concreteComponentId$ = config["concreteComponentId"];
  this.$containerComponentId$ = config["containerComponentId"];
  this.$componentDef$ = cmpDef;
  this.$interopClass$ = cmpDef.$interopClass$;
  this.$rendered$ = false;
  this.$inUnrender$ = false;
  this.$shouldAutoDestroy$ = true;
  this.$localId$ = config["localId"];
  this.$attributeValueProvider$ = config["attributes"]["valueProvider"];
  this.$owner$ = $A.$clientService$.$getCurrentAccessGlobalId$();
  this.$allElements$ = [];
  this.$setupGlobalId$(config["globalId"]);
  $A.$componentService$.$indexComponent$(this);
  $A.$lockerService$.$trust$(cmpDef.definition, this);
  if(this.$localId$) {
    this.$doIndex$(this)
  }
  this.$setupMethods$()
}
goog.$exportSymbol$("InteropModule", InteropModule);
InteropModule.prototype = Object.create(Aura.$Component$.$InteropComponent$.prototype);
InteropModule.prototype.constructor = InteropModule;
InteropModule.prototype.$getPublicMethodNames$ = function() {
  return Object.getOwnPropertyNames(this.$interopClass$)
};
goog.$exportProperty$(InteropModule.prototype, "getPublicMethodNames", InteropModule.prototype.$getPublicMethodNames$);
InteropModule.prototype.$setupMethods$ = function() {
  var interopClass = this.$interopClass$;
  var self = this;
  this.$getPublicMethodNames$().forEach(function(m) {
    Object.defineProperty(self, m, {get:function() {
      return interopClass[m]
    }})
  })
};
InteropModule.prototype.get = function() {
  this.$raiseInvalidInteropApi$("get", arguments)
};
goog.$exportProperty$(InteropModule.prototype, "get", InteropModule.prototype.get);
InteropModule.prototype.set = function() {
  this.$raiseInvalidInteropApi$("set", arguments)
};
goog.$exportProperty$(InteropModule.prototype, "set", InteropModule.prototype.set);
InteropModule.prototype.$render$ = function() {
};
goog.$exportProperty$(InteropModule.prototype, "render", InteropModule.prototype.$render$);
InteropModule.prototype.$unrender$ = function() {
};
goog.$exportProperty$(InteropModule.prototype, "unrender", InteropModule.prototype.$unrender$);
InteropModule.prototype.$destroy$ = function() {
  this.$doDeIndex$();
  $A.$componentService$.$deIndex$(this.$globalId$)
};
goog.$exportProperty$(InteropModule.prototype, "destroy", InteropModule.prototype.$destroy$);
InteropModule.prototype.toString = function() {
  return"InteropModule: " + this.$componentDef$.$getDescriptor$().toString()
};
goog.$exportProperty$(InteropModule.prototype, "toString", InteropModule.prototype.toString);
Aura.$Component$.$InteropModule$ = InteropModule;
function ComponentDef(config) {
  var descriptor = new DefDescriptor(config[Json.$ApplicationKey$.$DESCRIPTOR$]);
  this.$descriptor$ = descriptor;
  this.$hasRemoteDeps$ = descriptor.toString().indexOf("layout://") !== 0 && (config[Json.$ApplicationKey$.$HASSERVERDEPENDENCIES$] || false);
  this.$access$ = config[Json.$ApplicationKey$.$ACCESS$];
  this.$styleDef$ = config[Json.$ApplicationKey$.$STYLEDEF$] ? new StyleDef(config[Json.$ApplicationKey$.$STYLEDEF$]) : undefined;
  this.$flavoredStyleDef$ = config[Json.$ApplicationKey$.$FLAVOREDSTYLEDEF$] ? new StyleDef(config[Json.$ApplicationKey$.$FLAVOREDSTYLEDEF$]) : undefined;
  this.$controllerDef$ = config[Json.$ApplicationKey$.$CONTROLLERDEF$] ? $A.$componentService$.$createControllerDef$(config[Json.$ApplicationKey$.$CONTROLLERDEF$]) : undefined;
  this.$modelDef$ = config[Json.$ApplicationKey$.$MODELDEF$] ? $A.$componentService$.$createModelDef$(config[Json.$ApplicationKey$.$MODELDEF$]) : undefined;
  this.$methodDefs$ = config[Json.$ApplicationKey$.$METHODDEFS$] ? config[Json.$ApplicationKey$.$METHODDEFS$] : undefined;
  this.$tokens$ = config[Json.$ApplicationKey$.$TOKENS$] ? config[Json.$ApplicationKey$.$TOKENS$] : undefined;
  this.$minVersion$ = config[Json.$ApplicationKey$.$MINVERSION$] ? config[Json.$ApplicationKey$.$MINVERSION$] : undefined;
  this.$interfaces$ = {};
  var intfConfig = config[Json.$ApplicationKey$.$INTERFACES$];
  if(intfConfig) {
    for(var m = 0;m < intfConfig.length;m++) {
      var intf = new DefDescriptor(intfConfig[m]);
      var intfName = intf.$getFullName$();
      this.$interfaces$[intfName] = true
    }
  }
  var superDef = config[Json.$ApplicationKey$.$SUPERDEF$];
  if(superDef === undefined && !this.$interfaces$["aura:rootComponent"]) {
    superDef = "markup://aura:component"
  }
  this.$superDef$ = this.$initSuperDef$(superDef);
  if(config.hasOwnProperty(Json.$ApplicationKey$.$COMPONENTCLASS$)) {
    try {
      var componentClass = $A.$clientService$.$evalExporter$(config[Json.$ApplicationKey$.$COMPONENTCLASS$], descriptor.toString());
      componentClass()
    }catch(e) {
      var auraError = new $A.$auraError$("ComponentDef initialization error", e);
      auraError.$setComponent$(descriptor.$getQualifiedName$());
      throw auraError;
    }
  }
  var appHandlerDefs;
  var cmpHandlerDefs;
  var valueHandlerDefs;
  this.$facets$ = config[Json.$ApplicationKey$.$FACETS$];
  this.$isAbs$ = !!config[Json.$ApplicationKey$.$ABSTRACT$];
  if(config[Json.$ApplicationKey$.$LOCATIONCHANGEEVENTDEF$]) {
    this.$locationChangeEventDef$ = $A.$eventService$.$createEventDef$(config[Json.$ApplicationKey$.$LOCATIONCHANGEEVENTDEF$])
  }else {
    this.$locationChangeEventDef$ = null
  }
  var registerEventDefs = {};
  this.$registerEventDefs$ = registerEventDefs;
  var allEvents = [];
  this.$allEvents$ = allEvents;
  var cred = config[Json.$ApplicationKey$.$REGISTEREVENTDEFS$];
  if(cred) {
    for(var i = 0;i < cred.length;i++) {
      var regConfig = cred[i];
      var name = regConfig[Json.$ApplicationKey$["NAME"]];
      allEvents.push(name);
      var eventDef = {};
      eventDef[Json.$ApplicationKey$.$DESCRIPTOR$] = regConfig[Json.$ApplicationKey$.$EVENTDEF$];
      registerEventDefs[name] = $A.$eventService$.$createEventDef$(eventDef)
    }
  }
  var handlerDefConfigs = config[Json.$ApplicationKey$.$HANDLERDEFS$];
  if(handlerDefConfigs) {
    for(var j = 0;j < handlerDefConfigs.length;j++) {
      var handlerConfig = handlerDefConfigs[j];
      if(handlerConfig[Json.$ApplicationKey$.$EVENTDEF$]) {
        if(handlerConfig[Json.$ApplicationKey$["NAME"]]) {
          if(!cmpHandlerDefs) {
            cmpHandlerDefs = []
          }
          cmpHandlerDefs.push({"name":handlerConfig[Json.$ApplicationKey$["NAME"]], "action":handlerConfig[Json.$ApplicationKey$.$ACTION$], "phase":handlerConfig[Json.$ApplicationKey$.$PHASE$], "includeFacets":handlerConfig[Json.$ApplicationKey$.$INCLUDEFACETS$], "eventDef":$A.$eventService$.$createEventDef$(handlerConfig[Json.$ApplicationKey$.$EVENTDEF$])})
        }else {
          if(!appHandlerDefs) {
            appHandlerDefs = []
          }
          appHandlerDefs.push({"action":handlerConfig[Json.$ApplicationKey$.$ACTION$], "phase":handlerConfig[Json.$ApplicationKey$.$PHASE$], "includeFacets":handlerConfig[Json.$ApplicationKey$.$INCLUDEFACETS$], "eventDef":$A.$eventService$.$createEventDef$(handlerConfig[Json.$ApplicationKey$.$EVENTDEF$])})
        }
      }else {
        if(handlerConfig[Json.$ApplicationKey$.$VALUE$]) {
          if(!valueHandlerDefs) {
            valueHandlerDefs = []
          }
          valueHandlerDefs.push({"name":handlerConfig[Json.$ApplicationKey$["NAME"]], "action":handlerConfig[Json.$ApplicationKey$.$ACTION$], "value":handlerConfig[Json.$ApplicationKey$.$VALUE$]})
        }else {
          if(!cmpHandlerDefs) {
            cmpHandlerDefs = []
          }
          cmpHandlerDefs.push({"name":handlerConfig[Json.$ApplicationKey$["NAME"]], "action":handlerConfig[Json.$ApplicationKey$.$ACTION$]})
        }
      }
    }
  }
  var subDefs = config[Json.$ApplicationKey$.$SUBDEFS$];
  if(subDefs) {
    for(var k = 0;k < subDefs.length;k++) {
      $A.$componentService$.$getDef$(subDefs[k])
    }
  }
  this.$appHandlerDefs$ = appHandlerDefs || null;
  this.$cmpHandlerDefs$ = cmpHandlerDefs || null;
  this.$valueHandlerDefs$ = valueHandlerDefs || null;
  this.$isCSSPreloaded$ = config[Json.$ApplicationKey$.$CSSPRELOADED$] || false;
  if(config[Json.$ApplicationKey$.$DEFAULTFLAVOR$]) {
    this.$defaultFlavor$ = config[Json.$ApplicationKey$.$DEFAULTFLAVOR$]
  }
  if(config[Json.$ApplicationKey$.$FLAVORABLECHILD$]) {
    this.$flavorableChild$ = true
  }
  if(config[Json.$ApplicationKey$.$DYNAMICALLYFLAVORABLE$]) {
    this.$dynamicallyFlavorable$ = config[Json.$ApplicationKey$.$DYNAMICALLYFLAVORABLE$]
  }
  if(config[Json.$ApplicationKey$.$FLAVOROVERRIDES$]) {
    this.$flavorOverrides$ = new FlavorsDef(config[Json.$ApplicationKey$.$FLAVOROVERRIDES$])
  }
  if(config[Json.$ApplicationKey$.$LOCATORDEFS$]) {
    this.$locatorDefs$ = config[Json.$ApplicationKey$.$LOCATORDEFS$]
  }
  this.$attributeDefs$ = new AttributeDefSet(config[Json.$ApplicationKey$.$ATTRIBUTEDEFS$], this.$descriptor$.$getNamespace$());
  this.$requiredVersionDefs$ = new RequiredVersionDefSet(config[Json.$ApplicationKey$.$REQUIREDVERSIONDEFS$]);
  this.$initStyleDefs$();
  this.$hasInitHandler$
}
goog.$exportSymbol$("ComponentDef", ComponentDef);
ComponentDef.prototype.$hasInit$ = function() {
  if(this.$hasInitHandler$ === undefined) {
    if(!this.$valueHandlerDefs$) {
      this.$hasInitHandler$ = false
    }else {
      for(var c = 0;c < this.$valueHandlerDefs$.length;c++) {
        if(this.$valueHandlerDefs$[c].name === "init") {
          this.$hasInitHandler$ = true;
          return this.$hasInitHandler$
        }
      }
    }
    this.$hasInitHandler$ = false
  }
  return this.$hasInitHandler$
};
ComponentDef.prototype.$getDescriptor$ = function() {
  return this.$descriptor$
};
goog.$exportProperty$(ComponentDef.prototype, "getDescriptor", ComponentDef.prototype.$getDescriptor$);
ComponentDef.prototype.$isAbstract$ = function() {
  return this.$isAbs$
};
goog.$exportProperty$(ComponentDef.prototype, "isAbstract", ComponentDef.prototype.$isAbstract$);
ComponentDef.prototype.$getSuperDef$ = function() {
  return this.$superDef$
};
goog.$exportProperty$(ComponentDef.prototype, "getSuperDef", ComponentDef.prototype.$getSuperDef$);
ComponentDef.prototype.$getHelper$ = function() {
  var name = this.$descriptor$.$getQualifiedName$();
  var componentClass = $A.$componentService$.$getComponentClass$(name);
  return componentClass ? componentClass.prototype["helper"] : undefined
};
goog.$exportProperty$(ComponentDef.prototype, "getHelper", ComponentDef.prototype.$getHelper$);
ComponentDef.prototype.$getRequiredVersionDefs$ = function() {
  return this.$requiredVersionDefs$
};
ComponentDef.prototype.$hasRemoteDependencies$ = function() {
  return this.$hasRemoteDeps$
};
ComponentDef.prototype.$getAllStyleDefs$ = function() {
  return this.$allStyleDefs$
};
ComponentDef.prototype.$getAllFlavoredStyleDefs$ = function() {
  return this.$allFlavoredStyleDefs$
};
ComponentDef.prototype.$getStyleClassName$ = function() {
  var className = this.$styleClassName$;
  if(!className) {
    className = "";
    var styleDefs = this.$getAllStyleDefs$();
    if(styleDefs) {
      var styleDefLen = styleDefs.length;
      for(var t = 0;t < styleDefLen;t++) {
        var styleDef = styleDefs[t];
        className = className + styleDef.$getClassName$() + " ";
        if(!this.$isCSSPreloaded$) {
          styleDef.apply()
        }
      }
    }
    this.$styleClassName$ = className;
    if(!this.$isCSSPreloaded$) {
      var flavoredStyleDefs = this.$getAllFlavoredStyleDefs$();
      if(flavoredStyleDefs) {
        var i = 0;
        for(var len = flavoredStyleDefs.length;i < len;i++) {
          flavoredStyleDefs[i].apply()
        }
      }
    }
  }
  return className
};
goog.$exportProperty$(ComponentDef.prototype, "getStyleClassName", ComponentDef.prototype.$getStyleClassName$);
ComponentDef.prototype.$getStyleDef$ = function() {
  return this.$styleDef$
};
goog.$exportProperty$(ComponentDef.prototype, "getStyleDef", ComponentDef.prototype.$getStyleDef$);
ComponentDef.prototype.$getDefaultFlavor$ = function() {
  if($A["util"].$isUndefined$(this.$flavorOverride$)) {
    var override = null;
    var appDesc = $A.getContext().$getApp$();
    if(appDesc) {
      var appDef = $A.$componentService$.$getDef$(appDesc, true);
      if(appDef) {
        var defaults = appDef.$getFlavorOverrides$();
        if(defaults) {
          override = defaults.$getFlavor$(this.$descriptor$);
          if(override === "{!remove}") {
            override = ""
          }
        }
      }
    }
    this.$flavorOverride$ = $A["util"].$isUndefinedOrNull$(override) ? null : override
  }
  return!$A["util"].$isUndefinedOrNull$(this.$flavorOverride$) ? this.$flavorOverride$ : this.$getExplicitDefaultFlavor$()
};
goog.$exportProperty$(ComponentDef.prototype, "getDefaultFlavor", ComponentDef.prototype.$getDefaultFlavor$);
ComponentDef.prototype.$getExplicitDefaultFlavor$ = function() {
  if(!$A["util"].$isUndefinedOrNull$(this.$defaultFlavor$)) {
    return this.$defaultFlavor$
  }
  if(this.$superDef$) {
    return this.$superDef$.$getExplicitDefaultFlavor$()
  }
  return null
};
ComponentDef.prototype.$hasFlavorableChild$ = function() {
  return!!this.$flavorableChild$
};
goog.$exportProperty$(ComponentDef.prototype, "hasFlavorableChild", ComponentDef.prototype.$hasFlavorableChild$);
ComponentDef.prototype.$getFlavorOverrides$ = function() {
  return this.$flavorOverrides$
};
goog.$exportProperty$(ComponentDef.prototype, "getFlavorOverrides", ComponentDef.prototype.$getFlavorOverrides$);
ComponentDef.prototype.$isDynamicallyFlavorable$ = function() {
  return this.$dynamicallyFlavorable$ || this.$superDef$ && this.$superDef$.$isDynamicallyFlavorable$()
};
ComponentDef.prototype.$getDynamicallyFlavorable$ = function() {
  var ret = [];
  if(this.$dynamicallyFlavorable$) {
    ret.push(this)
  }
  if(this.$superDef$) {
    ret = ret.concat(this.$superDef$.$getDynamicallyFlavorable$())
  }
  return ret
};
ComponentDef.prototype.$getAttributeDefs$ = function() {
  return this.$attributeDefs$
};
goog.$exportProperty$(ComponentDef.prototype, "getAttributeDefs", ComponentDef.prototype.$getAttributeDefs$);
ComponentDef.prototype.$getFacets$ = function() {
  return this.$facets$
};
goog.$exportProperty$(ComponentDef.prototype, "getFacets", ComponentDef.prototype.$getFacets$);
ComponentDef.prototype.$getFacet$ = function(facetName) {
  if(!this.$facetMap$) {
    var facetMap = {};
    if(this.$facets$) {
      var facets = this.$facets$;
      var c = 0;
      for(var length = facets.length;c < length;c++) {
        facetMap[facets[c]["descriptor"]] = facets[c]
      }
    }
    this.$facetMap$ = facetMap
  }
  return this.$facetMap$.hasOwnProperty(facetName) ? this.$facetMap$[facetName] : undefined
};
ComponentDef.prototype.$getControllerDef$ = function() {
  return this.$controllerDef$
};
goog.$exportProperty$(ComponentDef.prototype, "getControllerDef", ComponentDef.prototype.$getControllerDef$);
ComponentDef.prototype.$getModelDef$ = function() {
  return this.$modelDef$
};
goog.$exportProperty$(ComponentDef.prototype, "getModelDef", ComponentDef.prototype.$getModelDef$);
ComponentDef.$valueEvents$ = {"change":"aura:valueChange", "destroy":"aura:valueDestroy", "init":"aura:valueInit", "render":"aura:valueRender"};
ComponentDef.prototype.$getEventDef$ = function(name, includeValueEvents) {
  var ret = this.$registerEventDefs$[name];
  if(!ret && includeValueEvents) {
    if(ComponentDef.$valueEvents$.hasOwnProperty(name)) {
      name = ComponentDef.$valueEvents$[name]
    }
    ret = $A.get("e").$getDef$(name)
  }
  return ret
};
goog.$exportProperty$(ComponentDef.prototype, "getEventDef", ComponentDef.prototype.$getEventDef$);
ComponentDef.prototype.$getEventNameByDescriptor$ = function(descriptor) {
  for(var name in this.$registerEventDefs$) {
    if(this.$registerEventDefs$[name] && this.$registerEventDefs$[name].$descriptor$ && this.$registerEventDefs$[name].$descriptor$.$qualifiedName$ === descriptor) {
      return name
    }
  }
  return null
};
ComponentDef.prototype.$getAllEvents$ = function() {
  return this.$allEvents$
};
goog.$exportProperty$(ComponentDef.prototype, "getAllEvents", ComponentDef.prototype.$getAllEvents$);
ComponentDef.prototype.$getAppHandlerDefs$ = function() {
  return this.$appHandlerDefs$
};
goog.$exportProperty$(ComponentDef.prototype, "getAppHandlerDefs", ComponentDef.prototype.$getAppHandlerDefs$);
ComponentDef.prototype.$getCmpHandlerDefs$ = function() {
  return this.$cmpHandlerDefs$
};
goog.$exportProperty$(ComponentDef.prototype, "getCmpHandlerDefs", ComponentDef.prototype.$getCmpHandlerDefs$);
ComponentDef.prototype.$getValueHandlerDefs$ = function() {
  return this.$valueHandlerDefs$
};
ComponentDef.prototype.toString = function() {
  return this.$descriptor$.$getQualifiedName$()
};
goog.$exportProperty$(ComponentDef.prototype, "toString", ComponentDef.prototype.toString);
ComponentDef.prototype.$isInstanceOf$ = function(name) {
  var thisName = this.$descriptor$.$getFullName$();
  if(thisName === name || this.$implementsDirectly$(name)) {
    return true
  }
  if(this.$superDef$) {
    return this.$superDef$.$isInstanceOf$(name)
  }
  return false
};
goog.$exportProperty$(ComponentDef.prototype, "isInstanceOf", ComponentDef.prototype.$isInstanceOf$);
ComponentDef.prototype.$implementsDirectly$ = function(type) {
  return!$A["util"].$isUndefined$(this.$interfaces$[type])
};
ComponentDef.prototype.$getLocationChangeEvent$ = function() {
  var evt = this.$locationChangeEventDef$;
  if(evt) {
    return evt.$getDescriptor$().$getQualifiedName$()
  }
  return"markup://aura:locationChange"
};
goog.$exportProperty$(ComponentDef.prototype, "getLocationChangeEvent", ComponentDef.prototype.$getLocationChangeEvent$);
ComponentDef.prototype.$getLayouts$ = function() {
  return this.$layouts$
};
goog.$exportProperty$(ComponentDef.prototype, "getLayouts", ComponentDef.prototype.$getLayouts$);
ComponentDef.prototype.$getLocatorDefs$ = function() {
  return this.$locatorDefs$
};
goog.$exportProperty$(ComponentDef.prototype, "getLocatorDefs", ComponentDef.prototype.$getLocatorDefs$);
ComponentDef.prototype.$initSuperDef$ = function(config) {
  if(!config) {
    return null
  }
  var superDef = $A.$componentService$.$createComponentDef$(config);
  if(!superDef) {
    var failingCmp = this.$descriptor$.$getFullName$();
    var superCmp = config["descriptor"] ? config["descriptor"] : config;
    var auraError = new $A.$auraError$("Super component's def (" + superCmp + ") is missing for " + failingCmp);
    auraError.$setComponent$(failingCmp);
    throw auraError;
  }
  return superDef
};
ComponentDef.prototype.$initStyleDefs$ = function() {
  this.$allStyleDefs$ = [];
  this.$allFlavoredStyleDefs$ = [];
  var s = this.$superDef$;
  if(s) {
    var superStyles = s.$getAllStyleDefs$();
    if(superStyles) {
      this.$allStyleDefs$ = this.$allStyleDefs$.concat(superStyles)
    }
    var superFlavoredStyles = s.$getAllFlavoredStyleDefs$();
    if(superFlavoredStyles) {
      this.$allFlavoredStyleDefs$ = this.$allFlavoredStyleDefs$.concat(superFlavoredStyles)
    }
  }
  if(this.$styleDef$) {
    this.$allStyleDefs$.push(this.$styleDef$)
  }
  if(this.$flavoredStyleDef$) {
    this.$allFlavoredStyleDefs$.push(this.$flavoredStyleDef$)
  }
};
ComponentDef.prototype.$getMinVersion$ = function() {
  return this.$minVersion$
};
ComponentDef.prototype.$getApiVersion$ = function() {
  if(!$A.$clientService$.$isInternalNamespace$(this.$descriptor$.$getNamespace$())) {
    var requiredVersionDef = this.$getRequiredVersionDefs$().$getDef$("aura");
    return requiredVersionDef ? requiredVersionDef.$getVersion$() : null
  }
};
Aura.$Component$.$ComponentDef$ = ComponentDef;
function InteropComponentDef(config) {
  this.$interop$ = true;
  this.$access$ = config.$access$;
  this.$descriptor$ = new DefDescriptor(config.$descriptor$);
  this.$dependencies$ = config.$dependencies$;
  this.definition = config.definition;
  this.$moduleName$ = config.$moduleName$;
  this.$interopClass$ = config.$interopClass$;
  this.$elementName$ = this.$moduleName$;
  this.$interopClassName$ = this.$descriptor$.$getNamespace$() + "$" + this.$descriptor$.getName();
  this.$minVersion$ = config.$minVersion$;
  if(typeof this.$interopClass$ === "function") {
    this.$interopDef$ = $A.$componentService$.$moduleEngine$["getComponentDef"](this.$interopClass$);
    this.$setupPropAttrMap$(this.$interopClass$["interopMap"], this.$interopDef$["props"])
  }
}
goog.$exportSymbol$("InteropComponentDef", InteropComponentDef);
InteropComponentDef.prototype.$setupPropAttrMap$ = function(interopMap, props) {
  var propNames = Object.keys(props);
  var interopPropOverride = interopMap && $A["util"].$isObject$(interopMap["props"]) ? interopMap["props"] : {};
  var propName;
  var attrName;
  this.$attrNameToPropMap$ = {};
  this.$propNameToAttrMap$ = {};
  for(var i = 0;i < propNames.length;i++) {
    propName = propNames[i];
    attrName = interopPropOverride[propName] || propName;
    this.$attrNameToPropMap$[attrName] = propName;
    this.$propNameToAttrMap$[propName] = attrName
  }
};
InteropComponentDef.prototype.$hasInit$ = function() {
};
InteropComponentDef.prototype.$getDescriptor$ = function() {
  return this.$descriptor$
};
goog.$exportProperty$(InteropComponentDef.prototype, "getDescriptor", InteropComponentDef.prototype.$getDescriptor$);
InteropComponentDef.prototype.$isAbstract$ = function() {
  return this.$isAbs$
};
goog.$exportProperty$(InteropComponentDef.prototype, "isAbstract", InteropComponentDef.prototype.$isAbstract$);
InteropComponentDef.prototype.$getSuperDef$ = function() {
  return this.$superDef$
};
goog.$exportProperty$(InteropComponentDef.prototype, "getSuperDef", InteropComponentDef.prototype.$getSuperDef$);
InteropComponentDef.prototype.$getHelper$ = function() {
  var name = this.$getDescriptor$().$getQualifiedName$();
  var componentClass = $A.$componentService$.$getComponentClass$(name);
  return componentClass ? componentClass.prototype["helper"] : undefined
};
goog.$exportProperty$(InteropComponentDef.prototype, "getHelper", InteropComponentDef.prototype.$getHelper$);
InteropComponentDef.prototype.$getRequiredVersionDefs$ = function() {
  return this.$requiredVersionDefs$
};
InteropComponentDef.prototype.$getMinVersion$ = function() {
  return this.$minVersion$
};
InteropComponentDef.prototype.$getApiVersion$ = function() {
  return undefined
};
InteropComponentDef.prototype.$hasRemoteDependencies$ = function() {
  return this.$hasRemoteDeps$
};
InteropComponentDef.prototype.$getAllStyleDefs$ = function() {
  return this.$allStyleDefs$
};
InteropComponentDef.prototype.$getAllFlavoredStyleDefs$ = function() {
  return this.$allFlavoredStyleDefs$
};
InteropComponentDef.prototype.$getStyleClassName$ = function() {
  var className = this.$styleClassName$;
  if(!className) {
    className = "";
    var styleDefs = this.$getAllStyleDefs$();
    if(styleDefs) {
      var styleDefLen = styleDefs.length;
      for(var t = 0;t < styleDefLen;t++) {
        var styleDef = styleDefs[t];
        className = className + styleDef.$getClassName$() + " ";
        if(!this.$isCSSPreloaded$) {
          styleDef.apply()
        }
      }
    }
    this.$styleClassName$ = className;
    if(!this.$isCSSPreloaded$) {
      var flavoredStyleDefs = this.$getAllFlavoredStyleDefs$();
      if(flavoredStyleDefs) {
        var i = 0;
        for(var len = flavoredStyleDefs.length;i < len;i++) {
          flavoredStyleDefs[i].apply()
        }
      }
    }
  }
  return className
};
goog.$exportProperty$(InteropComponentDef.prototype, "getStyleClassName", InteropComponentDef.prototype.$getStyleClassName$);
InteropComponentDef.prototype.$getStyleDef$ = function() {
  return this.$styleDef$
};
goog.$exportProperty$(InteropComponentDef.prototype, "getStyleDef", InteropComponentDef.prototype.$getStyleDef$);
InteropComponentDef.prototype.$getDefaultFlavor$ = function() {
  if($A["util"].$isUndefined$(this.$flavorOverride$)) {
    var override = null;
    var appDesc = $A.getContext().$getApp$();
    if(appDesc) {
      var appDef = $A.$componentService$.$getDef$(appDesc, true);
      if(appDef) {
        var defaults = appDef.$getFlavorOverrides$();
        if(defaults) {
          override = defaults.$getFlavor$(this.$descriptor$);
          if(override === "{!remove}") {
            override = ""
          }
        }
      }
    }
    this.$flavorOverride$ = $A["util"].$isUndefinedOrNull$(override) ? null : override
  }
  return!$A["util"].$isUndefinedOrNull$(this.$flavorOverride$) ? this.$flavorOverride$ : this.$getExplicitDefaultFlavor$()
};
goog.$exportProperty$(InteropComponentDef.prototype, "getDefaultFlavor", InteropComponentDef.prototype.$getDefaultFlavor$);
InteropComponentDef.prototype.$getExplicitDefaultFlavor$ = function() {
  if(!$A["util"].$isUndefinedOrNull$(this.$defaultFlavor$)) {
    return this.$defaultFlavor$
  }
  if(this.$superDef$) {
    return this.$superDef$.$getExplicitDefaultFlavor$()
  }
  return null
};
InteropComponentDef.prototype.$hasFlavorableChild$ = function() {
  return!!this.$flavorableChild$
};
goog.$exportProperty$(InteropComponentDef.prototype, "hasFlavorableChild", InteropComponentDef.prototype.$hasFlavorableChild$);
InteropComponentDef.prototype.$getFlavorOverrides$ = function() {
  return this.$flavorOverrides$
};
goog.$exportProperty$(InteropComponentDef.prototype, "getFlavorOverrides", InteropComponentDef.prototype.$getFlavorOverrides$);
InteropComponentDef.prototype.$isDynamicallyFlavorable$ = function() {
  return this.$dynamicallyFlavorable$ || this.$superDef$ && this.$superDef$.$isDynamicallyFlavorable$()
};
InteropComponentDef.prototype.$getDynamicallyFlavorable$ = function() {
  var ret = [];
  if(this.$dynamicallyFlavorable$) {
    ret.push(this)
  }
  if(this.$superDef$) {
    ret = ret.concat(this.$superDef$.$getDynamicallyFlavorable$())
  }
  return ret
};
InteropComponentDef.prototype.$getAttributeDefs$ = function() {
  return this.$attributeDefs$
};
goog.$exportProperty$(InteropComponentDef.prototype, "getAttributeDefs", InteropComponentDef.prototype.$getAttributeDefs$);
InteropComponentDef.prototype.$getFacets$ = function() {
  return this.$facets$
};
goog.$exportProperty$(InteropComponentDef.prototype, "getFacets", InteropComponentDef.prototype.$getFacets$);
InteropComponentDef.prototype.$getFacet$ = function(facetName) {
  if(!this.$facetMap$) {
    var facetMap = {};
    if(this.$facets$) {
      var facets = this.$facets$;
      var c = 0;
      for(var length = facets.length;c < length;c++) {
        facetMap[facets[c]["descriptor"]] = facets[c]
      }
    }
    this.$facetMap$ = facetMap
  }
  return this.$facetMap$.hasOwnProperty(facetName) ? this.$facetMap$[facetName] : undefined
};
InteropComponentDef.prototype.$getControllerDef$ = function() {
  return this.$controllerDef$
};
goog.$exportProperty$(InteropComponentDef.prototype, "getControllerDef", InteropComponentDef.prototype.$getControllerDef$);
InteropComponentDef.prototype.$getModelDef$ = function() {
  return this.$modelDef$
};
goog.$exportProperty$(InteropComponentDef.prototype, "getModelDef", InteropComponentDef.prototype.$getModelDef$);
ComponentDef.$valueEvents$ = {"change":"aura:valueChange", "destroy":"aura:valueDestroy", "init":"aura:valueInit", "render":"aura:valueRender"};
InteropComponentDef.prototype.$getEventDef$ = function(name, includeValueEvents) {
  var ret = this.$registerEventDefs$[name];
  if(!ret && includeValueEvents) {
    if(ComponentDef.$valueEvents$.hasOwnProperty(name)) {
      name = ComponentDef.$valueEvents$[name]
    }
    ret = $A.get("e").$getDef$(name)
  }
  return ret
};
goog.$exportProperty$(InteropComponentDef.prototype, "getEventDef", InteropComponentDef.prototype.$getEventDef$);
InteropComponentDef.prototype.$getEventNameByDescriptor$ = function(descriptor) {
  for(var name in this.$registerEventDefs$) {
    if(this.$registerEventDefs$[name] && this.$registerEventDefs$[name].$descriptor$ && this.$registerEventDefs$[name].$descriptor$.$qualifiedName$ === descriptor) {
      return name
    }
  }
  return null
};
InteropComponentDef.prototype.$getAllEvents$ = function() {
  return this.$allEvents$
};
goog.$exportProperty$(InteropComponentDef.prototype, "getAllEvents", InteropComponentDef.prototype.$getAllEvents$);
InteropComponentDef.prototype.$getAppHandlerDefs$ = function() {
  return this.$appHandlerDefs$
};
goog.$exportProperty$(InteropComponentDef.prototype, "getAppHandlerDefs", InteropComponentDef.prototype.$getAppHandlerDefs$);
InteropComponentDef.prototype.$getCmpHandlerDefs$ = function() {
  return this.$cmpHandlerDefs$
};
goog.$exportProperty$(InteropComponentDef.prototype, "getCmpHandlerDefs", InteropComponentDef.prototype.$getCmpHandlerDefs$);
InteropComponentDef.prototype.$getValueHandlerDefs$ = function() {
  return this.$valueHandlerDefs$
};
InteropComponentDef.prototype.toString = function() {
  return this.$getDescriptor$().$getQualifiedName$()
};
goog.$exportProperty$(InteropComponentDef.prototype, "toString", InteropComponentDef.prototype.toString);
InteropComponentDef.prototype.$isInstanceOf$ = function(name) {
  var thisName = this.$descriptor$.$getNamespace$() + ":" + this.$descriptor$.getName();
  return thisName === name
};
goog.$exportProperty$(InteropComponentDef.prototype, "isInstanceOf", InteropComponentDef.prototype.$isInstanceOf$);
InteropComponentDef.prototype.$implementsDirectly$ = function(type) {
  return!$A["util"].$isUndefined$(this.$interfaces$[type])
};
InteropComponentDef.prototype.$getLocationChangeEvent$ = function() {
  var evt = this.$locationChangeEventDef$;
  if(evt) {
    return evt.$getDescriptor$().$getQualifiedName$()
  }
  return"markup://aura:locationChange"
};
goog.$exportProperty$(InteropComponentDef.prototype, "getLocationChangeEvent", InteropComponentDef.prototype.$getLocationChangeEvent$);
InteropComponentDef.prototype.$getLayouts$ = function() {
  return this.$layouts$
};
goog.$exportProperty$(InteropComponentDef.prototype, "getLayouts", InteropComponentDef.prototype.$getLayouts$);
InteropComponentDef.prototype.$getLocatorDefs$ = function() {
  return this.$locatorDefs$
};
goog.$exportProperty$(InteropComponentDef.prototype, "getLocatorDefs", InteropComponentDef.prototype.$getLocatorDefs$);
InteropComponentDef.prototype.$initSuperDef$ = function(config) {
  if(config) {
    var sDef = $A.$componentService$.$createComponentDef$(config);
    $A.assert(sDef, "Super def undefined for " + this.$descriptor$ + " value \x3d " + config["descriptor"]);
    return sDef
  }
  return null
};
InteropComponentDef.prototype.$initStyleDefs$ = function() {
  this.$allStyleDefs$ = [];
  this.$allFlavoredStyleDefs$ = [];
  var s = this.$superDef$;
  if(s) {
    var superStyles = s.$getAllStyleDefs$();
    if(superStyles) {
      this.$allStyleDefs$ = this.$allStyleDefs$.concat(superStyles)
    }
    var superFlavoredStyles = s.$getAllFlavoredStyleDefs$();
    if(superFlavoredStyles) {
      this.$allFlavoredStyleDefs$ = this.$allFlavoredStyleDefs$.concat(superFlavoredStyles)
    }
  }
  if(this.$styleDef$) {
    this.$allStyleDefs$.push(this.$styleDef$)
  }
  if(this.$flavoredStyleDef$) {
    this.$allFlavoredStyleDefs$.push(this.$flavoredStyleDef$)
  }
};
Aura.$Component$.$InteropComponentDef$ = InteropComponentDef;
function ActionValueProvider(component, controllerDef) {
  this.$actions$;
  this.$component$ = component;
  this.$controllerDef$ = controllerDef
}
ActionValueProvider.prototype.get = function(key) {
  if(!this.$actions$) {
    this.$actions$ = {}
  }
  var actionDef = this.$actions$[key];
  if(!actionDef) {
    actionDef = this.$component$["controller"] && this.$component$["controller"][key];
    if(actionDef) {
      var clientDef = {};
      clientDef[Json.$ApplicationKey$.$DESCRIPTOR$] = this.$component$.$getType$() + "$controller$" + key;
      clientDef[Json.$ApplicationKey$["NAME"]] = key;
      clientDef[Json.$ApplicationKey$.$ACTIONTYPE$] = "CLIENT";
      clientDef[Json.$ApplicationKey$.$CODE$] = actionDef;
      actionDef = new ActionDef(clientDef);
      if(this.$controllerDef$ && this.$controllerDef$.$hasActionDef$(key)) {
        var message = "Component '" + this.$component$.$getType$() + "' has server and client action name conflicts: " + key;
        $A.$warning$(message)
      }
    }else {
      actionDef = this.$controllerDef$ && this.$controllerDef$.$getActionDef$(key)
    }
    if(!actionDef) {
      var auraError = new $A.$auraError$("Unknown controller action '" + key + "'");
      auraError.$setComponent$(this.$component$.$getDef$().$getDescriptor$().toString());
      auraError["componentStack"] = $A["util"].$getComponentHierarchy$(this.$component$);
      throw auraError;
    }
    this.$actions$[key] = actionDef
  }
  return actionDef.$newInstance$(this.$component$)
};
Aura.$Component$.$ActionValueProvider$ = ActionValueProvider;
function EventValueProvider(component) {
  this.$events$ = {};
  this.$component$ = component.$globalId$
}
EventValueProvider.prototype.get = function(key) {
  return $A.$getComponent$(this.$component$).$getEvent$(key)
};
Aura.$Component$.$EventValueProvider$ = EventValueProvider;
function StyleValueProvider(component) {
  this.$component$ = component
}
StyleValueProvider.prototype.get = function(key) {
  if(key === "name") {
    var styleDef = this.$component$.$getDef$().$getStyleDef$();
    return!$A["util"].$isUndefinedOrNull$(styleDef) ? styleDef.$getClassName$() : null
  }
};
Aura.$Component$.$StyleValueProvider$ = StyleValueProvider;
function GlobalValueProviders(gvp, initCallback) {
  this.$valueProviders$ = {"$Browser":new Aura.$Provider$.$ObjectValueProvider$(gvp["$Browser"]), "$Label":new Aura.$Provider$.$LabelValueProvider$(gvp["$Label"]), "$Locale":new Aura.$Provider$.$ObjectValueProvider$(gvp["$Locale"]), "$Global":new Aura.$Provider$.$ContextValueProvider$(gvp["$Global"])};
  for(var type in gvp) {
    if(["$Browser", "$Label", "$Locale", "$Global"].indexOf(type) >= 0) {
      continue
    }
    $A.assert(this.$valueProviders$[type] == null, "$A.globalValueProviders.ctor(): '" + type + "' has already been registered.");
    var valueProvider = gvp[type];
    valueProvider.$getValues$ = valueProvider.$getValues$ || valueProvider["getValues"];
    valueProvider.get = valueProvider.get || valueProvider["get"];
    valueProvider.$merge$ = valueProvider.$merge$ || valueProvider["merge"];
    this.$valueProviders$[type] = valueProvider
  }
  var that = this;
  this.$loadFromStorage$(function() {
    that.load(gvp);
    if(initCallback) {
      initCallback(that)
    }
  })
}
goog.$exportSymbol$("GlobalValueProviders", GlobalValueProviders);
GlobalValueProviders.prototype.$STORAGE_KEY$ = "globalValueProviders";
GlobalValueProviders.prototype.$MUTEX_KEY$ = "GlobalValueProviders";
GlobalValueProviders.prototype.$mutexUnlock$ = undefined;
GlobalValueProviders.prototype.$persistenceQueued$ = false;
GlobalValueProviders.prototype.$LOADED_FROM_PERSISTENT_STORAGE$ = false;
GlobalValueProviders.prototype.$ABSENT_GVP_VALUES_COOKIE$ = "auraGvpValuesAbsence";
GlobalValueProviders.prototype.$merge$ = function(gvps, doNotPersist) {
  if(!gvps) {
    return
  }
  var valueProvider;
  var i;
  var type;
  var newGvp;
  var values;
  for(i = 0;i < gvps.length;i++) {
    try {
      newGvp = gvps[i];
      type = newGvp["type"];
      if(!this.$valueProviders$[type]) {
        this.$valueProviders$[type] = new Aura.$Provider$.$ObjectValueProvider$
      }
      valueProvider = this.$valueProviders$[type];
      if(valueProvider.$merge$) {
        valueProvider.$merge$(newGvp["values"])
      }else {
        $A["util"].$applyNotFromPrototype$(valueProvider, newGvp["values"], true)
      }
      $A.$expressionService$.$updateGlobalReferences$(type, newGvp["values"])
    }catch(e$$0) {
      var auraError = new $A.$auraError$("Merging GVP '" + type + "' failed", e$$0);
      auraError.$setComponent$(type);
      throw auraError;
    }
  }
  if(doNotPersist) {
    return
  }
  var storage = this.$getStorage$();
  if(!storage) {
    return
  }
  if(this.$persistenceQueued$) {
    return
  }
  this.$persistenceQueued$ = true;
  var that = this;
  $A["util"].$Mutex$.$lock$(that.$MUTEX_KEY$, function(unlock) {
    that.$mutexUnlock$ = unlock;
    var errors = [];
    storage.get(that.$STORAGE_KEY$, true).$then$(undefined, function(e) {
      var message = "GlobalValueProviders.merge(): failed to load GVP values from storage, will overwrite storage with in-memory values.";
      $A.$warning$(message, e);
      errors.push({"action":"load", "message":message, "error":e})
    }).$then$(function(value) {
      that.$persistenceQueued$ = false;
      var toStore = [];
      for(type in that.$valueProviders$) {
        if(that.$valueProviders$.hasOwnProperty(type)) {
          valueProvider = that.$valueProviders$[type];
          var storable = typeof valueProvider["isStorable"] === "function" ? valueProvider["isStorable"]() : true;
          if(storable) {
            values = valueProvider.$getStorableValues$ ? valueProvider.$getStorableValues$() : valueProvider.$getValues$ ? valueProvider.$getValues$() : valueProvider;
            toStore.push({"type":type, "values":values})
          }
        }
      }
      if(value) {
        try {
          var j;
          var map = {};
          for(j in value) {
            map[value[j]["type"]] = value[j]["values"]
          }
          for(j in toStore) {
            type = toStore[j]["type"];
            if(!map[type]) {
              map[type] = {};
              value.push({"type":type, "values":map[type]})
            }
            $A["util"].$applyNotFromPrototype$(map[type], toStore[j]["values"], true, true)
          }
          toStore = value
        }catch(e) {
          var message = "GlobalValueProviders.merge(): merging from storage failed, overwriting with in-memory values.";
          $A.$warning$(message, e);
          errors.push({"action":"merge", "message":message, "error":e})
        }
      }
      return storage.set(that.$STORAGE_KEY$, toStore)
    }).$then$(function() {
      if(that.$getAbsentGvpValuesCookie$()) {
        that.$clearAbsentGvpValuesCookie$()
      }
      if(errors.length > 0) {
        var message = "GlobalValueProviders.merge(): GVP values in storage have been overwritten with in-memory values.";
        $A.$warning$(message);
        $A.$metricsService$.transaction("aura", "performance:gvpStorageFailure", {"context":{"attributes":{"message":message, "errors":JSON.stringify(errors)}}})
      }
      that.$mutexUnlock$()
    }, function(e) {
      that.$setAbsentGvpValuesCookie$();
      var message = "GlobalValueProviders.merge(): failed to store merged GVP values to storage.";
      $A.$warning$(message, e);
      var labels = [];
      for(i = 0;i < gvps.length;i++) {
        if(gvps[i]["type"] === "$Label") {
          labels = Object.keys(gvps[i]["values"]);
          break
        }
      }
      errors.push({"action":"save", "message":message, "error":e, "dropped-labels":labels});
      $A.$metricsService$.transaction("aura", "performance:gvpStorageFailure", {"context":{"attributes":{"message":message, "errors":JSON.stringify(errors)}}});
      that.$mutexUnlock$()
    })
  })
};
GlobalValueProviders.prototype.$getStorage$ = function() {
  var storage = $A.$storageService$.$getStorage$($A.$clientService$.$getActionStorageName$());
  return storage && storage.$isPersistent$() ? storage : undefined
};
GlobalValueProviders.prototype.$loadFromStorage$ = function(callback) {
  var storage = this.$getStorage$();
  if(!storage || this.$getAbsentGvpValuesCookie$()) {
    callback();
    return
  }
  var that = this;
  storage.get(this.$STORAGE_KEY$, true).$then$(function(value) {
    $A.$run$(function() {
      if(value) {
        that.$merge$(value, true);
        that.$LOADED_FROM_PERSISTENT_STORAGE$ = true
      }
      callback()
    })
  }).$then$(undefined, function() {
    $A.$run$(function() {
      callback()
    })
  })
};
GlobalValueProviders.prototype.load = function(gvp) {
  if(gvp) {
    for(var i = 0;i < gvp.length;i++) {
      this.$merge$(gvp[i])
    }
  }
};
GlobalValueProviders.prototype.$addValueProvider$ = function(type, valueProvider) {
  if(!this.$valueProviders$.hasOwnProperty(type)) {
    valueProvider.$getValues$ = valueProvider.$getValues$ || valueProvider["getValues"];
    valueProvider.get = valueProvider.get || valueProvider["get"];
    valueProvider.$merge$ = valueProvider.$merge$ || valueProvider["merge"];
    this.$valueProviders$[type] = valueProvider
  }
};
GlobalValueProviders.prototype.$getValueProvider$ = function(type) {
  return this.$valueProviders$[type]
};
GlobalValueProviders.prototype.get = function(expression, callback) {
  expression = $A.$expressionService$.normalize(expression).split(".");
  var type = expression.shift();
  var valueProvider = this.$valueProviders$[type];
  $A.assert(valueProvider, "Unknown value provider: '" + type + "'.");
  return valueProvider.get ? valueProvider.get(expression, callback) : $A.$expressionService$.$resolve$(expression, valueProvider)
};
goog.$exportProperty$(GlobalValueProviders.prototype, "get", GlobalValueProviders.prototype.get);
GlobalValueProviders.prototype.$getAbsentGvpValuesCookie$ = function() {
  var cookie = $A["util"].$getCookie$(this.$ABSENT_GVP_VALUES_COOKIE$);
  return cookie === "true"
};
GlobalValueProviders.prototype.$setAbsentGvpValuesCookie$ = function() {
  var duration = 1E3 * 60 * 60 * 24 * 7;
  $A["util"]["setCookie"](this.$ABSENT_GVP_VALUES_COOKIE$, "true", duration)
};
GlobalValueProviders.prototype.$clearAbsentGvpValuesCookie$ = function() {
  $A["util"].$clearCookie$(this.$ABSENT_GVP_VALUES_COOKIE$)
};
Aura.$Provider$.$GlobalValueProviders$ = GlobalValueProviders;
function LabelQueue() {
  this.reset()
}
LabelQueue.prototype.$getComponents$ = function() {
  return this.$components$
};
LabelQueue.prototype.$addComponent$ = function(component) {
  this.$components$.push(component)
};
LabelQueue.prototype.$getReturnValues$ = function() {
  return this.$returnValues$
};
LabelQueue.prototype.$addReturnValue$ = function(value) {
  this.$returnValues$.push(value)
};
LabelQueue.prototype.$getCallbacks$ = function() {
  return this.$callbacks$
};
LabelQueue.prototype.$addCallback$ = function(callback) {
  this.$callbacks$.push(callback)
};
LabelQueue.prototype.$setRequested$ = function() {
  this.$requested$ = true
};
LabelQueue.prototype.$isRequested$ = function() {
  return this.$requested$
};
LabelQueue.prototype.reset = function() {
  this.$components$ = [];
  this.$callbacks$ = [];
  this.$returnValues$ = [];
  this.$requested$ = false
};
Aura.$Provider$.$LabelQueue$ = LabelQueue;
function LabelValueProvider(values) {
  this.$values$ = values || {};
  this.$queue$ = {}
}
LabelValueProvider.prototype.$requestServerLabel$ = function(section, name, callback) {
  var lvp = this;
  var queue = this.$getQueue$(section, name);
  var placeholder = $A.getContext().$getMode$() === "PROD" ? "" : "[" + section + "." + name + "]";
  if($A["util"].$isFunction$(callback)) {
    queue.$addCallback$(callback)
  }
  if(!queue.$isRequested$()) {
    var action = $A.get("c.aura://LabelController.getLabel");
    action.$setParams$({"name":name, "section":section});
    action.$setCallback$(this, function(a) {
      var returnValue = placeholder;
      if(a.$getState$() === "SUCCESS") {
        returnValue = a.$getReturnValue$();
        if(!this.$values$[section]) {
          this.$values$[section] = {}
        }
        this.$values$[section][name] = returnValue;
        $A.$expressionService$.$updateGlobalReference$(["$Label", section, name].join("."), null, returnValue)
      }else {
        $A.log("Error getting label: " + section + "." + name)
      }
      var callbacks = queue.$getCallbacks$();
      for(var i = 0;i < callbacks.length;i++) {
        callbacks[i].call(null, returnValue)
      }
      lvp.$removeQueue$(section, name)
    });
    $A.$enqueueAction$(action);
    $A.$run$(function() {
    }, "LabelValueProvider.requestServerLabel");
    queue.$setRequested$()
  }
  return placeholder
};
LabelValueProvider.prototype.$getQueue$ = function(section, name) {
  var exp = this.$getQueueKey$(section, name);
  if(!this.$queue$[exp]) {
    this.$queue$[exp] = new Aura.$Provider$.$LabelQueue$
  }
  return this.$queue$[exp]
};
LabelValueProvider.prototype.$removeQueue$ = function(section, name) {
  var exp = this.$getQueueKey$(section, name);
  delete this.$queue$[exp]
};
LabelValueProvider.prototype.$getQueueKey$ = function(section, name) {
  return section + "." + name
};
LabelValueProvider.prototype.$getValues$ = function() {
  return this.$values$
};
LabelValueProvider.prototype.$merge$ = function(values) {
  $A["util"].$applyNotFromPrototype$(this.$values$, values, true, true)
};
LabelValueProvider.prototype.get = function(expression, callback) {
  var value;
  var path = expression.split(".");
  if(path.length === 2) {
    var section = path[0];
    var name = path[1];
    value = this.$values$[section] && this.$values$[section][name];
    if(value === undefined) {
      value = this.$requestServerLabel$(section, name, callback)
    }else {
      if($A["util"].$isFunction$(callback)) {
        callback.call(null, value)
      }
    }
  }else {
    $A.log("$Label requests must have both section and name")
  }
  return value
};
Aura.$Provider$.$LabelValueProvider$ = LabelValueProvider;
function ObjectValueProvider(values) {
  this.$values$ = values || {}
}
ObjectValueProvider.prototype.$getValues$ = function() {
  return this.$values$
};
ObjectValueProvider.prototype.$merge$ = function(values) {
  $A["util"].$applyNotFromPrototype$(this.$values$, values, true, true)
};
ObjectValueProvider.prototype.get = function(expression, callback) {
  var value = this.$values$[expression] || $A.$expressionService$.$resolve$(expression, this.$values$);
  if($A["util"].$isFunction$(callback)) {
    callback(value)
  }
  return value
};
Aura.$Provider$.$ObjectValueProvider$ = ObjectValueProvider;
function ContextValueProvider(values) {
  this.$values$ = values || {}
}
ContextValueProvider.prototype.$getValues$ = function() {
  var result = {};
  for(var key in this.$values$) {
    if(this.$values$.hasOwnProperty(key)) {
      result[key] = this.$extract$(this.$values$[key])
    }
  }
  return result
};
ContextValueProvider.prototype.$getStorableValues$ = function() {
  return this.$values$
};
ContextValueProvider.prototype.$serializeForServer$ = function() {
  var serverValues = {};
  for(var key in this.$values$) {
    if(this.$values$.hasOwnProperty(key)) {
      var current = this.$values$[key];
      if(current.hasOwnProperty("value")) {
        serverValues[key] = current["value"]
      }
    }
  }
  return serverValues
};
ContextValueProvider.prototype.$merge$ = function(values) {
  for(var key in values) {
    if(values.hasOwnProperty(key)) {
      var value = values[key];
      if(!value || !(value.hasOwnProperty("value") || value.hasOwnProperty("defaultValue"))) {
        throw new Error("Invalid merge value at key '" + key + "' with value '" + value + "'");
      }
      if(value.hasOwnProperty("value")) {
        if(!this.$values$.hasOwnProperty(key)) {
          if(value.hasOwnProperty("originalValue")) {
            delete value["originalValue"]
          }
          this.$values$[key] = value
        }else {
          if(value["originalValue"] === this.$values$[key].value) {
            delete value["originalValue"];
            this.$values$[key] = value
          }
        }
      }else {
        delete value["originalValue"];
        this.$values$[key] = value
      }
    }
  }
};
ContextValueProvider.prototype.get = function(key) {
  if(this.$values$.hasOwnProperty(key) === false) {
    throw new Error("Attempting to retrieve an unknown global item '" + key + "'. Global items must be pre-registered and have a default value");
  }
  return this.$extract$(this.$values$[key])
};
ContextValueProvider.prototype.set = function(key, value) {
  $A.assert(key.indexOf(".") === -1, "Unable to set value for key '" + key + "', did you add an extra '.'?");
  if($A["util"].$isExpression$(value)) {
    throw new Error("Unable to set global value '" + key + "' to the expression '" + value + "'. Global items must be constants");
  }
  if(this.$values$.hasOwnProperty(key) === false) {
    throw new Error("Attempting to set an unknown global item '" + key + "'. Global items must be pre-registered and have a default value");
  }
  var gv = this.$values$[key];
  if(gv && gv["writable"]) {
    gv["value"] = value === null ? undefined : value
  }else {
    throw new Error("Attempting to set a read only global item '" + key + "'");
  }
  return value
};
ContextValueProvider.prototype.$extract$ = function(gv) {
  return gv && (gv.hasOwnProperty("value") ? gv["value"] : gv["defaultValue"])
};
Aura.$Provider$.$ContextValueProvider$ = ContextValueProvider;
function LibraryIncludeRegistry() {
  this.$libExporter$ = {};
  this.$exporter$ = {};
  this.$dependencies$ = {};
  this.$dependenciesInstances$ = {};
  this.$instance$ = {};
  this.$dependencyQueue$ = [];
  this.$dependencyQueueChanged$ = false
}
LibraryIncludeRegistry.prototype.$hasLibraryInclude$ = function(descriptor) {
  return descriptor in this.$exporter$ || descriptor in this.$instance$
};
LibraryIncludeRegistry.prototype.$addLibraryInclude$ = function(descriptor, dependencies, exporter) {
  $A.assert($A["util"].$isString$(descriptor), "Include descriptor is invalid: " + descriptor);
  $A.assert($A["util"].$isFunction$(exporter), "Include exporter is not a function: " + descriptor);
  if(!this.$hasLibraryInclude$(descriptor)) {
    this.$exporter$[descriptor] = exporter;
    this.$dependencies$[descriptor] = dependencies;
    this.$dependenciesInstances$[descriptor] = []
  }
};
LibraryIncludeRegistry.prototype.$addLibraryExporter$ = function(descriptor, exporter) {
  this.$libExporter$[descriptor] = exporter
};
LibraryIncludeRegistry.prototype.$getLibraryInclude$ = function(descriptor) {
  var instance;
  if(descriptor in this.$instance$) {
    instance = this.$instance$[descriptor]
  }else {
    this.$clearDependencyQueue$();
    for(this.$enqueueDependency$(descriptor);this.$hasDependencyQueue$();) {
      var queue = this.$cloneDependencyQueue$();
      for(var i = 0;i < queue.length;i++) {
        var dependency = queue[i];
        instance = this.$buildLibraryInclude$(dependency)
      }
      if(!this.$hasDependencyQueueChanged$()) {
        throw new Error("Cannot solve library include dependencies: " + descriptor);
      }
    }
  }
  return instance
};
goog.$exportSymbol$("LibraryIncludeRegistry.prototype.getLibraryInclude", LibraryIncludeRegistry.prototype.$getLibraryInclude$);
LibraryIncludeRegistry.prototype.$hydrateLibrary$ = function(descriptor, exporter) {
  var script = $A.$clientService$.$uncommentExporter$(exporter);
  exporter = $A.$clientService$.$evalExporter$(script, descriptor, "lib");
  if(!exporter) {
    var defDescriptor = new Aura.$System$.$DefDescriptor$(descriptor);
    var includeComponentSource = $A.$clientService$.$isInternalNamespace$(defDescriptor.$getNamespace$());
    var errorMessage = !includeComponentSource ? "Hydrating the component" + descriptor + " failed." : "Hydrating the component" + descriptor + " failed.\n Exporter code: " + script;
    var auraError = new $A.$auraError$(errorMessage, null, $A.severity.$QUIET$);
    auraError.$setComponent$(descriptor);
    throw auraError;
  }
  return exporter()
};
LibraryIncludeRegistry.prototype.$buildLibraryInclude$ = function(descriptor) {
  if(this.$libExporter$[descriptor]) {
    this.$hydrateLibrary$(descriptor, this.$libExporter$[descriptor]);
    delete this.$libExporter$[descriptor]
  }
  var resolved = true;
  var dependencies = this.$dependencies$[descriptor] || [];
  var dependenciesInstances = this.$dependenciesInstances$[descriptor] || [];
  for(var i = 0;i < dependencies.length;i++) {
    if(!dependenciesInstances.hasOwnProperty(i)) {
      var dependency = dependencies[i];
      if(this.$instance$.hasOwnProperty(dependency)) {
        dependenciesInstances[i] = this.$instance$[dependency]
      }else {
        this.$enqueueDependency$(dependency);
        resolved = false
      }
    }
  }
  if(resolved) {
    var exporter = this.$exporter$[descriptor];
    if(!$A["util"].$isFunction$(exporter)) {
      throw new Error("Library include not defined: " + descriptor);
    }
    var instance = exporter.apply({}, dependenciesInstances);
    this.$instance$[descriptor] = instance;
    this.$dequeueDependency$(descriptor);
    delete this.$exporter$[descriptor];
    return instance
  }
};
LibraryIncludeRegistry.prototype.$clearDependencyQueue$ = function() {
  this.$dependencyQueue$ = []
};
LibraryIncludeRegistry.prototype.$enqueueDependency$ = function(descriptor) {
  var index = this.$dependencyQueue$.indexOf(descriptor);
  if(index < 0) {
    this.$dependencyQueue$.unshift(descriptor);
    this.$dependencyQueueChanged$ = true
  }
};
LibraryIncludeRegistry.prototype.$dequeueDependency$ = function(descriptor) {
  var index = this.$dependencyQueue$.indexOf(descriptor);
  if(index >= 0) {
    this.$dependencyQueue$.splice(index, 1);
    this.$dependencyQueueChanged$ = true
  }
};
LibraryIncludeRegistry.prototype.$cloneDependencyQueue$ = function() {
  var queue = this.$dependencyQueue$.slice(0);
  this.$dependencyQueueChanged$ = false;
  return queue
};
LibraryIncludeRegistry.prototype.$hasDependencyQueue$ = function() {
  return this.$dependencyQueue$.length > 0
};
LibraryIncludeRegistry.prototype.$hasDependencyQueueChanged$ = function() {
  return this.$dependencyQueueChanged$
};
Aura.$Library$.$LibraryIncludeRegistry$ = LibraryIncludeRegistry;
function LibraryRegistry() {
  this.$libraries$ = {};
  this.$instance$ = {}
}
LibraryRegistry.prototype.$initLibraries$ = function(libraries) {
  $A.assert($A["util"].$isEmpty$(this.$libraries$), "Library registry already initialized.");
  $A.assert($A["util"].isArray(libraries), "Library registry must be initialized with an array.");
  this.$libraries$ = libraries
};
goog.$exportSymbol$("LibraryRegistry.prototype.initLibraries", LibraryRegistry.prototype.$initLibraries$);
LibraryRegistry.prototype.$hasLibrary$ = function(descriptor) {
  return descriptor in this.$libraries$ || descriptor in this.$instance$
};
LibraryRegistry.prototype.$addLibrary$ = function(descriptor, includes) {
  $A.assert($A["util"].$isString$(descriptor), "Library descriptor is invalid: " + descriptor);
  $A.assert($A["util"].$isObject$(includes), "Library includes must be an array: " + descriptor);
  if(!this.$hasLibrary$(descriptor)) {
    this.$libraries$[descriptor] = includes
  }
};
LibraryRegistry.prototype.$getLibrary$ = function(descriptor) {
  var instance = this.$instance$[descriptor];
  if(!instance) {
    var includes = this.$libraries$[descriptor];
    if(includes) {
      instance = this.$buildLibrary$(includes);
      this.$instance$[descriptor] = instance;
      $A.$componentService$.$addModule$(descriptor, descriptor, [], null, instance)
    }
  }
  return instance
};
LibraryRegistry.prototype.$buildLibrary$ = function(includes) {
  var instance = {};
  for(var key in includes) {
    if(includes.hasOwnProperty(key)) {
      var descriptor = includes[key];
      instance[key] = $A.$componentService$.$getLibraryInclude$(descriptor)
    }
  }
  return instance
};
Aura.$Library$.$LibraryRegistry$ = LibraryRegistry;
function EventDef(config) {
  if(typeof config === "string") {
    this.$descriptor$ = new DefDescriptor(config);
    return
  }
  this.$descriptor$ = new DefDescriptor(config[Json.$ApplicationKey$.$DESCRIPTOR$]);
  var superDef = config[Json.$ApplicationKey$.$SUPERDEF$];
  if(!superDef && EventDef.$KNOWN_SUPER_DEFS$.hasOwnProperty(config[Json.$ApplicationKey$.$TYPE$]) && EventDef.$KNOWN_SUPER_DEFS$[config[Json.$ApplicationKey$.$TYPE$]] !== config[Json.$ApplicationKey$.$DESCRIPTOR$]) {
    superDef = EventDef.$KNOWN_SUPER_DEFS$[config[Json.$ApplicationKey$.$TYPE$]]
  }
  this.$superDef$ = this.$initSuperDef$(superDef);
  this.$attributeDefsConfigs$ = config[Json.$ApplicationKey$.$ATTRIBUTES$];
  this.$attributeDefs$ = undefined;
  this.type = config[Json.$ApplicationKey$.$TYPE$];
  this.$access$ = config[Json.$ApplicationKey$.$ACCESS$]
}
goog.$exportSymbol$("EventDef", EventDef);
EventDef.prototype.$getDescriptor$ = function() {
  return this.$descriptor$
};
goog.$exportProperty$(EventDef.prototype, "getDescriptor", EventDef.prototype.$getDescriptor$);
EventDef.prototype.$getEventType$ = function() {
  return this.type
};
goog.$exportProperty$(EventDef.prototype, "getEventType", EventDef.prototype.$getEventType$);
EventDef.prototype.$getAttributeDefs$ = function() {
  if(this.$attributeDefs$ === undefined) {
    var definitions = [];
    for(var key in this.$attributeDefsConfigs$) {
      definitions.push(this.$attributeDefsConfigs$[key])
    }
    this.$attributeDefs$ = new AttributeDefSet(definitions, this.$getDescriptor$().$getNamespace$())
  }
  return this.$attributeDefs$
};
goog.$exportProperty$(EventDef.prototype, "getAttributeDefs", EventDef.prototype.$getAttributeDefs$);
EventDef.prototype.$getSuperDef$ = function() {
  return this.$superDef$
};
goog.$exportProperty$(EventDef.prototype, "getSuperDef", EventDef.prototype.$getSuperDef$);
EventDef.prototype.$initSuperDef$ = function(superDef) {
  if(superDef) {
    return $A.$eventService$.$createEventDef$(superDef)
  }else {
    return null
  }
};
EventDef.$KNOWN_SUPER_DEFS$ = {"APPLICATION":"markup://aura:applicationEvent", "COMPONENT":"markup://aura:componentEvent", "VALUE":"markup://aura:valueEvent"};
Aura.$Event$.$EventDef$ = EventDef;
Aura.$Event$.$Event$ = function(config) {
  this.source = config["component"] || $A.$clientService$.$currentAccess$ || $A.$getRoot$();
  this.$sourceEvent$ = null;
  this.$eventDef$ = config["eventDef"];
  this.$eventDispatcher$ = config["eventDispatcher"];
  this.$eventName$ = config["name"];
  this.$params$ = {};
  this.$fired$ = false;
  this.$eventStopPropagation$ = false;
  this.defaultPrevented = false;
  this.paused = false;
  this.$componentEvent$ = false;
  this.$phase$ = undefined;
  this.$eventHandlerIterator$ = null;
  $A.$lockerService$.$trust$(this.source, this)
};
goog.$exportSymbol$("Aura.Event.Event", Aura.$Event$.$Event$);
Aura.$Event$.$Event$.prototype.$getSource$ = function() {
  return this.source
};
goog.$exportProperty$(Aura.$Event$.$Event$.prototype, "getSource", Aura.$Event$.$Event$.prototype.$getSource$);
Aura.$Event$.$Event$.prototype.$getSourceEvent$ = function() {
  return this.$sourceEvent$
};
goog.$exportProperty$(Aura.$Event$.$Event$.prototype, "getSourceEvent", Aura.$Event$.$Event$.prototype.$getSourceEvent$);
Aura.$Event$.$Event$.prototype.$getDef$ = function() {
  return this.$eventDef$
};
goog.$exportProperty$(Aura.$Event$.$Event$.prototype, "getDef", Aura.$Event$.$Event$.prototype.$getDef$);
Aura.$Event$.$Event$.prototype.$getPhase$ = function() {
  return this.$phase$
};
goog.$exportProperty$(Aura.$Event$.$Event$.prototype, "getPhase", Aura.$Event$.$Event$.prototype.$getPhase$);
Aura.$Event$.$Event$.prototype.stopPropagation = function() {
  var eventExecutionType = this.$getEventExecutionType$();
  $A.assert(eventExecutionType !== "COMPONENT" || eventExecutionType !== "APPLICATION" || this.$getPhase$() !== "default", "stopPropagation() is not supported in the 'default' phase");
  this.$eventStopPropagation$ = true
};
goog.$exportProperty$(Aura.$Event$.$Event$.prototype, "stopPropagation", Aura.$Event$.$Event$.prototype.stopPropagation);
Aura.$Event$.$Event$.prototype.preventDefault = function() {
  $A.assert(this.$getPhase$() !== "default", "preventDefault() is not supported in the 'default' phase");
  this.defaultPrevented = true
};
goog.$exportProperty$(Aura.$Event$.$Event$.prototype, "preventDefault", Aura.$Event$.$Event$.prototype.preventDefault);
Aura.$Event$.$Event$.prototype.pause = function() {
  $A.assert(this.$getPhase$() !== "default", "pause() is not supported in the 'default' phase");
  if(!this.paused) {
    this.paused = true
  }
  return this
};
goog.$exportProperty$(Aura.$Event$.$Event$.prototype, "pause", Aura.$Event$.$Event$.prototype.pause);
Aura.$Event$.$Event$.prototype.$resume$ = function() {
  $A.assert(this.$getPhase$() !== "default", "resume() is not supported in the 'default' phase");
  if(this.paused) {
    this.paused = false;
    this.$executeHandlers$()
  }
};
goog.$exportProperty$(Aura.$Event$.$Event$.prototype, "resume", Aura.$Event$.$Event$.prototype.$resume$);
Aura.$Event$.$Event$.prototype.$setComponentEvent$ = function() {
  this.$componentEvent$ = true;
  return this
};
goog.$exportProperty$(Aura.$Event$.$Event$.prototype, "setComponentEvent", Aura.$Event$.$Event$.prototype.$setComponentEvent$);
Aura.$Event$.$Event$.prototype.getName = function() {
  return this.$eventName$
};
goog.$exportProperty$(Aura.$Event$.$Event$.prototype, "getName", Aura.$Event$.$Event$.prototype.getName);
Aura.$Event$.$Event$.prototype.$getType$ = function() {
  return this.$eventDef$.$getDescriptor$().$getFullName$()
};
goog.$exportProperty$(Aura.$Event$.$Event$.prototype, "getType", Aura.$Event$.$Event$.prototype.$getType$);
Aura.$Event$.$Event$.prototype.$getEventType$ = function() {
  return this.$eventDef$.$getEventType$()
};
goog.$exportProperty$(Aura.$Event$.$Event$.prototype, "getEventType", Aura.$Event$.$Event$.prototype.$getEventType$);
Aura.$Event$.$Event$.prototype.$setParams$ = function(config) {
  if(this.$fired$) {
    $A.assert(false, "Event.setParams(): cannot modify all params in an event that has already been fired.")
  }
  if(config) {
    var attributeDefs = this.$eventDef$.$getAttributeDefs$();
    for(var key in config) {
      if(config.hasOwnProperty(key)) {
        if(attributeDefs.hasAttribute(key)) {
          this.$params$[key] = config[key]
        }else {
          $A.$warning$("Event.setParams(): '" + key + "'('" + config[key] + "') is not a valid parameter. Valid parameters are '" + attributeDefs.$getNames$().join("', '") + "'")
        }
      }
    }
  }
  return this
};
goog.$exportProperty$(Aura.$Event$.$Event$.prototype, "setParams", Aura.$Event$.$Event$.prototype.$setParams$);
Aura.$Event$.$Event$.prototype.$setParam$ = function(key, value) {
  if(this.$fired$ && this.$componentEvent$) {
    $A.assert(false, "Event.setParam(): cannot modify a component event that has already been fired.")
  }
  if(this.$eventDef$.$getAttributeDefs$().hasAttribute(key)) {
    this.$params$[key] = value
  }else {
    $A.$warning$("Event.setParam(): '" + key + "' is not a valid parameter. Valid parameters are '" + this.$eventDef$.$getAttributeDefs$().$getNames$().join("', '") + "'")
  }
};
goog.$exportProperty$(Aura.$Event$.$Event$.prototype, "setParam", Aura.$Event$.$Event$.prototype.$setParam$);
Aura.$Event$.$Event$.prototype.$getParam$ = function(name) {
  return this.$params$[name]
};
goog.$exportProperty$(Aura.$Event$.$Event$.prototype, "getParam", Aura.$Event$.$Event$.prototype.$getParam$);
Aura.$Event$.$Event$.prototype.$getParams$ = function() {
  return this.$params$
};
goog.$exportProperty$(Aura.$Event$.$Event$.prototype, "getParams", Aura.$Event$.$Event$.prototype.$getParams$);
Aura.$Event$.$Event$.prototype.$getEventExecutionType$ = function() {
  if(this.$eventDef$.$getDescriptor$().$getQualifiedName$() === "markup://aura:methodCall") {
    return"VALUE"
  }else {
    if(this.$eventName$) {
      return this.$componentEvent$ ? "LEGACY_COMPONENT" : "COMPONENT"
    }else {
      for(var def = this.$eventDef$;def;) {
        var qname = def.$getDescriptor$().$getQualifiedName$();
        var handlers = this.$eventDispatcher$[qname];
        if(handlers) {
          return def.$getEventType$() === "VALUE" ? "VALUE" : "APPLICATION"
        }
        def = def.$getSuperDef$()
      }
      return"APPLICATION"
    }
  }
};
Aura.$Event$.$Event$.prototype.$executeHandlers$ = function() {
  if(!this.$eventHandlerIterator$) {
    this.$eventHandlerIterator$ = this.$getHandlerIterator$()
  }
  this.$executeHandlerIterator$(this.$eventHandlerIterator$)
};
Aura.$Event$.$Event$.prototype.$executeHandlerIterator$ = function(handlerIterator) {
  var res = {};
  var value;
  var type = this.$getType$();
  var isSystemError = type === "aura:systemError";
  var isCustomerError = type === "aura:customerError";
  for(var isComponentEventType = this.$getEventExecutionType$() === "COMPONENT";!this.paused && !res.$done$;) {
    res = handlerIterator.next();
    value = res.value;
    if(value && value.$handler$) {
      if(isComponentEventType && !value.$cmp$.$isValid$() && this.$phase$ !== "default") {
        this.stopPropagation()
      }
      this.$phase$ = value.$phase$;
      if(isSystemError || isCustomerError) {
        try {
          value.$handler$(this)
        }catch(e) {
          $A.$warning$("aura:systemError | aura:customerError event handler failed", e);
          $A.$logger$.$reportError$(e)
        }
      }else {
        $A.$clientService$.$setCurrentAccess$(value.$cmp$);
        try {
          value.$handler$(this)
        }finally {
          $A.$clientService$.$releaseCurrentAccess$()
        }
      }
    }
  }
};
Aura.$Event$.$Event$.prototype.$getHandlerIterator$ = function() {
  var eventExecutionType = this.$getEventExecutionType$();
  switch(eventExecutionType) {
    case "VALUE":
      return $A.$eventService$.$getValueHandlerIterator$(this);
    case "LEGACY_COMPONENT":
      return $A.$eventService$.$getNonBubblingComponentEventHandlerIterator$(this);
    case "COMPONENT":
      return $A.$eventService$.$getComponentEventHandlerIterator$(this);
    case "APPLICATION":
      return $A.$eventService$.$getAppEventHandlerIterator$(this);
    default:
      throw new Aura.$Errors$.$AuraError$("Invalid event type");
  }
};
Aura.$Event$.$Event$.prototype.$fire$ = function(params) {
  var self = this;
  if(this.$fired$) {
    aura.assert(false, "Event.fire(): Unable to fire event. Event has already been fired.")
  }
  if(params) {
    this.$setParams$(params)
  }
  $A.$run$(function() {
    self.$fired$ = true;
    self.$executeHandlers$()
  }, this.$eventDef$.$getDescriptor$().$getQualifiedName$())
};
goog.$exportProperty$(Aura.$Event$.$Event$.prototype, "fire", Aura.$Event$.$Event$.prototype.$fire$);
Aura.$Event$.$InteropEvent$ = function(component, config) {
  $A.assert(component, "InteropEvent constructor requires the `component` argument.");
  var _config = config || {};
  var nativeEvent = _config["isEvent"] && _config["params"];
  var event = nativeEvent || {};
  this.$_name$ = event.type || _config["name"] || "";
  this.$_source$ = component;
  this.$_params$ = _config["isEvent"] ? event.detail || {} : _config["params"] || {};
  this["target"] = null;
  this["currentTarget"] = null;
  this["initEvent"] = null;
  if(nativeEvent) {
    if(nativeEvent.preventDefault) {
      this["preventDefault"] = nativeEvent.preventDefault.bind(nativeEvent)
    }
    if(nativeEvent.stopPropagation) {
      this["stopPropagation"] = nativeEvent.stopPropagation.bind(nativeEvent)
    }
    if(_config["exposeNativeAPI"]) {
      this["target"] = event.target;
      this["currentTarget"] = event.currentTarget;
      this.$exposeNativeEventAPI$(this, nativeEvent)
    }
  }
};
goog.$exportSymbol$("Aura.Event.InteropEvent", Aura.$Event$.$InteropEvent$);
Aura.$Event$.$InteropEvent$.prototype.$exposeNativeEventAPI$ = function(auraEvent, nativeEvent) {
  var createGetter = function(_nativeEvent, _attrName) {
    return function() {
      $A.$warning$("Avoid relying on the native event attribute `" + _attrName + "` as it is only included for backwards-compatibility. It " + "will eventually be deprecated. Use the aura event API " + "(e.g., getSource(), getParams(), etc) instead.");
      var value = _nativeEvent[_attrName];
      if(typeof value === "function") {
        value = value.bind(_nativeEvent)
      }
      return value
    }
  };
  for(var attrName in nativeEvent) {
    if(!(attrName in auraEvent)) {
      Object.defineProperty(auraEvent, attrName, {enumerable:true, get:createGetter(nativeEvent, attrName)})
    }
  }
};
Aura.$Event$.$InteropEvent$.prototype.$fire$ = function() {
  this.$raiseInvalidInteropApi$("fire", arguments)
};
goog.$exportProperty$(Aura.$Event$.$InteropEvent$.prototype, "fire", Aura.$Event$.$InteropEvent$.prototype.$fire$);
Aura.$Event$.$InteropEvent$.prototype.getName = function() {
  return this.$_name$
};
goog.$exportProperty$(Aura.$Event$.$InteropEvent$.prototype, "getName", Aura.$Event$.$InteropEvent$.prototype.getName);
Aura.$Event$.$InteropEvent$.prototype.$getParam$ = function(name) {
  return this.$_params$[name]
};
goog.$exportProperty$(Aura.$Event$.$InteropEvent$.prototype, "getParam", Aura.$Event$.$InteropEvent$.prototype.$getParam$);
Aura.$Event$.$InteropEvent$.prototype.$getParams$ = function() {
  return this.$_params$
};
goog.$exportProperty$(Aura.$Event$.$InteropEvent$.prototype, "getParams", Aura.$Event$.$InteropEvent$.prototype.$getParams$);
Aura.$Event$.$InteropEvent$.prototype.$getPhase$ = function() {
  this.$raiseInvalidInteropApi$("getPhase", arguments)
};
goog.$exportProperty$(Aura.$Event$.$InteropEvent$.prototype, "getPhase", Aura.$Event$.$InteropEvent$.prototype.$getPhase$);
Aura.$Event$.$InteropEvent$.prototype.$getSource$ = function() {
  return this.$_source$
};
goog.$exportProperty$(Aura.$Event$.$InteropEvent$.prototype, "getSource", Aura.$Event$.$InteropEvent$.prototype.$getSource$);
Aura.$Event$.$InteropEvent$.prototype.pause = function() {
  this.$raiseInvalidInteropApi$("pause", arguments)
};
goog.$exportProperty$(Aura.$Event$.$InteropEvent$.prototype, "pause", Aura.$Event$.$InteropEvent$.prototype.pause);
Aura.$Event$.$InteropEvent$.prototype.preventDefault = function() {
};
goog.$exportProperty$(Aura.$Event$.$InteropEvent$.prototype, "preventDefault", Aura.$Event$.$InteropEvent$.prototype.preventDefault);
Aura.$Event$.$InteropEvent$.prototype.$resume$ = function() {
  this.$raiseInvalidInteropApi$("resume", arguments)
};
goog.$exportProperty$(Aura.$Event$.$InteropEvent$.prototype, "resume", Aura.$Event$.$InteropEvent$.prototype.$resume$);
Aura.$Event$.$InteropEvent$.prototype.$setParam$ = function() {
};
goog.$exportProperty$(Aura.$Event$.$InteropEvent$.prototype, "setParam", Aura.$Event$.$InteropEvent$.prototype.$setParam$);
Aura.$Event$.$InteropEvent$.prototype.$setParams$ = function() {
};
goog.$exportProperty$(Aura.$Event$.$InteropEvent$.prototype, "setParams", Aura.$Event$.$InteropEvent$.prototype.$setParams$);
Aura.$Event$.$InteropEvent$.prototype.stopPropagation = function() {
};
goog.$exportProperty$(Aura.$Event$.$InteropEvent$.prototype, "stopPropagation", Aura.$Event$.$InteropEvent$.prototype.stopPropagation);
Aura.$Event$.$InteropEvent$.prototype.$raiseInvalidInteropApi$ = function(func, args) {
  var error = "Interop event tried calling function [" + func + "]";
  var argsArr = Array.prototype.slice.call(args);
  if(argsArr.length) {
    error += " with arguments [" + argsArr.join(",") + "]"
  }
  if(this.$_source$ && this.$_source$.$globalId$) {
    error += ", " + this.$_source$ + " [" + this.$_source$.$globalId$ + "]"
  }
  var ae = new $A.$auraError$(error, null, $A.severity.$QUIET$);
  ae.$component$ = this.$_source$.toString();
  throw ae;
};
function ActionDef(config) {
  this.name = config[Json.$ApplicationKey$["NAME"]];
  this.$descriptor$ = config[Json.$ApplicationKey$.$DESCRIPTOR$];
  this.$actionType$ = config[Json.$ApplicationKey$.$ACTIONTYPE$];
  this.$meth$ = null;
  this.$paramDefs$ = {};
  this.background = false;
  this.$caboose$ = false;
  this.$publicCachingEnabled$ = false;
  this.$publicCachingExpiration$ = -1;
  if(this.$actionType$ === "SERVER") {
    this.$returnType$ = config[Json.$ApplicationKey$.$RETURNTYPE$] && config[Json.$ApplicationKey$.$RETURNTYPE$]["name"];
    var params = config[Json.$ApplicationKey$.$PARAMS$];
    if(!!params && $A["util"].isArray(params)) {
      for(var i = 0;i < params.length;i++) {
        this.$paramDefs$[params[i]["name"]] = params[i]
      }
    }
    if(config[Json.$ApplicationKey$.$BACKGROUND$]) {
      this.background = true
    }
    if(config[Json.$ApplicationKey$.$CABOOSE$]) {
      this.$caboose$ = true
    }
    if(config[Json.$ApplicationKey$.$PUBLICCACHINGENABLED$]) {
      this.$publicCachingEnabled$ = true;
      this.$publicCachingExpiration$ = config[Json.$ApplicationKey$.$PUBLICCACHINGEXPIRATION$]
    }
  }else {
    if(this.$actionType$ === "CLIENT") {
      try {
        this.$meth$ = $A["util"].$json$.$decodeString$(config[Json.$ApplicationKey$.$CODE$])
      }catch(e) {
        throw new $A.$auraError$("ActionDef ctor decode error: " + config[Json.$ApplicationKey$.$CODE$], e, $A.severity.$QUIET$);
      }
    }
  }
}
goog.$exportSymbol$("ActionDef", ActionDef);
ActionDef.prototype.getName = function() {
  return this.name
};
goog.$exportProperty$(ActionDef.prototype, "getName", ActionDef.prototype.getName);
ActionDef.prototype.$getDescriptor$ = function() {
  return this.$descriptor$
};
ActionDef.prototype.$getActionType$ = function() {
  return this.$actionType$
};
ActionDef.prototype.$isClientAction$ = function() {
  return this.$actionType$ === "CLIENT"
};
goog.$exportProperty$(ActionDef.prototype, "isClientAction", ActionDef.prototype.$isClientAction$);
ActionDef.prototype.$isServerAction$ = function() {
  return this.$actionType$ === "SERVER"
};
goog.$exportProperty$(ActionDef.prototype, "isServerAction", ActionDef.prototype.$isServerAction$);
ActionDef.prototype.$isBackground$ = function() {
  return this.background === true
};
ActionDef.prototype.$isCaboose$ = function() {
  return this.$caboose$ === true
};
ActionDef.prototype.$isPublicCachingEnabled$ = function() {
  return this.$publicCachingEnabled$ === true
};
ActionDef.prototype.$getPublicCachingExpiration$ = function() {
  return this.$publicCachingExpiration$
};
ActionDef.prototype.$newInstance$ = function(cmp) {
  return new Action(this, "a", this.$meth$, this.$paramDefs$, this.background, cmp, this.$caboose$)
};
ActionDef.prototype.toString = function() {
  return this.$descriptor$.toString()
};
Aura.$Controller$.$ActionDef$ = ActionDef;
function Action(def, suffix, method, paramDefs, background, cmp, caboose) {
  this.$def$ = def;
  this.$meth$ = method;
  this.$paramDefs$ = paramDefs;
  this.background = background;
  this.$cmp$ = cmp;
  this.$params$ = {};
  this.$responseState$ = null;
  this.state = "NEW";
  this.$callbacks$ = {};
  this.$events$ = [];
  this.$components$ = null;
  this.$actionId$ = Action.prototype.$nextActionId$++;
  this.id = this.$actionId$ > 0 ? this.$actionId$ + ";" + suffix : suffix;
  this.$originalResponse$ = undefined;
  this.$storable$ = false;
  this.$caboose$ = caboose;
  this.$allAboardCallback$ = undefined;
  this.$abortable$ = false;
  this.$deferred$ = false;
  this.returnValue = undefined;
  this.$returnValueUserland$ = undefined;
  this.$pathStack$ = [];
  this.$canCreate$ = true;
  this.$pushCreationPath$("body");
  this.$setCreationPathIndex$(0);
  this.$refreshAction$ = undefined;
  this.$callingCmp$ = $A.$clientService$.$currentAccess$;
  this.$retryCount$ = 0;
  $A.$lockerService$.$trust$(cmp, this)
}
goog.$exportSymbol$("Action", Action);
Action.$getStorageKey$ = function(descriptor, params) {
  return descriptor + ":" + $A["util"]["json"].$orderedEncode$(params)
};
Action.prototype.$nextActionId$ = 0;
Action.prototype.$getId$ = function() {
  return this.id
};
goog.$exportProperty$(Action.prototype, "getId", Action.prototype.$getId$);
Action.prototype.$setId$ = function(id) {
  this.id = id
};
Action.prototype.$getNextGlobalId$ = function() {
  if(!this.$nextGlobalId$) {
    this.$nextGlobalId$ = 1
  }
  return this.$nextGlobalId$++
};
Action.prototype.$reactivatePath$ = function() {
  this.$canCreate$ = true
};
Action.prototype.$forceCreationPath$ = function(path) {
  var absPath = "(empty)";
  var newAbsPath = this.$getId$() + path;
  if(this.$pathStack$.length > 0) {
    var top = this.$pathStack$[this.$pathStack$.length - 1];
    if(top.$absPath$ === newAbsPath) {
      return undefined
    }
    absPath = top.$absPath$
  }
  if(this.$topPath$() !== newAbsPath && (path.length < 2 || path.indexOf("/", 1) !== -1)) {
    $A.$warning$("force path of " + newAbsPath + " from " + absPath + " likely a use of returned component array without changing index")
  }
  var pathEntry = {$relPath$:"~FORCED~", $absPath$:newAbsPath, $idx$:undefined, $startIdx$:undefined};
  this.$pathStack$.push(pathEntry);
  return newAbsPath
};
Action.prototype.$setDeferred$ = function() {
  this.$deferred$ = this.$abortable$
};
Action.prototype.$isDeferred$ = function() {
  return this.$deferred$
};
Action.prototype.$releaseCreationPath$ = function(path) {
  var last;
  if(this.$pathStack$.length > 0) {
    last = this.$pathStack$[this.$pathStack$.length - 1]
  }
  if(!last || last.$absPath$ !== path) {
    $A.$warning$("unexpected unwinding of pathStack.  found " + (last ? last.$absPath$ + " idx " + last.$idx$ : "empty") + " expected " + path)
  }
  if(last && last.$relPath$ === "~FORCED~") {
    this.$pathStack$.pop()
  }
};
Action.prototype.$pushCreationPath$ = function(pathPart) {
  this.$canCreate$ = true;
  switch(pathPart) {
    case "body":
      pathPart = "*";
      break;
    case "super":
      pathPart = "$";
      break
  }
  var addedPath = "/" + pathPart;
  var newPath = this.$topPath$() + addedPath;
  var pathEntry = {$relPath$:addedPath, $absPath$:newPath, $idx$:undefined, $startIdx$:undefined};
  this.$pathStack$.push(pathEntry)
};
Action.prototype.$popCreationPath$ = function(pathPart) {
  var addedPath;
  this.$canCreate$ = false;
  switch(pathPart) {
    case "body":
      pathPart = "*";
      break;
    case "super":
      pathPart = "$";
      break
  }
  addedPath = "/" + pathPart;
  var last = this.$pathStack$.pop();
  if(!last || last.$relPath$ !== addedPath) {
    $A.$warning$("unexpected unwinding of pathStack.  found " + (last ? last.$relPath$ + " idx " + last.$idx$ : "empty") + " expected " + addedPath)
  }
  return last
};
Action.prototype.$topPath$ = function() {
  if(this.$pathStack$.length === 0) {
    return this.$getId$()
  }
  var top = this.$pathStack$[this.$pathStack$.length - 1];
  return top.$absPath$ + (top.$idx$ !== undefined ? "[" + top.$idx$ + "]" : "")
};
Action.prototype.$setCreationPathIndex$ = function(idx) {
  this.$canCreate$ = true;
  if(this.$pathStack$.length < 1) {
    $A.$warning$("Attempting to increment index on empty stack")
  }
  var top = this.$pathStack$[this.$pathStack$.length - 1];
  if(top.$idx$ === undefined) {
    top.$startIdx$ = idx;
    top.$idx$ = idx
  }else {
    if(idx !== 0 && idx !== top.$idx$ + 1) {
      $A.$warning$("Improper index increment. Expected: " + (top.$idx$ + 1) + ", Actual: " + idx)
    }else {
      top.$idx$ = idx
    }
  }
};
Action.prototype.$getCurrentPath$ = function() {
  if(!this.$canCreate$) {
  }
  this.$canCreate$ = false;
  return this.$topPath$()
};
Action.prototype.$getDef$ = function() {
  return this.$def$
};
goog.$exportProperty$(Action.prototype, "getDef", Action.prototype.$getDef$);
Action.prototype.getName = function() {
  return this.$def$.getName()
};
goog.$exportProperty$(Action.prototype, "getName", Action.prototype.getName);
Action.prototype.$setParams$ = function(config) {
  $A.assert($A["util"].$isObject$(config), "setParams() must be passed an object.");
  var paramDefs = this.$paramDefs$;
  for(var key in paramDefs) {
    this.$params$[key] = config[key]
  }
};
goog.$exportProperty$(Action.prototype, "setParams", Action.prototype.$setParams$);
Action.prototype.$setParam$ = function(key, value) {
  var paramDef = this.$paramDefs$[key];
  if(paramDef) {
    this.$params$[key] = value
  }
};
goog.$exportProperty$(Action.prototype, "setParam", Action.prototype.$setParam$);
Action.prototype.$getParam$ = function(name) {
  return this.$params$[name]
};
goog.$exportProperty$(Action.prototype, "getParam", Action.prototype.$getParam$);
Action.prototype.$getParams$ = function() {
  return this.$params$
};
goog.$exportProperty$(Action.prototype, "getParams", Action.prototype.$getParams$);
Action.prototype.$getComponent$ = function() {
  return this.$cmp$
};
Action.prototype.$setCallback$ = function(scope, callback, name) {
  $A.assert($A["util"].$isFunction$(callback), "Action.setCallback(): callback for '" + name + "' must be a function");
  if(name !== undefined && name !== "ALL" && name !== "SUCCESS" && name !== "ERROR" && name !== "INCOMPLETE" && name !== "ABORTED") {
    throw new $A.$auraError$("Action.setCallback(): Invalid callback name '" + name + "'");
  }
  if($A.$clientService$.$currentAccess$ && $A.$clientService$.$inAuraLoop$()) {
    callback = $A.$getCallback$(callback)
  }
  if(name === undefined || name === "ALL") {
    this.$callbacks$["SUCCESS"] = {"fn":callback, "s":scope};
    this.$callbacks$["ERROR"] = {"fn":callback, "s":scope};
    this.$callbacks$["INCOMPLETE"] = {"fn":callback, "s":scope}
  }else {
    this.$callbacks$[name] = {"fn":callback, "s":scope}
  }
};
goog.$exportProperty$(Action.prototype, "setCallback", Action.prototype.$setCallback$);
Action.prototype.$getCallback$ = function(type) {
  return this.$callbacks$[type]
};
goog.$exportProperty$(Action.prototype, "getCallback", Action.prototype.$getCallback$);
Action.prototype.$setAllAboardCallback$ = function(scope, callback) {
  $A.assert($A["util"].$isFunction$(callback), "Action 'All Aboard' callback should be a function");
  var that = this;
  this.$allAboardCallback$ = function() {
    callback.call(scope, that)
  }
};
goog.$exportProperty$(Action.prototype, "setAllAboardCallback", Action.prototype.$setAllAboardCallback$);
Action.prototype.$callAllAboardCallback$ = function(context) {
  if(this.$allAboardCallback$) {
    var previous = context.$setCurrentAction$(this);
    $A.$clientService$.$setCurrentAccess$(this.$cmp$);
    try {
      this.$allAboardCallback$()
    }catch(e) {
      this.$markException$(e);
      return false
    }finally {
      context.$setCurrentAction$(previous);
      $A.$clientService$.$releaseCurrentAccess$()
    }
  }
  return true
};
Action.prototype.$wrapCallback$ = function(scope, callback) {
  var nestedCallbacks = this.$callbacks$;
  var outerCallback = callback;
  var outerScope = scope;
  this.$callbacks$ = {};
  this.$setCallback$(this, function(action, cmp) {
    var cb = nestedCallbacks[this.$getState$()];
    if(cb && cb["fn"]) {
      cb["fn"].call(cb["s"], action, cmp)
    }
    outerCallback.call(outerScope, this, cmp);
    this.$callbacks$ = nestedCallbacks
  })
};
Action.prototype.$run$ = function(evt) {
  this.$runDeprecated$(evt)
};
goog.$exportProperty$(Action.prototype, "run", Action.prototype.$run$);
Action.prototype.$runDeprecated$ = function(evt) {
  $A.assert(this.$def$ && this.$def$.$isClientAction$(), "run() cannot be called on a server action. Use $A.enqueueAction() instead.");
  if(this.$cmp$.$destroyed$ === 1) {
    return
  }
  this.state = "RUNNING";
  $A.$clientService$.$setCurrentAccess$(this.$cmp$);
  try {
    var secureCmp = $A.$lockerService$.$wrapComponent$(this.$cmp$);
    var secureEvt = $A.$lockerService$.$wrapComponentEvent$(secureCmp, evt);
    this.returnValue = this.$meth$.call(undefined, secureCmp, secureEvt, this.$cmp$["helper"]);
    this.state = "SUCCESS"
  }catch(e) {
    this.$markException$(e)
  }finally {
    $A.$clientService$.$releaseCurrentAccess$()
  }
};
goog.$exportProperty$(Action.prototype, "runDeprecated", Action.prototype.$runDeprecated$);
Action.prototype.$getState$ = function() {
  return this.state
};
goog.$exportProperty$(Action.prototype, "getState", Action.prototype.$getState$);
Action.prototype.$getReturnValue$ = function() {
  if(this.$returnValueUserland$ !== undefined) {
    return this.$returnValueUserland$
  }
  if(this.$storable$ && this.$responseState$ === "SUCCESS") {
    if($A["util"].isArray(this.returnValue)) {
      this.$returnValueUserland$ = $A["util"].apply([], this.returnValue, true, true)
    }else {
      if($A["util"].$isObject$(this.returnValue)) {
        this.$returnValueUserland$ = $A["util"].apply({}, this.returnValue, true, true)
      }else {
        this.$returnValueUserland$ = this.returnValue
      }
    }
  }else {
    this.$returnValueUserland$ = this.returnValue
  }
  return this.$returnValueUserland$
};
goog.$exportProperty$(Action.prototype, "getReturnValue", Action.prototype.$getReturnValue$);
Action.prototype.getError = function() {
  return this.error
};
goog.$exportProperty$(Action.prototype, "getError", Action.prototype.getError);
Action.prototype.$isBackground$ = function() {
  return this.background === true
};
goog.$exportProperty$(Action.prototype, "isBackground", Action.prototype.$isBackground$);
Action.prototype.$setBackground$ = function() {
  this.background = true
};
goog.$exportProperty$(Action.prototype, "setBackground", Action.prototype.$setBackground$);
Action.prototype.$updateFromResponse$ = function(response) {
  this.state = response["state"];
  this.$responseState$ = response["state"];
  this.returnValue = response["returnValue"];
  this.$returnValueUserland$ = undefined;
  this.error = response["error"];
  this.$storage$ = response["storage"];
  this.$components$ = response["components"];
  if(this.state === "ERROR") {
    var i;
    var newErrors = [];
    var fired = false;
    for(i = 0;i < response["error"].length;i++) {
      var err = response["error"][i];
      if(err["exceptionEvent"]) {
        if(err["useDefault"]) {
          var error = err["event"]["attributes"]["values"]["error"];
          error.severity = $A.severity.$ALERT$;
          var evtArgs = {"message":error["message"], "error":null, "auraError":error};
          window.setTimeout(function() {
            $A.$eventService$.$getNewEvent$("markup://aura:systemError").$fire$(evtArgs)
          }, 0);
          return false
        }
        var eventObj = err["event"];
        if(eventObj["descriptor"]) {
          var eventDescriptor = new DefDescriptor(eventObj["descriptor"]);
          var eventName = eventDescriptor.getName();
          var eventNamespace = eventDescriptor.$getNamespace$();
          if(eventNamespace === "aura") {
            if(eventName === "clientOutOfSync" || eventName === "invalidSession") {
              $A.$clientService$.$throwExceptionEvent$(err);
              return false
            }
            if(eventName === "serverActionError") {
              this.error = [eventObj["attributes"]["values"]["error"]];
              return true
            }
          }
        }
        fired = true;
        this.$events$.push(err["event"])
      }else {
        newErrors.push(err)
      }
    }
    if(fired === true && newErrors.length === 0) {
      newErrors.push({"message":"Event fired"})
    }
    this.error = newErrors
  }else {
    if(this.$originalResponse$ && this.state === "SUCCESS") {
      var originalValue = $A["util"].$json$.$orderedEncode$(this.$originalReturnValue$);
      var refreshedValue = $A["util"].$json$.$orderedEncode$(this.returnValue);
      if(refreshedValue === originalValue) {
        var originalComponents = $A["util"].$json$.$orderedEncode$(this.$originalResponse$["components"]);
        var refreshedComponents = $A["util"].$json$.$orderedEncode$(response["components"]);
        if(refreshedComponents === originalComponents) {
          $A.log("Action.updateFromResponse(): skipping duplicate response: " + this.$getStorageKey$() + ", " + this.$getId$());
          return false
        }
      }
    }
  }
  if(this.$originalResponse$ && this.state === "INCOMPLETE") {
    return false
  }
  return true
};
Action.prototype.$getStored$ = function() {
  if(this.$storable$ && this.$responseState$ === "SUCCESS") {
    return{"returnValue":this.returnValue, "components":this.$components$, "state":"SUCCESS", "storage":{"created":(new Date).getTime()}}
  }
  return null
};
Action.prototype.$prepareToSend$ = function() {
  var json = this.toJSON();
  if(this.$isPubliclyCacheable$()) {
    delete json.id
  }
  return json
};
Action.prototype.$finishAction$ = function(context) {
  var previous = context.$setCurrentAction$(this);
  var clearComponents = false;
  var id = this.$getId$(context);
  var error = undefined;
  var oldDisplayFlag = $A.$showErrors$();
  $A.$clientService$.$setCurrentAccess$(this.$cmp$);
  try {
    if(this.$isFromStorage$()) {
      $A.$showErrors$(false)
    }
    try {
      if(this.$cmp$ === undefined || this.$cmp$.$destroyed$ !== 1) {
        if(this.$components$) {
          context.$joinComponentConfigs$(this.$components$, id);
          clearComponents = true
        }
        if(this.$events$.length > 0) {
          for(var x = 0;x < this.$events$.length;x++) {
            try {
              this.$parseAndFireEvent$(this.$events$[x])
            }catch(e) {
              var eventFailedMessage = "Events failed: " + (this.$def$ ? this.$def$.toString() : "");
              $A.$warning$(eventFailedMessage, e);
              e.message = e.message ? e.message + "\n" + eventFailedMessage : eventFailedMessage;
              error = e
            }
          }
        }
        var cb = this.$callbacks$[this.$getState$()];
        try {
          if(cb) {
            cb["fn"].call(cb["s"], this, this.$cmp$)
          }
        }catch(e$$0) {
          var callbackFailedMessage = "Callback failed: " + (this.$def$ ? this.$def$.toString() : "");
          $A.$warning$(callbackFailedMessage, e$$0);
          e$$0.message = e$$0.message ? e$$0.message + "\n" + callbackFailedMessage : callbackFailedMessage;
          if(!error) {
            error = e$$0
          }
        }
        if(this.$components$ && (cb || !this.$storable$ || !$A.$clientService$.$getActionStorage$().$isStorageEnabled$())) {
          context.$finishComponentConfigs$(id);
          clearComponents = false
        }
      }else {
        this.abort()
      }
    }catch(e$$1) {
      var actionFailedMessage = "Action failed: " + (this.$def$ ? this.$def$.toString() : "");
      $A.$warning$(actionFailedMessage, e$$1);
      e$$1.message = e$$1.message ? e$$1.message + "\n" + actionFailedMessage : actionFailedMessage;
      if(!error) {
        error = e$$1
      }
      clearComponents = true
    }
  }finally {
    $A.$clientService$.$releaseCurrentAccess$()
  }
  context.$setCurrentAction$(previous);
  if(clearComponents) {
    context.$clearComponentConfigs$(id)
  }
  $A.$showErrors$(oldDisplayFlag);
  if(error) {
    if($A.$clientService$.$inAuraLoop$() || error instanceof $A.$auraFriendlyError$) {
      throw error;
    }else {
      throw new $A.$auraError$("Action.prototype.finishAction Error ", error);
    }
  }
};
Action.prototype.$abortIfComponentInvalid$ = function(beforeSend) {
  if((!beforeSend || this.$abortable$) && this.$cmp$ !== undefined && this.$cmp$.$destroyed$ === 1) {
    this.abort();
    return true
  }
  return false
};
Action.prototype.abort = function() {
  this.state = "ABORTED";
  var cb = this.$callbacks$[this.state];
  try {
    if(cb) {
      cb["fn"].call(cb["s"], this, this.$cmp$)
    }
  }catch(e) {
    if($A.$clientService$.$inAuraLoop$()) {
      throw e;
    }else {
      throw new $A.$auraError$("Failed during aborted callback", e);
    }
  }finally {
    $A.log("ABORTED: " + this.$getStorageKey$())
  }
};
Action.prototype.$setAbortable$ = function() {
  this.$abortable$ = true
};
goog.$exportProperty$(Action.prototype, "setAbortable", Action.prototype.$setAbortable$);
Action.prototype.$isRefreshAction$ = function() {
  return this.$originalResponse$ !== undefined
};
goog.$exportProperty$(Action.prototype, "isRefreshAction", Action.prototype.$isRefreshAction$);
Action.prototype.$isAbortable$ = function() {
  return this.$abortable$
};
goog.$exportProperty$(Action.prototype, "isAbortable", Action.prototype.$isAbortable$);
Action.prototype.$setStorable$ = function(config) {
  $A.assert(this.$def$ && this.$def$.$isServerAction$(), "setStorable() cannot be called on a client action.");
  this.$storable$ = true;
  this.$storableConfig$ = config;
  this.$abortable$ = true
};
goog.$exportProperty$(Action.prototype, "setStorable", Action.prototype.$setStorable$);
Action.prototype.$isStorable$ = function() {
  var ignoreExisting = this.$storableConfig$ && this.$storableConfig$["ignoreExisting"];
  return this.$_isStorable$() && !ignoreExisting
};
goog.$exportProperty$(Action.prototype, "isStorable", Action.prototype.$isStorable$);
Action.prototype.$setCaboose$ = function() {
  this.$caboose$ = true
};
goog.$exportProperty$(Action.prototype, "setCaboose", Action.prototype.$setCaboose$);
Action.prototype.$isCaboose$ = function() {
  return this.$caboose$
};
goog.$exportProperty$(Action.prototype, "isCaboose", Action.prototype.$isCaboose$);
Action.prototype.$_isStorable$ = function() {
  return this.$storable$ || false
};
Action.prototype.$getStorageKey$ = function() {
  return Action.$getStorageKey$(this.$def$ ? this.$def$.$getDescriptor$().toString() : "", this.$params$)
};
goog.$exportProperty$(Action.prototype, "getStorageKey", Action.prototype.$getStorageKey$);
Action.prototype.$isFromStorage$ = function() {
  return!$A["util"].$isUndefinedOrNull$(this.$storage$)
};
goog.$exportProperty$(Action.prototype, "isFromStorage", Action.prototype.$isFromStorage$);
Action.prototype.$setChained$ = function() {
  this.$chained$ = true;
  $A.$enqueueAction$(this)
};
goog.$exportProperty$(Action.prototype, "setChained", Action.prototype.$setChained$);
Action.prototype.$isChained$ = function() {
  return this.$chained$ || false
};
Action.prototype.$getRetryCount$ = function() {
  return this.$retryCount$
};
Action.prototype.$incrementRetryCount$ = function() {
  this.$retryCount$++
};
Action.prototype.toJSON = function() {
  var callingComponentDef = this.$callingCmp$ ? this.$callingCmp$.$getDef$() : null;
  var requiredVersionDefs = callingComponentDef ? callingComponentDef.$getRequiredVersionDefs$() : null;
  var version = this.$cmp$ ? this.$cmp$.$getVersion$() : null;
  var isVersioned = requiredVersionDefs && requiredVersionDefs.$values$ || version;
  var json = {"id":this.$getId$(), "descriptor":this.$def$ ? this.$def$.$getDescriptor$() : "UNKNOWN", "callingDescriptor":isVersioned ? callingComponentDef ? callingComponentDef.$getDescriptor$().$getQualifiedName$() : "UNKNOWN" : "UNKNOWN", "params":this.$params$, "version":isVersioned ? version : null};
  return json
};
goog.$exportProperty$(Action.prototype, "toJSON", Action.prototype.toJSON);
Action.prototype.$markException$ = function(e) {
  var descriptor = this.$def$ ? this.$def$.toString() : "";
  if(e instanceof $A.$auraError$ || e instanceof $A.$auraFriendlyError$) {
    e.$setComponent$(e["component"] || descriptor)
  }
  if(!e.id) {
    e = new $A.$auraError$(descriptor ? "Action failed: " + descriptor : "", e);
    e.$setComponent$(descriptor)
  }
  if(!e["componentStack"]) {
    e["componentStack"] = $A["util"].$getComponentHierarchy$(this.$cmp$)
  }
  this.state = "ERROR";
  this.error = e;
  if($A.$clientService$.$inAuraLoop$()) {
    $A.$lastKnownError$ = e;
    throw e;
  }
};
Action.prototype.$markError$ = function(context, e) {
  this.state = "ERROR";
  this.error = e;
  this.$finishAction$(context)
};
Action.prototype.$incomplete$ = function(context) {
  this.state = "INCOMPLETE";
  if(!this.error || !(this.error instanceof Array)) {
    this.error = [{message:"Disconnected or Canceled"}]
  }
  if(!this.$isRefreshAction$()) {
    this.$finishAction$(context)
  }
};
Action.prototype.$copyToRefresh$ = function() {
  var refreshAction = this.$def$.$newInstance$(this.$cmp$);
  refreshAction.$setParams$(this.$params$);
  refreshAction.$setStorable$({"ignoreExisting":true});
  refreshAction.background = this.background;
  refreshAction.$abortable$ = this.$abortable$;
  this.$refreshAction$ = refreshAction;
  return refreshAction
};
Action.prototype.$getRefreshAction$ = function(originalResponse) {
  var storage = originalResponse["storage"];
  var actionStorage = $A.$clientService$.$getActionStorage$().$getStorage$();
  var autoRefreshInterval = this.$storableConfig$ && !$A["util"].$isUndefined$(this.$storableConfig$["refresh"]) && $A["util"].$isNumber$(this.$storableConfig$["refresh"]) ? this.$storableConfig$["refresh"] * 1E3 : actionStorage.$getDefaultAutoRefreshInterval$();
  var now = (new Date).getTime();
  if(now - storage["created"] >= autoRefreshInterval && this.$def$) {
    var refreshAction = this.$copyToRefresh$();
    $A.log("Action.refresh(): auto refresh begin: " + this.$getId$() + " to " + refreshAction.$getId$());
    refreshAction.$originalResponse$ = originalResponse;
    refreshAction.$originalReturnValue$ = this.returnValue;
    var executeCallbackIfUpdated = this.$storableConfig$ && !$A["util"].$isUndefined$(this.$storableConfig$["executeCallbackIfUpdated"]) ? this.$storableConfig$["executeCallbackIfUpdated"] : true;
    if(executeCallbackIfUpdated !== false) {
      refreshAction.$callbacks$ = this.$callbacks$
    }
    return refreshAction
  }
  return null
};
Action.prototype.$getRetryFromStorageAction$ = function() {
  if(this.$isFromStorage$()) {
    var retryAction = this.$copyToRefresh$();
    retryAction.$callbacks$ = this.$callbacks$;
    return retryAction
  }
  return null
};
Action.prototype.$getStorage$ = function() {
  return $A.$clientService$.$getActionStorage$().$getStorage$()
};
goog.$exportProperty$(Action.prototype, "getStorage", Action.prototype.$getStorage$);
Action.prototype.$parseAndFireEvent$ = function(evtObj) {
  var descriptor = evtObj["descriptor"];
  var evt = null;
  var comp = this.$getComponent$();
  if(comp) {
    evt = comp.$getEventByDescriptor$(descriptor)
  }
  if(evt !== null) {
    if(evtObj["attributes"]) {
      evt.$setParams$(evtObj["attributes"]["values"])
    }
    evt.$fire$()
  }else {
    $A.$clientService$.$parseAndFireEvent$(evtObj)
  }
};
Action.prototype.$fireRefreshEvent$ = function(event, responseUpdated) {
  if(this.$cmp$ && this.$cmp$.$isValid$()) {
    var isRefreshObserver = this.$cmp$.$isInstanceOf$("auraStorage:refreshObserver");
    if(isRefreshObserver) {
      this.$cmp$.$getEvent$(event).$setParams$({"action":this, "responseUpdated":responseUpdated}).$fire$()
    }
  }
};
Action.prototype.$isPubliclyCacheable$ = function() {
  return $A.getContext().$isActionPublicCachingEnabled$() && this.$def$.$isPublicCachingEnabled$() && this.$def$.$getPublicCachingExpiration$() > 0
};
Aura.$Controller$.$Action$ = Action;
function ActionStorage() {
  this.$actionKeysFilter$ = undefined;
  this.$actionsFilterEnabled$ = true;
  this.$actionsFilterInited$ = false
}
ActionStorage.prototype.$STORAGE_NAME$ = "actions";
ActionStorage.prototype.$enableActionsFilter$ = function(enable) {
  this.$actionsFilterEnabled$ = !!enable
};
ActionStorage.prototype.$setupActionsFilter$ = function() {
  if(this.$actionKeysFilter$ !== undefined) {
    return this.$actionsFilterInited$
  }
  if(!this.$actionsFilterEnabled$) {
    this.$actionKeysFilter$ = null;
    this.$actionsFilterInited$ = false
  }else {
    this.$actionKeysFilter$ = {};
    this.$actionsFilterInited$ = true
  }
  return this.$actionsFilterInited$
};
ActionStorage.prototype.$populateActionsFilter$ = function() {
  if(!this.$isStoragePersistent$() || !this.$setupActionsFilter$()) {
    return Promise["resolve"]()
  }
  return this.$getAll$()
};
ActionStorage.prototype.$clearActionsFilter$ = function() {
  this.$actionKeysFilter$ = undefined;
  this.$setupActionsFilter$()
};
ActionStorage.prototype.$isActionsFilterEnabled$ = function() {
  return this.$actionsFilterEnabled$
};
ActionStorage.prototype.$isActionsFilterInitialized$ = function() {
  return this.$actionsFilterInited$
};
ActionStorage.prototype.$isKeyAbsentFromCache$ = function(key) {
  if(!this.$isStorageEnabled$()) {
    return true
  }
  if(!this.$actionsFilterEnabled$ || !this.$actionKeysFilter$) {
    return false
  }
  return!this.$actionKeysFilter$[key]
};
ActionStorage.prototype.$getStorage$ = function() {
  return $A.$storageService$.$getStorage$(this.$STORAGE_NAME$)
};
ActionStorage.prototype.$isStoragePersistent$ = function() {
  var storage = this.$getStorage$();
  return!!storage && storage.$isPersistent$()
};
ActionStorage.prototype.$isStorageEnabled$ = function() {
  return!!this.$getStorage$()
};
ActionStorage.prototype.$setAll$ = function(values) {
  var key;
  var storage = this.$getStorage$();
  if(!storage) {
    return Promise["resolve"]()
  }
  if(!this.$setupActionsFilter$()) {
    return storage.$setAll$(values)
  }
  for(key in values) {
    this.$actionKeysFilter$[key] = true
  }
  var that = this;
  return storage.$setAll$(values).$then$(undefined, function(e) {
    for(key in values) {
      that.$actionKeysFilter$[key] = undefined
    }
    throw e;
  })
};
ActionStorage.prototype.set = function(actionKey, value) {
  var values = {};
  values[actionKey] = value;
  return this.$setAll$(values)
};
ActionStorage.prototype.$getAll$ = function(actionKeys) {
  var storage = this.$getStorage$();
  if(!storage) {
    return Promise["resolve"]({})
  }
  if(!this.$setupActionsFilter$()) {
    return storage.$getAll$(actionKeys, true)
  }
  var that = this;
  var key;
  return storage.$getAll$(actionKeys, true).$then$(function(items) {
    if(Array.isArray(actionKeys) && actionKeys.length > 0) {
      for(var i = 0;i < actionKeys.length;i++) {
        key = actionKeys[i];
        if(!items[key] && that.$actionKeysFilter$[key]) {
          delete that.$actionKeysFilter$[key]
        }
      }
    }
    for(key in items) {
      that.$actionKeysFilter$[key] = true
    }
    return items
  })
};
ActionStorage.prototype.get = function(actionKey) {
  return this.$getAll$([actionKey]).$then$(function(items) {
    return items ? items[actionKey] : undefined
  })
};
ActionStorage.prototype.$removeAll$ = function(actionKeys, doNotFireModified) {
  var storage = this.$getStorage$();
  if(!storage) {
    return Promise["resolve"]()
  }
  if(!this.$setupActionsFilter$()) {
    return storage.$removeAll$(actionKeys, doNotFireModified)
  }
  var key;
  for(var i = 0;i < actionKeys.length;i++) {
    key = actionKeys[i];
    if(this.$actionKeysFilter$[key]) {
      delete this.$actionKeysFilter$[key]
    }
  }
  return storage.$removeAll$(actionKeys, doNotFireModified)
};
ActionStorage.prototype.remove = function(actionKey, doNotFireModified) {
  return this.$removeAll$([actionKey], doNotFireModified)
};
ActionStorage.prototype.clear = function() {
  var storage = this.$getStorage$();
  if(!storage) {
    return Promise["resolve"]()
  }
  if(this.$actionsFilterEnabled$) {
    this.$clearActionsFilter$()
  }
  return storage.clear()
};
Aura.$Controller$.$ActionStorage$ = ActionStorage;
function ControllerDef(config) {
  this.$descriptor$ = config[Json.$ApplicationKey$.$DESCRIPTOR$];
  this.$actionDefs$ = {};
  var actionDefs = config[Json.$ApplicationKey$.$ACTIONDEFS$];
  for(var i = 0;i < actionDefs.length;i++) {
    var actionDefConfig = actionDefs[i];
    var actionDef = $A.$componentService$.$createActionDef$(actionDefConfig);
    this.$actionDefs$[actionDef.getName()] = actionDef
  }
}
goog.$exportSymbol$("ControllerDef", ControllerDef);
ControllerDef.prototype.$getDescriptor$ = function() {
  return this.$descriptor$
};
ControllerDef.prototype.$hasActionDef$ = function(key) {
  return this.$actionDefs$.hasOwnProperty(key)
};
ControllerDef.prototype.$getActionDef$ = function(key) {
  var action = this.$actionDefs$[key];
  if(!action) {
    var ae = new $A.$auraError$("Unable to find '" + key + "' on '" + this.$descriptor$ + "'.", null, $A.severity.$QUIET$);
    ae.$setComponent$(this.$descriptor$.replace("compound://", "markup://").replace(".", ":"));
    throw ae;
  }
  return action
};
goog.$exportProperty$(ControllerDef.prototype, "getActionDef", ControllerDef.prototype.$getActionDef$);
ControllerDef.prototype.get = function(key) {
  return this.$getActionDef$(key).$newInstance$()
};
goog.$exportProperty$(ControllerDef.prototype, "get", ControllerDef.prototype.get);
Aura.$Controller$.$ControllerDef$ = ControllerDef;
function AttributeDef(config) {
  this.$descriptor$ = new DefDescriptor(config[0]);
  this.$typeDefDescriptor$ = config[1];
  this.$access$ = config[2];
  this.required = config[3] === true;
  this.defaultValue = config[4]
}
goog.$exportSymbol$("AttributeDef", AttributeDef);
AttributeDef.prototype.$getDescriptor$ = function() {
  return this.$descriptor$
};
goog.$exportProperty$(AttributeDef.prototype, "getDescriptor", AttributeDef.prototype.$getDescriptor$);
AttributeDef.prototype.$isRequired$ = function() {
  return this.required === true
};
goog.$exportProperty$(AttributeDef.prototype, "isRequired", AttributeDef.prototype.$isRequired$);
AttributeDef.prototype.$getDefault$ = function() {
  return $A["util"].copy(this.defaultValue)
};
goog.$exportProperty$(AttributeDef.prototype, "getDefault", AttributeDef.prototype.$getDefault$);
AttributeDef.prototype.$getTypeDefDescriptor$ = function() {
  return this.$typeDefDescriptor$
};
goog.$exportProperty$(AttributeDef.prototype, "getTypeDefDescriptor", AttributeDef.prototype.$getTypeDefDescriptor$);
AttributeDef.prototype.$getNativeType$ = function() {
  $A.assert(this.$typeDefDescriptor$, "getNativeType() failed as there was no typeDefDescriptor for attribute " + this.$getDescriptor$() + ". Eacha attribute must have a definition before being set.");
  if(this.$typeDefDescriptor$.lastIndexOf("[]") === this.$typeDefDescriptor$.length - 2) {
    return"array"
  }
  switch(this.$typeDefDescriptor$) {
    case "aura://List":
      return"array";
    case "aura://Boolean":
      return"boolean";
    case "aura://String":
      return"string";
    case "aura://Decimal":
      return"number";
    case "aura://Number":
      return"number";
    case "aura://Integer":
      return"number"
  }
  return"object"
};
goog.$exportProperty$(AttributeDef.prototype, "getNativeType", AttributeDef.prototype.$getNativeType$);
Aura.$Attribute$.$AttributeDef$ = AttributeDef;
function AttributeSet(attributeDefSet) {
  this.$values$ = {};
  this.$shadowValues$ = {};
  this.$decorators$ = {};
  this.$attributeDefSet$ = attributeDefSet;
  this.$destroyed$ = false;
  this["values"] = this.$values$
}
AttributeSet.prototype.hasAttribute = function(name) {
  return this.$values$.hasOwnProperty(name)
};
AttributeSet.$getDef$ = function(key, component) {
  var def = [];
  for(var target = component.$getConcreteComponent$ ? component.$getConcreteComponent$() : component;target;) {
    var tempDef = target.$getDef$ ? target.$getDef$().$getAttributeDefs$().$getDef$(key) : target.$getAttributeDefs$().$getDef$(key);
    if(!tempDef) {
      break
    }
    def[0] = tempDef;
    def[1] = target;
    target = target.$getSuper$ ? target.$getSuper$() : target.$getSuperDef$()
  }
  return def
};
AttributeSet.prototype.get = function(key, component) {
  var value = undefined;
  var path = null;
  var attribute = key;
  key = key.replace(/^body\b/g, "body." + component.$globalId$);
  if(key.indexOf(".") > -1) {
    path = key.split(".");
    attribute = path[0]
  }
  var defs = AttributeSet.$getDef$(attribute, component);
  if(!$A.$clientService$.$allowAccess$(defs[0], defs[1])) {
    var message = "Access Check Failed! AttributeSet.get(): attribute '" + attribute + "' of component '" + component + "' is not visible to '" + $A.$clientService$.$currentAccess$ + "'.";
    if($A.$clientService$.$enableAccessChecks$) {
      if($A.$clientService$.$logAccessFailures$) {
        $A.error(null, new $A.$auraError$(message))
      }
      return undefined
    }else {
      if($A.$clientService$.$logAccessFailures$) {
        $A.$warning$(message)
      }
    }
  }
  if(!path) {
    var decorators = this.$decorators$[key];
    if(decorators && decorators.length) {
      if(decorators.$decorating$) {
        value = decorators.value
      }else {
        decorators.$decorating$ = true;
        decorators.value = this.$values$[key];
        for(var i = 0;i < decorators.length;i++) {
          var decorator = decorators[i];
          value = decorator.value = decorators[i].evaluate()
        }
        decorators.$decorating$ = false;
        decorators.value = null
      }
    }else {
      value = this.$values$[key]
    }
  }else {
    value = aura.$expressionService$.$resolve$(key, this.$values$)
  }
  if(aura["util"].$isExpression$(value)) {
    value = value.evaluate()
  }
  if(this.$shadowValues$.hasOwnProperty(key)) {
    value += this.$getShadowValue$(key)
  }
  return value
};
AttributeSet.prototype.$getBody$ = function(globalId) {
  var key = "body." + globalId;
  var value = this.$values$["body"][globalId];
  if(aura["util"].$isExpression$(value)) {
    value = value.evaluate()
  }
  if(this.$shadowValues$.hasOwnProperty(key)) {
    value += this.$getShadowValue$(key)
  }
  return value
};
AttributeSet.prototype.$getValue$ = function(key) {
  var value = undefined;
  var decorators = this.$decorators$[key];
  if(decorators && decorators.length) {
    if(decorators.$decorating$) {
      value = decorators.value
    }else {
      decorators.$decorating$ = true;
      decorators.value = this.$values$[key];
      for(var i = 0;i < decorators.length;i++) {
        var decorator = decorators[i];
        value = decorator.value = decorators[i].evaluate()
      }
      decorators.$decorating$ = false;
      decorators.value = null
    }
  }else {
    value = this.$values$[key]
  }
  if(aura["util"].$isExpression$(value)) {
    value = value.evaluate()
  }
  if(this.$shadowValues$.hasOwnProperty(key)) {
    value += this.$getShadowValue$(key)
  }
  return value
};
AttributeSet.prototype.$getShadowValue$ = function(key) {
  var value = aura.$expressionService$.$resolve$(key, this.$values$, true);
  if(value instanceof FunctionCallValue) {
    if(this.$shadowValues$.hasOwnProperty(key)) {
      return this.$shadowValues$[key]
    }
    return""
  }
  return undefined
};
AttributeSet.prototype.$setShadowValue$ = function(key, value) {
  var oldValue = aura.$expressionService$.$resolve$(key, this.$values$, true);
  if(oldValue instanceof FunctionCallValue) {
    this.$shadowValues$[key] = value
  }
};
AttributeSet.prototype.set = function(key, value, component) {
  var target = this.$values$;
  var path = null;
  var attribute = key;
  key = key.replace(/^body\b/g, "body." + component.$globalId$);
  if(key.indexOf(".") > -1) {
    path = key.split(".");
    attribute = path[0]
  }
  var defs = AttributeSet.$getDef$(attribute, component);
  if(!$A.$clientService$.$allowAccess$(defs[0], defs[1])) {
    var message = "Access Check Failed! AttributeSet.set(): '" + attribute + "' of component '" + component + "' is not visible to '" + $A.$clientService$.$currentAccess$ + "'.";
    if($A.$clientService$.$enableAccessChecks$) {
      if($A.$clientService$.$logAccessFailures$) {
        $A.error(null, new $A.$auraError$(message))
      }
      return
    }else {
      if($A.$clientService$.$logAccessFailures$) {
        $A.$warning$(message)
      }
    }
  }
  if(!$A["util"].$isUndefinedOrNull$(value) && !this.$isValueValidForAttribute$(key, value)) {
    if(this.$isTypeOfArray$(key)) {
      value = !$A["util"].isArray(value) ? [value] : value
    }else {
    }
  }
  if(path) {
    for(var step = path.shift();path.length > 0;) {
      var nextStep = path.shift();
      var nextTarget = target[step];
      if(nextTarget === undefined) {
        if(isNaN(nextStep)) {
          target[step] = {}
        }else {
          target[step] = []
        }
        target = target[step]
      }else {
        if($A["util"].$isExpression$(nextTarget)) {
          target = nextTarget.evaluate()
        }else {
          target = nextTarget
        }
      }
      step = nextStep
    }
    key = step
  }
  var attrType = defs[0] && defs[0].$getTypeDefDescriptor$();
  var isFacet = attrType === "aura://Aura.Component[]";
  if(isFacet && value) {
    var facet = value;
    if(!$A["util"].isArray(facet)) {
      facet = [facet]
    }
    var facetValue = null;
    for(var i = 0;i < facet.length;i++) {
      facetValue = facet[i];
      if(facetValue) {
        for(;facetValue instanceof PassthroughValue;) {
          facetValue = facetValue.$getComponent$()
        }
        if(facetValue.$setContainerComponentId$) {
          facetValue.$setContainerComponentId$(component.$globalId$)
        }
      }
    }
  }
  if(target[key] instanceof PropertyReferenceValue && !target[key].$isGlobal$) {
    target[key].set(value)
  }else {
    if(!(target[key] instanceof FunctionCallValue)) {
      target[key] = value
    }else {
      $A.$warning$("AttributeSet.set(): unable to override the value for '" + key + "\x3d" + target[key] + "'. FunctionCallValues declared in markup are constant.")
    }
  }
};
AttributeSet.prototype.$clearReference$ = function(key) {
  var oldValue;
  var target = this.$values$;
  var step = key;
  if(key.indexOf(".") >= 0) {
    var path = key.split(".");
    target = aura.$expressionService$.$resolve$(path.slice(0, path.length - 1), target);
    step = path[path.length - 1]
  }
  if(target) {
    oldValue = target[step];
    if(oldValue instanceof PropertyReferenceValue) {
      target[step] = undefined;
      return oldValue
    }
  }
  return null
};
AttributeSet.prototype.$isValueValidForAttribute$ = function(attributeName, value) {
  var attributeDefSet = this.$attributeDefSet$;
  if(attributeName.indexOf(".") >= 0) {
    var path = attributeName.split(".");
    attributeName = path[0];
    if(attributeName !== "body" && path.length > 1) {
      return true
    }
  }
  var attributeDef = attributeDefSet.$getDef$(attributeName);
  if(!attributeDef) {
    return false
  }
  var nativeType = attributeDef.$getNativeType$();
  if($A["util"].$isExpression$(value) || nativeType === "object") {
    return true
  }
  if(nativeType === "array") {
    return $A["util"].isArray(value)
  }
  return typeof value === nativeType
};
AttributeSet.prototype.$isTypeOfArray$ = function(attributeName) {
  if(attributeName.indexOf(".") >= 0) {
    var path = attributeName.split(".");
    attributeName = path[0];
    if(attributeName !== "body" && path.length > 1) {
      return false
    }
  }
  var attributeDef = this.$attributeDefSet$.$getDef$(attributeName);
  return attributeDef && attributeDef.$getNativeType$() === "array"
};
AttributeSet.prototype.$merge$ = function(attributes, attributeDefSet, component) {
  if(attributeDefSet) {
    $A.assert(attributeDefSet instanceof AttributeDefSet, "AttributeSet.merge: A valid AttributeDefSet is required to merge attributes.");
    this.$attributeDefSet$ = attributeDefSet
  }
  this.$initialize$(attributes, component)
};
AttributeSet.prototype.$getDefault$ = function(name) {
  if(name) {
    var attributeDef = this.$attributeDefSet$.$getDef$(name);
    if(attributeDef) {
      return attributeDef.$getDefault$()
    }
  }
  return null
};
AttributeSet.prototype.$destroy$ = function() {
  var expressions = {};
  if(!this.$destroyed$) {
    var values = this.$values$;
    for(var k in values) {
      var v = values[k];
      if(k === "body") {
        for(var globalId in v) {
          var body = v[globalId];
          if(body) {
            for(var j = 0;j < body.length;j++) {
              var bodyCmp = body[j];
              if($A["util"].$isComponent$(bodyCmp) && bodyCmp.$autoDestroy$()) {
                bodyCmp.$destroy$()
              }
            }
          }
        }
        values[k] = undefined;
        continue
      }
      if($A["util"].isArray(v)) {
        var i = 0;
        for(var value;i < v.length;i++) {
          value = v[i];
          if($A["util"].$isExpression$(value)) {
            expressions[k] = value
          }else {
            if($A["util"].$isComponent$(value) && value.$autoDestroy$()) {
              value.$destroy$()
            }
          }
        }
      }else {
        if($A["util"].$isExpression$(v)) {
          expressions[k] = v
        }else {
          if($A["util"].$isComponent$(v) && v.$autoDestroy$()) {
            v.$destroy$()
          }
        }
      }
      values[k] = undefined
    }
    this.$destroyed$ = true
  }
  return expressions
};
AttributeSet.prototype.$initialize$ = function(attributes, component) {
  var attributeDefs = this.$attributeDefSet$.$getValues$();
  var attributeNames = this.$attributeDefSet$.$getNames$();
  if(!attributeDefs || !attributeNames) {
    return
  }
  var configValues = attributes || {};
  for(var i = 0;i < attributeNames.length;i++) {
    var attributeDef = attributeDefs[attributeNames[i]];
    var name = attributeDef.$getDescriptor$().getName();
    var hasAttribute = this.hasAttribute(name);
    var hasValue = configValues.hasOwnProperty(name);
    var value = configValues[name];
    if(!hasValue && !hasAttribute) {
      value = valueFactory.create(this.$getDefault$(name), component);
      hasValue = value !== undefined
    }
    if(hasValue && this.$values$[name] !== value || !hasAttribute) {
      if(hasAttribute && value instanceof FunctionCallValue) {
        if(!this.$decorators$[name]) {
          this.$decorators$[name] = []
        }
        this.$decorators$[name].push(value)
      }else {
        if(!(value instanceof PropertyReferenceValue && value.$equals$(this.$values$[name]))) {
          this.$values$[name] = value
        }
      }
    }
  }
};
Aura.$Attribute$.$AttributeSet$ = AttributeSet;
function AttributeDefSet(configs, defaultNamespace) {
  this.$values$ = {};
  this.$valuesOrder$ = [];
  if(configs) {
    for(var i = 0;i < configs.length;i++) {
      var attributeDef = new AttributeDef(configs[i], defaultNamespace);
      var descriptor = attributeDef.$getDescriptor$();
      if(!descriptor.$namespace$) {
        descriptor.$namespace$ = defaultNamespace
      }
      var name = descriptor.getName();
      this.$values$[name] = attributeDef;
      this.$valuesOrder$.push(name)
    }
  }
}
goog.$exportSymbol$("AttributeDefSet", AttributeDefSet);
AttributeDefSet.prototype.$each$ = function(f) {
  var values = this.$values$;
  var valuesOrder = this.$valuesOrder$;
  if(values) {
    for(var i = 0;i < valuesOrder.length;i++) {
      f(values[valuesOrder[i]], i)
    }
  }
};
goog.$exportProperty$(AttributeDefSet.prototype, "each", AttributeDefSet.prototype.$each$);
AttributeDefSet.prototype.hasAttribute = function(name) {
  return this.$values$.hasOwnProperty(name)
};
AttributeDefSet.prototype.$getDef$ = function(name) {
  return this.$values$ && this.$values$[name.split(".")[0]] || null
};
goog.$exportProperty$(AttributeDefSet.prototype, "getDef", AttributeDefSet.prototype.$getDef$);
AttributeDefSet.prototype.$getNames$ = function() {
  return this.$valuesOrder$
};
goog.$exportProperty$(AttributeDefSet.prototype, "getNames", AttributeDefSet.prototype.$getNames$);
AttributeDefSet.prototype.$getValues$ = function() {
  return this.$values$
};
goog.$exportProperty$(AttributeDefSet.prototype, "getValues", AttributeDefSet.prototype.$getValues$);
Aura.$Attribute$.$AttributeDefSet$ = AttributeDefSet;
Aura.$Method$.$MethodDef$ = function(config) {
  this.$descriptor$ = new DefDescriptor(config["name"]);
  this.$access$ = config[Json.$ApplicationKey$.$ACCESS$];
  this.action = config["action"];
  this.attributes = new AttributeDefSet(config["attributes"], this.$descriptor$.$getNamespace$())
};
goog.$exportSymbol$("Aura.Method.MethodDef", Aura.$Method$.$MethodDef$);
Aura.$Method$.$MethodDef$.prototype.$getDescriptor$ = function() {
  return this.$descriptor$
};
goog.$exportProperty$(Aura.$Method$.$MethodDef$.prototype, "getDescriptor", Aura.$Method$.$MethodDef$.prototype.$getDescriptor$);
function RequiredVersionDef(config) {
  this.$descriptor$ = new DefDescriptor(config["namespace"]);
  this.$namespace$ = config["namespace"];
  this.version = config["version"]
}
RequiredVersionDef.prototype.$getDescriptor$ = function() {
  return this.$descriptor$
};
RequiredVersionDef.prototype.$getNamespace$ = function() {
  return $A["util"].copy(this.$namespace$)
};
RequiredVersionDef.prototype.$getVersion$ = function() {
  return $A["util"].copy(this.version)
};
function RequiredVersionDefSet(configs) {
  if(configs) {
    this.$values$ = {};
    for(var i = 0;i < configs.length;i++) {
      var requiredVersionDef = new RequiredVersionDef(configs[i]);
      var ns = requiredVersionDef.$getDescriptor$().getName();
      this.$values$[ns] = requiredVersionDef
    }
  }
}
RequiredVersionDefSet.prototype.$getDef$ = function(name) {
  var values = this.$values$;
  if(values) {
    return values[name]
  }
  return null
};
function AuraLocalizationContext(config) {
  this.$dateFormat$ = config.$dateFormat$
}
Aura.$L10n$.$AuraLocalizationContext$ = AuraLocalizationContext;
function AuraStorageService() {
  this.$storages$ = {};
  this.$adapters$ = {};
  this.version = "";
  this.$isolationKey$ = "";
  this.$partitionName$ = ""
}
goog.$exportSymbol$("AuraStorageService", AuraStorageService);
AuraStorageService.prototype.$getStorage$ = function(name) {
  $A.assert($A["util"].$isString$(name), "AuraStorageService.getStorage(): 'name' must be a String.");
  return this.$storages$[name]
};
goog.$exportProperty$(AuraStorageService.prototype, "getStorage", AuraStorageService.prototype.$getStorage$);
AuraStorageService.prototype.$getStorages$ = function() {
  return $A["util"].apply({}, this.$storages$)
};
goog.$exportProperty$(AuraStorageService.prototype, "getStorages", AuraStorageService.prototype.$getStorages$);
AuraStorageService.prototype.$initStorage$ = function(config) {
  $A.assert($A["util"].$isObject$(config), "config must be an object");
  $A.assert($A["util"].$isString$(config["name"]) && config["name"], "name must be a non-empty string");
  $A.assert(!this.$storages$[config["name"]], "Storage named '" + config["name"] + "' already exists");
  var validatedConfig = {"name":config["name"], "persistent":!!config["persistent"], "secure":!!config["secure"], "maxSize":$A["util"].$isFiniteNumber$(config["maxSize"]) && config["maxSize"] > 0 ? config["maxSize"] : 1E3 * 1024, "expiration":$A["util"].$isFiniteNumber$(config["expiration"]) && config["expiration"] > 0 ? config["expiration"] : 10, "debugLogging":!!config["debugLogging"], "clearOnInit":$A["util"].$isBoolean$(config["clearOnInit"]) ? config["clearOnInit"] : true, "version":config["version"] ? 
  "" + config["version"] : this.version, "isolationKey":this.$isolationKey$, "autoRefreshInterval":$A["util"].$isFiniteNumber$(config["autoRefreshInterval"]) && config["autoRefreshInterval"] >= 0 ? config["autoRefreshInterval"] : 30, "partitionName":this.$partitionName$};
  var adapterName = this.$selectAdapter$(validatedConfig["persistent"], validatedConfig["secure"]);
  validatedConfig["adapterClass"] = this.$adapters$[adapterName]["adapterClass"];
  var storage = new AuraStorage(validatedConfig);
  this.$storages$[validatedConfig["name"]] = storage;
  return storage
};
goog.$exportProperty$(AuraStorageService.prototype, "initStorage", AuraStorageService.prototype.$initStorage$);
AuraStorageService.prototype.$registerAdapter$ = function(config) {
  $A.assert($A["util"].$isString$(config["name"]) && config["name"], "config.name must be a non-empty string");
  $A.assert($A["util"].$isFunction$(config["adapterClass"]), "config.adapterClass must be a function");
  $A.assert(!this.$adapters$[config["name"]], "Adapter '" + config["name"] + "' already registered");
  var validatedConfig = {"name":config["name"], "adapterClass":config["adapterClass"], "persistent":!!config["persistent"], "secure":!!config["secure"]};
  this.$adapters$[validatedConfig["name"]] = validatedConfig
};
goog.$exportProperty$(AuraStorageService.prototype, "registerAdapter", AuraStorageService.prototype.$registerAdapter$);
AuraStorageService.prototype.$isRegisteredAdapter$ = function(name) {
  $A.assert($A["util"].$isString$(name), "AuraStorageService.isRegisteredAdapter(): 'name' must be a String.");
  return this.$adapters$[name] !== undefined
};
goog.$exportProperty$(AuraStorageService.prototype, "isRegisteredAdapter", AuraStorageService.prototype.$isRegisteredAdapter$);
AuraStorageService.prototype.$getAdapterConfig$ = function(adapter) {
  return this.$adapters$[adapter]
};
goog.$exportProperty$(AuraStorageService.prototype, "getAdapterConfig", AuraStorageService.prototype.$getAdapterConfig$);
AuraStorageService.prototype.$selectAdapter$ = function(persistent, secure) {
  var candidates = [];
  for(var name in this.$adapters$) {
    var adapter = this.$adapters$[name];
    if(!secure || adapter["secure"] === true) {
      candidates.push(adapter)
    }
  }
  if(candidates.length === 0) {
    $A.assert(this.$adapters$[Aura.$Storage$.$MemoryAdapter$["NAME"]], "Memory Aura Storage Adapter was not registered");
    return Aura.$Storage$.$MemoryAdapter$["NAME"]
  }
  var match;
  for(var n = 0;!match && n < candidates.length;n++) {
    var candidate = candidates[n];
    var candidateIsPersistent = candidate["persistent"];
    if(persistent && candidateIsPersistent === true || !persistent && !candidateIsPersistent) {
      match = candidate
    }
  }
  if(!match) {
    match = candidates[0]
  }
  return match["name"]
};
goog.$exportProperty$(AuraStorageService.prototype, "selectAdapter", AuraStorageService.prototype.$selectAdapter$);
AuraStorageService.prototype.$deleteStorage$ = function(name) {
  $A.assert($A["util"].$isString$(name), "AuraStorageService.deleteStorage(): 'name' must be a String.");
  var storage = this.$getStorage$(name);
  if(!storage) {
    return Promise["resolve"]()
  }
  delete this.$storages$[name];
  return storage.$deleteStorage$()
};
goog.$exportProperty$(AuraStorageService.prototype, "deleteStorage", AuraStorageService.prototype.$deleteStorage$);
AuraStorageService.prototype.setVersion = function(version) {
  this.version = (version || "") + ""
};
goog.$exportProperty$(AuraStorageService.prototype, "setVersion", AuraStorageService.prototype.setVersion);
AuraStorageService.prototype.$getVersion$ = function() {
  return this.version
};
goog.$exportProperty$(AuraStorageService.prototype, "getVersion", AuraStorageService.prototype.$getVersion$);
AuraStorageService.prototype.$setIsolation$ = function(isolationKey) {
  this.$isolationKey$ = "" + (isolationKey || "")
};
goog.$exportProperty$(AuraStorageService.prototype, "setIsolation", AuraStorageService.prototype.$setIsolation$);
AuraStorageService.prototype.$setPartition$ = function(partitionName) {
  this.$partitionName$ = "" + (partitionName || "")
};
goog.$exportProperty$(AuraStorageService.prototype, "setPartition", AuraStorageService.prototype.$setPartition$);
Aura.$Services$.$AuraStorageService$ = AuraStorageService;
var AuraStorage = function AuraStorage(config) {
  this.version = "" + config["version"];
  this.$keyPrefix$ = this.$generateKeyPrefix$(config["isolationKey"], this.version);
  config["keyPrefix"] = this.$keyPrefix$;
  this.$ready$ = undefined;
  this.$queue$ = [];
  this.$fallbackMode$ = false;
  this.$config$ = Object.freeze(config);
  var AdapterCtr = config["adapterClass"];
  this.$adapter$ = new AdapterCtr(this.$config$);
  this.$adapterAntiObfuscation$(this.$adapter$);
  this.name = config["name"];
  this.$maxSize$ = config["maxSize"];
  this.$expiration$ = config["expiration"] * 1E3;
  this.$autoRefreshInterval$ = config["autoRefreshInterval"] * 1E3;
  this.$debugLogging$ = config["debugLogging"];
  this.$operationsInFlight$ = 0;
  this.$stats$ = {size:-1};
  this.$sweepInterval$ = Math.min(Math.max(this.$expiration$ * 0.5, AuraStorage["SWEEP_INTERVAL"]["MIN"]), AuraStorage["SWEEP_INTERVAL"]["MAX"]);
  this.$lastSweepTime$ = (new Date).getTime();
  this.$sweepingSuspended$ = false;
  this.$sweepPromise$ = undefined;
  this.log(this.$LOG_LEVEL$.$INFO$, $A["util"].$format$("initializing storage adapter using { maxSize: {0} KB, expiration: {1} sec, autoRefreshInterval: {2} sec, clearStorageOnInit: {3}, isolationKey: {4} }", (this.$maxSize$ / 1024).toFixed(1), (this.$expiration$ / 1E3).toFixed(0), (this.$autoRefreshInterval$ / 1E3).toFixed(0), config["clearOnInit"], this.$keyPrefix$));
  this.$adapter$.$initialize$().$then$(this.$adapterInitialize$.bind(this, true), this.$adapterInitialize$.bind(this, false))
};
goog.$exportSymbol$("AuraStorage", AuraStorage);
AuraStorage.prototype.$LOG_LEVEL$ = {$INFO$:{id:0, $fn$:"log"}, $WARNING$:{id:1, $fn$:"warning"}};
AuraStorage.prototype.$adapterAntiObfuscation$ = function(adapter) {
  adapter.$initialize$ = adapter.$initialize$ || adapter["initialize"];
  adapter.getName = adapter.getName || adapter["getName"];
  adapter.$isSecure$ = adapter.$isSecure$ || adapter["isSecure"];
  adapter.$isPersistent$ = adapter.$isPersistent$ || adapter["isPersistent"];
  adapter.$suspendSweeping$ = adapter.$suspendSweeping$ || adapter["suspendSweeping"];
  adapter.$resumeSweeping$ = adapter.$resumeSweeping$ || adapter["resumeSweeping"];
  adapter.$setItems$ = adapter.$setItems$ || adapter["setItems"];
  adapter.$getItems$ = adapter.$getItems$ || adapter["getItems"];
  adapter.$removeItems$ = adapter.$removeItems$ || adapter["removeItems"];
  adapter.clear = adapter.clear || adapter["clear"];
  adapter.$sweep$ = adapter.$sweep$ || adapter["sweep"];
  adapter.$getSize$ = adapter.$getSize$ || adapter["getSize"];
  adapter.$deleteStorage$ = adapter.$deleteStorage$ || adapter["deleteStorage"];
  this["adapter"] = adapter;
  adapter["getItems"] = adapter.$getItems$;
  adapter["getMRU"] = adapter.$getMRU$;
  adapter["getSize"] = adapter.$getSize$;
  adapter["sweep"] = adapter.$sweep$
};
AuraStorage.prototype.getName = function() {
  return this.$adapter$.getName()
};
goog.$exportProperty$(AuraStorage.prototype, "getName", AuraStorage.prototype.getName);
AuraStorage.prototype.$getSize$ = function() {
  return this.$enqueue$(this.$getSizeInternal$.bind(this))
};
goog.$exportProperty$(AuraStorage.prototype, "getSize", AuraStorage.prototype.$getSize$);
AuraStorage.prototype.$getSizeInternal$ = function(resolve, reject) {
  var that = this;
  this.$adapter$.$getSize$().$then$(function(size) {
    that.$stats$.size = parseInt(size / 1024, 10);
    return size / 1024
  }).$then$(resolve, reject)
};
AuraStorage.prototype.$getMaxSize$ = function() {
  return this.$maxSize$ / 1024
};
goog.$exportProperty$(AuraStorage.prototype, "getMaxSize", AuraStorage.prototype.$getMaxSize$);
AuraStorage.prototype.$enqueue$ = function(execute) {
  var that = this;
  if(this.$ready$ === true) {
    return new Promise(function(resolve, reject) {
      execute(resolve, reject)
    })
  }else {
    if(this.$ready$ === false) {
      return Promise["reject"](new Error(this.$getInitializationError$()))
    }
  }
  return new Promise(function(resolve, reject) {
    that.$queue$.push({"execute":execute, "resolve":resolve, "reject":reject});
    if(that.$ready$ !== undefined) {
      that.$executeQueue$()
    }
  })
};
AuraStorage.prototype.$adapterInitialize$ = function(readyState, error) {
  if(this.$ready$ !== undefined) {
    return
  }
  if(!readyState && !this.$fallbackMode$) {
    this.log(this.$LOG_LEVEL$.$WARNING$, $A["util"].$format$("adapterReady(): {0} adapter failed initialization, falling back to memory adapter", this.$adapter$.getName()));
    this.$logError$({"operation":"adapterReady", "error":error});
    this.$fallbackMode$ = true;
    var adapterClass = $A.$storageService$.$getAdapterConfig$(Aura.$Storage$.$MemoryAdapter$["NAME"])["adapterClass"];
    this.$adapter$ = new adapterClass(this.$config$);
    this.$adapterAntiObfuscation$(this.$adapter$);
    this.$adapter$.$initialize$().$then$(this.$adapterInitialize$.bind(this, true), this.$adapterInitialize$.bind(this, false));
    return
  }
  var that = this;
  var promise;
  if(readyState && this.$config$["clearOnInit"]) {
    promise = (new Promise(function(resolve, reject) {
      that.$clearInternal$(resolve, reject)
    })).$then$(undefined, function() {
    })
  }else {
    promise = Promise["resolve"]()
  }
  promise.$then$(function() {
    that.$ready$ = !!readyState;
    that.$executeQueue$()
  })
};
AuraStorage.prototype.$executeQueue$ = function() {
  var queue = this.$queue$;
  this.$queue$ = [];
  if(this.$ready$) {
    this.log(this.$LOG_LEVEL$.$INFO$, "executeQueue(): adapter completed initialization. Processing " + queue.length + " operations.");
    this.$logError$({"operation":"initialize", "error":"success"})
  }else {
    var message = "executeQueue(): adapter failed initialization, entering permanent error state. All future operations will fail. Failing " + queue.length + " enqueued operations.";
    this.log(this.$LOG_LEVEL$.$WARNING$, message);
    this.$logError$({"operation":"initialize", "error":message})
  }
  for(var i = 0;i < queue.length;i++) {
    if(!this.$ready$) {
      queue[i]["reject"](new Error(this.$getInitializationError$()))
    }else {
      try {
        queue[i]["execute"](queue[i]["resolve"], queue[i]["reject"])
      }catch(e) {
        queue[i]["reject"](e)
      }
    }
  }
};
AuraStorage.prototype.$getInitializationError$ = function() {
  return"AuraStorage[" + this.name + "] adapter failed to initialize"
};
AuraStorage.prototype.clear = function() {
  return this.$enqueue$(this.$clearInternal$.bind(this))
};
goog.$exportProperty$(AuraStorage.prototype, "clear", AuraStorage.prototype.clear);
AuraStorage.prototype.$clearInternal$ = function(resolve, reject) {
  var that = this;
  this.$operationsInFlight$ += 1;
  this.$adapter$.clear().$then$(function() {
    that.$operationsInFlight$ -= 1;
    that.$fireModified$()
  }, function(e) {
    that.$operationsInFlight$ -= 1;
    that.$logError$({"operation":"clear", "error":e});
    throw e;
  }).$then$(resolve, reject)
};
AuraStorage.prototype.get = function(key, includeExpired) {
  $A.assert($A["util"].$isString$(key), "AuraStorage.get(): 'key' must be a String.");
  $A.assert(!includeExpired || $A["util"].$isBoolean$(includeExpired), "AuraStorage.get(): 'includeExpired' must be a Boolean.");
  return this.$getAll$([key], includeExpired).$then$(function(items) {
    if(items) {
      return items[key]
    }
    return undefined
  })
};
goog.$exportProperty$(AuraStorage.prototype, "get", AuraStorage.prototype.get);
AuraStorage.prototype.$inFlightOperations$ = function() {
  return this.$operationsInFlight$
};
goog.$exportProperty$(AuraStorage.prototype, "inFlightOperations", AuraStorage.prototype.$inFlightOperations$);
AuraStorage.prototype.$getAll$ = function(keys, includeExpired) {
  $A.assert(!keys || Array.isArray(keys), "AuraStorage.getAll(): 'keys' must be an Array.");
  $A.assert(!includeExpired || $A["util"].$isBoolean$(includeExpired), "AuraStorage.getAll(): 'includeExpired' must be a Boolean.");
  return this.$enqueue$(this.$getAllInternal$.bind(this, keys, includeExpired))
};
goog.$exportProperty$(AuraStorage.prototype, "getAll", AuraStorage.prototype.$getAll$);
AuraStorage.prototype.$getAllInternal$ = function(keys, includeExpired, resolve, reject) {
  function logHitsAndMisses(storageResults) {
    var hit = [];
    var miss = [];
    var key;
    for(var j = 0;j < keys.length;j++) {
      key = keys[j];
      if(storageResults.hasOwnProperty(key)) {
        hit.push(key)
      }else {
        miss.push(key)
      }
    }
    if(hit.length > 0) {
      that.log(that.$LOG_LEVEL$.$INFO$, "getAll() - HIT on key(s): " + hit.join(", "))
    }
    if(miss.length > 0) {
      that.log(that.$LOG_LEVEL$.$INFO$, "getAll() - MISS on key(s): " + miss.join(", "))
    }
  }
  var that = this;
  var prefixedKeys;
  if(Array.isArray(keys) && keys.length > 0) {
    prefixedKeys = [];
    for(var i = 0;i < keys.length;i++) {
      prefixedKeys.push(this.$keyPrefix$ + keys[i])
    }
  }
  this.$operationsInFlight$ += 1;
  this.$adapter$.$getItems$(prefixedKeys, includeExpired).$then$(function(items) {
    that.$operationsInFlight$ -= 1;
    var now = (new Date).getTime();
    var results = {};
    var item;
    var key;
    for(var k in items) {
      item = items[k];
      if(k.indexOf(that.$keyPrefix$) === 0 && (includeExpired || now < item["expires"])) {
        key = k.substring(that.$keyPrefix$.length);
        results[key] = item["value"]
      }
    }
    if(that.$debugLogging$ && Array.isArray(keys) && keys.length > 0) {
      logHitsAndMisses(results)
    }
    return results
  }).$then$(undefined, function(e) {
    that.$operationsInFlight$ -= 1;
    that.$logError$({"operation":"getAll", "error":e});
    throw e;
  }).$then$(resolve, reject)
};
AuraStorage.prototype.$buildPayload$ = function(key, value, now) {
  var encoded = false;
  var size = $A["util"].$estimateSize$("" + key);
  if(this.$adapter$.$encodeValue$) {
    try {
      value = this.$adapter$.$encodeValue$(value);
      encoded = true;
      size += value.length
    }catch(e) {
    }
  }
  if(!encoded) {
    size += $A["util"].$estimateSize$(value)
  }
  if(size > this.$maxSize$) {
    throw new Error("AuraStorage.set() cannot store " + key + " of size " + size + "b because it's over the max size of " + this.$maxSize$ + "b");
  }
  return[this.$keyPrefix$ + key, {"value":value, "created":now, "expires":now + this.$expiration$, "valueEncoded":encoded}, size]
};
AuraStorage.prototype.set = function(key, value) {
  $A.assert($A["util"].$isString$(key), "AuraStorage.set(): 'key' must be a String.");
  var values = {};
  values[key] = value;
  return this.$setAll$(values)
};
goog.$exportProperty$(AuraStorage.prototype, "set", AuraStorage.prototype.set);
AuraStorage.prototype.$setAll$ = function(values) {
  $A.assert($A["util"].$isObject$(values), "AuraStorage.setAll(): 'values' must be an Object.");
  return this.$enqueue$(this.$setAllInternal$.bind(this, values))
};
goog.$exportProperty$(AuraStorage.prototype, "setAll", AuraStorage.prototype.$setAll$);
AuraStorage.prototype.$setAllInternal$ = function(values, resolve, reject) {
  var now = (new Date).getTime();
  var storablesSize = 0;
  var storables = [];
  var storable;
  try {
    for(var key in values) {
      storable = this.$buildPayload$(key, values[key], now);
      storables.push(storable);
      storablesSize += storable[2]
    }
  }catch(e$$0) {
    this.$logError$({"operation":"setAll", "error":e$$0});
    reject(e$$0);
    return
  }
  if(storablesSize > this.$maxSize$) {
    var e2 = new Error("AuraStorage.set() cannot store " + Object.keys(values).length + " items of total size " + storablesSize + "b because it's over the max size of " + this.$maxSize$ + "b");
    this.$logError$({"operation":"setAll", "error":e2});
    reject(e2);
    return
  }
  var that = this;
  this.$operationsInFlight$ += 1;
  this.$adapter$.$setItems$(storables).$then$(function() {
    that.$operationsInFlight$ -= 1;
    var keys = Object.keys(values);
    that.log(that.$LOG_LEVEL$.$INFO$, "setAll() - " + keys.length + " key(s): " + keys.join(", "));
    that.$fireModified$()
  }, function(e) {
    that.$operationsInFlight$ -= 1;
    that.$logError$({"operation":"setAll", "error":e});
    throw e;
  }).$then$(resolve, reject);
  this.$sweep$()
};
AuraStorage.prototype.remove = function(key, doNotFireModified) {
  $A.assert($A["util"].$isString$(key), "AuraStorage.remove(): 'key' must be a String.");
  $A.assert(!doNotFireModified || $A["util"].$isBoolean$(doNotFireModified), "AuraStorage.remove(): 'doNotFireModified' must be a Boolean.");
  return this.$removeAll$([key], doNotFireModified)
};
goog.$exportProperty$(AuraStorage.prototype, "remove", AuraStorage.prototype.remove);
AuraStorage.prototype.$removeAll$ = function(keys, doNotFireModified) {
  $A.assert($A["util"].isArray(keys), "AuraStorage.removeAll(): 'keys' must be an Array.");
  $A.assert(doNotFireModified === undefined || $A["util"].$isBoolean$(doNotFireModified), "AuraStorage.removeAll(): 'doNotFireModified' must be undefined or a Boolean.");
  return this.$enqueue$(this.$removeAllInternal$.bind(this, keys, doNotFireModified))
};
goog.$exportProperty$(AuraStorage.prototype, "removeAll", AuraStorage.prototype.$removeAll$);
AuraStorage.prototype.$removeAllInternal$ = function(keys, doNotFireModified, resolve, reject) {
  var prefixedKeys = [];
  for(var i = 0;i < keys.length;i++) {
    prefixedKeys.push(this.$keyPrefix$ + keys[i])
  }
  var that = this;
  this.$operationsInFlight$ += 1;
  this.$adapter$.$removeItems$(prefixedKeys).$then$(function() {
    that.$operationsInFlight$ -= 1;
    if(that.$debugLogging$) {
      for(i = 0;i < prefixedKeys.length;i++) {
        that.log(that.$LOG_LEVEL$.$INFO$, "removeAll() - key " + prefixedKeys[i])
      }
    }
    if(!doNotFireModified) {
      that.$fireModified$()
    }
  }, function(e) {
    that.$operationsInFlight$ -= 1;
    that.$logError$({"operation":"removeAll", "error":e});
    throw e;
  }).$then$(resolve, reject)
};
AuraStorage.prototype.$sweep$ = function(ignoreInterval) {
  function doneSweeping(doNotFireModified, e) {
    this.$operationsInFlight$ -= 1;
    this.log(this.$LOG_LEVEL$.$INFO$, "sweep() - complete" + (e ? " (with errors)" : ""));
    this.$logStats$();
    this.$sweepPromise$ = undefined;
    this.$lastSweepTime$ = (new Date).getTime();
    if(!doNotFireModified) {
      this.$fireModified$()
    }
  }
  $A.assert(ignoreInterval === undefined || $A["util"].$isBoolean$(ignoreInterval), "AuraStorage.sweep(): 'ignoreInterval' must be undefined or a Boolean.");
  if(this.$sweepPromise$) {
    return this.$sweepPromise$
  }
  if(!this.$ready$) {
    return Promise["resolve"]()
  }
  if(!$A["finishedInit"]) {
    return Promise["resolve"]()
  }
  var sweepInterval = (new Date).getTime() - this.$lastSweepTime$;
  if(!ignoreInterval && sweepInterval < this.$sweepInterval$) {
    return Promise["resolve"]()
  }
  if(this.$sweepingSuspended$) {
    this.$logStats$();
    return Promise["resolve"]()
  }
  this.$operationsInFlight$ += 1;
  this.$sweepPromise$ = this.$adapter$.$sweep$().$then$(undefined, function(e) {
    this.$logError$({"operation":"sweep", "error":e});
    throw e;
  }.bind(this)).$then$(doneSweeping.bind(this), doneSweeping.bind(this, true));
  return this.$sweepPromise$
};
AuraStorage.prototype.$suspendSweeping$ = function() {
  this.log(this.$LOG_LEVEL$.$INFO$, "suspendSweeping()");
  this.$sweepingSuspended$ = true;
  if(this.$adapter$.$suspendSweeping$) {
    this.$adapter$.$suspendSweeping$()
  }
};
goog.$exportProperty$(AuraStorage.prototype, "suspendSweeping", AuraStorage.prototype.$suspendSweeping$);
AuraStorage.prototype.$resumeSweeping$ = function() {
  this.log(this.$LOG_LEVEL$.$INFO$, "resumeSweeping()");
  this.$sweepingSuspended$ = false;
  if(this.$adapter$.$resumeSweeping$) {
    this.$adapter$.$resumeSweeping$()
  }
  this.$sweep$()
};
goog.$exportProperty$(AuraStorage.prototype, "resumeSweeping", AuraStorage.prototype.$resumeSweeping$);
AuraStorage.prototype.log = function(level, msg, obj) {
  if(this.$debugLogging$ || level.id >= this.$LOG_LEVEL$.$WARNING$.id) {
    $A[level.$fn$]("AuraStorage['" + this.name + "'] " + msg, obj)
  }
};
AuraStorage.prototype.$logError$ = function(payload) {
  $A.$metricsService$.transaction("aura", "error:storage", {"context":{"attributes":{"name":this.name, "adapter":this.getName(), "operation":payload["operation"], "error":payload["error"] && payload["error"].toString()}}})
};
AuraStorage.prototype.$logStats$ = function() {
  if(this.$ready$ !== true) {
    return
  }
  $A.$metricsService$.transaction("aura", "performance:storage-stats", {"context":{"attributes":{"name":this.name, "adapter":this.getName(), "sizeKB":this.$stats$.size, "maxSizeKB":parseInt(this.$getMaxSize$(), 10)}}})
};
AuraStorage.prototype.$isPersistent$ = function() {
  return this.$adapter$.$isPersistent$()
};
goog.$exportProperty$(AuraStorage.prototype, "isPersistent", AuraStorage.prototype.$isPersistent$);
AuraStorage.prototype.$isSecure$ = function() {
  return this.$adapter$.$isSecure$()
};
goog.$exportProperty$(AuraStorage.prototype, "isSecure", AuraStorage.prototype.$isSecure$);
AuraStorage.prototype.$getVersion$ = function() {
  return this.version
};
goog.$exportProperty$(AuraStorage.prototype, "getVersion", AuraStorage.prototype.$getVersion$);
AuraStorage.prototype.$getExpiration$ = function() {
  return this.$expiration$ / 1E3
};
goog.$exportProperty$(AuraStorage.prototype, "getExpiration", AuraStorage.prototype.$getExpiration$);
AuraStorage.prototype.$getDefaultAutoRefreshInterval$ = function() {
  return this.$autoRefreshInterval$
};
AuraStorage.prototype.$deleteStorage$ = function() {
  return this.$enqueue$(this.$deleteStorageInternal$.bind(this))
};
AuraStorage.prototype.$deleteStorageInternal$ = function(resolve, reject) {
  if(!this.$adapter$.$deleteStorage$) {
    resolve();
    return
  }
  var that = this;
  this.$adapter$.$deleteStorage$().$then$(undefined, function(e) {
    that.$logError$({"operation":"deleteStorage", "error":e});
    throw e;
  }).$then$(resolve, reject)
};
AuraStorage.prototype.$generateKeyPrefix$ = function(isolationKey, version) {
  return"" + isolationKey + version + AuraStorage.$KEY_DELIMITER$
};
AuraStorage.prototype.$fireModified$ = function() {
  var e = $A.$eventService$.$getNewEvent$("markup://auraStorage:modified");
  if(e) {
    e.$fire$({"name":this.name})
  }
};
AuraStorage.$KEY_DELIMITER$ = ":";
AuraStorage["SWEEP_INTERVAL"] = {"MIN":6E4, "MAX":3E5};
Aura.$Storage$.$AuraStorage$ = AuraStorage;
Aura.$Services$.$AuraClientServiceMarker$ = 0;
Aura.$Services$.$AuraClientService$AuraXHR$ = function AuraXHR() {
  this.$allowFlowthrough$ = false;
  this.length = 0;
  this.$marker$ = 0;
  this.$request$ = undefined;
  this.$actions$ = {}
};
Aura.$Services$.$AuraClientService$AuraXHR$.prototype.reset = function() {
  this.$request$ = undefined;
  this.$actions$ = {}
};
Aura.$Services$.$AuraClientService$AuraXHR$.prototype.$addAction$ = function(action) {
  if(action) {
    if(this.$actions$["" + action.$getId$()]) {
      throw new $A.$auraError$("Adding duplicate action", null, $A.severity.$QUIET$);
    }
    this.$actions$["" + action.$getId$()] = action
  }
};
Aura.$Services$.$AuraClientService$AuraXHR$.prototype.$getAction$ = function(id) {
  var action;
  var key = id;
  if(!key) {
    var keys = Object.keys(this.$actions$);
    $A.assert(keys.length === 1, "When no ID is specified, there should only be one action in the XHR.");
    if(keys.length === 1) {
      key = keys[0]
    }
  }
  action = this.$actions$[key];
  if(action) {
    this.$actions$[key] = undefined
  }
  return action
};
Aura.$Services$.$AuraClientService$AuraActionCollector$ = function AuraActionCollector() {
  this.$clientActions$ = [];
  this.$clientIndex$ = 0;
  this.$actionsToCollect$ = 0;
  this.$collected$ = [];
  this.$collecting$ = [];
  this.$actionsToComplete$ = [];
  this.$completionIndex$ = 0;
  this.$collectedStorableActions$ = [];
  this.$actionsCompleted$ = 0
};
function AuraClientService(util) {
  this.$_host$ = "";
  this.$_token$ = null;
  this.$_isDisconnected$ = false;
  this.$_parallelBootstrapLoad$ = true;
  this.$auraStack$ = [];
  this.$actionStorage$ = new Aura.$Controller$.$ActionStorage$;
  this.$appcacheDownloadingEventFired$ = false;
  this.$isOutdated$ = false;
  this.$finishedInitDefs$ = false;
  this.$protocols$ = {"layout":true};
  this.$lastSendTime$ = Date.now();
  this.$moduleServices$ = {};
  this.$moduleSchemas$ = {"label":this.$labelSchemaResolver$};
  this.$moduleSchemasCache$ = {};
  this.$clientLibraries$ = {"ckeditor":{$resourceUrl$:"/auraFW/resources/{fwuid}/ckeditor/ckeditor-4.x/rel/ckeditor.js"}, "quill":{$resourceUrl$:"/auraFW/resources/{fwuid}/quill.js"}};
  this.$accessStack$ = [];
  this.$registeredNamespaces$ = {$internal$:{}, $privileged$:{}};
  this.$currentAccess$ = null;
  this.$enableAccessChecks$ = true;
  this.$logAccessFailures$ = true;
  this.$appCacheError$ = false;
  this.$_appNotTearingDown$ = true;
  this.$xhrTimeout$ = undefined;
  this.$appBootstrap$;
  this.$_disableBootstrapCacheCookie$ = "auraDisableBootstrapCache";
  this.$appCacheProgress$ = 0;
  this.$NOOP$ = function() {
  };
  var auraXHR = new Aura.$Services$.$AuraClientService$AuraXHR$;
  this.$availableXHRs$ = [auraXHR];
  this.$allXHRs$ = [auraXHR];
  this.$actionStoreMap$ = {};
  this.$collector$ = undefined;
  this.$xhrExclusivity$ = false;
  this.$actionsQueued$ = [];
  this.$actionsDeferred$ = [];
  if(window.XMLHttpRequest) {
    this.$httpType$ = "generic"
  }else {
    this.$httpType$ = undefined
  }
  this.$_disconnected$ = undefined;
  this.$xhrIdleQueue$ = [];
  this.$optionClientSynchronous$ = true;
  this.$reloadFunction$ = undefined;
  this.$reloadPointPassed$ = false;
  this.$tokenSharing$ = util && util.$isLocalStorageEnabled$();
  this.$maxActionRetries$ = 4;
  this.$handleAppCache$();
  this.$setupBootstrapErrorReloadButton$();
  this.$setupTokenListener$()
}
goog.$exportSymbol$("AuraClientService", AuraClientService);
AuraClientService.$TOKEN_KEY$ = "$AuraClientService.token$";
AuraClientService.$BOOTSTRAP_KEY$ = "$AuraClientService.bootstrap$";
AuraClientService.$BOOT_TIMER_DURATION$ = 3E4;
AuraClientService.$INCOMPLETE_BOOT_THRESHOLD$ = 5;
AuraClientService.$CACHE_BUST_QUERY_PARAM$ = "nocache";
AuraClientService.$SYSTEM_EXCEPTION_EVENT_RETURN_STATUS$ = "SYSTEMERROR";
AuraClientService.$INVALID_SESSION_RETURN_STATUS$ = "INVALIDSESSION";
AuraClientService.$CONSECUTIVE_RELOAD_COUNTER_KEY$ = "__RELOAD_COUNT";
AuraClientService.$UNKNOWN_FRAMEWORK_UID$ = "UNKNOWN";
AuraClientService.prototype.$setQueueSize$ = function(queueSize) {
  var auraXHR;
  if(queueSize === undefined) {
    queueSize = 4
  }
  if(queueSize < 2) {
    throw new $A.$auraError$("number of XHRs must be at least 2, is " + queueSize, null, $A.severity.$QUIET$);
  }
  if(this.$allXHRs$.length === 1) {
    for(var i = 1;i < queueSize;i += 1) {
      auraXHR = new Aura.$Services$.$AuraClientService$AuraXHR$;
      this.$availableXHRs$.push(auraXHR);
      this.$allXHRs$.push(auraXHR)
    }
  }
};
AuraClientService.prototype.$setXHRExclusivity$ = function(xhrExclusivity) {
  if(xhrExclusivity === undefined) {
    xhrExclusivity = false
  }
  this.$xhrExclusivity$ = xhrExclusivity
};
AuraClientService.prototype.$deferPendingActions$ = function() {
  var i;
  var action;
  for(i = 0;i < this.$actionsQueued$.length;i++) {
    action = this.$actionsQueued$[i];
    if(action) {
      action.$setDeferred$()
    }
  }
  for(i = 0;i < this.$actionsDeferred$.length;i++) {
    action = this.$actionsDeferred$[i];
    if(action) {
      action.$setDeferred$()
    }
  }
  if(this.$collector$) {
    for(i = 0;i < this.$collector$.$collecting$.length;i++) {
      action = this.$collector$.$collecting$[i];
      if(action) {
        action.$setDeferred$()
      }
    }
  }
};
AuraClientService.prototype.$getSourceMapsUrl$ = function(descriptor, type) {
  if(window.location) {
    var splitChar = ":";
    var folder = "/components/";
    if(type === "lib") {
      splitChar = ".";
      folder = "/libraries/"
    }
    var parts = descriptor.split("://").pop().split(splitChar);
    return[window.location.origin, folder, parts.join("/"), ".js"].join("")
  }
};
AuraClientService.prototype.$uncommentExporter$ = function(exporter) {
  exporter = exporter.toString();
  var start = exporter.indexOf("/*") + 2;
  var end = exporter.lastIndexOf("*/");
  return start < 0 || end < start ? exporter : exporter.substr(start, end - start)
};
AuraClientService.prototype.$evalExporter$ = function(script, descriptor, type) {
  return $A["util"].$globalEval$("function () {" + script + " }", this.$getSourceMapsUrl$(descriptor, type))
};
AuraClientService.prototype.$decode$ = function(response, noStrip, timedOut) {
  var ret = {};
  var e;
  if(timedOut || this.$isDisconnectedOrCancelled$(response)) {
    this.$setConnected$(false);
    ret["status"] = "INCOMPLETE";
    return ret
  }
  if(this.$_isDisconnected$) {
    e = $A.$eventService$.$getNewEvent$("markup://aura:connectionResumed");
    if(e) {
      this.$_isDisconnected$ = false;
      e.$fire$()
    }
  }
  var text = response["responseText"];
  if(/^\s*</.test(text)) {
    ret["message"] = "Communication error, invalid JSON: " + text;
    ret["status"] = "ERROR";
    return ret
  }
  var status = response["status"];
  if(status !== 200 || $A["util"].$stringEndsWith$(text, "/*ERROR*/")) {
    if(status === 200) {
      text = text.substring(text.indexOf("*/") + 2, text.lastIndexOf("/*"))
    }else {
      if(!noStrip === true && text.charAt(0) === "w") {
        text = text.substring(text.indexOf("\n") + 1)
      }
    }
    var resp = $A["util"].$json$.$decode$(text);
    if($A["util"].$isUndefinedOrNull$(resp)) {
      ret["message"] = "Communication error, invalid JSON: " + text;
      ret["status"] = "ERROR";
      var appCache = window.applicationCache;
      if(appCache && (appCache.status === appCache.IDLE || appCache.status === appCache.UPDATEREADY || appCache.status === appCache.OBSOLETE)) {
        try {
          $A.log("[AuraClientService.decode]: Communication error, status - " + status + ". Check for app cache updates using applicationCache.update()");
          appCache.update()
        }catch(ignore) {
        }
      }
      return ret
    }else {
      if(resp["exceptionEvent"] === true) {
        var evtObj = resp["event"];
        var eventName;
        var eventNamespace;
        if(evtObj["descriptor"]) {
          var descriptor = new DefDescriptor(evtObj["descriptor"]);
          eventName = descriptor.getName();
          eventNamespace = descriptor.$getNamespace$()
        }
        if(eventNamespace === "aura" && eventName === "invalidSession") {
          ret["status"] = AuraClientService.$INVALID_SESSION_RETURN_STATUS$;
          ret["event"] = evtObj;
          return ret
        }
        this.$throwExceptionEvent$(resp);
        if(eventNamespace === "aura" && eventName === "clientOutOfSync") {
          ret["status"] = AuraClientService.$SYSTEM_EXCEPTION_EVENT_RETURN_STATUS$;
          return ret
        }
        ret["status"] = "ERROR";
        ret["message"] = "Received exception event" + (eventNamespace ? " " + eventNamespace + ":" : "") + (eventName ? eventName : "") + " from server";
        return ret
      }else {
        if(resp["message"] && resp["stack"]) {
          ret["message"] = resp["message"] + "\n" + resp["stack"]
        }else {
          ret["message"] = "Communication error, invalid JSON: " + text
        }
        ret["status"] = "ERROR";
        return ret
      }
    }
  }
  if(!noStrip === true && text.charAt(0) === "w") {
    text = text.substring(text.indexOf("\n") + 1)
  }
  var responseMessage = $A["util"].$json$.$decode$(text);
  if($A["util"].$isUndefinedOrNull$(responseMessage)) {
    ret["message"] = "Communication error, invalid JSON: " + text;
    ret["status"] = "ERROR";
    return ret
  }
  ret["status"] = "SUCCESS";
  ret["message"] = responseMessage;
  return ret
};
AuraClientService.prototype.$throwExceptionEvent$ = function(resp) {
  var evtObj = resp["event"];
  var descriptor = evtObj["descriptor"];
  var values = evtObj["attributes"] && evtObj["attributes"]["values"];
  if(evtObj["eventDef"]) {
    $A.$eventService$.$createEventDef$(evtObj["eventDef"])
  }
  if($A.$eventService$.$hasHandlers$(descriptor)) {
    var evt = $A.$eventService$.$getNewEvent$(descriptor);
    if(evtObj["attributes"]) {
      evt.$setParams$(values)
    }
    evt.$fire$()
  }else {
    switch(descriptor) {
      case "markup://aura:noAccess":
        this.$handleNoAccessException$(values);
        break;
      case "markup://aura:clientOutOfSync":
        this.$handleClientOutOfSyncException$();
        break;
      case "markup://aura:invalidSession":
        this.$handleInvalidSessionException$(values);
        break;
      case "markup://aura:systemError":
        this.$handleSystemErrorException$();
        break;
      default:
        this.$handleGenericEventException$()
    }
  }
};
goog.$exportProperty$(AuraClientService.prototype, "throwExceptionEvent", AuraClientService.prototype.$throwExceptionEvent$);
AuraClientService.prototype.$handleNoAccessException$ = function(values) {
  $A.log("[AuraClientService.handleNoAccessException]: Reloading the page.");
  var redirectURL = values["redirectURL"];
  if(redirectURL) {
    window.location = redirectURL
  }else {
    this.$hardRefresh$()
  }
};
AuraClientService.prototype.$handleClientOutOfSyncException$ = function() {
  $A.log("[AuraClientService.handleClientOutOfSyncException]: Client out of sync.");
  this.$setOutdated$()
};
AuraClientService.prototype.$handleInvalidSessionException$ = function(values) {
  var newToken = values["newToken"];
  try {
    this.$invalidSession$(newToken)
  }catch(e) {
    $A.log("[AuraClientService.handleInvalidSessionException]: Invalid session, reloading the page.");
    window.location.reload(true)
  }
};
AuraClientService.prototype.$handleSystemErrorException$ = function() {
  var e = new Error("[SystemErrorException from server] unknown error");
  e.$reported$ = true;
  throw e;
};
AuraClientService.prototype.$handleGenericEventException$ = function() {
  var e = new Error("[GenericEventException from server] Unable to process event");
  e.$reported$ = true;
  throw e;
};
AuraClientService.prototype.$fireDoneWaiting$ = function() {
  $A.$eventService$.$getNewEvent$("markup://aura:doneWaiting").$fire$()
};
AuraClientService.prototype.$tearDown$ = function() {
  this.$_appNotTearingDown$ = false
};
AuraClientService.prototype.$initializeClientLibraries$ = function() {
  var scripts = document.getElementsByTagName("script");
  if(scripts) {
    var i = 0;
    for(var len = scripts.length;i < len;i++) {
      var script = scripts[i];
      if(script.getAttribute("data-src") && !script.getAttribute("src")) {
        var source = script.getAttribute("data-src");
        var name = source.split("/").pop().split(".").shift().toLowerCase();
        var lib = this.$clientLibraries$[name];
        if(lib && lib["loaded"]) {
          continue
        }
        this.$clientLibraries$[name] = $A["util"].apply(lib || {}, {$script$:script, loaded:false, $loading$:[]})
      }
    }
  }
};
AuraClientService.prototype.$loadClientLibrary$ = function(name, callback) {
  function afterLoad() {
    $A.$metricsService$.$transactionEnd$("aura", "performance:loadClientLibrary");
    lib.loaded = true;
    for(var i in lib.$loading$) {
      lib.$loading$[i]()
    }
    lib.$loading$ = []
  }
  $A.assert(typeof name === "string", "AuraClientService.loadClientLibrary(): name must be a String.");
  name = name.toLowerCase();
  var lib = this.$clientLibraries$[name];
  $A.assert(lib, "AuraClientService.loadClientLibrary(): ClientLibrary has not been registered: " + name);
  if(lib.loaded) {
    return callback()
  }
  if(!lib.$script$) {
    var script = window.document.createElement("script");
    script.setAttribute("data-src", lib.$resourceUrl$.replace("{fwuid}", $A.getContext().$fwuid$));
    window.document.body.appendChild(script);
    lib.$script$ = script
  }
  lib.$loading$ = lib.$loading$ || [];
  lib.$loading$.push($A.$getCallback$(callback));
  lib.$script$.onload = afterLoad;
  lib.$script$.onerror = function(event) {
    var message = "Failed to load client library: " + lib.$script$.getAttribute("data-src");
    if(event && event.message) {
      message += ". Caused by: " + event.message
    }
    var error = new $A.$auraError$(message, event && event.error);
    error.$setComponent$(name);
    $A.$warning$(message, error);
    $A.$logger$.$reportError$(error);
    afterLoad(error)
  };
  $A.$metricsService$.$transactionStart$("aura", "performance:loadClientLibrary", {"context":{"attributes":{"library":name}}});
  lib.$script$.src = lib.$script$.getAttribute("data-src")
};
goog.$exportProperty$(AuraClientService.prototype, "loadClientLibrary", AuraClientService.prototype.$loadClientLibrary$);
AuraClientService.prototype.$setInCollection$ = function() {
  this.$auraStack$.push("AuraClientService$collection")
};
AuraClientService.prototype.$clearInCollection$ = function() {
  var name = this.$auraStack$.pop();
  $A.assert(name === "AuraClientService$collection")
};
AuraClientService.prototype.$isDisconnectedOrCancelled$ = function(response) {
  if(response && response.status) {
    if(response.status === 0) {
      return true
    }else {
      if(response.status >= 12E3 && response.status < 13E3) {
        return true
      }
    }
  }else {
    return true
  }
  return false
};
AuraClientService.prototype.$singleAction$ = function(action, actionResponse) {
  var needUpdate;
  var needsRefresh;
  needUpdate = action.$updateFromResponse$(actionResponse);
  needsRefresh = action.$isRefreshAction$();
  if(!action.$abortIfComponentInvalid$(false)) {
    if(needUpdate) {
      action.$finishAction$($A.getContext())
    }
    if(needsRefresh) {
      action.$fireRefreshEvent$("refreshEnd", needUpdate)
    }
  }
};
AuraClientService.prototype.$isBB10$ = function() {
  var ua = navigator.userAgent;
  return ua.indexOf("BB10") > 0 && ua.indexOf("AppleWebKit") > 0
};
AuraClientService.prototype.$getManifestURL$ = function() {
  var htmlNode = document.body.parentNode;
  return htmlNode ? htmlNode.getAttribute("manifest") : null
};
AuraClientService.prototype.$isManifestPresent$ = function() {
  return!!this.$getManifestURL$()
};
AuraClientService.prototype.$countAvailableXHRs$ = function() {
  return this.$availableXHRs$.length
};
AuraClientService.prototype.$getAvailableXHR$ = function(isBackground) {
  if(isBackground && this.$availableXHRs$.length === 1) {
    return null
  }
  var auraXHR = this.$availableXHRs$.pop();
  return auraXHR
};
AuraClientService.prototype.$releaseXHR$ = function(auraXHR) {
  auraXHR.reset();
  this.$availableXHRs$.push(auraXHR);
  if(this.$inFlightXHRs$() === 0) {
    this.$processXHRIdleQueue$()
  }
};
goog.$exportProperty$(AuraClientService.prototype, "releaseXHR", AuraClientService.prototype.$releaseXHR$);
AuraClientService.prototype.$setupBootstrapErrorReloadButton$ = function() {
  var reloadButton = document.getElementById("auraErrorReload");
  if(!reloadButton) {
    return
  }
  reloadButton.href = this.$getHardRefreshURL$()
};
AuraClientService.prototype.$getHardRefreshURL$ = function() {
  var url = location.href;
  if(this.$isBB10$() && window.applicationCache && window.applicationCache.status !== window.applicationCache.UNCACHED) {
    url = location.protocol + "//" + location.host + location.pathname + "?b\x3d" + Date.now()
  }
  var params = "?" + AuraClientService.$CACHE_BUST_QUERY_PARAM$ + "\x3d" + encodeURIComponent(url).replace(/\%20/g, "%2b");
  var hIndex = url.indexOf("#");
  var qIndex = url.indexOf("?");
  var cutIndex = -1;
  if(hIndex > -1 && qIndex > -1) {
    cutIndex = hIndex < qIndex ? hIndex : qIndex
  }else {
    if(hIndex > -1) {
      cutIndex = hIndex
    }else {
      if(qIndex > -1) {
        cutIndex = qIndex
      }
    }
  }
  if(cutIndex > -1) {
    url = url.substring(0, cutIndex)
  }
  var sIndex = url.lastIndexOf("/");
  var appName = url.substring(sIndex + 1, url.length);
  var newUrl = appName + params;
  return newUrl
};
AuraClientService.prototype.$hardRefresh$ = function() {
  var cacheBustKey = "?" + AuraClientService.$CACHE_BUST_QUERY_PARAM$ + "\x3d";
  if(this.$shouldPreventReload$()) {
    var ae = new $A.$auraError$("We can't load the page. Please click Refresh.");
    ae["reported"] = true;
    this.$showErrorDialogWithReload$(ae);
    return
  }
  if(!this.$isManifestPresent$() || location.href.indexOf(cacheBustKey) > -1) {
    $A.log("[AuraClientService.hardRefresh]: Reloading page - " + location.href);
    window.location.reload(true);
    return
  }
  var url = this.$getHardRefreshURL$();
  $A.log("[AuraClientService.hardRefresh]: loading page - " + url);
  history.pushState(null, null, url);
  location.href = url
};
goog.$exportProperty$(AuraClientService.prototype, "hardRefresh", AuraClientService.prototype.$hardRefresh$);
AuraClientService.prototype.$isDevMode$ = function() {
  var context = $A.getContext();
  return!$A["util"].$isUndefined$(context) && context.$getMode$() === "DEV"
};
AuraClientService.prototype.$actualDumpCachesAndReload$ = function(metricsPayload) {
  function reload() {
    $A.log("[AuraClientService:actualDumpCachesAndReload] Reloading the page. Cause - " + JSON.stringify(metricsPayload));
    window.location.reload(true)
  }
  $A.$componentService$.$clearDefsFromStorage$(metricsPayload).$then$(reload, reload)
};
AuraClientService.prototype.$dumpCachesAndReload$ = function(force, metricsPayload) {
  if(this.$reloadFunction$) {
    return
  }
  this.$reloadFunction$ = this.$actualDumpCachesAndReload$.bind(this, metricsPayload);
  if(this.$reloadPointPassed$ || force) {
    if(this.$shouldPreventReload$()) {
      var err = new AuraError("We can't load the page. Please click Refresh.");
      var extraMessage = "Bootstrap state: " + JSON.stringify(this.$getBootstrapState$());
      this.$showErrorDialogWithReload$(err, extraMessage)
    }else {
      this.$reloadFunction$()
    }
    this.$reloadFunction$ = undefined
  }
};
AuraClientService.prototype.$shouldPreventReload$ = function() {
  if(!$A["util"].$isSessionStorageEnabled$()) {
    return false
  }
  try {
    var count = window.sessionStorage.getItem(AuraClientService.$CONSECUTIVE_RELOAD_COUNTER_KEY$);
    count = +count;
    count = isFinite(count) ? count : 0;
    if(count >= AuraClientService.$INCOMPLETE_BOOT_THRESHOLD$) {
      var idb = window.indexedDB;
      if(idb) {
        idb.deleteDatabase(this.$getActionStorageName$());
        idb.deleteDatabase($A.$componentService$.$getComponentDefStorageName$())
      }
      this.$clearReloadCount$();
      return true
    }
    window.sessionStorage.setItem(AuraClientService.$CONSECUTIVE_RELOAD_COUNTER_KEY$, "" + (count + 1));
    return false
  }catch(ignore) {
  }
  return false
};
AuraClientService.prototype.$clearReloadCount$ = function() {
  if(!$A["util"].$isSessionStorageEnabled$()) {
    return
  }
  try {
    window.sessionStorage.removeItem(AuraClientService.$CONSECUTIVE_RELOAD_COUNTER_KEY$)
  }catch(ignore) {
  }
};
AuraClientService.prototype.$showErrorDialogWithReload$ = function(e, additionalLoggedMessage) {
  if(e && e.message) {
    $A.message(e.message, e, true);
    if(e["reported"]) {
      return
    }
    try {
      if(additionalLoggedMessage) {
        e.message = e.message + " " + additionalLoggedMessage
      }
      $A.$logger$.$reportError$(e, undefined, "ERROR", true)
    }catch(e2) {
      var xhr = this.$createXHR$();
      xhr.open("POST", "/aura?r\x3d0", true);
      xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded; charset\x3dISO-8859-13");
      var payload = {"actions":[{"id":"1;a", "descriptor":"aura://ComponentController/ACTION$reportFailedAction", "callingDescriptor":"UNKNOWN", "params":{"failedId":e.id && e.id.toString() || "", "failedAction":e["component"] || "", "clientError":e.message, "clientStack":(e.$stackTrace$ || e.stack || "").toString().substr(0, Aura.$Utils$.$Logger$.$MAX_STACKTRACE_SIZE$), "componentStack":"", "stacktraceIdGen":e["stacktraceIdGen"], "level":"ERROR"}, "version":null}]};
      var context;
      try {
        context = $A.getContext().$encodeForServer$(true)
      }catch(ce) {
        context = $A["util"].$json$.$encode$({"fwuid":AuraClientService.$UNKNOWN_FRAMEWORK_UID$})
      }
      var params = {"message":$A["util"].$json$.$encode$(payload), "aura.context":context};
      var queryString = this.$buildParams$(params);
      xhr.send(queryString)
    }
  }
};
AuraClientService.prototype.$handleAppCache$ = function() {
  function showProgress(progress) {
    if(!isFinite(progress)) {
      return
    }
    acs.$appCacheProgress$ = progress;
    if(!acs.$isDevMode$()) {
      return
    }
    var progressContEl = document.getElementById("auraAppcacheProgress");
    if(progressContEl) {
      if(progress > 0 && progress < 100) {
        progressContEl.style.display = "block";
        var progressEl = progressContEl.firstChild;
        progressEl.firstChild.style.width = progress + "%"
      }else {
        if(progress >= 100) {
          progressContEl.style.display = "none"
        }else {
          if(progress < 0) {
            progressContEl.className = "error"
          }
        }
      }
    }
  }
  function handleAppcacheChecking() {
    acs.$appcacheDownloadingEventFired$ = false
  }
  function handleAppcacheUpdateReady() {
    if(window.applicationCache.swapCache && window.applicationCache.status === window.applicationCache.UPDATEREADY) {
      try {
        window.applicationCache.swapCache()
      }catch(ignore) {
      }
      acs.$dumpCachesAndReload$(false, {"cause":"applicationCache.updateready: Swap old cache for new one."})
    }
  }
  function handleAppcacheError(e) {
    acs.$appCacheError$ = true;
    if(e.stopImmediatePropagation) {
      e.stopImmediatePropagation()
    }
    if(window.applicationCache.status === window.applicationCache.OBSOLETE) {
      return
    }
    if(acs.$isBB10$()) {
      handleAppcacheObsolete();
      return
    }
    if(acs.$isOutdated$ && acs.$appcacheDownloadingEventFired$) {
      acs.$dumpCachesAndReload$(false, {"cause":"applicationCache.error: App gets outdated while downloading app cache resources."});
      return
    }
    showProgress(-1);
    acs.$startBootTimers$();
    acs.$updateAppCacheIfOnlineAndIdle$()
  }
  function handleAppcacheDownloading(e) {
    acs.$appcacheDownloadingEventFired$ = true;
    var progress = Math.round(100 * e.loaded / e.total);
    showProgress(progress + 1)
  }
  function handleAppcacheProgress(e) {
    var progress = Math.round(100 * e.loaded / e.total);
    showProgress(progress)
  }
  function handleAppcacheNoUpdate() {
    showProgress(100);
    if(acs.$isOutdated$) {
      acs.$dumpCachesAndReload$(false, {"cause":"applicationCache.noupdate: App gets outdated even if all app cache resources are up to date."})
    }
  }
  function handleAppcacheCached() {
    showProgress(100)
  }
  function handleAppcacheObsolete() {
    acs.$dumpCachesAndReload$(false, {"cause":"applicationCache.obsolete: App cache resources are obsolete."})
  }
  var acs = this;
  if(window.applicationCache && window.applicationCache.addEventListener) {
    window.applicationCache.addEventListener("checking", handleAppcacheChecking, false);
    window.applicationCache.addEventListener("downloading", handleAppcacheDownloading, false);
    window.applicationCache.addEventListener("updateready", handleAppcacheUpdateReady, false);
    window.applicationCache.addEventListener("error", handleAppcacheError, false);
    window.applicationCache.addEventListener("progress", handleAppcacheProgress, false);
    window.applicationCache.addEventListener("noupdate", handleAppcacheNoUpdate, false);
    window.applicationCache.addEventListener("cached", handleAppcacheCached, false);
    window.applicationCache.addEventListener("obsolete", handleAppcacheObsolete, false)
  }
};
AuraClientService.prototype.$getBootstrapState$ = function() {
  var state = {"inline.js":!!Aura["inlineJsLoaded"], "aura.js":!!Aura["frameworkJsReady"], "appcore.js":!!Aura["appCoreJsReady"], "app.js":!!Aura["appJsReady"], "bootstrap.js":!!Aura["appBootstrap"] || !!Aura["appBootstrapCache"] || !!this.$appBootstrap$};
  if(this.$isManifestPresent$()) {
    state["appcache"] = this.$appCacheProgress$
  }
  return state
};
AuraClientService.prototype.$startBootTimers$ = function() {
  function getBootProgressed(state1, state2) {
    var change = Object.keys(state1).reduce(function(prev, curr) {
      return prev || state1[curr] !== state2[curr]
    }, false);
    return change
  }
  var that = this;
  if(this.$_bootTimerId$) {
    window.clearTimeout(this.$_bootTimerId$)
  }
  var oldState = this.$getBootstrapState$();
  this.$_bootTimerId$ = window.setTimeout(function() {
    if($A["finishedInit"]) {
      return
    }
    var newState = that.$getBootstrapState$();
    var progress = getBootProgressed(oldState, newState);
    if(progress || window.applicationCache && (window.applicationCache.status === window.applicationCache.CHECKING || window.applicationCache.status === window.applicationCache.DOWNLOADING)) {
      that.$startBootTimers$();
      return
    }
    $A.log("[AuraClientService.startBootTimers]: No progress made, reloading the page.");
    window.location.reload(true)
  }, AuraClientService.$BOOT_TIMER_DURATION$)
};
AuraClientService.prototype.$setOutdated$ = function() {
  this.$isOutdated$ = true;
  var logPrefix = "AuraClientService.setOutdated";
  if(!$A.getContext()) {
    this.$actualDumpCachesAndReload$({"cause":logPrefix + ": Exception in inline.js does not create aura context."});
    return
  }
  var appCache = window.applicationCache;
  if(!appCache) {
    this.$dumpCachesAndReload$(false, {"cause":logPrefix + ": App cache not supported."})
  }else {
    if(appCache.status === appCache.UNCACHED) {
      this.$dumpCachesAndReload$(false, {"cause":logPrefix + ": UNCACHED app cache status."})
    }else {
      if(appCache.status === appCache.OBSOLETE) {
        this.$dumpCachesAndReload$(false, {"cause":logPrefix + ": OBSOLETE app cache status."})
      }else {
        if(appCache.status === appCache.IDLE) {
          try {
            $A.log("[" + logPrefix + "]: IDLE app cache status. Check for app cache updates using applicationCache.update()");
            appCache.update()
          }catch(e) {
            this.$dumpCachesAndReload$(false, {"cause":logPrefix + ": IDLE app cache status."})
          }
        }
      }
    }
  }
};
goog.$exportProperty$(AuraClientService.prototype, "setOutdated", AuraClientService.prototype.$setOutdated$);
AuraClientService.prototype.$updateAppCacheIfOnlineAndIdle$ = function() {
  if((!("onLine" in window.navigator) || window.navigator.onLine) && window.applicationCache.status === window.applicationCache.IDLE) {
    try {
      $A.log("[AuraClientService.updateAppCacheIfOnlineAndIdle]: Check for app cache updates using applicationCache.update()");
      window.applicationCache.update();
      return true
    }catch(ignore) {
    }
  }
  return false
};
AuraClientService.prototype.$setConnected$ = function(isConnected) {
  var isDisconnected = !isConnected;
  if(isDisconnected === this.$_isDisconnected$) {
    return
  }
  var e = $A.$eventService$.$getNewEvent$(isDisconnected ? "aura:connectionLost" : "aura:connectionResumed");
  if(e) {
    this.$_isDisconnected$ = isDisconnected;
    e.$fire$()
  }else {
    alert(isDisconnected ? "Connection lost" : "Connection resumed")
  }
};
goog.$exportProperty$(AuraClientService.prototype, "setConnected", AuraClientService.prototype.$setConnected$);
AuraClientService.prototype.$saveTokenToStorage$ = function() {
  var storage = $A.$storageService$.$getStorage$(this.$getActionStorageName$());
  if(storage && storage.$isPersistent$() && $A["util"].$isString$(this.$_token$) && !$A["util"].$isEmpty$(this.$_token$)) {
    var token = this.$_token$;
    var now = (new Date).getTime();
    var tuple = [AuraClientService.$TOKEN_KEY$, {"value":{"token":this.$_token$}, "expires":now + 15768E6, "created":now}, $A["util"].$estimateSize$(AuraClientService.$TOKEN_KEY$) + $A["util"].$estimateSize$(this.$_token$)];
    return storage.$enqueue$(function(resolve) {
      storage.$adapter$.$setItems$([tuple]).$then$(function() {
        $A.log("AuraClientService.saveTokenToStorage(): token persisted");
        resolve(token)
      }, function(err) {
        $A.$warning$("AuraClientService.saveTokenToStorage(): failed to persist token: " + err);
        resolve(token)
      })
    })
  }
  return Promise["resolve"](this.$_token$)
};
AuraClientService.prototype.$loadTokenFromStorage$ = function() {
  var self = this;
  var storage = $A.$storageService$.$getStorage$(this.$getActionStorageName$());
  if(storage && storage.$isPersistent$()) {
    return storage.$enqueue$(function(resolve, reject) {
      storage.$adapter$.$getItems$([AuraClientService.$TOKEN_KEY$]).$then$(function(items) {
        if(items[AuraClientService.$TOKEN_KEY$]) {
          var token = items[AuraClientService.$TOKEN_KEY$]["value"]["token"];
          if($A["util"].$isString$(token) && !$A["util"].$isEmpty$(token)) {
            self.$setToken$(token);
            $A.log("AuraClientService.loadTokenFromStorage(): token loaded");
            resolve(token)
          }else {
            resolve(undefined)
          }
        }else {
          $A.log("AuraClientService.loadTokenFromStorage(): no token found");
          resolve(undefined)
        }
      }).$then$(undefined, function(err) {
        $A.$warning$("AuraClientService.loadTokenFromStorage(): failed to load token: " + err);
        reject(err)
      })
    })
  }
  $A.log("AuraClientService.loadTokenFromStorage(): no Action storage");
  return Promise["resolve"]()
};
AuraClientService.prototype.$initHost$ = function(host) {
  this.$_host$ = host || ""
};
goog.$exportProperty$(AuraClientService.prototype, "initHost", AuraClientService.prototype.$initHost$);
AuraClientService.prototype.$init$ = function(config, token, container) {
  if(token) {
    this.$_token$ = token
  }
  var context = $A.getContext();
  var rootDef = $A.$componentService$.$getComponentDef$(config["componentDef"]);
  context.$setTokens$(rootDef.$tokens$);
  Aura.$bootstrapMark$("appCreationStart");
  var component = $A.$componentService$.$createComponentPriv$(config);
  Aura.$bootstrapMark$("appCreationEnd");
  this.$setCurrentAccess$(component);
  try {
    Aura.$bootstrapMark$("appRenderingStart");
    $A.$renderingService$.$render$(component, container || document.body);
    $A.$renderingService$.$afterRender$(component)
  }catch(e) {
    if(e instanceof $A.$auraError$) {
      throw e;
    }else {
      throw new $A.$auraError$("Error during rendering in init", e, $A.severity.$QUIET$);
    }
  }finally {
    this.$releaseCurrentAccess$();
    Aura.$bootstrapMark$("appRenderingEnd")
  }
  return component
};
goog.$exportProperty$(AuraClientService.prototype, "init", AuraClientService.prototype.$init$);
AuraClientService.prototype.$getCurrentAccessName$ = function() {
  if(!this.$currentAccess$) {
    return null
  }
  if(this.$currentAccess$.$getType$) {
    return this.$currentAccess$.$getType$()
  }else {
    return this.$currentAccess$.$getDescriptor$().$getFullName$()
  }
};
AuraClientService.prototype.$inFlightXHRs$ = function(excludeBackground) {
  if(excludeBackground) {
    var inFlight = $A["util"].filter(this.$allXHRs$, function(xhr) {
      return this.$availableXHRs$.indexOf(xhr) === -1 && !xhr.background
    }, this);
    return inFlight.length
  }
  return this.$allXHRs$.length - this.$availableXHRs$.length
};
goog.$exportProperty$(AuraClientService.prototype, "inFlightXHRs", AuraClientService.prototype.$inFlightXHRs$);
AuraClientService.prototype.$idle$ = function() {
  return this.$actionsQueued$.length === 0 && this.$actionsDeferred$.length === 0 && this.$availableXHRs$.length === this.$allXHRs$.length
};
AuraClientService.prototype.$runWhenXHRIdle$ = function(f) {
  this.$xhrIdleQueue$.push(f);
  if(this.$inFlightXHRs$() === 0) {
    this.$processXHRIdleQueue$();
    return
  }
};
AuraClientService.prototype.$processXHRIdleQueue$ = function() {
  $A.assert(this.$inFlightXHRs$() === 0, "Idle queue should only be processed when no XHRs are in flight");
  if(this.$xhrIdleQueue$.length === 0) {
    return
  }
  var queue = this.$xhrIdleQueue$;
  this.$xhrIdleQueue$ = [];
  for(var i = 0;i < queue.length;i++) {
    try {
      queue[i]()
    }catch(e) {
      $A.log("AuraClientService.processXHRIdleQueue: error thrown by enqueued function", e)
    }
  }
};
AuraClientService.prototype.$areActionsWaiting$ = function() {
  return!(this.$actionsQueued$.length === 0 && this.$actionsDeferred$.length === 0)
};
AuraClientService.prototype.$setNamespacePrivileges$ = function(sentNs) {
  var namespaces = {"internal":this.$registeredNamespaces$.$internal$, "privileged":this.$registeredNamespaces$.$privileged$};
  if(sentNs) {
    for(var x in namespaces) {
      if(sentNs[x]) {
        for(var i = 0;i < sentNs[x].length;i++) {
          namespaces[x][sentNs[x][i]] = true
        }
      }
    }
  }
};
AuraClientService.prototype.$initDefs$ = function() {
  if(!Aura["appCoreJsReady"] || !Aura["appJsReady"]) {
    Aura["appDefsReady"] = this.$initDefs$.bind(this);
    return
  }
  var i;
  var config = Aura["ApplicationDefs"];
  if(config) {
    var libraryDefs = config["libExporter"];
    for(i in libraryDefs) {
      $A.$componentService$.$addLibraryExporter$(i, libraryDefs[i])
    }
    var cmpExporter = config["cmpExporter"];
    for(i in cmpExporter) {
      $A.$componentService$.$addComponent$(i, cmpExporter[i])
    }
    $A.$componentService$.$initEventDefs$(config["eventDefs"]);
    $A.$componentService$.$initLibraryDefs$(config["libraryDefs"]);
    $A.$componentService$.$initControllerDefs$(config["controllerDefs"]);
    $A.$componentService$.$initModuleDefs$(config["moduleDefs"]);
    delete Aura["ApplicationDefs"]
  }
  this.$finishedInitDefs$ = true;
  if(Aura["afterAppDefsReady"]) {
    Aura["afterAppDefsReady"].forEach(function(fn) {
      fn()
    })
  }
  Aura["afterDefsReady"] = true;
  delete Aura["afterAppDefsReady"]
};
goog.$exportProperty$(AuraClientService.prototype, "initDefs", AuraClientService.prototype.$initDefs$);
AuraClientService.prototype.$getAppBootstrap$ = function() {
  if(Aura["appBootstrapStatus"] === "loaded") {
    this.$clearDisableParallelBootstrapLoadOnNextLoad$();
    return{source:"network", value:Aura["appBootstrap"]}
  }else {
    if(Aura["appBootstrapCacheStatus"] === "loaded" && this.$getParallelBootstrapLoad$()) {
      return{source:"cache", value:Aura["appBootstrapCache"]}
    }else {
      if(Aura["appBootstrapStatus"] === "failed" && Aura["appBootstrapCacheStatus"] === "loaded") {
        return{source:"cache", value:Aura["appBootstrapCache"]}
      }else {
        if(Aura["appBootstrapStatus"] === "failed" && Aura["appBootstrapCacheStatus"] === "failed") {
          if(!window.applicationCache || window.applicationCache.status === window.applicationCache.UNCACHED || window.applicationCache.status === window.applicationCache.IDLE) {
            this.$dumpCachesAndReload$(false, {"cause":"AuraClientService.getAppBootstrap: Failed to load bootstrap.js from network or cache."})
          }
        }
      }
    }
  }
  return undefined
};
AuraClientService.prototype.$setAppBootstrapStatus$ = function() {
  if(Aura["appBootstrapStatus"] === "loaded") {
    return
  }
  Aura["appBootstrapStatus"] = "failed";
  if(Aura["afterBootstrapReady"] && Aura["afterBootstrapReady"].length) {
    var queue = Aura["afterBootstrapReady"];
    Aura["afterBootstrapReady"] = [];
    for(var i = 0;i < queue.length;i++) {
      queue[i]()
    }
  }
};
AuraClientService.prototype.$runAfterBootstrapReady$ = function(callback) {
  Aura["afterBootstrapReady"] = Aura["afterBootstrapReady"] || [];
  if(this.$appBootstrap$) {
    callback.call(this, this.$appBootstrap$["data"]["app"]);
    return
  }
  var bootstrap = this.$getAppBootstrap$();
  if(!bootstrap) {
    Aura["afterBootstrapReady"].push(this.$runAfterBootstrapReady$.bind(this, callback));
    return
  }
  var boot = bootstrap.value;
  if(boot["error"]) {
    if(boot["error"]["exceptionEvent"]) {
      this.$throwExceptionEvent$(boot["error"]);
      return
    }else {
      throw new $A.$auraError$("Aura.loadComponent(): Failed to initialize application.\n" + boot["error"]["message"]);
    }
  }
  if(bootstrap.source === "network") {
    if(boot["token"]) {
      $A.log("AuraClientService.runAfterBootstrapReady(): Received updated token from bootstrap");
      this.$setToken$(boot["token"], true)
    }
    if(this.$tokenSharing$ && this.$_token$) {
      $A.log("AuraClientService.runAfterBootstrapReady(): Broadcasting token received during bootstrap");
      this.$broadcastToken$(this.$_token$)
    }
    this.$checkBootstrapUIDs$(Aura["appBootstrapCache"]);
    this.$saveBootstrapToStorage$(boot)
  }
  try {
    if(boot["data"]["components"]) {
      boot["context"]["components"] = boot["data"]["components"]
    }
    $A.getContext()["merge"](boot["context"])
  }catch(e) {
    if(bootstrap.source === "cache" && this.$getParallelBootstrapLoad$() && Aura["appBootstrapStatus"] !== "failed") {
      $A.$warning$("Bootstrap cache merge failed, waiting for bootstrap.js from network");
      Aura["afterBootstrapReady"].push(this.$runAfterBootstrapReady$.bind(this, callback));
      return
    }else {
      throw new $A.$auraError$("AuraClientService.runAfterBootstrapReady: bootstrap from " + bootstrap.source + " failed to merge");
    }
  }
  $A.log("[AuraClientService.runAfterBootstrapReady]: Bootstrap loaded and processed from " + bootstrap.source);
  this.$appBootstrap$ = boot;
  if(bootstrap.source === "cache" && this.$getParallelBootstrapLoad$() && Aura["appBootstrapStatus"] !== "failed") {
    Aura["afterBootstrapReady"].push(function() {
      if(Aura["appBootstrapStatus"] === "loaded") {
        if(Aura["appBootstrap"]["error"]) {
          $A.$warning$("AuraClientService.runAfterBootstrapReady(): bootstrap from network contained error: " + Aura["appBootstrap"]["error"]["message"])
        }else {
          Aura["bootstrapUpgrade"] = this.$appBootstrap$["md5"] !== Aura["appBootstrap"]["md5"];
          if(Aura["appBootstrap"]["token"]) {
            $A.log("AuraClientService.runAfterBootstrapReady(): Received updated token after cached bootstrap");
            this.$setToken$(Aura["appBootstrap"]["token"], true)
          }
          this.$checkBootstrapUIDs$(Aura["appBootstrap"]);
          this.$checkBootstrapUpgrade$()
        }
      }
      delete Aura["appBootstrap"]
    }.bind(this))
  }
  delete Aura["appBootstrap"];
  callback.call(this, boot["data"]["app"])
};
AuraClientService.prototype.$checkBootstrapUIDs$ = function(boot) {
  var context = $A.getContext();
  if(boot && boot["context"] && boot["context"]["fwuid"] && boot["context"]["loaded"] && context) {
    var currentAppDesc = "markup://" + context.$getApp$();
    var currentAppUid = null;
    var bootAppUid = null;
    var currentLoaded = context.$findLoaded$(currentAppDesc);
    if($A["util"].$isObject$(currentLoaded)) {
      currentAppUid = currentLoaded["value"]
    }
    var bootLoaded = context.$findLoaded$(currentAppDesc, boot["context"]["loaded"]);
    if($A["util"].$isObject$(bootLoaded)) {
      bootAppUid = bootLoaded["value"]
    }
    if(context.$fwuid$ !== boot["context"]["fwuid"] || currentAppUid !== bootAppUid) {
      if(!this.$updateAppCacheIfOnlineAndIdle$()) {
        this.$dumpCachesAndReload$(false, {"cause":"AuraClientService.checkBootstrapUIDs: Framework or App UID is different between cached and network version."})
      }
    }
  }
};
AuraClientService.prototype.$checkBootstrapUpgrade$ = function() {
  function fireApplicationRefreshed() {
    $A.$eventService$.$getNewEvent$("markup://aura:applicationRefreshed").$fire$()
  }
  if(Aura["bootstrapUpgrade"] === undefined) {
    return
  }
  $A.log("Checking bootstrap signature: network returned " + (Aura["bootstrapUpgrade"] ? "new" : "same") + " version");
  if($A["finishedInit"] && Aura["bootstrapUpgrade"]) {
    this.$saveBootstrapToStorage$(Aura["appBootstrap"]).$then$(fireApplicationRefreshed, fireApplicationRefreshed)
  }
};
AuraClientService.prototype.$runAfterInitDefs$ = function(callback) {
  if(this.$finishedInitDefs$) {
    return callback()
  }
  Aura["afterAppDefsReady"] = Aura["afterAppDefsReady"] || [];
  Aura["afterAppDefsReady"].push(callback)
};
AuraClientService.prototype.$runAfterAppReady$ = function(callback) {
  if($A["finishedInit"]) {
    return callback()
  }
  Aura["afterAppReady"] = Aura["afterAppReady"] || [];
  Aura["afterAppReady"].push(callback)
};
AuraClientService.prototype.$loadBootstrapFromStorage$ = function() {
  if(Aura["appBootstrap"]) {
    Aura["appBootstrapCacheStatus"] = "failed";
    return Promise["resolve"]()
  }
  var storage = $A.$storageService$.$getStorage$(this.$getActionStorageName$());
  if(!storage || !storage.$isPersistent$()) {
    Aura["appBootstrapCacheStatus"] = "failed";
    return Promise["resolve"]()
  }
  return storage.get(AuraClientService.$BOOTSTRAP_KEY$).$then$(function(value) {
    if(value) {
      Aura["appBootstrapCacheStatus"] = "loaded";
      Aura["appBootstrapCache"] = value
    }else {
      Aura["appBootstrapCacheStatus"] = "failed"
    }
  }, function(err) {
    Aura["appBootstrapCacheStatus"] = "failed";
    $A.$warning$("AuraClientService.loadBootstrapFromStorage(): failed to load bootstrap from storage: " + err)
  })
};
AuraClientService.prototype.$saveBootstrapToStorage$ = function(boot) {
  var storage = $A.$storageService$.$getStorage$(this.$getActionStorageName$());
  if(!storage || !storage.$isPersistent$()) {
    return Promise["resolve"]()
  }
  var that = this;
  var defsPromise = $A.$componentService$.$saveDefsToStorage$(boot["context"], $A.getContext()).$then$(undefined, function(e) {
    $A.$warning$("AuraClientService.saveBootstrapToStorage(): failed to persist bootstrap.js defs: " + e);
    that.$disableParallelBootstrapLoadOnNextLoad$()
  });
  var bootstrapPromise = storage.set(AuraClientService.$BOOTSTRAP_KEY$, boot).$then$(undefined, function(e) {
    $A.$warning$("AuraClientService.saveBootstrapToStorage(): failed to persist bootstrap.js: " + e);
    that.$disableParallelBootstrapLoadOnNextLoad$()
  });
  return Promise["all"]([defsPromise, bootstrapPromise])
};
AuraClientService.prototype.$initializeApplication$ = function() {
  Aura.$bootstrapMark$("runAfterContextCreated");
  var self = this;
  return new Promise(function(resolve) {
    self.$runAfterInitDefs$(function() {
      Aura.$bootstrapMark$("runAfterInitDefsReady");
      self.$runAfterBootstrapReady$(function(bootConfig) {
        Aura.$bootstrapMark$("runAfterBootstrapReady");
        resolve(bootConfig)
      })
    })
  })
};
AuraClientService.prototype.$initializeInjectedServices$ = function(services) {
  if(services) {
    var serviceRegistry = this.$moduleServices$;
    services.forEach(function(serviceDefinition) {
      var serviceConstructor = $A.$componentService$.$evaluateModuleDef$(serviceDefinition);
      var service = serviceConstructor(Aura.$ServiceApi$, $A.$componentService$.$moduleEngine$);
      $A.assert(service.name, "Unknown service name");
      serviceRegistry[service.name] = service
    })
  }
};
AuraClientService.prototype.$addModuleSchemaResolver$ = function(schema, resolver) {
  $A.assert(typeof resolver === "function", "Schema resolver must be a function");
  $A.assert(this.$moduleSchemas$[schema] === undefined, "Unable to add a resolver for schema " + schema + ". A resolver its already registered");
  this.$moduleSchemas$[schema] = resolver
};
goog.$exportProperty$(AuraClientService.prototype, "addModuleSchemaResolver", AuraClientService.prototype.$addModuleSchemaResolver$);
AuraClientService.prototype.$resolveSchemaDependency$ = function(schema, resourceUri, fullImport) {
  if(!this.$moduleSchemasCache$[fullImport]) {
    var resolver = this.$moduleSchemas$[schema];
    $A.assert(resolver, "Unknown schema for '" + schema + "://" + resourceUri + "'. Either the schema is not supported or a resolver hasn't been provided.");
    this.$moduleSchemasCache$[fullImport] = resolver(resourceUri)
  }
  return this.$moduleSchemasCache$[fullImport]
};
AuraClientService.prototype.$labelSchemaResolver$ = function(resourceUri) {
  var parts = resourceUri.split(".");
  $A.assert(parts.length === 2, "Malformed label URI. Static imports for label schema require two parts: section and key");
  return $A.get("$Label." + resourceUri)
};
AuraClientService.prototype.$inAuraLoop$ = function() {
  return this.$auraStack$.length > 0
};
AuraClientService.prototype.$pushStack$ = function(name) {
  this.$auraStack$.push(name)
};
AuraClientService.prototype.$popStack$ = function(name) {
  var lastName;
  if(this.$auraStack$.length > 0) {
    lastName = this.$auraStack$.pop();
    $A.assert(lastName === name, "Broken stack: popped " + lastName + " expected " + name + ", stack \x3d " + this.$auraStack$)
  }else {
    $A.$warning$("Pop from empty stack")
  }
  if(this.$auraStack$.length === 0) {
    this.$auraStack$.push("AuraClientService$popStack");
    this.$postProcess$()
  }
};
AuraClientService.prototype.$postProcess$ = function() {
  if(this.$auraStack$.length === 1 && this.$auraStack$[0] === "AuraClientService$popStack") {
    try {
      this.$process$()
    }catch(e) {
      throw e instanceof $A.$auraError$ ? e : new $A.$auraError$("AuraClientService.postProcess: error in processing", e);
    }
    this.$auraStack$.pop()
  }
};
AuraClientService.prototype.$process$ = function() {
  if(this.$collector$) {
    return
  }
  this.$collector$ = new Aura.$Services$.$AuraClientService$AuraActionCollector$;
  this.$continueProcessing$()
};
AuraClientService.prototype.$continueProcessing$ = function() {
  var i;
  var index = 0;
  var action;
  var actionList;
  var isStorageEnabled = this.$actionStorage$.$isStorageEnabled$();
  this.$collector$.$actionsToCollect$ += 1;
  actionList = this.$actionsQueued$;
  this.$actionsQueued$ = [];
  for(i = 0;i < actionList.length;i++) {
    action = actionList[i];
    try {
      if(action.$abortIfComponentInvalid$(true)) {
        continue
      }
      if(action.$getDef$().$isServerAction$()) {
        this.$collector$.$actionsToCollect$ += 1;
        this.$collector$.$collected$[index] = undefined;
        this.$collector$.$collecting$[index] = action;
        if(!action.$isRefreshAction$() && action.$isStorable$() && isStorageEnabled) {
          this.$collectStorableAction$(action, index)
        }else {
          this.$collectServerAction$(action, index)
        }
        index += 1
      }else {
        this.$collector$.$clientActions$.push(action)
      }
    }catch(e) {
      var errorWrapper = new $A.$auraError$(null, e);
      errorWrapper.action = action;
      $A.$logger$.$reportError$(errorWrapper)
    }
  }
  this.$processStorableActions$();
  this.$collector$.$actionsToCollect$ -= 1;
  this.$collector$.$clientIndex$ = 0;
  if(this.$optionClientSynchronous$) {
    this.$runClientActions$()
  }else {
    this.$continueClientActions$()
  }
};
AuraClientService.prototype.$collectStorableAction$ = function(action, index) {
  this.$collector$.$collectedStorableActions$[index] = action
};
AuraClientService.prototype.$processStorableActions$ = function() {
  var arr;
  var i;
  var action;
  if(this.$collector$.$collectedStorableActions$.length === 0) {
    return
  }
  var collectedStorableActions = this.$collector$.$collectedStorableActions$;
  this.$collector$.$collectedStorableActions$ = [];
  if(!this.$actionStorage$.$isStorageEnabled$()) {
    for(i = 0;i < collectedStorableActions.length;i++) {
      action = collectedStorableActions[i];
      if(!action) {
        this.$collectServerAction$(action, i)
      }
    }
    return
  }
  var keysToActions = {};
  var key;
  for(i = 0;i < collectedStorableActions.length;i++) {
    action = collectedStorableActions[i];
    if(action) {
      key = action.$getStorageKey$();
      if(this.$actionStorage$.$isStoragePersistent$() && this.$actionStorage$.$isKeyAbsentFromCache$(key)) {
        this.$collectServerAction$(action, i);
        continue
      }
      arr = keysToActions[key];
      if(!arr) {
        arr = [];
        keysToActions[key] = arr
      }
      arr.push({action:action, index:i})
    }
  }
  if(Object.keys(keysToActions).length === 0) {
    return
  }
  var that = this;
  this.$actionStorage$.$getAll$(Object.keys(keysToActions)).$then$(function(items) {
    var value;
    for(var k in keysToActions) {
      arr = keysToActions[k];
      value = items[k];
      for(i = 0;i < arr.length;i++) {
        try {
          if(value) {
            that.$executeStoredAction$(arr[i].action, value, that.$collector$.$collected$, arr[i].index);
            that.$collector$.$actionsToCollect$ -= 1
          }else {
            that.$collectServerAction$(arr[i].action, arr[i].index)
          }
        }catch(e) {
          $A.$logger$.$reportError$(e)
        }
      }
      that.$finishCollection$()
    }
  }, function() {
    for(var k in keysToActions) {
      arr = keysToActions[k];
      for(i = 0;i < arr.length;i++) {
        that.$collectServerAction$(arr[i].action, arr[i].index)
      }
    }
  }).$then$(undefined, function(error) {
    $A.$logger$.$reportError$(error)
  })
};
AuraClientService.prototype.$persistStorableActions$ = function(actions) {
  var action;
  var key;
  var value;
  var doStore = false;
  var values = {};
  for(var i = 0;i < actions.length;i++) {
    action = actions[i];
    value = action.$getStored$();
    if(value) {
      try {
        key = action.$getStorageKey$()
      }catch(e) {
        var message = "AuraClientService.persistStorableActions(): Failed to get action storage key";
        var auraError = new $A.$auraError$(message, e);
        $A.$logger$.$reportError$(auraError, action);
        continue
      }
      doStore = true;
      values[key] = value
    }
  }
  if(doStore && this.$actionStorage$.$isStorageEnabled$()) {
    this.$actionStorage$.$setAll$(values).$then$(undefined, function(error) {
      var keys = Object.keys(values);
      $A.$warning$("AuraClientService.persistStorableActions, problem storing " + keys.length + " actions:\n" + keys.join("\n") + "\n" + error)
    })
  }
};
AuraClientService.prototype.$enqueueStoredAction$ = function(action, response) {
  this.$collector$.$actionsToComplete$.push({"action":action, "response":response})
};
AuraClientService.prototype.$executeStoredAction$ = function(action, response, collected, index) {
  var refreshAction = null;
  this.$setInCollection$();
  try {
    if(!action.$abortIfComponentInvalid$(false)) {
      try {
        action.$updateFromResponse$(response);
        action.$finishAction$($A.getContext())
      }catch(e) {
        refreshAction = action.$getRetryFromStorageAction$();
        $A.$warning$("Finishing cached action failed. Trying to refetch from server: " + refreshAction.$getStorageKey$(), e);
        $A.getContext().$clearComponentConfigs$(action.$getId$())
      }
      this.$collector$.$actionsCompleted$ += 1;
      if(!refreshAction) {
        refreshAction = action.$getRefreshAction$(response)
      }
      if(refreshAction) {
        action.$fireRefreshEvent$("refreshBegin");
        collected[index] = refreshAction
      }
    }
  }catch(e$$0) {
    var auraError = new $A.$auraError$("AuraClientService.executeStoredAction(): error happened when processing stored action", e$$0);
    $A.$logger$.$reportError$(auraError, action)
  }finally {
    this.$clearInCollection$()
  }
};
AuraClientService.prototype.$collectServerAction$ = function(action, index) {
  this.$collector$.$collected$[index] = action;
  this.$collector$.$actionsToCollect$ -= 1;
  this.$finishCollection$()
};
AuraClientService.prototype.$continueClientActions$ = function() {
  var that = this;
  if(this.$collector$.$clientIndex$ < this.$collector$.$clientActions$.length) {
    setTimeout(function() {
      that.$setInCollection$();
      that.$executeClientAction$(that.$collector$.$clientActions$[that.$collector$.$clientIndex$]);
      that.$clearInCollection$();
      that.$collector$.$clientIndex$ += 1;
      that.$continueClientActions$()
    }, 0)
  }else {
    this.$collector$.$clientActions$ = [];
    this.$finishCollection$()
  }
};
AuraClientService.prototype.$runClientActions$ = function() {
  var i;
  this.$setInCollection$();
  for(i = 0;i < this.$collector$.$clientActions$.length;i++) {
    this.$executeClientAction$(this.$collector$.$clientActions$[i])
  }
  this.$clearInCollection$();
  this.$collector$.$clientActions$ = [];
  this.$finishCollection$()
};
AuraClientService.prototype.$executeClientAction$ = function(action) {
  try {
    if(!action.$abortIfComponentInvalid$(false)) {
      action.$runDeprecated$();
      action.$finishAction$($A.getContext())
    }
  }catch(ignore) {
  }
};
AuraClientService.prototype.$finishCollection$ = function() {
  if(!this.$collector$ || this.$collector$.$actionsToCollect$ !== 0 || this.$collector$.$clientActions$.length) {
    return
  }
  if(this.$collector$.$actionsCompleted$) {
    this.$fireDoneWaiting$()
  }
  var i = 0;
  var length;
  var collected = this.$collector$.$collected$;
  this.$collector$.$collected$ = [];
  for(i = 0, length = collected.length;i < length;i++) {
    if(collected[i]) {
      this.$actionsDeferred$.push(collected[i])
    }
  }
  if(this.$actionsQueued$.length) {
    this.$continueProcessing$();
    return
  }
  if(this.$actionsDeferred$.length) {
    this.$sendActionXHRs$()
  }
  if(this.$collector$.$actionsToComplete$.length) {
    for(i = 0;i < this.$collector$.$actionsToComplete$.length;i++) {
      this.$collector$.$collected$.push(undefined)
    }
    this.$continueCompletions$()
  }else {
    this.$finishProcessing$()
  }
};
AuraClientService.prototype.$shouldSendOutForegroundActions$ = function(foregroundActions, cabooseCount) {
  if(foregroundActions.length > cabooseCount || cabooseCount > 0 && Date.now() - this.$lastSendTime$ > 6E4) {
    return true
  }else {
    return false
  }
};
AuraClientService.prototype.$sendActionXHRs$ = function() {
  var processing;
  var foreground = [];
  var background = [];
  var publiclyCacheableAndBackground = [];
  var publiclyCacheable = [];
  var deferred = [];
  var action;
  var auraXHR;
  var caboose = 0;
  var i;
  processing = this.$actionsDeferred$;
  this.$actionsDeferred$ = [];
  for(i = 0;i < processing.length;i++) {
    action = processing[i];
    if(action.$abortIfComponentInvalid$(true)) {
      continue
    }
    if(action.$isDeferred$()) {
      deferred.push(action)
    }else {
      if(!action.$isBackground$() && action.$isPubliclyCacheable$()) {
        publiclyCacheable.push(action)
      }else {
        if(action.$isBackground$() && action.$isPubliclyCacheable$()) {
          publiclyCacheableAndBackground.push(action)
        }else {
          if(action.$isBackground$()) {
            background.push(action)
          }else {
            foreground.push(action);
            if(action.$isCaboose$()) {
              caboose += 1
            }
          }
        }
      }
    }
  }
  if(this.$xhrExclusivity$) {
    this.$sendAsSingle$(foreground, foreground.length, {background:false})
  }else {
    if(this.$shouldSendOutForegroundActions$(foreground, caboose)) {
      auraXHR = this.$getAvailableXHR$(false);
      if(auraXHR) {
        if(!this.send(auraXHR, foreground, "POST")) {
          this.$releaseXHR$(auraXHR)
        }
      }
    }
    if(!auraXHR) {
      this.$actionsDeferred$ = this.$actionsDeferred$.concat(foreground)
    }
  }
  if(publiclyCacheable.length) {
    this.$sendAsSingle$(publiclyCacheable, publiclyCacheable.length, {background:false})
  }
  if(publiclyCacheableAndBackground.length) {
    this.$sendAsSingle$(publiclyCacheableAndBackground, publiclyCacheableAndBackground.length, {background:true})
  }
  if(background.length) {
    this.$sendAsSingle$(background, background.length, {background:true})
  }
  if(deferred.length) {
    if(this.$idle$()) {
      this.$sendAsSingle$(deferred, deferred.length, {background:true})
    }else {
      this.$actionsDeferred$ = this.$actionsDeferred$.concat(deferred)
    }
  }
};
AuraClientService.prototype.$sendAsSingle$ = function(actions, count, options) {
  var i;
  var sent = 0;
  var auraXHR;
  var action;
  var background = options && options.background;
  for(i = 0;i < actions.length;i++) {
    action = actions[i];
    if(this.$deDupe$(action, false)) {
      continue
    }
    auraXHR = undefined;
    if(sent < count) {
      sent += 1;
      auraXHR = this.$getAvailableXHR$(background);
      if(auraXHR) {
        if(!this.send(auraXHR, [action], action.$isPubliclyCacheable$() ? "GET" : "POST", options)) {
          this.$releaseXHR$(auraXHR)
        }
      }
    }
    if(!auraXHR) {
      this.$actionsDeferred$.push(action)
    }
  }
};
AuraClientService.prototype.$continueCompletions$ = function() {
  var that = this;
  if(this.$collector$.$completionIndex$ < this.$collector$.$actionsToComplete$.length) {
    setTimeout(function() {
      var collected = [null];
      var completion = that.$collector$.$actionsToComplete$[that.$collector$.$completionIndex$];
      that.$executeStoredAction$(completion["action"], completion["response"], collected, 0);
      that.$collector$.$completionIndex$ += 1;
      if(collected[0]) {
        that.$enqueueAction$(collected[0])
      }
      that.$continueCompletions$()
    }, 0)
  }else {
    if(this.$actionsQueued$.length) {
      this.$continueProcessing$()
    }else {
      this.$finishProcessing$()
    }
  }
};
AuraClientService.prototype.$finishProcessing$ = function() {
  this.$setInCollection$();
  try {
    $A.$renderingService$.$rerenderDirty$()
  }finally {
    this.$clearInCollection$();
    if(this.$actionsQueued$.length > 0) {
      this.$continueProcessing$()
    }else {
      this.$collector$ = undefined
    }
  }
};
AuraClientService.prototype.$deDupe$ = function(action, sending) {
  var key;
  var entry;
  var dupes;
  if(!action.$isStorable$()) {
    return false
  }
  try {
    key = action.$getStorageKey$()
  }catch(e) {
    return false
  }
  entry = this.$actionStoreMap$[key];
  if(entry && !(entry.action.$getState$() === "NEW" || entry.action.$getState$() === "RUNNING")) {
    dupes = entry.$dupes$;
    $A.$warning$("Unfinished handling of action for key " + key);
    entry = undefined
  }
  if(!entry) {
    if(!sending) {
      return false
    }
    entry = {};
    entry.action = action;
    if(dupes) {
      entry.$dupes$ = dupes
    }
    this.$actionStoreMap$[key] = entry;
    this.$actionStoreMap$[action.$getId$()] = key;
    return false
  }else {
    if(entry.action !== action) {
      if(!entry.$dupes$) {
        entry.$dupes$ = [action]
      }else {
        entry.$dupes$.push(action)
      }
      return true
    }
  }
  return false
};
AuraClientService.prototype.$getAndClearDupes$ = function(key) {
  if(!key || !this.$actionStoreMap$[key]) {
    return undefined
  }
  var entry;
  var dupes;
  entry = this.$actionStoreMap$[key];
  dupes = entry.$dupes$;
  delete this.$actionStoreMap$[entry.action.$getId$()];
  delete this.$actionStoreMap$[key];
  return dupes
};
AuraClientService.prototype.send = function(auraXHR, actions, method, options) {
  options = options || {background:false};
  var actionsToSend = [];
  var that = this;
  var action;
  var context = $A.getContext();
  var i;
  for(i = 0;i < actions.length;i++) {
    action = actions[i];
    if(!action.$callAllAboardCallback$(context)) {
      action.$finishAction$(context);
      continue
    }
    if(this.$deDupe$(action, true)) {
      continue
    }
    auraXHR.$addAction$(action);
    if(action.$isChained$()) {
      continue
    }
    actionsToSend.push(action.$prepareToSend$())
  }
  if(actionsToSend.length === 0) {
    return false
  }
  var processed = false;
  var timedOut = false;
  var timerId = undefined;
  var marker = Aura.$Services$.$AuraClientServiceMarker$++;
  var qs;
  var url;
  var loc = window.location;
  try {
    var params = {"message":$A["util"].$json$.$encode$({"actions":actionsToSend}), "aura.context":context.$encodeForServer$(method === "POST", method === "GET")};
    if(method === "GET") {
      params["aura.isAction"] = true
    }else {
      params["aura.pageURI"] = loc.pathname + loc.search + loc.hash;
      params["aura.token"] = this.$_token$
    }
    qs = this.$buildParams$(params)
  }catch(e) {
    for(i = 0;i < actions.length;i++) {
      action = actions[i];
      action.$markException$(e);
      action.$finishAction$(context)
    }
    $A.error("failed to generate parameters for action xhr for action: " + actionsToSend[0], e);
    return false
  }
  if(method === "GET") {
    url = this.$_host$ + "/aura?" + qs
  }else {
    url = this.$_host$ + "/aura?r\x3d" + marker + "\x26" + this.$buildActionNameList$(actionsToSend)
  }
  auraXHR.background = options.background;
  auraXHR.length = qs.length;
  auraXHR.$request$ = this.$createXHR$();
  auraXHR.$request$["open"](method, url, this.$_appNotTearingDown$);
  auraXHR.$marker$ = marker;
  auraXHR.url = url;
  if(this.$_appNotTearingDown$ && "withCredentials" in auraXHR.$request$) {
    auraXHR.$request$["withCredentials"] = true
  }
  var onReady = function() {
    if(processed === false && (auraXHR.$request$["readyState"] === 4 || timedOut)) {
      processed = true;
      if(timerId !== undefined) {
        that.$xhrClearTimeout$(timerId)
      }
      that.$receive$(auraXHR, timedOut)
    }
  };
  if(this.$currentAccess$ && this.$inAuraLoop$()) {
    onReady = $A.$getCallback$(onReady)
  }
  auraXHR.$request$["onreadystatechange"] = onReady;
  if(options["headers"]) {
    var key;
    var headers = options["headers"];
    for(key in headers) {
      if(headers.hasOwnProperty(key)) {
        auraXHR.$request$.setRequestHeader(key, headers[key])
      }
    }
  }
  if(qs && method === "POST") {
    auraXHR.$request$.setRequestHeader("Content-Type", "application/x-www-form-urlencoded; charset\x3dISO-8859-13");
    auraXHR.$request$["send"](qs)
  }else {
    if(method !== "POST") {
      auraXHR.$request$["send"]()
    }else {
      return false
    }
  }
  if(this.$xhrTimeout$ !== undefined) {
    timerId = this.$xhrSetTimeout$(function() {
      timedOut = true;
      timerId = undefined;
      onReady()
    })
  }
  setTimeout(function() {
    $A.$eventService$.$getNewEvent$("markup://aura:waiting").$fire$()
  }, 1);
  this.$lastSendTime$ = Date.now();
  return true
};
AuraClientService.prototype.$sendBeacon$ = function(action) {
  if(window.navigator && window.navigator["sendBeacon"] && window.Blob) {
    try {
      var params = {"message":$A["util"].$json$.$encode$({"actions":[action]}), "aura.context":$A.getContext().$encodeForServer$(true), "aura.token":this.$_token$};
      var blobObj = new Blob([this.$buildParams$(params)], {"type":"application/x-www-form-urlencoded; charset\x3dISO-8859-13"});
      return window.navigator["sendBeacon"](this.$_host$ + "/auraAnalytics", blobObj)
    }catch(e) {
      $A.$warning$("Unable to parse action payload")
    }
  }else {
    $A.$enqueueAction$(action);
    return true
  }
};
goog.$exportProperty$(AuraClientService.prototype, "sendBeacon", AuraClientService.prototype.$sendBeacon$);
AuraClientService.prototype.$xhrSetTimeout$ = function(f) {
  return setTimeout(f, this.$xhrTimeout$)
};
AuraClientService.prototype.$xhrClearTimeout$ = function(id) {
  return clearTimeout(id)
};
AuraClientService.prototype.$createXHR$ = function() {
  if(this.$httpType$) {
    if(this.$httpType$ === "generic") {
      return new XMLHttpRequest
    }else {
      if(this.$httpType$ === "msxml2") {
        return new ActiveXObject("Msxml2.XMLHTTP")
      }else {
        return new ActiveXObject("Microsoft.XMLHTTP")
      }
    }
  }
  if(window.ActiveXObject) {
    try {
      this.$httpType$ = "msxml2";
      return new ActiveXObject("Msxml2.XMLHTTP")
    }catch(e) {
      this.$httpType$ = "msxml";
      return new ActiveXObject("Microsoft.XMLHTTP")
    }
  }else {
    throw new $A.$auraError$("AuraClientService.createXHR: Unable to find an appropriate XHR");
  }
};
AuraClientService.prototype.$buildParams$ = function(map) {
  var arr = [];
  var first = true;
  for(var key in map) {
    if(!first) {
      arr.push("\x26")
    }
    first = false;
    if($A["util"].isArray(map[key])) {
      var valueArray = map[key];
      if(valueArray.length === 0) {
        arr.push(key);
        arr.push("\x3d")
      }else {
        for(var i = 0;i < valueArray.length;i++) {
          if(i > 0) {
            arr.push("\x26")
          }
          arr.push(key);
          arr.push("\x3d");
          arr.push(encodeURIComponent(valueArray[i]))
        }
      }
    }else {
      arr.push(key);
      arr.push("\x3d");
      arr.push(encodeURIComponent(map[key]))
    }
  }
  return arr.join("")
};
AuraClientService.prototype.$buildActionNameList$ = function(actions) {
  var map = {};
  for(var i = 0;i < actions.length;i++) {
    var actionDescriptor = actions[i]["descriptor"];
    var parts = actionDescriptor.split("/");
    var controllerMethod = parts.pop().split("$").pop();
    var controller = parts.pop().split(".").pop().split("Controller").shift();
    var actionName = controller + "." + controllerMethod;
    map[actionName] = map[actionName] ? map[actionName] + 1 : 1
  }
  return this.$buildParams$(map)
};
AuraClientService.prototype.$hydrateActions$ = function(actions, preloadMapId, response) {
  var i;
  var action;
  var xhr = this.$getAvailableXHR$(true);
  if(!xhr) {
    for(i = 0;i < actions.length;i++) {
      action = actions[i];
      this.$actionsDeferred$.unshift(action)
    }
    return
  }
  xhr.$request$ = response;
  for(i = 0;i < actions.length;i++) {
    action = actions[i];
    var id = preloadMapId[action.$getId$()];
    if(id) {
      action.$setId$(id)
    }
    xhr.$addAction$(action)
  }
  this.$receive$(xhr)
};
goog.$exportProperty$(AuraClientService.prototype, "hydrateActions", AuraClientService.prototype.$hydrateActions$);
AuraClientService.prototype.$receive$ = function(auraXHR, timedOut) {
  var responseMessage;
  this.$auraStack$.push("AuraClientService$receive");
  try {
    responseMessage = this.$decode$(auraXHR.$request$, false, timedOut);
    if(responseMessage["status"] === "SUCCESS") {
      this.$processResponses$(auraXHR, responseMessage["message"])
    }else {
      if(responseMessage["status"] === "INCOMPLETE") {
        this.$processIncompletes$(auraXHR)
      }else {
        if(responseMessage["status"] === "ERROR") {
          this.$processErrors$(auraXHR, responseMessage["message"])
        }else {
          if(responseMessage["status"] === AuraClientService.$INVALID_SESSION_RETURN_STATUS$) {
            this.$retryActions$(auraXHR, responseMessage["event"])
          }else {
            if(responseMessage["status"] === AuraClientService.$SYSTEM_EXCEPTION_EVENT_RETURN_STATUS$) {
              this.$processSystemError$(auraXHR)
            }
          }
        }
      }
    }
    this.$fireDoneWaiting$()
  }catch(e) {
    if(e instanceof $A.$auraError$) {
      if(e.action) {
        var failingCmp = e.action.$getComponent$();
        if(failingCmp) {
          var descriptor = failingCmp.$getDef$().$getDescriptor$().toString();
          e.$setComponent$(descriptor)
        }
      }
      throw e;
    }
    throw new $A.$auraError$("AuraClientService.receive action callback failed", e);
  }finally {
    this.$auraStack$.pop();
    this.$releaseXHR$(auraXHR);
    this.$process$()
  }
  return responseMessage
};
AuraClientService.prototype.$retryActions$ = function(auraXHR, event) {
  var newToken = event["attributes"] && event["attributes"]["values"] && event["attributes"]["values"]["newToken"];
  if($A["util"].$isString$(newToken) && !$A["util"].$isEmpty$(newToken) && newToken !== this.$_token$) {
    this.$invalidSession$(newToken);
    $A.log("[AuraClientService].retryActions]: New token received, attempting to retry failed actions");
    for(var name in auraXHR.$actions$) {
      if(auraXHR.$actions$[name].$getRetryCount$() < this.$maxActionRetries$) {
        auraXHR.$actions$[name].$incrementRetryCount$();
        this.$enqueueAction$(auraXHR.$actions$[name])
      }else {
        $A.log("[AuraClientService].retryActions]: Exceeded action retry limit");
        this.$throwExceptionEvent$({event:event});
        this.$processSystemError$(auraXHR);
        break
      }
    }
  }else {
    $A.log("[AuraClientService].retryActions]: Could not retry actions, no token received.");
    this.$throwExceptionEvent$({event:event});
    this.$processSystemError$(auraXHR)
  }
};
AuraClientService.prototype.$processErrors$ = function(auraXHR, errorMessage) {
  var action;
  var actions = auraXHR.$actions$;
  for(var id in actions) {
    if(actions.hasOwnProperty(id)) {
      action = actions[id];
      var error = new Error(errorMessage);
      $A.$warning$("Error in the server action response:" + errorMessage);
      try {
        action.$markError$($A.getContext(), [error])
      }catch(e) {
        if(e instanceof $A.$auraError$) {
          throw e;
        }
        var auraError = new $A.$auraError$("Error happened when processing action errors", e);
        auraError.action = action;
        throw auraError;
      }
    }
  }
};
AuraClientService.prototype.$processSystemError$ = function(auraXHR) {
  var action;
  var actions = auraXHR.$actions$;
  for(var id in actions) {
    if(actions.hasOwnProperty(id)) {
      if(this.$actionStoreMap$[id]) {
        action = actions[id];
        delete this.$actionStoreMap$[id];
        delete this.$actionStoreMap$[action.$getStorageKey$()]
      }
    }
  }
};
AuraClientService.prototype.$processResponses$ = function(auraXHR, responseMessage) {
  var action;
  var actionResponses;
  var response;
  var dupes;
  var token = responseMessage["token"];
  if(token) {
    this.$setToken$(token, true)
  }
  var context = $A.getContext();
  var priorAccess = this.$currentAccess$;
  if(!priorAccess) {
    this.$setCurrentAccess$($A.$getRoot$())
  }
  try {
    if("context" in responseMessage) {
      var responseContext = responseMessage["context"];
      context["merge"](responseContext);
      $A.$componentService$.$saveDefsToStorage$(responseContext, context)
    }
  }catch(e) {
    $A.$logger$.$reportError$(e)
  }finally {
    if(!priorAccess) {
      this.$releaseCurrentAccess$()
    }
  }
  var events = responseMessage["events"];
  if(events) {
    var en = 0;
    for(var len = events.length;en < len;en++) {
      try {
        this.$parseAndFireEvent$(events[en])
      }catch(e$$0) {
        $A.$logger$.$reportError$(e$$0)
      }
    }
  }
  actionResponses = responseMessage["actions"];
  var actionsToPersist = [];
  for(var r = 0;r < actionResponses.length;r++) {
    action = null;
    try {
      response = actionResponses[r];
      $A.assert(!response["id"] ? actionResponses.length === 1 : true, "When an action has no ID, there should be only one action in the response.");
      action = auraXHR.$getAction$(response["id"]);
      if(action) {
        if(response["storable"] && !action.$isStorable$()) {
          action.$setStorable$()
        }
      }else {
        if(response["state"] !== "SUCCESS") {
          continue
        }
        action = this.$buildStorableServerAction$(response)
      }
      if(!action) {
        throw new $A.$auraError$("Unable to find an action for " + response["id"] + ": " + response);
      }else {
        actionsToPersist.push(action);
        var key = this.$actionStoreMap$[action.$getId$()];
        dupes = this.$getAndClearDupes$(key);
        this.$singleAction$(action, response);
        if(dupes) {
          for(var i = 0;i < dupes.length;i++) {
            this.$singleAction$(dupes[i], response)
          }
        }
      }
    }catch(e$$1) {
      if(e$$1 instanceof $A.$auraError$) {
        throw e$$1;
      }
      var auraError = new $A.$auraError$("Error happened when processing action responses", e$$1);
      auraError.action = action;
      throw auraError;
    }
  }
  this.$persistStorableActions$(actionsToPersist)
};
AuraClientService.prototype.$buildStorableServerAction$ = function(response) {
  var action = null;
  if(response["storable"]) {
    var descriptor = response["action"];
    var actionDef = $A.$services$.$component$.$getActionDef$(descriptor);
    if(!actionDef) {
      throw new $A.$auraError$("Missing action definition for " + descriptor);
    }
    action = actionDef.$newInstance$();
    action.$setStorable$();
    if(response["params"]) {
      action.$setParams$(response["params"])
    }
    action.$updateFromResponse$(response)
  }
  return action
};
AuraClientService.prototype.$processIncompletes$ = function(auraXHR) {
  var actions = auraXHR.$actions$;
  var id;
  var action;
  var key;
  var dupes;
  for(id in actions) {
    if(actions.hasOwnProperty(id)) {
      try {
        action = actions[id];
        action.$incomplete$($A.getContext());
        key = this.$actionStoreMap$[action.$getId$()];
        dupes = this.$getAndClearDupes$(key);
        if(dupes) {
          for(var i = 0;i < dupes.length;i++) {
            dupes[i].$incomplete$($A.getContext())
          }
        }
      }catch(e) {
        if(e instanceof $A.$auraError$) {
          throw e;
        }
        var auraError = new $A.$auraError$("Error happened when processing incompleted actions", e);
        auraError.action = action;
        throw auraError;
      }
    }
  }
};
AuraClientService.prototype.$parseAndFireEvent$ = function(evtObj) {
  var descriptor = evtObj["descriptor"];
  if(evtObj["eventDef"]) {
    $A.$eventService$.$createEventDef$(evtObj["eventDef"])
  }
  if($A.$eventService$.$hasHandlers$(descriptor)) {
    var evt = $A.$getEvt$(descriptor);
    if(evtObj["attributes"]) {
      evt.$setParams$(evtObj["attributes"]["values"])
    }
    evt.$fire$()
  }
};
AuraClientService.prototype.$setToken$ = function(newToken, saveToStorage, broadcast) {
  var oldToken = this.$_token$;
  this.$_token$ = newToken;
  if(saveToStorage) {
    this.$saveTokenToStorage$()
  }
  if(broadcast && this.$tokenSharing$ && (!oldToken || newToken !== oldToken)) {
    this.$broadcastToken$(newToken)
  }
};
AuraClientService.prototype.$broadcastToken$ = function(newToken) {
  if(this.$tokenSharing$) {
    $A.log("[AuraClientService.broadcastToken]: Broadcasting new token.");
    window.localStorage.setItem(AuraClientService.$TOKEN_KEY$, newToken)
  }
};
AuraClientService.prototype.$setupTokenListener$ = function() {
  if(this.$tokenSharing$) {
    var self = this;
    if(window.addEventListener) {
      window.addEventListener("storage", function(event) {
        if(event.key === AuraClientService.$TOKEN_KEY$ && event.newValue && event.oldValue !== event.newValue) {
          $A.log("[AuraClientService.tokenListener]: Received new token.");
          self.$_token$ = event.newValue;
          window.localStorage.removeItem(AuraClientService.$TOKEN_KEY$)
        }
      })
    }
  }
};
AuraClientService.prototype.$resetToken$ = function(newToken) {
  this.$setToken$(newToken, true)
};
goog.$exportProperty$(AuraClientService.prototype, "resetToken", AuraClientService.prototype.$resetToken$);
AuraClientService.prototype.$injectComponent$ = function(config, locatorDomId, localId) {
  var context = $A.getContext();
  context["merge"](config["context"]);
  var priorAccess = this.$currentAccess$;
  this.$initializeClientLibraries$();
  var actionResult = config["actions"][0];
  var action = $A.get("c.aura://ComponentController.getComponent");
  var self = this;
  action.$setCallback$(action, function(a) {
    var root = $A.$getRoot$();
    if(!priorAccess) {
      self.$setCurrentAccess$(root)
    }
    try {
      var element = $A["util"].$getElement$(locatorDomId);
      var errors;
      if(!element) {
        element = document.body;
        errors = ["Invalid locatorDomId specified - no element found in the DOM with id\x3d" + locatorDomId]
      }else {
        errors = a.$getState$() === "SUCCESS" ? undefined : action.getError()
      }
      var componentConfig;
      if(!errors) {
        componentConfig = a.$getReturnValue$()
      }else {
        $A.getContext().$clearComponentConfigs$(a.$getId$());
        componentConfig = self.$createIntegrationErrorConfig$(errors)
      }
      $A["util"].apply(componentConfig, {"localId":localId, "attributes":{"valueProvider":root}}, null, true);
      var c = $A.$componentService$.$createComponentPriv$(componentConfig);
      if(!errors) {
        self.$addComponentHandlers$(c, config["actionEventHandlers"])
      }
      var body = root.get("v.body");
      body.push(c);
      root.set("v.body", body, true);
      $A.$render$(c, element);
      $A.$afterRender$(c)
    }finally {
      if(!priorAccess) {
        self.$releaseCurrentAccess$()
      }
    }
  });
  action.$updateFromResponse$(actionResult);
  action.$finishAction$($A.getContext())
};
goog.$exportProperty$(AuraClientService.prototype, "injectComponent", AuraClientService.prototype.$injectComponent$);
AuraClientService.prototype.$createIntegrationErrorConfig$ = function(errorText) {
  return{"componentDef":{"descriptor":"markup://ui:message"}, "attributes":{"valueProvider":$A.$getRoot$(), "values":{"title":"Aura Integration Service Error", "severity":"error", "body":[{"componentDef":{"descriptor":"markup://ui:outputText"}, "attributes":{"values":{"value":$A["util"].$json$.$encode$(errorText)}}}]}}}
};
AuraClientService.prototype.$renderInjection$ = function(component, locator, actionEventHandlers) {
  var error = null;
  var stringLocator = $A["util"].$isString$(locator);
  var hostEl = stringLocator ? document.getElementById(locator) : locator;
  if(!hostEl) {
    error = "Invalid locator specified - " + (stringLocator ? "no element found in the DOM with id\x3d" + locator : "locator element not provided");
    hostEl = document.body
  }
  if(component.$isInstanceOf$("aura:text")) {
    error = component.get("v.value")
  }
  if(error) {
    var errorConfig = this.$createIntegrationErrorConfig$(error);
    errorConfig["localId"] = component.$getLocalId$();
    component = $A.$componentService$.$createComponentPriv$(errorConfig)
  }
  this.$addComponentHandlers$(component, actionEventHandlers);
  $A.$render$(component, hostEl);
  $A.$afterRender$(component)
};
AuraClientService.prototype.$injectComponentAsync$ = function(config, locator, eventHandlers, callback) {
  var self = this;
  var priorAccess = this.$currentAccess$;
  var root = $A.$getRoot$();
  if(!priorAccess) {
    self.$setCurrentAccess$(root)
  }
  try {
    $A.$componentService$.$newComponentAsync$(undefined, function(component) {
      if(callback) {
        callback(component)
      }
      self.$renderInjection$(component, locator, eventHandlers)
    }, config, root, false, false, true)
  }finally {
    if(!priorAccess) {
      self.$releaseCurrentAccess$()
    }
  }
  var labelAction = $A.get("c.aura://ComponentController.loadLabels");
  labelAction.$setCallback$(this, function() {
  });
  self.$enqueueAction$(labelAction)
};
goog.$exportProperty$(AuraClientService.prototype, "injectComponentAsync", AuraClientService.prototype.$injectComponentAsync$);
AuraClientService.prototype.$addComponentHandlers$ = function(component, actionEventHandlers) {
  if(actionEventHandlers) {
    var containerValueProvider = {get:function(functionName) {
      var action = new Action;
      action.$run$ = action.$runDeprecated$ = window[functionName];
      return action
    }};
    for(var evt in actionEventHandlers) {
      component.$addHandler$(evt, containerValueProvider, actionEventHandlers[evt])
    }
  }
};
AuraClientService.prototype.$isConnected$ = function() {
  return!this.$_isDisconnected$
};
goog.$exportProperty$(AuraClientService.prototype, "isConnected", AuraClientService.prototype.$isConnected$);
AuraClientService.prototype.$enqueueAction$ = function(action, background) {
  $A.assert($A["util"].$isAction$(action), "Cannot call EnqueueAction() with a non Action parameter.");
  if(background) {
    $A.$warning$("$A.enqueueAction(): Do not use the deprecated background parameter. The parameter is not used anymore.")
  }
  if(this.$allowFlowthrough$) {
    var isServerAction = action.$getDef$().$isServerAction$() && !action.$isRefreshAction$();
    if(isServerAction && this.$isActionAbsentFromStorage$(action)) {
      var auraXHR = this.$getAvailableXHR$(false);
      if(auraXHR) {
        if(!this.send(auraXHR, [action], action.$isPubliclyCacheable$() ? "GET" : "POST")) {
          this.$releaseXHR$(auraXHR)
        }
        return
      }
    }
  }
  this.$actionsQueued$.push(action)
};
goog.$exportProperty$(AuraClientService.prototype, "enqueueAction", AuraClientService.prototype.$enqueueAction$);
AuraClientService.prototype.$isActionAbsentFromStorage$ = function(action) {
  if(!action || !action.$isStorable$()) {
    return true
  }
  if(!this.$actionStorage$.$isStoragePersistent$() || !this.$actionStorage$.$isActionsFilterInitialized$()) {
    return true
  }
  return this.$actionStorage$.$isKeyAbsentFromCache$(action.$getStorageKey$())
};
AuraClientService.prototype.$isActionInStorage$ = function(descriptor, params, callback) {
  callback = callback || this.$NOOP$;
  if(!$A["util"].$isString$(descriptor) || !$A["util"].$isObject$(params) || !this.$actionStorage$.$isStorageEnabled$()) {
    callback(false);
    return
  }
  var key = Action.$getStorageKey$(descriptor, params);
  if(this.$actionStorage$.$isStoragePersistent$() && this.$actionStorage$.$isKeyAbsentFromCache$(key)) {
    callback(false);
    return
  }
  this.$actionStorage$.get(key).$then$(function(value) {
    $A.$run$(function() {
      callback(!!value)
    })
  }, function(err) {
    $A.$warning$("AuraClientService.isActionInStorage(): storage.get() threw " + err);
    callback(false)
  })
};
goog.$exportProperty$(AuraClientService.prototype, "isActionInStorage", AuraClientService.prototype.$isActionInStorage$);
AuraClientService.prototype.$revalidateAction$ = function(descriptor, params, callback) {
  callback = callback || this.$NOOP$;
  if(!$A["util"].$isString$(descriptor) || !$A["util"].$isObject$(params) || !this.$actionStorage$.$isStorageEnabled$()) {
    callback(false);
    return
  }
  var key = Action.$getStorageKey$(descriptor, params);
  if(this.$actionStorage$.$isStoragePersistent$() && this.$actionStorage$.$isKeyAbsentFromCache$(key)) {
    callback(false);
    return
  }
  var that = this;
  this.$actionStorage$.get(key).$then$(function(value) {
    if(value) {
      that.$actionStorage$.set(key, value).$then$(function() {
        callback(true)
      }, function() {
        callback(false)
      })
    }else {
      callback(false)
    }
  }, function(err) {
    $A.$warning$("AuraClientService.revalidateAction(): storage.get() threw " + err);
    callback(false)
  })
};
goog.$exportProperty$(AuraClientService.prototype, "revalidateAction", AuraClientService.prototype.$revalidateAction$);
AuraClientService.prototype.$invalidateAction$ = function(descriptor, params, successCallback, errorCallback) {
  successCallback = successCallback || this.$NOOP$;
  errorCallback = errorCallback || this.$NOOP$;
  if(!$A["util"].$isString$(descriptor) || !$A["util"].$isObject$(params) || !this.$actionStorage$.$isStorageEnabled$()) {
    successCallback(false);
    return
  }
  var key = Action.$getStorageKey$(descriptor, params);
  if(this.$actionStorage$.$isStoragePersistent$() && this.$actionStorage$.$isKeyAbsentFromCache$(key)) {
    successCallback(true);
    return
  }
  this.$actionStorage$.remove(key).$then$(function() {
    successCallback(true)
  }, errorCallback)
};
goog.$exportProperty$(AuraClientService.prototype, "invalidateAction", AuraClientService.prototype.$invalidateAction$);
AuraClientService.prototype.$isInternalNamespace$ = function(namespace) {
  return this.$registeredNamespaces$.$internal$.hasOwnProperty(namespace)
};
AuraClientService.prototype.$isPrivilegedNamespace$ = function(namespace) {
  return this.$registeredNamespaces$.$privileged$.hasOwnProperty(namespace)
};
AuraClientService.prototype.$getAccessStackHierarchy$ = function() {
  return this.$currentAccess$ ? this.$accessStack$.map(function(component) {
    return"[" + component.$getType$() + "]"
  }).join(" \x3e ") : ""
};
AuraClientService.prototype.$setCurrentAccess$ = function(component) {
  if(!component) {
    component = this.$currentAccess$
  }else {
    for(;component instanceof PassthroughValue;) {
      component = component.$getComponent$()
    }
  }
  if(component) {
    this.$accessStack$.push(component);
    this.$currentAccess$ = component
  }
};
AuraClientService.prototype.$releaseCurrentAccess$ = function() {
  this.$accessStack$.pop();
  this.$currentAccess$ = this.$accessStack$[this.$accessStack$.length - 1]
};
AuraClientService.prototype.$getAccessVersion$ = function(name) {
  var currentAccessCaller = this.$accessStack$[this.$accessStack$.length - 2];
  var ret = null;
  if(currentAccessCaller) {
    var def = currentAccessCaller.$getDef$();
    if(def) {
      if(def.$getDescriptor$().$getNamespace$() === name) {
        ret = currentAccessCaller.get("version")
      }else {
        ret = def.$getRequiredVersionDefs$().$getDef$(name);
        if(ret) {
          ret = ret.$getVersion$()
        }
      }
    }
  }
  return ret
};
AuraClientService.prototype.$allowAccess$ = function(definition, component) {
  if(definition && definition.$getDescriptor$) {
    var currentAccess = this.$currentAccess$;
    if(definition.$access$ === "G") {
      return true
    }else {
      if(definition.$access$ === "p") {
        return currentAccess && (currentAccess === component || currentAccess.$getComponentValueProvider$() === component || currentAccess.$getDef$() === component)
      }else {
        if(!currentAccess) {
          currentAccess = component
        }
        if(currentAccess) {
          var accessDef = null;
          var accessFacetDef = null;
          if(currentAccess.$getComponentValueProvider$ && currentAccess.$getDef$) {
            var accessFacetValueProvider = currentAccess.$getComponentValueProvider$();
            accessFacetDef = accessFacetValueProvider && accessFacetValueProvider.$getDef$();
            accessDef = currentAccess.$getDef$()
          }else {
            accessDef = currentAccess
          }
          var accessDescriptor = accessDef && accessDef.$getDescriptor$();
          var accessFacetDescriptor = accessFacetDef && accessFacetDef.$getDescriptor$();
          var accessNamespace = accessDescriptor && accessDescriptor.$getNamespace$();
          var accessFacetNamespace = accessFacetDescriptor && accessFacetDescriptor.$getNamespace$();
          var allowProtocol = this.$protocols$.hasOwnProperty(accessDescriptor && accessDescriptor.$getPrefix$()) || this.$protocols$.hasOwnProperty(accessFacetDescriptor && accessFacetDescriptor.$getPrefix$());
          var isInternal = allowProtocol || this.$registeredNamespaces$.$internal$.hasOwnProperty(accessNamespace) || this.$registeredNamespaces$.$internal$.hasOwnProperty(accessFacetNamespace);
          if(definition.$access$ === "PP") {
            var isPrivileged = this.$registeredNamespaces$.$privileged$.hasOwnProperty(accessNamespace) || this.$registeredNamespaces$.$privileged$.hasOwnProperty(accessFacetNamespace);
            if(isPrivileged || isInternal) {
              return true
            }
          }
          var effectiveAccess = definition.$access$ || (isInternal ? "I" : "P");
          if(effectiveAccess === "P") {
            var targetNamespace = definition.$getDescriptor$().$getNamespace$();
            if(currentAccess === component || accessNamespace === targetNamespace || accessFacetNamespace === targetNamespace) {
              return true
            }
          }
          if(effectiveAccess === "I") {
            return isInternal
          }
        }
        return definition.$isInstanceOf$ && definition.$isInstanceOf$("aura:application") || (!$A.$getRoot$() || !$A.$getRoot$().$isInstanceOf$("aura:application")) && !this.$currentAccess$ || false
      }
    }
  }
  return false
};
AuraClientService.prototype.$invalidSession$ = function(newToken) {
  function refresh(disableParallelBootstrapLoad) {
    if(disableParallelBootstrapLoad) {
      self.$disableParallelBootstrapLoadOnNextLoad$()
    }
    $A.log("[AuraClientService.invalidSession]: Reloading the page.");
    self.$hardRefresh$()
  }
  var self = this;
  if($A["util"].$isString$(newToken) && !$A["util"].$isEmpty$(newToken) && newToken !== this.$_token$) {
    if(this.$tokenSharing$) {
      $A.log("[AuraClientService.invalidSession]: Token sharing enabled, attempting token update.");
      this.$setToken$(newToken, false, true);
      this.$saveTokenToStorage$().$then$(undefined, refresh.bind(null, true))
    }else {
      this.$_token$ = newToken;
      this.$saveTokenToStorage$().$then$(refresh.bind(null, false), refresh.bind(null, true)).$then$(undefined, function(err) {
        $A.$warning$("AuraClientService.invalidSession(): Failed to refresh, " + err)
      })
    }
  }else {
    refresh(true)
  }
};
goog.$exportProperty$(AuraClientService.prototype, "invalidSession", AuraClientService.prototype.$invalidSession$);
AuraClientService.prototype.$setParallelBootstrapLoad$ = function(parallel) {
  this.$_parallelBootstrapLoad$ = !!parallel
};
goog.$exportProperty$(AuraClientService.prototype, "setParallelBootstrapLoad", AuraClientService.prototype.$setParallelBootstrapLoad$);
AuraClientService.prototype.$disableParallelBootstrapLoadOnNextLoad$ = function() {
  if(this.$actionStorage$.$isStoragePersistent$()) {
    var duration = 1E3 * 60 * 60 * 24 * 7;
    $A["util"]["setCookie"](this.$_disableBootstrapCacheCookie$, "true", duration)
  }
};
AuraClientService.prototype.$clearDisableParallelBootstrapLoadOnNextLoad$ = function() {
  $A["util"].$clearCookie$(this.$_disableBootstrapCacheCookie$)
};
AuraClientService.prototype.$getParallelBootstrapLoad$ = function() {
  if(!this.$_parallelBootstrapLoad$) {
    return false
  }
  var cookie = $A["util"].$getCookie$(this.$_disableBootstrapCacheCookie$);
  return cookie !== "true"
};
AuraClientService.prototype.$setXHRTimeout$ = function(timeout) {
  $A.assert($A["util"].$isFiniteNumber$(timeout) && timeout > 0, "Timeout must be a positive number");
  this.$xhrTimeout$ = timeout
};
goog.$exportProperty$(AuraClientService.prototype, "setXHRTimeout", AuraClientService.prototype.$setXHRTimeout$);
AuraClientService.prototype.$populateActionsFilter$ = function() {
  var context = $A.getContext();
  if(!context.$globalValueProviders$.$LOADED_FROM_PERSISTENT_STORAGE$) {
    return Promise["resolve"]()
  }
  return this.$actionStorage$.$populateActionsFilter$().$then$(function(items) {
    $A.log("ActionStorage: restored " + Object.keys(items).length + " actions")
  })
};
AuraClientService.prototype.$setPersistedActionsFilter$ = function(enable) {
  this.$actionStorage$.$enableActionsFilter$(enable)
};
goog.$exportProperty$(AuraClientService.prototype, "setPersistedActionsFilter", AuraClientService.prototype.$setPersistedActionsFilter$);
AuraClientService.prototype.$clearActionsFilter$ = function() {
  this.$actionStorage$.$clearActionsFilter$()
};
AuraClientService.prototype.$getActionStorage$ = function() {
  return this.$actionStorage$
};
AuraClientService.prototype.$getActionStorageName$ = function() {
  return this.$actionStorage$.$STORAGE_NAME$
};
AuraClientService.prototype.$getCurrentAccessGlobalId$ = function() {
  var owner = null;
  if(!$A["util"].$isUndefinedOrNull$(this.$currentAccess$)) {
    owner = this.$currentAccess$.$globalId$
  }
  return owner
};
Aura.$Services$.$AuraClientService$ = AuraClientService;
function AuraComponentContext() {
  this.stack = []
}
AuraComponentContext.prototype.$Frame$ = function(cmp) {
  this.$cmp$ = cmp;
  this.$notes$ = undefined
};
AuraComponentContext.prototype.push = function(cmp) {
  var prior = this.stack.length ? this.stack[this.stack.length - 1].$cmp$ : undefined;
  this.stack.push(new this.$Frame$(cmp));
  return prior
};
AuraComponentContext.prototype.pop = function(cmp) {
  var oldFrame = this.stack.pop();
  if(cmp) {
    $A.assert(cmp === oldFrame.$cmp$, "ComponentContext mismatch detected.")
  }
  return oldFrame.$cmp$
};
AuraComponentContext.prototype.$currentContext$ = function() {
  var len = this.stack.length;
  return len ? this.stack[len - 1].$cmp$ : undefined
};
AuraComponentContext.prototype.$addNote$ = function(k, v) {
  if(!this.stack.length) {
    return
  }
  var top = this.stack[this.stack.length - 1];
  if(top.$notes$ === undefined) {
    top.$notes$ = {}
  }
  top[k] = v
};
AuraComponentContext.prototype.$getNote$ = function(k) {
  if(!this.stack.length) {
    return undefined
  }
  var top = this.stack[this.stack.length - 1];
  if(!top.$notes$) {
    return undefined
  }
  return top[k]
};
AuraComponentContext.prototype.$clearNote$ = function(k) {
  if(!this.stack.length) {
    return
  }
  var top = this.stack[this.stack.length - 1];
  if(!top.$notes$) {
    return
  }
  delete top[k]
};
Aura.$Services$.$AuraComponentContext$ = AuraComponentContext;
function AuraComponentService() {
  this.$moduleEngine$ = window["Engine"];
  this.$wrappedEngine$ = undefined;
  this.$moduleDefRegistry$ = {};
  this.$moduleRegistry$ = {};
  this.$componentDefRegistry$ = {};
  this.$controllerDefRegistry$ = {};
  this.$actionDefRegistry$ = {};
  this.$modelDefRegistry$ = {};
  this.$libraryRegistry$ = new Aura.$Library$.$LibraryRegistry$;
  this.$libraryIncludeRegistry$ = new Aura.$Library$.$LibraryIncludeRegistry$;
  this.$componentClassRegistry$ = new Aura.$Component$.$ComponentClassRegistry$;
  this.$componentDefStorage$ = new Aura.$Component$.$ComponentDefStorage$;
  this.$actionStorage$ = new Aura.$Controller$.$ActionStorage$;
  this.$moduleNameToDescriptorLookup$ = {};
  this.$moduleStyleBuffer$ = [];
  this.$savedComponentConfigs$ = {};
  this.$controllerDefRelationship$ = {};
  this.$actionDefRelationship$ = {};
  this.$indexes$ = {$globalId$:{}};
  this.$dynamicNamespaces$ = [];
  this.$flavorable$ = "auraFlavorable";
  this.$renderedBy$ = "auraRenderedBy";
  this["renderedBy"] = this.$renderedBy$;
  this.$initCoreModules$();
  this.$trackingCreate$ = false
}
goog.$exportSymbol$("AuraComponentService", AuraComponentService);
AuraComponentService.prototype.get = function(globalId) {
  return this.$indexes$.$globalId$[globalId]
};
goog.$exportProperty$(AuraComponentService.prototype, "get", AuraComponentService.prototype.get);
AuraComponentService.prototype.$initCoreModules$ = function() {
  var babelHelpers = window["EngineHelpers"] && window["EngineHelpers"]["babelHelpers"];
  var ProxyObject = window["Proxy"] || {};
  this.$addModule$("markup://engine", "engine", [], null, this.$moduleEngine$);
  this.$addModule$("markup://assert", "assert", [], null, Aura.$ExportsAssert$);
  this.$addModule$("markup://logger", "logger", [], null, Aura.$ExportsLogger$);
  this.$addModule$("markup://aura", "aura", [], null, Aura.$ExportsModule$);
  this.$addModule$("markup://aura-storage", "aura-storage", [], null, Aura.$ExportsStorage$);
  this.$addModule$("markup://aura-instrumentation", "aura-instrumentation", [], null, Aura.$ExportsMetricsService$);
  var proxyPrefix = "proxy-compat/";
  Object.keys(ProxyObject).forEach(function(helper) {
    var moduleName = proxyPrefix + helper;
    this.$addModule$("markup://" + moduleName, moduleName, [], null, ProxyObject[helper])
  }.bind(this));
  if(babelHelpers) {
    var babelHelpersPrefix = "babel/helpers/";
    Object.keys(babelHelpers).forEach(function(helper) {
      var moduleName = babelHelpersPrefix + helper;
      this.$addModule$("markup://" + moduleName, moduleName, [], null, babelHelpers[helper])
    }.bind(this));
    this.$addModule$("markup://babel/regeneratorRuntime", "babel/regenerator", [], null, babelHelpers["regeneratorRuntime"])
  }
};
AuraComponentService.prototype.$getComponent$ = function(identifier) {
  return this.get(identifier) || this.$getRenderingComponentForElement$(identifier)
};
goog.$exportProperty$(AuraComponentService.prototype, "getComponent", AuraComponentService.prototype.$getComponent$);
AuraComponentService.prototype.$isComponentDefRef$ = function(config) {
  if(!$A["util"].$isObject$(config)) {
    return false
  }
  var descriptor = config[Json.$ApplicationKey$.$DESCRIPTOR$] || config["descriptor"] || config["componentDef"] && config["componentDef"]["descriptor"];
  return descriptor !== null && descriptor !== undefined
};
AuraComponentService.prototype.$getDescriptorFromConfig$ = function(descriptorConfig) {
  var descriptor = descriptorConfig;
  if(descriptorConfig && typeof descriptorConfig !== "string") {
    if(descriptorConfig.hasOwnProperty(Json.$ApplicationKey$.$DESCRIPTOR$)) {
      descriptor = descriptorConfig[Json.$ApplicationKey$.$DESCRIPTOR$]
    }else {
      descriptor = descriptorConfig["descriptor"]
    }
  }
  $A.assert(descriptor, "Descriptor for Config required for registration");
  return descriptor
};
AuraComponentService.prototype.$createDescriptorConfig$ = function(descriptorConfig) {
  var descriptor = descriptorConfig;
  if(descriptorConfig && typeof descriptorConfig !== "string") {
    if(descriptorConfig.hasOwnProperty(Json.$ApplicationKey$.$DESCRIPTOR$)) {
      descriptor = descriptorConfig[Json.$ApplicationKey$.$DESCRIPTOR$]
    }else {
      descriptor = descriptorConfig["descriptor"]
    }
  }
  descriptor = descriptor.indexOf("://") < 0 ? "markup://" + descriptor : descriptor;
  return{"descriptor":descriptor}
};
AuraComponentService.prototype.$countComponents$ = function() {
  return Object.keys(this.$indexes$.$globalId$).length
};
goog.$exportProperty$(AuraComponentService.prototype, "countComponents", AuraComponentService.prototype.$countComponents$);
AuraComponentService.prototype.$getComponentLocator$ = function(cmp, targetCmp, includeMetadata) {
  $A.assert(cmp, "No component provided");
  return cmp.$getLocator$(targetCmp, includeMetadata)
};
goog.$exportProperty$(AuraComponentService.prototype, "getComponentLocator", AuraComponentService.prototype.$getComponentLocator$);
AuraComponentService.prototype.$getRenderingComponentForElement$ = function(element) {
  var ret;
  if($A["util"].$isUndefinedOrNull$(element)) {
    return null
  }
  if($A["util"].$hasDataAttribute$(element, this.$renderedBy$)) {
    var id = $A["util"].$getDataAttribute$(element, this.$renderedBy$);
    ret = this.get(id)
  }else {
    if(element.parentNode) {
      ret = this.$getRenderingComponentForElement$(element.parentNode)
    }
  }
  return ret
};
goog.$exportProperty$(AuraComponentService.prototype, "getRenderingComponentForElement", AuraComponentService.prototype.$getRenderingComponentForElement$);
AuraComponentService.prototype.$getAttributeProviderForElement$ = function(element) {
  return this.$getRenderingComponentForElement$(element).$getAttributeValueProvider$()
};
goog.$exportProperty$(AuraComponentService.prototype, "getAttributeProviderForElement", AuraComponentService.prototype.$getAttributeProviderForElement$);
AuraComponentService.prototype.$containsComponent$ = function() {
  function contains(container, cmp, visited, isOwner) {
    if(container === cmp) {
      return{result:true, $isOwner$:isOwner}
    }
    if(!cmp || !container || visited[cmp.$globalId$]) {
      return{result:false}
    }
    visited[cmp.$globalId$] = true;
    var answer = contains(container, cmp.$getSuper$(), visited, isOwner);
    if(!answer.result) {
      for(var next = cmp;next;) {
        next = next.$getOwner$();
        if(next === cmp || !$A["util"].$isComponent$(next)) {
          return{result:false}
        }
        if(next.$getGlobalId$() !== cmp.$getGlobalId$()) {
          answer = contains(container, next, visited, isOwner);
          break
        }else {
          cmp = next
        }
      }
    }
    if(!answer.result) {
      answer = contains(container, cmp.$getContainer$(), visited, false)
    }
    return answer
  }
  return function(container, cmp) {
    return contains(container, cmp, {}, true)
  }
}();
AuraComponentService.prototype.$newComponentArray$ = function(config, attributeValueProvider, localCreation, doForce) {
  var ret = [];
  for(var i = 0;i < config.length;i++) {
    ret.push(this.$newComponentDeprecated$(config[i], attributeValueProvider, localCreation, doForce))
  }
  return ret
};
AuraComponentService.prototype.$createComponent$ = function(type, attributes, callback) {
  $A.assert($A["util"].$isString$(type), "ComponentService.createComponent(): 'type' must be a valid String.");
  $A.assert(!attributes || $A["util"].$isObject$(attributes), "ComponentService.createComponent(): 'attributes' must be a valid Object.");
  $A.assert($A["util"].$isFunction$(callback), "ComponentService.createComponent(): 'callback' must be a Function pointer.");
  if(type.indexOf(":") < 0) {
    attributes = {"tag":type, "HTMLAttributes":attributes};
    type = "aura:html"
  }
  var config = {"componentDef":this.$createDescriptorConfig$(type), "attributes":{"values":attributes}, "localId":attributes && attributes["aura:id"], "flavor":attributes && attributes["aura:flavor"], "skipCreationPath":true};
  this.$createComponentPrivAsync$(config, callback)
};
goog.$exportProperty$(AuraComponentService.prototype, "createComponent", AuraComponentService.prototype.$createComponent$);
AuraComponentService.prototype.$createInternalConfig$ = function(config) {
  var descriptor = config["descriptor"];
  $A.assert(descriptor.indexOf("markup://") === 0, "Descriptor needs to be of the format markup://ns:name");
  return{"componentDef":this.$createDescriptorConfig$(config["descriptor"]), "localId":config["localId"] || config["aura:id"], "flavor":config["flavor"], "attributes":{"values":config["attributes"], "valueProvider":config["valueProvider"]}}
};
AuraComponentService.prototype.$createComponentFromConfig$ = function(config) {
  $A.assert(config, "Config is required to create a component");
  if(config["descriptor"]) {
    config = this.$createInternalConfig$(config)
  }
  if(!config["attributes"]) {
    config["attributes"] = {}
  }
  return this.$createComponentPriv$(config)
};
goog.$exportProperty$(AuraComponentService.prototype, "createComponentFromConfig", AuraComponentService.prototype.$createComponentFromConfig$);
AuraComponentService.prototype.$createComponents$ = function(components, callback) {
  function getCollector(index) {
    return function(component, status, statusMessage) {
      created[index] = component;
      statusList[index] = {"status":status, "message":statusMessage};
      if(status === "ERROR" || status === "INCOMPLETE" && overallStatus !== "ERROR") {
        overallStatus = status
      }
      if(++collected === components.length) {
        callback(created, overallStatus, statusList)
      }
    }
  }
  $A.assert($A["util"].isArray(components), "ComponentService.createComponents(): 'components' must be a valid Array.");
  $A.assert($A["util"].$isFunction$(callback), "ComponentService.createComponents(): 'callback' must be a Function pointer.");
  var created = [];
  var overallStatus = "SUCCESS";
  var statusList = [];
  var collected = 0;
  for(var i = 0;i < components.length;i++) {
    this.$createComponent$(components[i][0], components[i][1], getCollector(i))
  }
};
goog.$exportProperty$(AuraComponentService.prototype, "createComponents", AuraComponentService.prototype.$createComponents$);
AuraComponentService.prototype.$newComponent$ = function(config, attributeValueProvider, localCreation, doForce) {
  $A.$deprecated$("$A.newCmp and $A.componentService.newComponent are no longer supported.", "Use '$A.createComponent();'.", "2017/01/06", "2017/02/17", "AuraComponentService.newComponent");
  return this.$newComponentDeprecated$(config, attributeValueProvider, localCreation, doForce)
};
goog.$exportProperty$(AuraComponentService.prototype, "newComponent", AuraComponentService.prototype.$newComponent$);
AuraComponentService.prototype.$newComponentDeprecated$ = function(config, attributeValueProvider, localCreation, doForce) {
  $A.$deprecated$("$A.newCmpDeprecated and $A.componentService.newComponentDeprecated are not supported.", "Use '$A.createComponent();'.", "2017/01/06", "2017/02/17", "AuraComponentService.newComponentDeprecated");
  $A.assert(config, "config is required in ComponentService.newComponentDeprecated(config)");
  if($A["util"].isArray(config)) {
    return this.$newComponentArray$(config, attributeValueProvider, localCreation, doForce)
  }
  var configObj = this.$getComponentConfigs$(config, attributeValueProvider);
  var def = configObj["definition"];
  var desc = configObj["descriptor"];
  var load;
  config = configObj["configuration"];
  if(doForce !== true && !config["creationPath"]) {
    if(def && !def.$hasRemoteDependencies$()) {
      localCreation = true;
      delete config["load"]
    }else {
      if(!config["load"]) {
        load = "LAZY"
      }else {
        load = config["load"]
      }
    }
  }
  if(desc === "markup://aura:placeholder") {
    load = null
  }
  if(load === "LAZY" || load === "EXCLUSIVE") {
    localCreation = true;
    var oldConfig = config;
    config = {"componentDef":{"descriptor":"markup://aura:placeholder"}, "localId":oldConfig["localId"], "attributes":{"values":{"refDescriptor":desc, "attributes":oldConfig["attributes"] ? oldConfig["attributes"]["values"] : null, "exclusive":oldConfig["load"] === "EXCLUSIVE"}, "valueProvider":oldConfig["valueProvider"]}}
  }else {
    if(!$A.$clientService$.$allowAccess$(def)) {
      var message = "Access Check Failed! AuraComponentService.newComponentDeprecated(): '" + (def && def.$getDescriptor$().$getQualifiedName$()) + "' is not visible to '" + $A.$clientService$.$currentAccess$ + "'.";
      if($A.$clientService$.$enableAccessChecks$) {
        if($A.$clientService$.$logAccessFailures$) {
          $A.error(null, new $A.$auraError$(message))
        }
        return null
      }else {
        if($A.$clientService$.$logAccessFailures$) {
          $A.$warning$(message)
        }
      }
    }
  }
  return this.$createComponentInstance$(config, localCreation, def)
};
goog.$exportProperty$(AuraComponentService.prototype, "newComponentDeprecated", AuraComponentService.prototype.$newComponentDeprecated$);
AuraComponentService.prototype.$createComponentInstance$ = function(config, localCreation, def) {
  if(!config["skipCreationPath"]) {
    var context = $A.getContext();
    var creationPath;
    var action;
    action = context.$getCurrentAction$();
    if(action) {
      var newConfig;
      var currentPath = action.$topPath$();
      if(config["creationPath"]) {
        creationPath = action.$forceCreationPath$(config["creationPath"]);
        action.$releaseCreationPath$(creationPath)
      }else {
        if(!context.$containsComponentConfig$(currentPath) && !!localCreation) {
        }else {
          creationPath = action.$getCurrentPath$()
        }
      }
      if(creationPath) {
        newConfig = context.$getComponentConfig$(creationPath);
        if(newConfig) {
          config["componentDef"] = newConfig["componentDef"]
        }
      }
    }
  }
  var componentDef = config["componentDef"];
  var desc = componentDef[Json.$ApplicationKey$.$DESCRIPTOR$] || componentDef;
  if(desc.$getDescriptor$) {
    desc = desc.$getDescriptor$().$getQualifiedName$()
  }else {
    if(desc.$getQualifiedName$) {
      desc = desc.$getQualifiedName$()
    }else {
      if(desc.indexOf("://") === -1) {
        desc = "markup://" + desc
      }
    }
  }
  var componentClassDef = config["componentClass"] || config["componentDef"][Json.$ApplicationKey$.$COMPONENTCLASS$];
  if(componentClassDef && !this.$hasComponentClass$(desc)) {
    componentClassDef = $A["util"].$globalEval$(componentClassDef, $A.$clientService$.$getSourceMapsUrl$(desc));
    componentClassDef()
  }
  if(!this.$hasComponentClass$(desc)) {
    this.$createFromSavedComponentConfigs$(desc)
  }
  var classConstructor = this.$getComponentClass$(desc, def);
  if(!classConstructor) {
    throw new $A.$auraError$("Component class not found: " + desc, null, $A.severity.$QUIET$);
  }
  return new classConstructor(config, localCreation)
};
AuraComponentService.prototype.$addComponentClass$ = function(descriptor, exporter) {
  return this.$componentClassRegistry$.$addComponentClass$(descriptor, exporter)
};
goog.$exportProperty$(AuraComponentService.prototype, "addComponentClass", AuraComponentService.prototype.$addComponentClass$);
AuraComponentService.prototype.$initModuleDefs$ = function(modules) {
  var moduleDefRegistry = this.$moduleDefRegistry$;
  modules.forEach(function(module) {
    var exporter = {"exporter":module[Json.$ApplicationKey$.$CODE$], "minVersion":module[Json.$ApplicationKey$.$MINVERSION$], "access":module[Json.$ApplicationKey$.$ACCESS$], "requireLocker":module[Json.$ApplicationKey$.$REQUIRELOCKER$]};
    moduleDefRegistry[module[Json.$ApplicationKey$.$DESCRIPTOR$]] = moduleDefRegistry[module[Json.$ApplicationKey$["NAME"]]] = exporter
  })
};
goog.$exportProperty$(AuraComponentService.prototype, "initModuleDefs", AuraComponentService.prototype.$initModuleDefs$);
AuraComponentService.prototype.$addModule$ = function(descriptor, name, dependencies, exporterClass, nsexports) {
  this.$moduleNameToDescriptorLookup$[name] = descriptor;
  if(exporterClass === undefined) {
    return this.$addModule$(descriptor, name, [], dependencies)
  }
  var entry = this.$moduleDefRegistry$[descriptor] || (this.$moduleDefRegistry$[descriptor] = this.$moduleDefRegistry$[name] = {});
  entry.$dependencies$ = dependencies;
  entry.definition = exporterClass;
  entry.$descriptor$ = descriptor;
  entry.$moduleName$ = name;
  entry.$ns$ = nsexports
};
goog.$exportProperty$(AuraComponentService.prototype, "addModule", AuraComponentService.prototype.$addModule$);
AuraComponentService.prototype.$evaluateModuleDef$ = function(descriptor) {
  var entry = this.$moduleDefRegistry$[descriptor] || this.$getLibraryAsModule$(descriptor);
  var factory;
  var exportns;
  var url;
  $A.assert(entry, "Failed to find definition for dependency: " + descriptor);
  if(entry.$ns$) {
    return entry.$ns$
  }
  if(!entry.$dependencies$) {
    url = $A.$clientService$.$getSourceMapsUrl$(descriptor);
    factory = $A["util"].$globalEval$(entry["exporter"], url);
    factory()
  }
  var namespaceAliases = $A.getContext().$moduleNamespaceAliases$;
  var deps = entry.$dependencies$.map(function(name) {
    if(name === "exports") {
      exportns = {};
      return exportns
    }
    var desc;
    var depEntry;
    var hasSchema = name[0] === "@";
    if(hasSchema) {
      var schemaParts = name.substr(1).split("/");
      return $A.$clientService$.$resolveSchemaDependency$(schemaParts[0], schemaParts[1], name)
    }else {
      if(name.indexOf(":") !== -1) {
        desc = "markup://" + name
      }else {
        desc = name;
        var names = name.split("-");
        var ns = names.shift();
        var aliased = namespaceAliases[ns];
        if(aliased) {
          var aliasedDesc = aliased + "-" + names.join("-");
          var aliasedDep = this.$moduleDefRegistry$[aliasedDesc];
          if(aliasedDep) {
            depEntry = aliasedDep;
            desc = aliasedDesc
          }
        }
      }
    }
    if(!depEntry) {
      depEntry = this.$moduleDefRegistry$[desc]
    }
    if(depEntry && depEntry.$dependencies$) {
      var dep = this.$moduleDefRegistry$[desc];
      if(dep.$ns$) {
        return dep.$ns$
      }else {
        var tmp$$0 = function tmp() {
          return dep.$ns$
        };
        tmp$$0["__circular__"] = true;
        return tmp$$0
      }
    }
    return this.$evaluateModuleDef$(desc)
  }, this);
  var Ctor;
  var defDescriptor;
  if(descriptor.indexOf("markup://") !== -1) {
    defDescriptor = new DefDescriptor(descriptor)
  }else {
    defDescriptor = new DefDescriptor(this.$moduleNameToDescriptorLookup$[descriptor])
  }
  var namespace = defDescriptor.$getNamespace$();
  var isInternalNamespace = $A.$clientService$.$isInternalNamespace$(namespace);
  if(entry.definition && $A["util"].$isFunction$(entry.definition)) {
    if(!isInternalNamespace || isInternalNamespace && entry["requireLocker"]) {
      entry.definition = $A.$lockerService$.$createForModule$(entry.definition.toString(), defDescriptor);
      var index = entry.$dependencies$.indexOf("engine");
      if(index !== -1) {
        deps.splice(index, 1, this.$wrappedEngine$ || (this.$wrappedEngine$ = $A.$lockerService$.$wrapEngine$(deps[index])))
      }
    }
    Ctor = entry.definition.apply(undefined, deps)
  }
  Ctor = Ctor || exportns;
  entry.$ns$ = Ctor;
  this.$collectModuleStyles$(Ctor);
  $A.$lockerService$.$trust$(entry.definition, Ctor);
  return Ctor
};
AuraComponentService.prototype.$collectModuleStyles$ = function(Ctor) {
  if(Ctor.style) {
    this.$moduleStyleBuffer$.push(Ctor.style);
    Ctor.style = undefined
  }
};
AuraComponentService.prototype.$flushModuleStyles$ = function() {
  var styles = this.$moduleStyleBuffer$;
  if(styles.length) {
    this.$moduleStyleBuffer$ = [];
    $A["util"].style.apply(styles.join("\n"))
  }
};
AuraComponentService.prototype.$createInteropComponentDef$ = function(descriptor) {
  var Ctor = this.$evaluateModuleDef$(descriptor);
  var module = this.$moduleDefRegistry$[descriptor];
  var interOpCmpDef = new Aura.$Component$.$InteropComponentDef$({$dependencies$:module.$dependencies$, definition:module.definition, $descriptor$:module.$descriptor$, $moduleName$:module.$moduleName$, $access$:module["access"], $minVersion$:module["minVersion"], $interopClass$:Ctor});
  this.$componentDefRegistry$[descriptor] = interOpCmpDef;
  this.$flushModuleStyles$();
  return interOpCmpDef
};
AuraComponentService.prototype.$getComponentClass$ = function(descriptor, def) {
  return this.$componentClassRegistry$.$getComponentClass$(descriptor, def)
};
goog.$exportProperty$(AuraComponentService.prototype, "getComponentClass", AuraComponentService.prototype.$getComponentClass$);
AuraComponentService.prototype.$initEventDefs$ = function(evtConfigs) {
  for(var i = 0;i < evtConfigs.length;i++) {
    $A.$eventService$.$saveEventConfig$(evtConfigs[i])
  }
};
goog.$exportProperty$(AuraComponentService.prototype, "initEventDefs", AuraComponentService.prototype.$initEventDefs$);
AuraComponentService.prototype.$initLibraryDefs$ = function(libraryConfigs) {
  for(var i = 0;i < libraryConfigs.length;i++) {
    $A.$componentService$.$saveLibraryConfig$(libraryConfigs[i])
  }
};
goog.$exportProperty$(AuraComponentService.prototype, "initLibraryDefs", AuraComponentService.prototype.$initLibraryDefs$);
AuraComponentService.prototype.$initControllerDefs$ = function(controllerConfigs) {
  for(var i = 0;i < controllerConfigs.length;i++) {
    $A.$componentService$.$createControllerDef$(controllerConfigs[i])
  }
};
goog.$exportProperty$(AuraComponentService.prototype, "initControllerDefs", AuraComponentService.prototype.$initControllerDefs$);
AuraComponentService.prototype.$hasComponentClass$ = function(descriptor) {
  return this.$componentClassRegistry$.$hasComponentClass$(descriptor)
};
AuraComponentService.prototype.$newComponentAsync$ = function(callbackScope, callback, config, attributeValueProvider, localCreation, doForce, forceServer) {
  function collectComponent(newComponent, status, statusMessage, index) {
    components[index] = newComponent;
    statusList[index] = status;
    if(status === "ERROR" || status === "INCOMPLETE" && overallStatus !== "ERROR") {
      overallStatus = status
    }
    if(++collected === config.length) {
      callback.call(callbackScope, isSingle ? components[0] : components, overallStatus, statusList)
    }
  }
  $A.$deprecated$("$A.newCmpAsync and $A.componentService.newComponentAsync are not supported.", "Use '$A.createComponent();'.", "2017/01/06", "2017/02/17");
  $A.assert(config, "ComponentService.newComponentAsync(): 'config' must be a valid Object.");
  $A.assert($A["util"].$isFunction$(callback), "ComponentService.newComponentAsync(): 'callback' must be a Function pointer.");
  var isSingle = !$A["util"].isArray(config);
  if(isSingle) {
    config = [config]
  }
  var components = [];
  var overallStatus = "SUCCESS";
  var statusList = [];
  var collected = 0;
  for(var i = 0;i < config.length;i++) {
    var configItem = config[i];
    if(configItem) {
      var configObj = this.$getComponentConfigs$(configItem, attributeValueProvider);
      var def = configObj["definition"];
      var desc = configObj["descriptor"]["descriptor"] || configObj["descriptor"];
      var forceClient = false;
      configItem = configObj["configuration"];
      if(configItem["creationPath"] && !forceServer) {
        forceClient = true
      }
      configItem["componentDef"] = {"descriptor":desc};
      if(!def && desc.indexOf("layout://") === 0) {
        $A.$componentService$.$dynamicNamespaces$ = [];
        throw new $A.$auraError$("Missing definition: " + desc, null, $A.severity.$QUIET$);
      }
      if(!forceClient && (!def || def && def.$hasRemoteDependencies$() || forceServer)) {
        var action = this.$requestComponent$(collectComponent, configItem, attributeValueProvider, i);
        $A.$enqueueAction$(action)
      }else {
        if($A.$clientService$.$allowAccess$(def)) {
          collectComponent(this["newComponentDeprecated"](configItem, attributeValueProvider, localCreation, doForce), "SUCCESS", "", i)
        }else {
          var message = "Access Check Failed! AuraComponentService.newComponentAsync(): '" + def.$getDescriptor$().$getQualifiedName$() + "' is not visible to '" + $A.$clientService$.$currentAccess$ + "'.";
          if($A.$clientService$.$enableAccessChecks$) {
            if($A.$clientService$.$logAccessFailures$) {
              $A.error(null, new $A.$auraError$(message))
            }
            collectComponent(null, "ERROR", "Unknown component '" + desc + "'.", i)
          }else {
            if($A.$clientService$.$logAccessFailures$) {
              $A.$warning$(message)
            }
            collectComponent(this["newComponentDeprecated"](configItem, attributeValueProvider, localCreation, doForce), "SUCCESS", "", i)
          }
        }
      }
    }
  }
};
goog.$exportProperty$(AuraComponentService.prototype, "newComponentAsync", AuraComponentService.prototype.$newComponentAsync$);
AuraComponentService.prototype.$requestComponent$ = function(callback, config, avp, index, returnNullOnError) {
  var action = $A.get("c.aura://ComponentController.getComponent");
  var attributes = config["attributes"] ? config["attributes"]["values"] ? config["attributes"]["values"] : config["attributes"] : null;
  var atts = {};
  for(var key in attributes) {
    var value = attributes[key];
    if(value && value.hasOwnProperty("value")) {
      value = value["value"]
    }
    var auraValue = valueFactory.create(value, avp);
    atts[key] = this.$computeValue$(auraValue, avp)
  }
  action.$setCallback$(this, function(a) {
    if(avp && avp.$isValid$ && !avp.$isValid$()) {
      return
    }
    if($A.$clientService$.$currentAccess$ && !$A.$clientService$.$currentAccess$.$isValid$()) {
      return
    }
    var newComp = null;
    var status = a.$getState$();
    var statusMessage = "";
    if(status === "SUCCESS") {
      var returnedConfig = a.$getReturnValue$();
      if(!returnedConfig["attributes"]) {
        returnedConfig["attributes"] = {}
      }
      returnedConfig["attributes"]["valueProvider"] = avp;
      var merging = returnedConfig["attributes"];
      if(merging.hasOwnProperty("values")) {
        merging = merging["values"]
      }
      for(var mkey in attributes) {
        merging[mkey] = attributes[mkey]
      }
      returnedConfig["localId"] = config["localId"];
      returnedConfig["flavor"] = config["flavor"];
      var error;
      try {
        newComp = this.$createComponentPriv$(returnedConfig)
      }catch(e) {
        status = "ERROR";
        statusMessage = e.message;
        error = e
      }
      if($A["util"].$isFunction$(callback)) {
        callback(newComp, status, statusMessage, index, error)
      }
    }else {
      var errors = a.getError();
      statusMessage = errors ? errors[0].message : "Unknown Error.";
      if(statusMessage !== "Event fired") {
        if(!returnNullOnError) {
          newComp = this.$createComponentPriv$({"componentDef":{"descriptor":"markup://aura:text"}, "attributes":{"values":{"value":statusMessage}}})
        }
        if($A["util"].$isFunction$(callback)) {
          callback(newComp, status, statusMessage, index)
        }
      }
    }
  });
  action.$setParams$({"name":config["componentDef"]["descriptor"], "attributes":atts});
  return action
};
AuraComponentService.prototype.$computeValue$ = function(value, valueProvider) {
  if($A["util"].$isExpression$(value)) {
    value = value.evaluate(valueProvider)
  }
  if($A["util"].$isComponent$(value)) {
    return null
  }
  if($A["util"].isArray(value)) {
    var newValue = [];
    var c = 0;
    for(var length = value.length;c < length;c++) {
      if(!$A["util"].$isComponent$(value[c])) {
        newValue.push(value[c])
      }
    }
    value = newValue
  }
  return value
};
goog.$exportProperty$(AuraComponentService.prototype, "computeValue", AuraComponentService.prototype.$computeValue$);
AuraComponentService.prototype.$getComponentConfigs$ = function(config, attributeValueProvider) {
  var configuration;
  var configAttributes;
  var def;
  var desc;
  var configKey;
  var attributeKey;
  if(config && $A["util"].$isString$(config)) {
    config = {"componentDef":config}
  }
  if(attributeValueProvider) {
    configuration = {};
    for(configKey in config) {
      if(config.hasOwnProperty(configKey)) {
        configuration[configKey] = config[configKey]
      }
    }
    configAttributes = config["attributes"];
    configuration["attributes"] = {};
    if(configAttributes) {
      for(attributeKey in configAttributes) {
        if(configAttributes.hasOwnProperty(attributeKey)) {
          configuration["attributes"][attributeKey] = configAttributes[attributeKey]
        }
      }
    }
    configuration["attributes"]["valueProvider"] = attributeValueProvider
  }else {
    configuration = config
  }
  var componentDef = configuration["componentDef"];
  def = this.$getDef$(componentDef);
  if(!def && componentDef[Json.$ApplicationKey$.$ATTRIBUTEDEFS$]) {
    def = this.$createComponentDef$(componentDef)
  }
  if(def) {
    desc = def.$getDescriptor$().toString()
  }else {
    desc = componentDef[Json.$ApplicationKey$.$DESCRIPTOR$] ? componentDef[Json.$ApplicationKey$.$DESCRIPTOR$] : componentDef
  }
  return{"configuration":configuration, "definition":def, "descriptor":desc}
};
AuraComponentService.prototype.$indexComponent$ = function(component) {
  this.$indexes$.$globalId$[component.$globalId$] = component
};
AuraComponentService.prototype.$hasDefinition$ = function(descriptor) {
  return!!this.$getDef$(descriptor)
};
AuraComponentService.prototype.$getUnusedDefinitions$ = function() {
  return Object.keys(this.$savedComponentConfigs$)
};
goog.$exportProperty$(AuraComponentService.prototype, "getUnusedDefinitions", AuraComponentService.prototype.$getUnusedDefinitions$);
AuraComponentService.prototype.$getDefinition$ = function(descriptor, callback) {
  var def = this.$getComponentDef$(this.$createDescriptorConfig$(descriptor));
  if(def) {
    if(!$A.$clientService$.$allowAccess$(def)) {
      var message = "Access Check Failed! ComponentService.getDef():'" + def.$getDescriptor$().toString() + "' is not visible to '" + $A.$clientService$.$currentAccess$ + "'.";
      if($A.$clientService$.$enableAccessChecks$) {
        if($A.$clientService$.$logAccessFailures$) {
          $A.error(null, new $A.$auraError$(message))
        }
        callback(null);
        return
      }else {
        if($A.$clientService$.$logAccessFailures$) {
          $A.$warning$(message)
        }
      }
    }
    callback(def);
    return
  }
  var action = $A.get("c.aura://ComponentController.getComponentDef");
  action.$setParams$({"name":descriptor});
  action.$setCallback$(this, function(actionResponse) {
    if(actionResponse.$getState$() === "SUCCESS") {
      callback(this.$getDef$(descriptor))
    }else {
      if(actionResponse.$getState$() === "ERROR") {
        actionResponse.getError().forEach(function(e) {
          $A.$warning$(e.message)
        });
        callback(null)
      }else {
        callback(null)
      }
    }
  });
  $A.$enqueueAction$(action)
};
AuraComponentService.prototype.$getComponentDef$ = function(config) {
  var descriptor = this.$getDescriptorFromConfig$(config);
  var definition = this.$componentDefRegistry$[descriptor];
  if(!definition && this.$savedComponentConfigs$[descriptor]) {
    return this.$createFromSavedComponentConfigs$(config)
  }else {
    if(!definition && this.$moduleDefRegistry$[descriptor]) {
      return this.$createInteropComponentDef$(descriptor)
    }
  }
  return definition
};
AuraComponentService.prototype.$hasDefinition$ = function(descriptor) {
  return!!this.$getDef$(descriptor)
};
AuraComponentService.prototype.$hasModuleDefinition$ = function(moduleName) {
  return!!this.$moduleDefRegistry$[moduleName]
};
AuraComponentService.prototype.$getDef$ = function(descriptor) {
  $A.assert(descriptor, "No ComponentDef descriptor specified");
  var def = this.$getComponentDef$(this.$createDescriptorConfig$(descriptor));
  if(def && !$A.$clientService$.$allowAccess$(def)) {
    var message = "Access Check Failed! ComponentService.getDef():'" + def.$getDescriptor$().toString() + "' is not visible to '" + $A.$clientService$.$currentAccess$ + "'.";
    if($A.$clientService$.$enableAccessChecks$) {
      if($A.$clientService$.$logAccessFailures$) {
        $A.error(null, new $A.$auraError$(message))
      }
      return null
    }else {
      if($A.$clientService$.$logAccessFailures$) {
        $A.$warning$(message)
      }
    }
  }
  return def
};
goog.$exportProperty$(AuraComponentService.prototype, "getDef", AuraComponentService.prototype.$getDef$);
AuraComponentService.prototype.$addComponent$ = function(descriptor, exporter) {
  this.$savedComponentConfigs$[descriptor] = exporter
};
goog.$exportProperty$(AuraComponentService.prototype, "addComponent", AuraComponentService.prototype.$addComponent$);
AuraComponentService.prototype.$hydrateComponent$ = function(descriptor, exporter) {
  var script = $A.$clientService$.$uncommentExporter$(exporter);
  exporter = $A.$clientService$.$evalExporter$(script, descriptor);
  if(!exporter) {
    var defDescriptor = new Aura.$System$.$DefDescriptor$(descriptor);
    var includeComponentSource = defDescriptor.$getPrefix$() === "layout" || $A.$clientService$.$isInternalNamespace$(defDescriptor.$getNamespace$());
    var errorMessage = !includeComponentSource ? "Hydrating the component" + descriptor + " failed." : "Hydrating the component" + descriptor + " failed.\n Exporter code: " + script;
    var auraError = new $A.$auraError$(errorMessage, null, $A.severity.$QUIET$);
    auraError.$setComponent$(descriptor);
    throw auraError;
  }
  return exporter()
};
AuraComponentService.prototype.$createFromSavedComponentConfigs$ = function(config) {
  var descriptor = this.$getDescriptorFromConfig$(config);
  var cmpConfig = this.$savedComponentConfigs$[descriptor];
  var definition = typeof cmpConfig === "function" ? this.$hydrateComponent$(descriptor, cmpConfig) : cmpConfig;
  var alreadyHasConstructor = this.$componentClassRegistry$.$classConstructors$[descriptor] || this.$componentClassRegistry$.$classExporter$[descriptor];
  var hasBuiltInConstructor = cmpConfig && cmpConfig.hasOwnProperty(Json.$ApplicationKey$.$COMPONENTCLASS$);
  if(alreadyHasConstructor || hasBuiltInConstructor) {
    var def = new ComponentDef(definition);
    this.$componentDefRegistry$[descriptor] = def;
    delete this.$savedComponentConfigs$[descriptor];
    return def
  }
  return null
};
AuraComponentService.prototype.$createComponentDef$ = function(config) {
  var descriptor = this.$getDescriptorFromConfig$(config);
  var definition = this.$componentDefRegistry$[descriptor];
  if(!definition) {
    if(this.$savedComponentConfigs$[descriptor]) {
      definition = this.$createFromSavedComponentConfigs$(config)
    }else {
      if(!!this.$componentClassRegistry$.$classConstructors$[descriptor] || !!this.$componentClassRegistry$.$classExporter$[descriptor]) {
        definition = new ComponentDef(config);
        this.$componentDefRegistry$[descriptor] = definition
      }
    }
  }
  return definition
};
AuraComponentService.prototype.$getControllerDef$ = function(descriptor) {
  return this.$controllerDefRegistry$[descriptor]
};
AuraComponentService.prototype.$createControllerDef$ = function(config) {
  var descriptor = this.$getDescriptorFromConfig$(config);
  var def = this.$controllerDefRegistry$[descriptor];
  if(!def) {
    def = new ControllerDef(config);
    delete this.$controllerDefRelationship$[descriptor];
    this.$controllerDefRegistry$[descriptor] = def
  }
  return def
};
AuraComponentService.prototype.$getActionDef$ = function(descriptor) {
  return this.$actionDefRegistry$[descriptor]
};
AuraComponentService.prototype.$createActionDef$ = function(config) {
  var descriptor = this.$getDescriptorFromConfig$(config);
  var def = this.$actionDefRegistry$[descriptor];
  if(!def) {
    def = new ActionDef(config);
    delete this.$actionDefRelationship$[descriptor];
    this.$actionDefRegistry$[descriptor] = def
  }
  return def
};
AuraComponentService.prototype.$getModelDef$ = function(descriptor) {
  return this.$modelDefRegistry$[descriptor]
};
AuraComponentService.prototype.$createModelDef$ = function(config) {
  var descriptor = this.$getDescriptorFromConfig$(config);
  var def = this.$modelDefRegistry$[descriptor];
  if(!def) {
    def = new ModelDef(config);
    this.$modelDefRegistry$[descriptor] = def
  }
  return def
};
AuraComponentService.prototype.$hasLibrary$ = function(descriptor) {
  return this.$libraryRegistry$.$hasLibrary$(descriptor)
};
AuraComponentService.prototype.$saveLibraryConfig$ = function(config) {
  this.$libraryRegistry$.$addLibrary$(config["descriptor"], config["includes"]);
  if(config.hasOwnProperty("includeClasses")) {
    var includeClasses = $A["util"].$globalEval$(config["includeClasses"], $A.$clientService$.$getSourceMapsUrl$(config["descriptor"], "lib"));
    includeClasses()
  }
};
goog.$exportProperty$(AuraComponentService.prototype, "saveLibraryConfig", AuraComponentService.prototype.$saveLibraryConfig$);
AuraComponentService.prototype.$addLibraryExporter$ = function(descriptor, exporter) {
  this.$libraryIncludeRegistry$.$addLibraryExporter$(descriptor, exporter)
};
goog.$exportProperty$(AuraComponentService.prototype, "addLibraryExporter", AuraComponentService.prototype.$addLibraryExporter$);
AuraComponentService.prototype.$getLibrary$ = function(descriptor) {
  return this.$libraryRegistry$.$getLibrary$(descriptor)
};
AuraComponentService.prototype.$getLibraryAsModule$ = function(descriptor) {
  return this.$libraryRegistry$.$getLibrary$(descriptor) && this.$moduleDefRegistry$[descriptor]
};
AuraComponentService.prototype.$addLibraryInclude$ = function(descriptor, dependencies, exporter) {
  this.$libraryIncludeRegistry$.$addLibraryInclude$(descriptor, dependencies, exporter)
};
goog.$exportProperty$(AuraComponentService.prototype, "addLibraryInclude", AuraComponentService.prototype.$addLibraryInclude$);
AuraComponentService.prototype.$getLibraryInclude$ = function(descriptor) {
  return this.$libraryIncludeRegistry$.$getLibraryInclude$(descriptor)
};
AuraComponentService.prototype.$destroy$ = function(components) {
  if(!$A["util"].isArray(components)) {
    components = [components]
  }
  for(var i = 0;i < components.length;i++) {
    var cmp = components[i];
    if(cmp && cmp.$destroy$) {
      cmp.$destroy$()
    }
  }
};
AuraComponentService.prototype.$deIndex$ = function(globalId) {
  delete this.$indexes$.$globalId$[globalId]
};
AuraComponentService.prototype.$getRegisteredComponentDescriptors$ = function() {
  var ret = [];
  var name;
  var componentDefs = this.$componentDefRegistry$;
  for(name in componentDefs) {
    ret.push(name)
  }
  return ret
};
goog.$exportProperty$(AuraComponentService.prototype, "getRegisteredComponentDescriptors", AuraComponentService.prototype.$getRegisteredComponentDescriptors$);
AuraComponentService.prototype.$getDynamicNamespaces$ = function() {
  return this.$dynamicNamespaces$
};
AuraComponentService.prototype.$getIndex$ = function() {
  var ret = "";
  var index = this.$indexes$.$globalId$;
  for(var globalId in index) {
    if(globalId.indexOf(":1") > -1) {
      var cmp = index[globalId];
      var par = "";
      var vp = cmp.$getComponentValueProvider$();
      if(vp) {
        par = vp.$getGlobalId$() + " : " + vp.$getDef$().toString()
      }
      ret = ret + globalId + " : ";
      ret = ret + cmp.$getDef$().toString();
      ret = ret + " [ " + par + " ] ";
      ret = ret + "\n"
    }
  }
  return ret
};
goog.$exportProperty$(AuraComponentService.prototype, "getIndex", AuraComponentService.prototype.$getIndex$);
AuraComponentService.prototype.$isConfigDescriptor$ = function(config) {
  return config && config["descriptor"]
};
AuraComponentService.prototype.$saveComponentConfig$ = function(config) {
  var componentDescriptor = this.$getDescriptorFromConfig$(config);
  if(componentDescriptor in this.$savedComponentConfigs$ || componentDescriptor in this.$componentDefRegistry$) {
    return
  }
  this.$savedComponentConfigs$[componentDescriptor] = config;
  var controllerDef = config[Json.$ApplicationKey$.$CONTROLLERDEF$];
  if(controllerDef) {
    if(controllerDef[Json.$ApplicationKey$.$DESCRIPTOR$]) {
      this.$controllerDefRelationship$[controllerDef[Json.$ApplicationKey$.$DESCRIPTOR$]] = componentDescriptor
    }
    if(controllerDef[Json.$ApplicationKey$.$ACTIONDEFS$]) {
      var actionDefs = controllerDef[Json.$ApplicationKey$.$ACTIONDEFS$];
      var len = actionDefs.length;
      var i;
      for(i = 0;i < len;i++) {
        var actionDef = actionDefs[i];
        if(actionDef[Json.$ApplicationKey$.$DESCRIPTOR$]) {
          this.$actionDefRelationship$[actionDef[Json.$ApplicationKey$.$DESCRIPTOR$]] = componentDescriptor
        }
      }
    }
  }
};
AuraComponentService.prototype.$restoreDefsFromStorage$ = function(context) {
  var defStorage = this.$componentDefStorage$.$getStorage$();
  if(!defStorage || !defStorage.$isPersistent$()) {
    this.$componentDefStorage$.$restoreAll$(context);
    return Promise["resolve"]()
  }
  return this.$componentDefStorage$.$restoreAll$(context)
};
AuraComponentService.prototype.$clearDefsFromStorage$ = function(metricsPayload) {
  return this.$componentDefStorage$.clear(metricsPayload).$then$(function() {
    return this.$actionStorage$.clear()
  }.bind(this))
};
AuraComponentService.prototype.$getComponentDefStorageName$ = function() {
  return this.$componentDefStorage$.$STORAGE_NAME$
};
AuraComponentService.prototype.$saveDefsToStorage$ = function(config, context) {
  var cmpConfigs = config["componentDefs"] || [];
  var libConfigs = config["libraryDefs"] || [];
  var evtConfigs = config["eventDefs"] || [];
  var moduleConfigs = config["moduleDefs"] || [];
  if(cmpConfigs.length === 0 && libConfigs.length === 0 && evtConfigs.length === 0 && moduleConfigs.length === 0) {
    return Promise["resolve"]()
  }
  var defStorage = this.$componentDefStorage$.$getStorage$();
  if(!defStorage) {
    return Promise["resolve"]()
  }
  var self = this;
  var defSizeKb = $A["util"].$estimateSize$(cmpConfigs) / 1024;
  var libSizeKb = $A["util"].$estimateSize$(libConfigs) / 1024;
  var evtSizeKb = $A["util"].$estimateSize$(evtConfigs) / 1024;
  var moduleSizeKb = $A["util"].$estimateSize$(moduleConfigs) / 1024;
  return self.$pruneDefsFromStorage$(defSizeKb + libSizeKb + evtSizeKb + moduleSizeKb).$then$(function(cleared) {
    if(!cleared) {
      return self.$componentDefStorage$.$storeDefs$(cmpConfigs, libConfigs, evtConfigs, moduleConfigs, context)
    }
  }).$then$(undefined, function(e) {
    var metricsPayload = {"cause":"saveDefsToStorage", "defsRequiredSize":defSizeKb + libSizeKb + evtSizeKb, "error":e};
    return self.$clearDefsFromStorage$(metricsPayload)
  })
};
AuraComponentService.prototype.$createComponentPrivAsync$ = function(config, callback) {
  var descriptor = this.$getDescriptorFromConfig$(config["componentDef"]);
  var def = this.$getComponentDef$({"descriptor":descriptor});
  var action;
  $A.assert(callback && typeof callback === "function", "Callback");
  if(def && !def.$hasRemoteDependencies$()) {
    this.$createComponentPriv$(config, callback);
    return
  }
  action = this.$requestComponent$(callback, config, null, null, true);
  action.$setAbortable$();
  $A.$enqueueAction$(action)
};
AuraComponentService.prototype.$createComponentPriv$ = function(config, callback) {
  var descriptor = this.$getDescriptorFromConfig$(config["componentDef"]);
  var def = this.$getComponentDef$({"descriptor":descriptor});
  var cmp = null;
  var createMark;
  var currentAccessCmp = $A.$clientService$.$currentAccess$;
  var currentAccessCmpDef = currentAccessCmp && currentAccessCmp.$getDef$();
  if(!this.$trackingCreate$ && descriptor.indexOf("markup://aura") < 0) {
    createMark = $A.$metricsService$["mark"]("component", "create", {"name":descriptor});
    this.$trackingCreate$ = true
  }
  try {
    if($A.$clientService$.$allowAccess$(def)) {
      var minVersion = def.$getMinVersion$();
      var currAccessCmpApiVer = currentAccessCmpDef && currentAccessCmpDef.$getApiVersion$();
      if(minVersion && currAccessCmpApiVer && parseInt(minVersion) > parseInt(currAccessCmpApiVer)) {
        var mveMessage = $A["util"].$format$("Component API version is too old: '{0}' must be set to API version '{1}' or later to use component '{2}'", currentAccessCmpDef.$getDescriptor$().$getQualifiedName$(), minVersion, descriptor);
        var minVersionValidationError = new $A.$auraError$(mveMessage);
        minVersionValidationError.$setComponent$(currentAccessCmpDef.$getDescriptor$().$getQualifiedName$());
        throw minVersionValidationError;
      }
      var classConstructor = this.$getComponentClass$(descriptor, def);
      if(!classConstructor) {
        var errorMessage = $A["util"].$format$("Component class not found: {0}\n hasClassConstructor: {1}\n hasClassExporter: {2}\n hasSavedComponentConfigs: {3}\n hasComponentDefCreated: {4}", descriptor, !!$A.$componentService$.$componentClassRegistry$.$classConstructors$[descriptor], !!$A.$componentService$.$componentClassRegistry$.$classExporter$[descriptor], !!$A.$componentService$.$savedComponentConfigs$[descriptor], !!$A.$componentService$.$componentDefRegistry$[descriptor]);
        var auraError = new $A.$auraError$(errorMessage, null, $A.severity.$QUIET$);
        auraError.$setComponent$(descriptor);
        throw auraError;
      }
      cmp = new classConstructor(config)
    }else {
      var message = "Access Check Failed! AuraComponentService.createComponentFromConfig(): '" + descriptor + "' is not visible to '" + currentAccessCmp + "'.";
      if($A.$clientService$.$enableAccessChecks$) {
        if($A.$clientService$.$logAccessFailures$) {
          $A.error(null, new $A.$auraError$(message))
        }
      }else {
        if($A.$clientService$.$logAccessFailures$) {
          $A.$warning$(message)
        }
        if(def) {
          cmp = new (this.$getComponentClass$(descriptor, def))(config)
        }
      }
    }
    if(callback && $A["util"].$isFunction$(callback)) {
      if(cmp !== null) {
        callback(cmp, "SUCCESS")
      }else {
        callback(null, "ERROR", "Unknown component '" + descriptor + "'.")
      }
      return undefined
    }else {
      if(cmp !== null) {
        return cmp
      }
    }
    throw new Error("Definition does not exist on the client for descriptor:" + descriptor);
  }finally {
    if(createMark) {
      this.$trackingCreate$ = false;
      createMark["duration"] = $A.$metricsService$.time() - createMark["ts"]
    }
  }
};
AuraComponentService.prototype.$findDependencies$ = function(key, defConfig, storedDeps) {
  var dependencies = [];
  var i;
  if($A["util"].isArray(defConfig)) {
    for(i = 0;i < defConfig.length;i++) {
      dependencies.push.apply(dependencies, this.$findDependencies$(key, defConfig[i], storedDeps))
    }
  }else {
    if($A["util"].$isObject$(defConfig)) {
      for(var attr in defConfig) {
        var value = defConfig[attr];
        if(attr === "descriptor") {
          if(value !== key && storedDeps.indexOf(value) !== -1) {
            dependencies.push(value)
          }
        }else {
          dependencies.push.apply(dependencies, this.$findDependencies$(key, value, storedDeps))
        }
      }
    }
  }
  return dependencies
};
AuraComponentService.prototype.$buildDependencyGraph$ = function() {
  var actionsBlackList = ["globalValueProviders", "aura://ComponentController/ACTION$getApplication"];
  var promises = [];
  var actionStorage = $A.$clientService$.$getActionStorage$();
  promises.push(actionStorage.$getAll$());
  promises.push(this.$componentDefStorage$.$getAll$());
  return Promise.all(promises).$then$(function(results) {
    function createNode(isAction, values, key) {
      var dependencies = this.$findDependencies$(key, values[key], defKeys);
      nodes[key] = {"id":key, "dependencies":dependencies, "action":isAction}
    }
    var actionEntries = results[0];
    var defEntries = results[1];
    var defKeys = Object.keys(defEntries);
    var nodes = {};
    var actionKeys = Object.keys(actionEntries).filter(function(a) {
      for(var i = 0;i < actionsBlackList.length;i++) {
        if(a.key.indexOf(actionsBlackList[i]) === 0) {
          return false
        }
      }
      return true
    });
    actionKeys.forEach(createNode.bind(this, true, actionEntries));
    defKeys.forEach(createNode.bind(this, false, defEntries));
    return nodes
  }.bind(this))
};
AuraComponentService.prototype.$sortDependencyGraph$ = function(graph) {
  var sorted = [];
  var visited = {};
  Object.keys(graph).forEach(function visit(idstr, ancestors) {
    var node = graph[idstr];
    var id = node["id"];
    if(visited[idstr]) {
      return
    }
    if(!Array.isArray(ancestors)) {
      ancestors = []
    }
    ancestors.push(id);
    visited[idstr] = true;
    node["dependencies"].forEach(function(afterId) {
      if(ancestors.indexOf(afterId) >= 0) {
        throw new $A.$auraError$("AuraComponentService.sortDependencyGraph: Found a cycle in the graph: " + afterId + " is in " + id, null, $A.severity.$QUIET$);
      }
      visit(afterId.toString(), ancestors.map(function(v) {
        return v
      }))
    });
    sorted.unshift(id)
  });
  return sorted
};
AuraComponentService.prototype.$getUpstreamDependencies$ = function(rootKey, graph, upstream) {
  upstream = upstream || {};
  for(var key in graph) {
    if(key !== rootKey) {
      var nodeDependencies = graph[key]["dependencies"];
      if(nodeDependencies.indexOf(rootKey) !== -1) {
        upstream[key] = true;
        this.$getUpstreamDependencies$(key, graph, upstream)
      }
    }
  }
  upstream[rootKey] = true;
  return upstream
};
AuraComponentService.prototype.$splitComponentsAndActions$ = function(graph, keys, exclude, actions, defs) {
  for(var key in keys) {
    if(exclude.indexOf(key) === -1) {
      if(graph[key]["action"]) {
        actions.push(key)
      }else {
        defs.push(key)
      }
    }
  }
};
AuraComponentService.prototype.$evictDefsFromStorage$ = function(sortedKeys, graph, requiredSpaceKb) {
  var defStorage = this.$componentDefStorage$.$getStorage$();
  var actionStorage = $A.$clientService$.$getActionStorage$();
  var self = this;
  return defStorage.$getSize$().$then$(function(startingSize) {
    var maxSize = defStorage.$getMaxSize$();
    var targetSize = Math.min(maxSize * self.$componentDefStorage$.$EVICTION_TARGET_LOAD$, maxSize - maxSize * self.$componentDefStorage$.$EVICTION_HEADROOM$ - requiredSpaceKb);
    var evicted = [];
    if(startingSize <= targetSize) {
      $A.log("AuraComponentService.evictDefsFromStorage: short-circuiting because current size (" + startingSize.toFixed(0) + "KB) \x3c target size (" + targetSize.toFixed(0) + "KB)");
      return Promise["resolve"]([])
    }
    return new Promise(function(resolve, reject) {
      function removeActions(actions) {
        if(!actionStorage.$isStorageEnabled$() || !actions.length) {
          $A.assert(actions.length === 0 || actionStorage.$isStorageEnabled$(), "Actions store doesn't exist but requested removal of " + actions.length + " actions");
          return Promise["resolve"]()
        }
        var promises = [];
        for(var i = 0;i < actions.length;i++) {
          promises.push(actionStorage.remove(actions[i], true))
        }
        return Promise["all"](promises).$then$(function() {
          $A.log("AuraComponentService.evictDefsFromStorage.removeActions(): removed " + promises.length + " actions")
        })
      }
      function evictRecursively(keysToEvict, currentSize) {
        var key = keysToEvict.pop();
        if(!key || currentSize <= targetSize) {
          resolve(evicted);
          return
        }
        var upstreamKeys = self.$getUpstreamDependencies$(key, graph);
        var actions = [];
        var defs = [];
        self.$splitComponentsAndActions$(graph, upstreamKeys, evicted, actions, defs);
        if(actions.length === 0 && defs.length === 0) {
          evictRecursively(keysToEvict, currentSize);
          return
        }
        removeActions(actions).$then$(function() {
          evicted.push.apply(evicted, actions)
        }).$then$(function() {
          return self.$componentDefStorage$.$removeDefs$(defs)
        }).$then$(function() {
          evicted.push.apply(evicted, defs);
          return defStorage.$getSize$()
        }).$then$(function(newSize) {
          evictRecursively(keysToEvict, newSize)
        }, function(e) {
          $A.log("AuraComponentService.evictDefsFromStorage(): error during component def or action removal", e);
          reject(e)
        })
      }
      $A.log("AuraComponentService.evictDefsFromStorage: evicting because current size (" + startingSize.toFixed(0) + "KB) \x3e target size (" + targetSize.toFixed(0) + "KB)");
      evictRecursively(sortedKeys, startingSize)
    })
  })
};
AuraComponentService.prototype.$pruneDefsFromStorage$ = function(requiredSpaceKb) {
  var self = this;
  var defStorage = this.$componentDefStorage$.$getStorage$();
  if(!defStorage) {
    return Promise["resolve"]()
  }
  var currentSize = 0;
  var newSize = 0;
  return defStorage.$getSize$().$then$(function(size) {
    currentSize = size;
    var maxSize = defStorage.$getMaxSize$();
    newSize = currentSize + requiredSpaceKb + maxSize * self.$componentDefStorage$.$EVICTION_HEADROOM$;
    if(newSize < maxSize) {
      return false
    }
    var metricsPayload = {"cause":"sizeAboveThreshold", "defsRequiredSize":requiredSpaceKb, "storageCurrentSize":currentSize, "storageRequiredSize":newSize};
    return self.$clearDefsFromStorage$(metricsPayload).$then$(function() {
      return true
    })
  })
};
Aura.$Services$.$AuraComponentService$ = AuraComponentService;
function AuraRenderingService() {
  this.$visited$ = undefined;
  this.$afterRenderStack$ = [];
  this.$dirtyComponents$ = {};
  this.$dirtyComponentIds$ = [];
  this.$needsCleaning$ = false;
  this.$markerToReferencesMap$ = {};
  this.$rerenderFacetTopVisit$ = true;
  this.$DATA_UID_KEY$ = "data-rendering-service-uid";
  this.uid = 1
}
goog.$exportSymbol$("AuraRenderingService", AuraRenderingService);
AuraRenderingService.prototype.$render$ = function(components, parent) {
  components = this.$getArray$(components);
  var elements = [];
  for(var i = 0;i < components.length;i++) {
    var cmp = components[i];
    if(!$A["util"].$isComponent$(cmp)) {
      if($A.$componentService$.$isComponentDefRef$(cmp)) {
        cmp = $A.$componentService$.$createComponentPriv$(cmp);
        components[i] = cmp
      }else {
        $A.$warning$("AuraRenderingService.render: 'component[" + i + "]' was not a valid component, found '" + cmp + "'.");
        continue
      }
    }
    if(cmp.$isValid$()) {
      $A.$clientService$.$setCurrentAccess$(cmp);
      try {
        var renderedElements = cmp["render"]();
        renderedElements = this.$finishRender$(cmp, renderedElements);
        elements = elements.concat(renderedElements)
      }catch(e) {
        if(e instanceof $A.$auraError$ && e["component"]) {
          throw e;
        }else {
          var ae = new $A.$auraError$("render threw an error in '" + cmp.$getType$() + "'", e);
          $A.$lastKnownError$ = ae;
          throw ae;
        }
      }finally {
        $A.$clientService$.$releaseCurrentAccess$()
      }
    }
  }
  if(parent) {
    $A["util"].appendChild(elements, parent)
  }
  return elements
};
goog.$exportProperty$(AuraRenderingService.prototype, "render", AuraRenderingService.prototype.$render$);
AuraRenderingService.prototype.$rerender$ = function(components) {
  var topVisit = false;
  var visited = this.$visited$;
  if(!visited) {
    visited = this.$visited$ = {};
    topVisit = true
  }
  var elements = [];
  components = this.$getArray$(components);
  for(var i = 0;i < components.length;i++) {
    var cmp = components[i];
    var id = cmp.$getGlobalId$();
    if(cmp.$isValid$()) {
      var renderedElements = [];
      var addExistingElements = visited[id];
      if(!visited[id]) {
        if(!cmp.$isRendered$()) {
          throw new $A.$auraError$("Aura.RenderingService.rerender: attempt to rerender component that has not been rendered.", null, $A.severity.$QUIET$);
        }
        var rerenderedElements = undefined;
        $A.$clientService$.$setCurrentAccess$(cmp);
        try {
          rerenderedElements = cmp["rerender"]()
        }catch(e) {
          if(e instanceof $A.$auraError$ && e["component"]) {
            throw e;
          }else {
            var ae = new $A.$auraError$("rerender threw an error in '" + cmp.$getType$() + "'", e);
            $A.$lastKnownError$ = ae;
            throw ae;
          }
        }finally {
          $A.$clientService$.$releaseCurrentAccess$();
          if(rerenderedElements != undefined) {
            renderedElements = renderedElements.concat(rerenderedElements)
          }else {
            addExistingElements = true
          }
        }
        visited[id] = true
      }
      if(addExistingElements) {
        renderedElements = renderedElements.concat(this.$getElements$(cmp))
      }
      elements = elements.concat(renderedElements)
    }
    this.$cleanComponent$(id)
  }
  if(topVisit) {
    this.$visited$ = undefined;
    this.$afterRender$(this.$afterRenderStack$);
    this.$afterRenderStack$.length = 0;
    for(var r = 0;r < components.length;r++) {
      components[r].$fire$("render")
    }
  }
  return elements
};
goog.$exportProperty$(AuraRenderingService.prototype, "rerender", AuraRenderingService.prototype.$rerender$);
AuraRenderingService.prototype.$afterRender$ = function(components) {
  components = this.$getArray$(components);
  for(var i = 0;i < components.length;i++) {
    var cmp = components[i];
    if(!$A["util"].$isComponent$(cmp)) {
      $A.$warning$("AuraRenderingService.afterRender: 'cmp' must be a valid Component, found '" + cmp + "'.", null, $A.severity.$QUIET$);
      continue
    }
    if(cmp.$isValid$()) {
      $A.$clientService$.$setCurrentAccess$(cmp);
      try {
        cmp["afterRender"]();
        cmp.$fire$("render")
      }catch(e) {
        if(e instanceof $A.$auraError$ && e["component"]) {
          throw e;
        }else {
          var ae = new $A.$auraError$("afterRender threw an error in '" + cmp.$getType$() + "'", e);
          $A.$lastKnownError$ = ae;
          throw ae;
        }
      }finally {
        $A.$clientService$.$releaseCurrentAccess$(cmp)
      }
    }
  }
};
goog.$exportProperty$(AuraRenderingService.prototype, "afterRender", AuraRenderingService.prototype.$afterRender$);
AuraRenderingService.prototype.$unrender$ = function(components) {
  if(!components) {
    return
  }
  var visited = this.$visited$;
  components = this.$getArray$(components);
  var cmp;
  var container;
  var beforeUnrenderElements;
  var i = 0;
  for(var length = components.length;i < length;i++) {
    cmp = components[i];
    if($A["util"].$isComponent$(cmp) && cmp.$destroyed$ !== 1 && cmp.$isRendered$()) {
      cmp.$setUnrendering$(true);
      $A.$clientService$.$setCurrentAccess$(cmp);
      container = cmp.$getContainer$() || cmp.$getOwner$();
      if(container && !container.$getConcreteComponent$().$isUnrendering$()) {
        beforeUnrenderElements = cmp.$getElements$()
      }else {
        beforeUnrenderElements = null
      }
      try {
        cmp["unrender"]()
      }catch(e) {
        if(e instanceof $A.$auraError$ && e["component"]) {
          throw e;
        }else {
          var ae = new $A.$auraError$("unrender threw an error in '" + cmp.$getType$() + "'", e);
          $A.$lastKnownError$ = ae;
          throw ae;
        }
      }finally {
        $A.$clientService$.$releaseCurrentAccess$(cmp);
        this.$removeElement$(this.$getMarker$(cmp), container);
        if(beforeUnrenderElements && beforeUnrenderElements.length) {
          var c = 0;
          for(var len = beforeUnrenderElements.length;c < len;c++) {
            $A["util"].$removeElement$(beforeUnrenderElements[c])
          }
        }
        if(cmp.$destroyed$ !== 1) {
          cmp.$setRendered$(false);
          if(visited) {
            visited[cmp.$getGlobalId$()] = true
          }
          cmp.$setUnrendering$(false)
        }
      }
    }
  }
};
goog.$exportProperty$(AuraRenderingService.prototype, "unrender", AuraRenderingService.prototype.$unrender$);
AuraRenderingService.prototype.$storeFacetInfo$ = function(component, facet) {
  if(!$A["util"].$isComponent$(component)) {
    throw new $A.$auraError$("AuraRenderingService.storeFacetInfo: 'component' must be a valid Component. Found '" + component + "'.", null, $A.severity.$QUIET$);
  }
  if($A["util"].$isComponent$(facet)) {
    facet = [facet]
  }
  if(!$A["util"].isArray(facet)) {
    $A.$warning$("AuraRenderingService.storeFacetInfo: 'facet' must be a Component or an Array. Found '" + facet + "' in '" + component.$getType$() + "'.");
    facet = []
  }
  component.$_facetInfo$ = facet.slice(0)
};
AuraRenderingService.prototype.$getUpdatedFacetInfo$ = function(component, facet) {
  if(!$A["util"].$isComponent$(component)) {
    throw new $A.$auraError$("AuraRenderingService.getUpdatedFacetInfo: 'component' must be a valid Component. Found '" + component + "'.", null, $A.severity.$QUIET$);
  }
  if($A["util"].$isComponent$(facet)) {
    facet = [facet]
  }
  if(!$A["util"].isArray(facet)) {
    $A.$warning$("AuraRenderingService.getUpdatedFacetInfo: 'facet' must be a Component or an Array. Found '" + facet + "' in '" + component.$getType$() + "'.");
    facet = []
  }
  var updatedFacet = {$components$:[], $facetInfo$:[], $useFragment$:false, $fullUnrender$:false};
  var renderCount = 0;
  if(component.$_facetInfo$) {
    var jmax = 0;
    for(var i = 0;i < facet.length;i++) {
      var child = facet[i];
      if(child) {
        if(!$A["util"].$isComponent$(child)) {
          $A.$warning$("AuraRenderingService.getUpdatedFacetInfo: all values to be rendered in an expression must be components.  Found '" + child + "' in '" + component.$getType$() + "'.");
          continue
        }
        var found = false;
        for(var j = 0;j < component.$_facetInfo$.length;j++) {
          if(child === component.$_facetInfo$[j]) {
            updatedFacet.$components$.push({action:"rerender", $component$:child, $oldIndex$:j, $newIndex$:i});
            if(j !== i - renderCount && j < jmax) {
              updatedFacet.$useFragment$ = true
            }
            jmax = j;
            found = true;
            component.$_facetInfo$[j] = undefined;
            break
          }
        }
        if(!found) {
          updatedFacet.$components$.push({action:"render", $component$:child, $oldIndex$:-1, $newIndex$:i});
          renderCount++
        }
        updatedFacet.$facetInfo$.push(child)
      }
    }
    if(!updatedFacet.$components$.length) {
      updatedFacet.$fullUnrender$ = true
    }
    for(var x = 0;x < component.$_facetInfo$.length;x++) {
      if(component.$_facetInfo$[x]) {
        updatedFacet.$components$.unshift({action:"unrender", $component$:component.$_facetInfo$[x], $oldIndex$:x, $newIndex$:-1})
      }
    }
  }
  return updatedFacet
};
AuraRenderingService.prototype.$renderFacet$ = function(component, facet, parent) {
  var ret = this.$render$(facet, parent);
  this.$storeFacetInfo$(component, facet);
  var containerId = component.$globalId$;
  var componentOnFacet;
  for(var i = 0;i < component.$_facetInfo$.length;i++) {
    componentOnFacet = component.$_facetInfo$[i];
    if($A["util"].$isComponent$(componentOnFacet) && componentOnFacet.$containerComponentId$ !== containerId) {
      componentOnFacet.$setContainerComponentId$(component.$globalId$)
    }
  }
  if(!ret.length) {
    if(parent) {
      this.$setMarker$(component, parent)
    }else {
      this.$setMarker$(component, ret[0] = this.$createMarker$(null, "render facet: " + component.$getGlobalId$()))
    }
  }else {
    if(parent) {
      this.$setMarker$(component, parent)
    }else {
      this.$setMarker$(component, ret[0])
    }
  }
  return ret
};
goog.$exportProperty$(AuraRenderingService.prototype, "renderFacet", AuraRenderingService.prototype.$renderFacet$);
AuraRenderingService.prototype.$rerenderFacet$ = function(component, facet, referenceNode) {
  var updatedFacet = this.$getUpdatedFacetInfo$(component, facet);
  var ret = [];
  var marker = this.$getMarker$(component);
  var target = referenceNode || marker.parentNode;
  var calculatedPosition = 0;
  var nextSibling = null;
  var topVisit = this.$rerenderFacetTopVisit$;
  var beforeRerenderElements = null;
  var oldElementContainerPositions = null;
  if(topVisit) {
    this.$rerenderFacetTopVisit$ = false;
    beforeRerenderElements = this.$getAllElementsCopy$(component);
    oldElementContainerPositions = this.$findElementsPositionFromContainers$(component)
  }
  if(marker !== target) {
    var elements = this.$getAllElements$(component);
    var length = elements.length;
    var current = marker;
    for(var totalElements = 0;current != null && current.previousSibling;) {
      calculatedPosition++;
      current = current.previousSibling
    }
    for(current = elements[length - 1];current != null;) {
      totalElements++;
      if(current === marker) {
        break
      }
      current = current.previousSibling
    }
    calculatedPosition = calculatedPosition + (totalElements - length)
  }
  var components = updatedFacet.$components$;
  for(var i = 0;i < components.length;i++) {
    var info = components[i];
    var renderedElements = null;
    if(!info.$component$.$isValid$() && info.action !== "unrender") {
      continue
    }
    switch(info.action) {
      case "render":
        var containerId = component.$globalId$;
        if(info.$component$.$containerComponentId$ !== containerId) {
          info.$component$.$setContainerComponentId$(containerId)
        }
        renderedElements = this.$render$(info.$component$);
        if(updatedFacet.$useFragment$) {
          ret = ret.concat(renderedElements)
        }else {
          if(renderedElements.length) {
            ret = ret.concat(renderedElements);
            nextSibling = target.childNodes[calculatedPosition];
            this.$insertElements$(renderedElements, nextSibling || target, nextSibling, nextSibling)
          }
        }
        calculatedPosition += renderedElements.length;
        this.$afterRenderStack$.push(info.$component$);
        break;
      case "rerender":
        if(this.$hasDirtyValue$(info.$component$)) {
          renderedElements = this.$rerender$(info.$component$)
        }else {
          renderedElements = this.$getAllElementsCopy$(info.$component$)
        }
        info.$component$.$disassociateElements$();
        this.$associateElements$(info.$component$, renderedElements);
        ret = ret.concat(renderedElements);
        calculatedPosition += renderedElements.length;
        break;
      case "unrender":
        marker = this.$getMarker$(component);
        if(!this.$isCommentMarker$(marker) && component.$getType$() !== "aura:html") {
          var allElements = this.$getAllElements$(info.$component$);
          if(updatedFacet.$fullUnrender$ || !marker.nextSibling) {
            var newMarker = this.$createMarker$(marker, "unrender facet: " + component.$getGlobalId$());
            this.$setMarker$(component, newMarker);
            calculatedPosition += 1
          }else {
            if(info.$component$.$isValid$() && allElements[0] === marker) {
              var count = allElements.length - 1;
              for(nextSibling = marker.nextSibling;count && nextSibling.nextSibling;) {
                nextSibling = nextSibling.nextSibling;
                count--
              }
              this.$setMarker$(component, nextSibling)
            }
          }
        }
        if($A["util"].$isComponent$(info.$component$) && info.$component$.$isValid$()) {
          if(info.$component$.$autoDestroy$()) {
            this.$cleanComponent$(info.$component$.$getGlobalId$());
            info.$component$.$destroy$()
          }else {
            this.$unrender$(info.$component$);
            info.$component$.$disassociateElements$();
            this.$cleanComponent$(info.$component$.$getGlobalId$())
          }
        }
        break
    }
  }
  this.$storeFacetInfo$(component, updatedFacet.$facetInfo$);
  if(updatedFacet.$useFragment$) {
    nextSibling = target.childNodes[calculatedPosition];
    this.$insertElements$(ret, nextSibling || target, nextSibling, nextSibling)
  }
  var type = component.$getType$();
  if(type !== "aura:html") {
    marker = this.$getMarker$(component);
    if(ret.length > 0 && marker !== ret[0]) {
      this.$setMarker$(component, ret[0]);
      if(this.$isCommentMarker$(marker)) {
        this.$moveReferencesToMarker$(marker, ret[0]);
        this.$removeElement$(marker)
      }
    }else {
      if(ret.length === 0 && marker) {
        ret.push(marker)
      }
    }
    component.$disassociateElements$();
    this.$associateElements$(component, ret);
    if(topVisit) {
      var updatedElements = this.$getAllElements$(component);
      var updateContainer = updatedElements.length !== beforeRerenderElements.length;
      if(!updateContainer) {
        var n = 0;
        for(var len = beforeRerenderElements.length;n < len;n++) {
          if(beforeRerenderElements[n] !== updatedElements[n]) {
            updateContainer = true;
            break
          }
        }
      }
      if(updateContainer) {
        var container = component.$getConcreteComponent$().$getContainer$();
        this.$updateContainerElements$(container, oldElementContainerPositions, beforeRerenderElements, updatedElements)
      }
    }
  }
  if(topVisit) {
    this.$rerenderFacetTopVisit$ = true
  }
  return ret
};
goog.$exportProperty$(AuraRenderingService.prototype, "rerenderFacet", AuraRenderingService.prototype.$rerenderFacet$);
AuraRenderingService.prototype.$findElementsPositionFromContainers$ = function(component) {
  var indexSet = [];
  var visited = {};
  var allElements = this.$getAllElements$(component);
  var concrete = component.$getConcreteComponent$();
  visited[concrete.$getGlobalId$()] = true;
  this.$collectElementPositionsFromContainers$(concrete, allElements[0], indexSet, visited);
  return indexSet
};
AuraRenderingService.prototype.$collectElementPositionsFromContainers$ = function(concreteComponent, element, indexSet, visited) {
  var container = concreteComponent.$getContainer$();
  if(!container) {
    return
  }
  var concrete = container.$getConcreteComponent$();
  var globalId = concrete.$getGlobalId$();
  if(concrete.$getType$() === "aura:html" && concrete["helper"].$canHaveBody$(concrete) || concrete.$isRendered$() === false || visited[globalId] === true) {
    return
  }
  var allElements = this.$getAllElements$(concrete);
  var index = allElements.indexOf(element);
  if(index < 0) {
    $A.log("AuraRenderingService.collectElementPositionsFromContainers(): Something is wrong. Container is missing children's elements");
    return
  }
  indexSet.push(index);
  visited[globalId] = true;
  this.$collectElementPositionsFromContainers$(concrete, element, indexSet, visited)
};
AuraRenderingService.prototype.$updateContainerElements$ = function(container, insertPositions, oldElements, updatedElements) {
  if(!container || insertPositions.length === 0) {
    return
  }
  var concrete = container.$getConcreteComponent$();
  if(concrete.$getType$() === "aura:html" && concrete["helper"].$canHaveBody$(concrete) || concrete.$isRendered$() === false) {
    return
  }
  var containerUpdatedElements = this.$getAllElementsCopy$(concrete);
  var index = insertPositions.shift();
  Array.prototype.splice.apply(containerUpdatedElements, [index, oldElements.length].concat(updatedElements));
  concrete.$disassociateElements$();
  this.$associateElements$(concrete, containerUpdatedElements);
  if(containerUpdatedElements[0] && containerUpdatedElements[0] !== this.$getMarker$(concrete)) {
    this.$setMarker$(concrete, containerUpdatedElements[0])
  }
  this.$updateContainerElements$(concrete.$getContainer$(), insertPositions, oldElements, updatedElements)
};
AuraRenderingService.prototype.$unrenderFacet$ = function(cmp, facet) {
  if(cmp.$_facetInfo$) {
    var facetInfo = [];
    if(cmp.$destroyed$ === -1 && cmp.$getType$() !== "aura:expression") {
      var existing = cmp.$_facetInfo$;
      for(var i = 0;i < existing.length;i++) {
        if(existing[i].$autoDestroy$()) {
          existing[i].$destroy$()
        }else {
          facetInfo.push(existing[i])
        }
      }
    }else {
      facetInfo = cmp.$_facetInfo$
    }
    this.$unrender$(facetInfo);
    cmp.$_facetInfo$ = null
  }
  if(facet) {
    this.$unrender$(facet)
  }
  var elements = this.$getAllElements$(cmp);
  var element;
  if(elements) {
    var globalId = cmp.$getGlobalId$();
    for(var c = elements.length - 1;c >= 0;c--) {
      element = elements[c];
      this.$removeMarkerReference$(element, globalId);
      this.$removeElement$(element, cmp)
    }
  }
  cmp.$disassociateElements$()
};
goog.$exportProperty$(AuraRenderingService.prototype, "unrenderFacet", AuraRenderingService.prototype.$unrenderFacet$);
AuraRenderingService.prototype.$getMarker$ = function(cmp) {
  if(!cmp || cmp.$destroyed$ === 1) {
    return null
  }
  return cmp.$getConcreteComponent$().$_marker$
};
goog.$exportProperty$(AuraRenderingService.prototype, "getMarker", AuraRenderingService.prototype.$getMarker$);
AuraRenderingService.prototype.$setMarker$ = function(cmp, newMarker) {
  if(!cmp) {
    return
  }
  var concrete = cmp.$getConcreteComponent$();
  var oldMarker = this.$getMarker$(concrete);
  if(oldMarker === newMarker) {
    return
  }
  var type = cmp.$getType$();
  if(type !== "aura:html") {
    $A.$renderingService$.$addMarkerReference$(newMarker, concrete.$getGlobalId$())
  }
  if(oldMarker) {
    $A.$renderingService$.$removeMarkerReference$(oldMarker, concrete.$getGlobalId$())
  }
  if(!newMarker) {
    concrete.$_marker$ = null
  }else {
    concrete.$_marker$ = newMarker
  }
};
AuraRenderingService.prototype.$addDirtyValue$ = function(expression, cmp) {
  this.$needsCleaning$ = true;
  if(cmp && cmp.$isValid$() && cmp.$isRendered$()) {
    var id = cmp.$getGlobalId$();
    var list = this.$dirtyComponents$[id];
    if(!list) {
      list = this.$dirtyComponents$[id] = {};
      this.$dirtyComponentIds$.push(id)
    }
    for(;expression.indexOf(".") > -1;) {
      list[expression] = true;
      expression = expression.substring(0, expression.lastIndexOf("."))
    }
  }
};
AuraRenderingService.prototype.$hasDirtyValue$ = function(cmp) {
  return this.$dirtyComponents$.hasOwnProperty(cmp.$getGlobalId$())
};
AuraRenderingService.prototype.$isDirtyValue$ = function(expression, cmp) {
  if(cmp && cmp.$isValid$()) {
    var id = cmp.$getGlobalId$();
    var list = this.$dirtyComponents$[id];
    if(list && list[expression]) {
      return true
    }
  }
  return false
};
AuraRenderingService.prototype.$rerenderDirty$ = function(stackName) {
  if(this.$needsCleaning$) {
    for(var maxiterations = 1E3;this.$needsCleaning$ && maxiterations;) {
      var dirty = [];
      this.$needsCleaning$ = false;
      for(maxiterations--;this.$dirtyComponentIds$.length;) {
        var id = this.$dirtyComponentIds$.shift();
        var cmp = $A.$componentService$.get(id);
        if(cmp && cmp.$isValid$() && cmp.$isRendered$()) {
          if(!cmp.$isUnrendering$()) {
            dirty.push(cmp)
          }
        }else {
          this.$cleanComponent$(id)
        }
      }
      if(dirty.length) {
        this.$rerender$(dirty)
      }
    }
    $A.assert(maxiterations, "Max Callstack Exceeded: Rerendering loop resulted in to many rerenderings.");
    $A.$eventService$.$getNewEvent$("markup://aura:doneRendering").$fire$()
  }
};
goog.$exportProperty$(AuraRenderingService.prototype, "rerenderDirty", AuraRenderingService.prototype.$rerenderDirty$);
AuraRenderingService.prototype.$removeDirtyValue$ = function(value, cmp) {
  if(cmp && cmp.$isValid$()) {
    var id = cmp.$getGlobalId$();
    var dirtyAttributes = this.$dirtyComponents$[id];
    if(dirtyAttributes) {
      if(dirtyAttributes[value]) {
        delete dirtyAttributes[value]
      }
      if($A["util"].$isEmpty$(dirtyAttributes)) {
        delete this.$dirtyComponents$[id];
        for(var i = 0;i < this.$dirtyComponentIds$.length;i++) {
          if(this.$dirtyComponentIds$[i] === id) {
            return this.$dirtyComponentIds$.splice(i, 1)
          }
        }
      }
    }
  }
};
AuraRenderingService.prototype.$cleanComponent$ = function(id) {
  delete this.$dirtyComponents$[id]
};
AuraRenderingService.prototype.$getArray$ = function(things) {
  if(!$A["util"].isArray(things)) {
    return things ? [things] : []
  }
  return things
};
AuraRenderingService.prototype.$evalStrings$ = function(elements) {
  if($A["util"].$isString$(elements)) {
    elements = $A["util"].$createElementsFromMarkup$(elements)
  }
  return elements || []
};
AuraRenderingService.prototype.$finishRender$ = function(cmp, elements) {
  elements = this.$evalStrings$(elements);
  this.$associateElements$(cmp, elements);
  cmp.$setRendered$(true);
  this.$cleanComponent$(cmp.$getGlobalId$());
  return elements
};
AuraRenderingService.prototype.$insertElements$ = function(elements, refNode, asSibling, asFirst) {
  if(refNode) {
    if(asSibling) {
      if(asFirst) {
        $A["util"].insertBefore(elements, refNode)
      }else {
        $A["util"].$insertAfter$(elements, refNode)
      }
    }else {
      if(asFirst) {
        $A["util"].$insertFirst$(elements, refNode)
      }else {
        $A["util"].appendChild(elements, refNode)
      }
    }
  }
};
AuraRenderingService.prototype.$getFlavorClass$ = function(cmp) {
  var flavor = null;
  var staticFlavorable = cmp.$isFlavorable$();
  var dynamicFlavorable = cmp.$getDef$().$isDynamicallyFlavorable$();
  var valueProvider = dynamicFlavorable ? cmp : cmp.$getComponentValueProvider$();
  if(valueProvider && (staticFlavorable || dynamicFlavorable)) {
    if(valueProvider.$getConcreteComponent$()) {
      flavor = valueProvider.$getConcreteComponent$().$getFlavor$()
    }
    if($A["util"].$isUndefinedOrNull$(flavor)) {
      flavor = valueProvider.$getFlavor$()
    }
    if(!$A["util"].$isUndefinedOrNull$(flavor) && $A["util"].$isExpression$(flavor)) {
      flavor = flavor.evaluate()
    }
    if(staticFlavorable && !$A["util"].$isUndefinedOrNull$(flavor)) {
      return $A["util"].$buildFlavorClass$(valueProvider, flavor)
    }else {
      if(dynamicFlavorable) {
        var flavorClasses = [];
        var dynamicallyFlavorableDefs = cmp.$getDef$().$getDynamicallyFlavorable$();
        var i = 0;
        for(var len = dynamicallyFlavorableDefs.length;i < len;i++) {
          var def = dynamicallyFlavorableDefs[i];
          var defFlavor = !$A["util"].$isUndefinedOrNull$(flavor) ? flavor : def.$getDefaultFlavor$();
          if(!$A["util"].$isUndefinedOrNull$(defFlavor)) {
            flavorClasses.push($A["util"].$buildFlavorClass$(def, defFlavor))
          }
        }
        return flavorClasses.join(" ")
      }
    }
  }
  return null
};
AuraRenderingService.prototype.$addAuraClass$ = function(cmp, element) {
  var concrete = cmp.$getConcreteComponent$();
  var className = concrete.$getDef$().$getStyleClassName$();
  var flavorClassName;
  if(className) {
    flavorClassName = this.$getFlavorClass$(concrete);
    if(flavorClassName) {
      className = className + flavorClassName
    }
    $A["util"].$addClass$(element, className);
    if(element["tagName"]) {
      element.setAttribute("data-aura-class", $A["util"].$buildClass$(element.getAttribute("data-aura-class"), className))
    }
  }else {
    if(concrete.$isInstanceOf$("aura:html")) {
      flavorClassName = this.$getFlavorClass$(concrete, element);
      if(flavorClassName) {
        $A["util"].$addClass$(element, flavorClassName);
        if(element["tagName"]) {
          element.setAttribute("data-aura-class", $A["util"].$buildClass$(element.getAttribute("data-aura-class"), flavorClassName))
        }
      }
    }
  }
};
AuraRenderingService.prototype.$associateElements$ = function(cmp, elements) {
  elements = this.$getArray$(elements);
  var len = elements.length;
  var element;
  for(var i = 0;i < len;i++) {
    element = elements[i];
    if(!this.$isCommentMarker$(element)) {
      this.$addAuraClass$(cmp, element)
    }
    cmp.$associateElement$(element)
  }
};
AuraRenderingService.prototype.$createMarker$ = function(target, reason) {
  var node = document.createComment(reason);
  node.$aura_marker$ = true;
  if(target) {
    $A["util"].insertBefore(node, target)
  }
  return node
};
AuraRenderingService.prototype.$isCommentMarker$ = function(node) {
  return node && node.$aura_marker$
};
AuraRenderingService.prototype.$getElements$ = function(component) {
  return component.$getConcreteComponent$().elements || []
};
AuraRenderingService.prototype.$getAllElements$ = function(component) {
  return component.$getConcreteComponent$().$allElements$ || []
};
AuraRenderingService.prototype.$getAllElementsCopy$ = function(component) {
  return component.$getConcreteComponent$().$allElements$.slice(0) || []
};
AuraRenderingService.prototype.$getUid$ = function(element) {
  if(element.nodeType === 1) {
    var id = $A["util"].$getDataAttribute$(element, $A.$componentService$.$renderedBy$);
    if(id !== null) {
      return id
    }
    id = $A["util"].$getDataAttribute$(element, this.$DATA_UID_KEY$);
    if(id !== null) {
      return id
    }
  }
  return element[this.$DATA_UID_KEY$]
};
AuraRenderingService.prototype.$newUid$ = function(element) {
  var nextUid = this.uid++;
  var success = null;
  if(element.nodeType === 1) {
    success = $A["util"].$setDataAttribute$(element, this.$DATA_UID_KEY$, nextUid)
  }
  if(success === null) {
    element[this.$DATA_UID_KEY$] = nextUid
  }
  return nextUid
};
AuraRenderingService.prototype.$resolveUid$ = function(element) {
  var uid = this.$getUid$(element);
  if(uid === null || uid === undefined) {
    return this.$newUid$(element)
  }
  return uid
};
AuraRenderingService.prototype.$addMarkerReference$ = function(marker, globalId) {
  if(!marker || !globalId) {
    return
  }
  var uid = this.$resolveUid$(marker);
  var existing = this.$markerToReferencesMap$[uid];
  if(!existing) {
    this.$markerToReferencesMap$[uid] = existing = new this.$ReferenceCollection$
  }
  existing.add(globalId)
};
AuraRenderingService.prototype.$removeMarkerReference$ = function(marker, globalId) {
  if(!marker || !globalId) {
    return
  }
  var resolvedMarker = this.$resolveUid$(marker);
  var references = this.$markerToReferencesMap$[resolvedMarker];
  if(!$A["util"].$isUndefinedOrNull$(references)) {
    references.$delete$(globalId, function(refs) {
      this.$removeMarkerFromReferenceMap$(resolvedMarker, refs)
    }.bind(this))
  }
};
AuraRenderingService.prototype.$removeMarkerFromReferenceMap$ = function(resolvedMarker, refs) {
  if(!resolvedMarker) {
    return
  }
  if($A["util"].$isUndefinedOrNull$(refs) || $A["util"].$isEmpty$(refs)) {
    this.$markerToReferencesMap$[resolvedMarker] = null;
    delete this.$markerToReferencesMap$[resolvedMarker]
  }
};
AuraRenderingService.prototype.$getMarkerReferences$ = function(marker) {
  if(!marker) {
    return null
  }
  return this.$markerToReferencesMap$[this.$resolveUid$(marker)]
};
AuraRenderingService.prototype.$removeElement$ = function(marker, container) {
  var concrete = container && container.$getConcreteComponent$();
  if(!concrete || !concrete.$isUnrendering$()) {
    if(this.$isSharedMarker$(marker)) {
      if(this.$isCommentMarker$(marker)) {
        return
      }
      this.$moveReferencesToMarker$(marker)
    }else {
      if(concrete && concrete.$destroyed$ === -1 && !this.$isCommentMarker$(marker)) {
        return
      }
    }
    $A["util"].$removeElement$(marker)
  }
};
AuraRenderingService.prototype.$moveReferencesToMarker$ = function(marker, newMarker) {
  var references = this.$getMarkerReferences$(marker);
  var isSwap = !!newMarker;
  newMarker = newMarker || this.$createMarker$(null, "unrender marker: " + marker.nodeValue);
  if(references) {
    var collection = references.get();
    for(var c = collection.length - 1;c >= 0;c--) {
      var cmp = $A.$getComponent$(collection[c]);
      if(cmp && !cmp.$destroyed$) {
        this.$setMarker$(cmp, newMarker);
        var concrete = cmp.$getConcreteComponent$();
        var elements = concrete.$allElements$;
        var position;
        if(!elements) {
          concrete.elements = concrete.$allElements$ = [newMarker]
        }else {
          position = elements.indexOf(marker);
          if(position === -1) {
            $A.$warning$("AuraRenderingService.moveReferencesToMarker(): Missing marker on component " + cmp);
            position = elements.length
          }
          var filteredElements = [];
          elements[position] = newMarker;
          for(var i = 0;i < elements.length;i++) {
            if(!elements[i].$aura_marker$) {
              filteredElements.push(elements[i])
            }
          }
          concrete.elements = filteredElements
        }
      }
    }
  }
  if(!isSwap && this.$isSharedMarker$(newMarker)) {
    $A["util"].insertBefore(newMarker, marker)
  }
};
AuraRenderingService.prototype.$isSharedMarker$ = function(marker) {
  var references = this.$getMarkerReferences$(marker);
  if(references) {
    return references.size() > 0
  }
  return false
};
AuraRenderingService.prototype.$ReferenceCollection$ = function() {
};
AuraRenderingService.prototype.$ReferenceCollection$.prototype.$isCollection$ = false;
AuraRenderingService.prototype.$ReferenceCollection$.prototype.add = function(value) {
  if(typeof value !== "string") {
    return
  }
  if(this.$has$(value)) {
    return
  }
  if(!this.$references$) {
    this.$references$ = value
  }else {
    if(!this.$isCollection$) {
      if(this.$references$ !== value) {
        this.$references$ = [this.$references$, value];
        this.$isCollection$ = true
      }
    }else {
      this.$references$.push(value)
    }
  }
};
AuraRenderingService.prototype.$ReferenceCollection$.prototype.$delete$ = function(value, callback) {
  if(typeof value !== "string") {
    return
  }
  if(this.$isCollection$) {
    var index = this.$references$.indexOf(value);
    if(index > -1) {
      this.$references$.splice(index, 1)
    }
  }
  if(this.$references$ === value) {
    this.$references$ = null
  }
  callback(this.$references$)
};
AuraRenderingService.prototype.$ReferenceCollection$.prototype.$has$ = function(value) {
  if(!this.$isCollection$) {
    return this.$references$ === value
  }
  if(this.$references$) {
    return this.$references$.indexOf(value) !== -1
  }
  return false
};
AuraRenderingService.prototype.$ReferenceCollection$.prototype.size = function() {
  if(this.$references$) {
    if(typeof this.$references$ === "string") {
      return 1
    }else {
      return this.$references$.length
    }
  }
  return 0
};
AuraRenderingService.prototype.$ReferenceCollection$.prototype.get = function(index) {
  if(index === undefined) {
    if(this.$isCollection$) {
      return this.$references$
    }else {
      return[this.$references$]
    }
  }
  return this.$references$[index]
};
Aura.$Services$.$AuraRenderingService$ = AuraRenderingService;
function AuraExpressionService() {
  this.$references$ = {}
}
goog.$exportSymbol$("AuraExpressionService", AuraExpressionService);
AuraExpressionService.$PRIMITIVE_SEPARATOR$ = "__";
AuraExpressionService.$AURA_IF$ = "aura:if";
AuraExpressionService.$AURA_ITERATION$ = "aura:iteration";
AuraExpressionService.prototype.$getReference$ = function(expression, valueProvider) {
  expression = $A.$expressionService$.normalize(expression);
  var isGlobal = expression.charAt(0) === "$";
  var target = null;
  if(isGlobal) {
    target = this.$references$
  }else {
    var id = valueProvider.$getGlobalId$();
    if(!this.$references$.hasOwnProperty(id)) {
      this.$references$[id] = {}
    }
    target = this.$references$[id]
  }
  if(!target.hasOwnProperty(expression)) {
    target[expression] = {$reference$:new PropertyReferenceValue(expression, isGlobal ? null : valueProvider), $consumers$:{}}
  }
  return target[expression].$reference$
};
AuraExpressionService.prototype.$clearReferences$ = function(valueProvider) {
  if($A["util"].$isComponent$(valueProvider)) {
    var globalId = valueProvider.$getGlobalId$();
    var target = this.$references$[globalId];
    if(target) {
      for(var expression in target) {
        var reference = target[expression];
        if(reference && reference.$consumers$) {
          for(var consumer in reference.$consumers$) {
            var component = $A.$getComponent$(consumer);
            for(var targetExpression in reference.$consumers$[consumer]) {
              component.$clearReference$(targetExpression)
            }
          }
        }
      }
    }
    delete this.$references$[globalId]
  }
};
AuraExpressionService.prototype.$updateGlobalReference$ = function(expression, oldValue, value) {
  expression = $A.$expressionService$.normalize(expression);
  var reference = this.$references$[expression];
  if(reference && reference.$consumers$ && reference.$reference$ && reference.$reference$.$lastResult$ !== value) {
    reference.$reference$.evaluate();
    for(var consumer in reference.$consumers$) {
      var component = $A.$getComponent$(consumer);
      if(component) {
        for(var targetExpression in reference.$consumers$[consumer]) {
          component.$markDirty$(targetExpression);
          component.$fireChangeEvent$(targetExpression, reference.$reference$.$lastResult$ || oldValue, value)
        }
      }
    }
  }
};
AuraExpressionService.prototype.$updateGlobalReferences$ = function(type, newValues) {
  function updateNestedValue(expression, values, newValuesInside) {
    if(!values) {
      values = {}
    }
    for(var value in newValuesInside) {
      var targetExpression = expression + "." + value;
      $A.$expressionService$.$updateGlobalReference$(targetExpression, values[value], newValuesInside[value]);
      if($A["util"].$isObject$(newValuesInside[value])) {
        updateNestedValue(targetExpression, values[value], newValuesInside[value])
      }
    }
  }
  var gvpValues = $A.get(type);
  updateNestedValue(type, gvpValues, newValues)
};
AuraExpressionService.prototype.$addExpressionListener$ = function(reference, expression, valueProvider) {
  expression = $A.$expressionService$.normalize(expression);
  var consumers = null;
  if(reference.$valueProvider$) {
    consumers = this.$references$[reference.$valueProvider$.$getGlobalId$()][reference.$expression$].$consumers$
  }else {
    consumers = this.$references$[reference.$expression$].$consumers$
  }
  var globalId = valueProvider.$getGlobalId$();
  if(!consumers.hasOwnProperty(globalId)) {
    consumers[globalId] = {}
  }
  consumers[globalId][expression] = true
};
AuraExpressionService.prototype.$removeExpressionListener$ = function(reference, expression, valueProvider) {
  expression = $A.$expressionService$.normalize(expression);
  var consumers = null;
  if(reference.$valueProvider$) {
    consumers = this.$references$[reference.$valueProvider$.$getGlobalId$()][reference.$expression$].$consumers$
  }else {
    consumers = this.$references$[reference.$expression$].$consumers$
  }
  var globalId = valueProvider.$getGlobalId$();
  if(consumers.hasOwnProperty(globalId)) {
    delete consumers[globalId][expression];
    if(!Object.keys(consumers[globalId]).length) {
      delete consumers[globalId]
    }
  }
};
AuraExpressionService.prototype.create = function(valueProvider, config) {
  return valueFactory.create(config, valueProvider)
};
goog.$exportProperty$(AuraExpressionService.prototype, "create", AuraExpressionService.prototype.create);
AuraExpressionService.prototype.$createPassthroughValue$ = function(primaryProviders, cmp) {
  return new PassthroughValue(primaryProviders, cmp)
};
goog.$exportProperty$(AuraExpressionService.prototype, "createPassthroughValue", AuraExpressionService.prototype.$createPassthroughValue$);
AuraExpressionService.prototype.normalize = function(expression) {
  if(typeof expression === "string") {
    expression = expression.trim();
    if(expression.charAt(0) === "{" && expression.charAt(expression.length - 1) === "}" && (expression.charAt(1) === "!" || expression.charAt(1) === "#")) {
      expression = expression.slice(2, -1).trim()
    }
    for(var startBrace = expression.indexOf("[");startBrace > -1;) {
      var endBrace = expression.indexOf("]", startBrace + 1);
      if(endBrace > -1) {
        expression = expression.substring(0, startBrace) + "." + expression.substring(startBrace + 1, endBrace) + expression.substring(endBrace + 1);
        startBrace = expression.indexOf("[", endBrace - 1)
      }else {
        startBrace = -1
      }
    }
  }
  return expression
};
goog.$exportProperty$(AuraExpressionService.prototype, "normalize", AuraExpressionService.prototype.normalize);
AuraExpressionService.prototype.$resolve$ = function(expression, container, rawValue) {
  var target = container;
  var path = expression;
  if(!$A["util"].isArray(path)) {
    path = path.split(".")
  }
  for(var segment;!$A["util"].$isUndefinedOrNull$(target) && path.length;) {
    segment = path.shift();
    if(!target["hasOwnProperty"](segment)) {
      var searchkey = segment.toLowerCase();
      for(var key in target) {
        if(target.hasOwnProperty(key) && key.toLowerCase() === searchkey) {
          throw new $A.$auraError$("Possible Case Sensitivity Issue: Expression '" + expression + "' on segment '" + segment + "'. Possible you meant '" + key + "'");
        }
      }
    }
    target = target[segment];
    if(!rawValue && $A["util"].$isExpression$(target)) {
      target = target.evaluate()
    }
  }
  return target
};
goog.$exportProperty$(AuraExpressionService.prototype, "resolve", AuraExpressionService.prototype.$resolve$);
AuraExpressionService.prototype.$resolveLocatorContext$ = function(cmp, locatorDef) {
  if(!locatorDef) {
    return undefined
  }
  var contextDefs = locatorDef["context"];
  if(!contextDefs) {
    return undefined
  }
  var context = {};
  if(cmp.$isValid$()) {
    try {
      $A.$clientService$.$setCurrentAccess$(cmp);
      for(var key in contextDefs) {
        var expression = this.create(cmp, contextDefs[key]);
        if(expression) {
          context[key] = typeof expression === "string" ? expression : expression.evaluate()
        }
      }
    }finally {
      $A.$clientService$.$releaseCurrentAccess$()
    }
  }
  return context
};
AuraExpressionService.prototype.$getContainer$ = function(cmp) {
  if(!cmp) {
    return undefined
  }
  var owner = cmp.$getOwner$();
  var ownerName = owner.$getType$();
  for(var prevOwner = undefined;ownerName === AuraExpressionService.$AURA_ITERATION$ || ownerName === AuraExpressionService.$AURA_IF$ || owner.$isInstanceOf$("ui:virtualComponent") || owner.$isInstanceOf$("ui:abstractList") || owner.$isInstanceOf$("ui:abstractDataGrid");) {
    owner = owner.$getOwner$();
    ownerName = owner.$getType$();
    if(owner === prevOwner) {
      break
    }
    prevOwner = owner
  }
  return owner
};
AuraExpressionService.prototype.$findLocatorDefInSuperChain$ = function(cmp, targetId) {
  var locatorDefs;
  for(var locatorDef;!locatorDef && cmp;) {
    locatorDefs = cmp.$getDef$().$getLocatorDefs$();
    locatorDef = locatorDefs && (locatorDefs[targetId] || locatorDefs["*"]);
    if(!locatorDef) {
      cmp = cmp.$getSuper$()
    }
  }
  return locatorDef
};
AuraExpressionService.prototype.$resolveLocator$ = function(parent, root, includeMetadata, primitiveFound) {
  var locator;
  var parentId = parent && parent.$getLocalId$();
  var rootId = root && root.$getLocalId$();
  if(!rootId) {
    return locator
  }
  var rootLocatorDef = this.$findLocatorDefInSuperChain$(parent, rootId);
  if(!primitiveFound && rootLocatorDef && rootLocatorDef["isPrimitive"]) {
    primitiveFound = {};
    primitiveFound["target"] = rootLocatorDef["alias"] || rootId;
    primitiveFound["resolvedContext"] = this.$resolveLocatorContext$(parent, rootLocatorDef);
    root = parent;
    parent = this.$getContainer$(parent).$getConcreteComponent$();
    return this.$resolveLocator$(parent, root, includeMetadata, primitiveFound)
  }
  var grandparent = this.$getContainer$(parent).$getConcreteComponent$();
  var parentLocatorDef = this.$findLocatorDefInSuperChain$(grandparent, parentId);
  if(!rootLocatorDef || !parentLocatorDef) {
    return locator
  }
  locator = {};
  var rootContext = this.$resolveLocatorContext$(parent, rootLocatorDef);
  var parentContext = this.$resolveLocatorContext$(grandparent, parentLocatorDef);
  var primitiveContext = primitiveFound && primitiveFound["resolvedContext"];
  var context = $A["util"].apply(parentContext || {}, rootContext);
  context = $A["util"].apply(context, primitiveContext);
  if(!$A["util"].$isEmpty$(context)) {
    locator["context"] = context
  }
  locator["target"] = rootLocatorDef["alias"] || rootId;
  locator["scope"] = parentLocatorDef["alias"] || parentId;
  if(primitiveFound) {
    locator["target"] = locator["target"] + AuraExpressionService.$PRIMITIVE_SEPARATOR$ + primitiveFound["target"]
  }
  if(includeMetadata) {
    locator["metadata"] = {"root":root.$getDef$().toString(), "rootId":rootId, "parent":parent.$getDef$().toString(), "parentId":parentId, "grandparent":grandparent.$getDef$().toString()};
    if(rootLocatorDef["description"]) {
      locator["metadata"]["targetDescription"] = rootLocatorDef["description"];
      locator["metadata"]["scopeDescription"] = parentLocatorDef["description"]
    }
  }
  return locator
};
Aura.$Services$.$AuraExpressionService$ = AuraExpressionService;
function AuraHistoryService() {
  this.history = [];
  this.$currentIndex$ = -1;
  this.$evt$ = null
}
goog.$exportSymbol$("AuraHistoryService", AuraHistoryService);
AuraHistoryService.prototype.set = function(token) {
  if(token) {
    if(this.$usePushState$()) {
      window.history.pushState({"hash":token}, null, "#" + token);
      this.$changeHandler$()
    }else {
      if($A["util"].$isIOSWebView$()) {
        var historyLength = this.history.length;
        if(this.$currentIndex$ < historyLength - 1) {
          this.history.splice(this.$currentIndex$ + 1, historyLength - this.$currentIndex$)
        }
        this.$currentIndex$++;
        this.history.push(token)
      }
      window.location.hash = "#" + token
    }
  }
};
goog.$exportProperty$(AuraHistoryService.prototype, "set", AuraHistoryService.prototype.set);
AuraHistoryService.prototype.replace = function(token) {
  if(token) {
    if(this.$usePushState$()) {
      window.history.replaceState({"hash":token}, null, "#" + token);
      this.$changeHandler$()
    }else {
      if($A["util"].$isIOSWebView$()) {
        var historyLength = this.history.length;
        if(this.$currentIndex$ < historyLength - 1) {
          this.history.splice(this.$currentIndex$ + 1, historyLength - this.$currentIndex$)
        }
        this.history[this.$currentIndex$] = token
      }
      if(window.location.replace) {
        window.location.replace("#" + token)
      }else {
        window.location.hash = "#" + token
      }
    }
  }
};
goog.$exportProperty$(AuraHistoryService.prototype, "replace", AuraHistoryService.prototype.replace);
AuraHistoryService.prototype.get = function() {
  var token = this.$getLocationHash$() || this.$getHistoryState$() || "";
  return this.$parseLocation$(token)
};
goog.$exportProperty$(AuraHistoryService.prototype, "get", AuraHistoryService.prototype.get);
AuraHistoryService.prototype.back = function() {
  if(!$A["util"].$isIOSWebView$()) {
    window.history.go(-1)
  }else {
    if(this.$currentIndex$ > 0) {
      var hash = this.history[--this.$currentIndex$];
      window.location.hash = "#" + hash
    }else {
      this.reset();
      window.location.hash = ""
    }
  }
};
goog.$exportProperty$(AuraHistoryService.prototype, "back", AuraHistoryService.prototype.back);
AuraHistoryService.prototype.$setTitle$ = function(title) {
  document.title = title
};
goog.$exportProperty$(AuraHistoryService.prototype, "setTitle", AuraHistoryService.prototype.$setTitle$);
AuraHistoryService.prototype.forward = function() {
  if(!$A["util"].$isIOSWebView$()) {
    window.history.go(1)
  }else {
    var historyLength = this.history.length;
    if(this.$currentIndex$ < historyLength - 1) {
      window.location.hash = "#" + this.history[++this.$currentIndex$]
    }
  }
};
goog.$exportProperty$(AuraHistoryService.prototype, "forward", AuraHistoryService.prototype.forward);
AuraHistoryService.prototype.reset = function() {
  this.history = [];
  this.$currentIndex$ = -1
};
goog.$exportProperty$(AuraHistoryService.prototype, "reset", AuraHistoryService.prototype.reset);
AuraHistoryService.prototype.$usePushState$ = function() {
  if(this.$_usePushState$ === undefined) {
    var ua = window.navigator.userAgent;
    this.$_usePushState$ = !!window.history.pushState && !(ua.indexOf("Android ") > -1 && ua.indexOf("Mozilla/5.0") > -1 && ua.indexOf("AppleWebKit") > -1 && ua.indexOf("Chrome") === -1) && !$A["util"].$isIOSWebView$()
  }
  return this.$_usePushState$
};
AuraHistoryService.prototype.$init$ = function() {
  var that = this;
  if(this.$usePushState$()) {
    window.addEventListener("popstate", function() {
      that.$changeHandler$()
    })
  }else {
    var hash = this.$getLocationHash$();
    this.history.push(hash);
    this.$currentIndex$++;
    var docMode = document["documentMode"];
    var hasOnHashChangeEvent = "onhashchange" in window && (docMode === undefined || docMode > 7);
    if(hasOnHashChangeEvent) {
      window["onhashchange"] = function() {
        that.$changeHandler$()
      }
    }else {
      var watch = function() {
        setTimeout(function() {
          var newHash = that.$getLocationHash$();
          if(newHash !== hash) {
            hash = newHash;
            that.$changeHandler$()
          }
          watch()
        }, 300)
      };
      watch()
    }
  }
  this.$changeHandler$();
  delete this.$init$
};
AuraHistoryService.prototype.$getEvent$ = function() {
  if(!this.$evt$) {
    this.$evt$ = $A.$getRoot$().$getDef$().$getLocationChangeEvent$()
  }
  return this.$evt$
};
AuraHistoryService.prototype.$changeHandler$ = function() {
  var loc = this.$getLocationHash$() || this.$getHistoryState$();
  $A.$clientService$.$setCurrentAccess$($A.$getRoot$());
  var event;
  try {
    event = $A.$eventService$.$newEvent$(this.$getEvent$())
  }finally {
    $A.$clientService$.$releaseCurrentAccess$()
  }
  if(!event) {
    throw new $A.$auraError$("The event specified on the app for the locationChange (" + this.$getEvent$() + ") was not found.", null, $A.severity.$QUIET$);
  }
  if(loc) {
    var parsedHash = this.$parseLocation$(loc);
    var parameters = {};
    var attributes = event.$getDef$().$getAttributeDefs$().$getNames$();
    var attribute;
    var c = 0;
    for(var length = attributes.length;c < length;c++) {
      attribute = attributes[c];
      if(parsedHash.hasOwnProperty(attribute)) {
        parameters[attribute] = parsedHash[attribute]
      }
    }
    event.$setParams$(parameters)
  }
  event.$fire$()
};
AuraHistoryService.prototype.$parseLocation$ = function(location) {
  if(location.indexOf("#") === 0) {
    location = location.substring(1)
  }
  if(location.indexOf("\x3d") > -1) {
    var position = location.indexOf("?");
    if(position === -1) {
      return{"token":location, "querystring":""}
    }
    var token = location.substring(0, position);
    var querystring = location.substring(position + 1);
    var decoded = this.$parseQueryString$(querystring);
    decoded["token"] = token;
    decoded["querystring"] = querystring;
    return decoded
  }else {
    return{"token":location, "querystring":""}
  }
};
AuraHistoryService.prototype.$parseQueryString$ = function(querystring) {
  var ret = {};
  var pairs = querystring.split("\x26");
  var position;
  var pair;
  for(var i = 0;i < pairs.length;i++) {
    pair = pairs[i];
    position = pair.indexOf("\x3d");
    if(position === -1) {
      ret[pair] = undefined
    }else {
      ret[pair.substring(0, position)] = decodeURIComponent(pair.substring(position + 1))
    }
  }
  return ret
};
AuraHistoryService.prototype.$getLocationHash$ = function() {
  var href = window.location["href"];
  var hashPosition = href.indexOf("#");
  if(hashPosition === -1) {
    return""
  }
  return href.substr(hashPosition)
};
AuraHistoryService.prototype.$getHistoryState$ = function() {
  var historyState = null;
  try {
    historyState = window.history["state"] && window.history["state"]["hash"]
  }catch(e) {
  }
  return historyState
};
Aura.$Services$.$AuraHistoryService$ = AuraHistoryService;
function AuraEventService() {
  this.$eventDispatcher$ = {};
  this.$eventDefRegistry$ = {};
  this.$savedEventConfigs$ = {};
  this.$componentHandlers$ = {}
}
goog.$exportSymbol$("AuraEventService", AuraEventService);
AuraEventService.$Phase$ = {$CAPTURE$:"capture", $BUBBLE$:"bubble", $DEFAULT$:"default"};
AuraEventService.$validatePhase$ = function(phase, defaultPhase) {
  if(phase) {
    if(phase !== AuraEventService.$Phase$.$BUBBLE$ && phase !== AuraEventService.$Phase$.$CAPTURE$ && phase !== AuraEventService.$Phase$.$DEFAULT$) {
      throw new Error("AuraEventService.validatePhase(): 'phase' must be omitted, or one of '" + AuraEventService.$Phase$.$BUBBLE$ + "', '" + AuraEventService.$Phase$.$CAPTURE$ + "', or '" + AuraEventService.$Phase$.$DEFAULT$ + "'. Found '" + phase + "'.");
    }
  }else {
    phase = defaultPhase || AuraEventService.$Phase$.$DEFAULT$
  }
  return phase
};
AuraEventService.prototype.$newEvent$ = function(eventDef, eventName, sourceCmp) {
  $A.assert(eventDef, "EventDef is required");
  eventDef = this.$getDef$(eventDef);
  return this.$getNewEvent$(eventDef, eventName, sourceCmp)
};
goog.$exportProperty$(AuraEventService.prototype, "newEvent", AuraEventService.prototype.$newEvent$);
AuraEventService.prototype.$getNewEvent$ = function(eventDefinition, eventName, sourceCmp) {
  var eventDef = eventDefinition;
  if(typeof eventDefinition === "string") {
    eventDef = this.$getEventDef$(eventDefinition)
  }
  if(eventDef) {
    var config = {};
    config["eventDef"] = eventDef;
    if(eventDef.$getEventType$() === "COMPONENT") {
      config["name"] = eventName;
      config["component"] = sourceCmp && sourceCmp.$getConcreteComponent$()
    }else {
      config["eventDispatcher"] = this.$eventDispatcher$
    }
    return new Aura.$Event$.$Event$(config)
  }
};
AuraEventService.prototype.$collectBubblePath$ = function(cmp, queue, visited, isOwner) {
  if(!cmp || cmp.$destroyed$ === 1) {
    return queue
  }
  if(visited[cmp.$globalId$]) {
    if(!isOwner) {
      queue.push({$cmp$:cmp, $isMarker$:true})
    }
    return queue
  }
  queue.push({$cmp$:cmp, $isOwner$:isOwner});
  visited[cmp.$globalId$] = true;
  var superCmp = cmp.$getSuper$();
  if(superCmp) {
    this.$collectBubblePath$(superCmp, queue, visited, isOwner && true)
  }
  var next = cmp;
  for(var queueIndex = queue.length;next;) {
    next = next.$getOwner$();
    if(next === cmp || !$A["util"].$isComponent$(next)) {
      break
    }
    if(next.$getGlobalId$() !== cmp.$getGlobalId$()) {
      this.$collectBubblePath$(next, queue, visited, isOwner && true);
      break
    }else {
      cmp = next
    }
  }
  if(cmp.$isConcrete$()) {
    var concreteCmpContainerComponent = cmp.$getContainer$();
    if(concreteCmpContainerComponent) {
      var containerComponentQueue = this.$collectBubblePath$(concreteCmpContainerComponent, [], visited, false);
      var intersectionPoint = null;
      for(var pStopIdx = 0;pStopIdx < containerComponentQueue.length;pStopIdx++) {
        if(containerComponentQueue[pStopIdx].$isMarker$) {
          intersectionPoint = containerComponentQueue[pStopIdx].$cmp$;
          break
        }
      }
      var intersectionIndex = queueIndex;
      if(intersectionPoint) {
        for(var j = 0;j < queue.length;j++) {
          if(queue[j].$cmp$ === intersectionPoint) {
            intersectionIndex = j;
            break
          }
        }
      }
      queue.splice.apply(queue, [intersectionIndex, 0].concat(containerComponentQueue.slice(0, pStopIdx)))
    }
  }
  return queue
};
AuraEventService.prototype.$getEventPhaseCmpIterator$ = function() {
  function EventPhaseCmpIterator(cmp, eventService) {
    var queue = eventService.$collectBubblePath$(cmp, [], {}, true);
    queue = queue.slice().reverse().concat(queue);
    var queueIndex = 0;
    var phaseSwitchIndex = queue.length / 2;
    var phase = AuraEventService.$Phase$.$CAPTURE$;
    var currentValue;
    var done = false;
    this.next = function() {
      for(;!done;) {
        if(queueIndex < queue.length) {
          if(queueIndex === phaseSwitchIndex) {
            phase = AuraEventService.$Phase$.$BUBBLE$
          }
          var qval = queue[queueIndex++];
          currentValue = {$cmp$:qval.$cmp$, $isOwner$:qval.$isOwner$, $phase$:phase};
          break
        }else {
          done = true;
          currentValue = undefined
        }
      }
      return{value:currentValue, $done$:done}
    };
    this.$return$ = function(value) {
      if(!done) {
        done = true;
        currentValue = value
      }
      return{value:currentValue, $done$:done}
    };
    this.$throw$ = function(e) {
      if(!done) {
        done = true;
        currentValue = undefined
      }
      throw e;
    }
  }
  return function(cmp) {
    return new EventPhaseCmpIterator(cmp, this)
  }
}();
AuraEventService.prototype.$getPhasedEventHandlerIterator$ = function() {
  function PhasedEventHandlerIterator(evt, eventPhaseCmpIterator, handlerSupplierFn) {
    function moveCmpCursor() {
      currentHandlersIndex = 0;
      var res = eventPhaseCmpIterator.next();
      if(res.$done$) {
        currentHandlers = currentLocation = null
      }else {
        currentLocation = res.value;
        currentHandlers = handlerSupplierFn(evt, currentLocation.$cmp$, currentLocation.$phase$, currentLocation.$isOwner$);
        currentHandlersIndex = 0
      }
    }
    var done = false;
    var currentValue;
    var currentLocation = null;
    var currentHandlers = null;
    var currentHandlersIndex = 0;
    moveCmpCursor();
    this.next = function() {
      for(;!done;) {
        if(!currentLocation) {
          done = true;
          currentValue = undefined
        }else {
          if(currentHandlersIndex < currentHandlers.length) {
            currentValue = {$cmp$:currentLocation.$cmp$, $phase$:currentLocation.$phase$, $handler$:currentHandlers[currentHandlersIndex++]};
            break
          }else {
            if(evt.$eventStopPropagation$) {
              return this.$return$({$cmp$:currentValue.$cmp$, $phase$:currentValue.$phase$})
            }else {
              moveCmpCursor()
            }
          }
        }
      }
      return{value:currentValue, $done$:done}
    };
    this.$return$ = function(value) {
      if(!done) {
        done = true;
        currentValue = value
      }
      return{value:currentValue, $done$:done}
    };
    this.$throw$ = function(e) {
      if(!done) {
        done = true;
        currentValue = undefined
      }
      throw e;
    }
  }
  return function(evt, handlerSupplierFn) {
    return new PhasedEventHandlerIterator(evt, this.$getEventPhaseCmpIterator$(evt.$getSource$()), handlerSupplierFn)
  }
}();
AuraEventService.prototype.$getComponentEventHandlerIterator$ = function() {
  return function(evt) {
    return this.$getPhasedEventHandlerIterator$(evt, this.$getComponentEventHandlers$.bind(this))
  }
}();
AuraEventService.prototype.$eventStopPropagationHandler$ = function(evt) {
  evt.stopPropagation()
};
AuraEventService.prototype.$getComponentEventHandlers$ = function(evt, cmp, phase, isOwner) {
  var handlers;
  var eventName = evt.getName();
  var dispatcher = cmp.$destroyed$ !== 1 && cmp.$getEventDispatcher$();
  if(dispatcher) {
    var dispatcherHandlers = dispatcher[eventName];
    if(dispatcherHandlers) {
      var phasedHandlers = dispatcherHandlers[phase];
      if(phasedHandlers && phasedHandlers.length) {
        handlers = [];
        var cmpHandlerDefs = cmp.$getDef$().$getCmpHandlerDefs$();
        var includedHandlers = false;
        if(cmpHandlerDefs) {
          for(var i = 0;i < cmpHandlerDefs.length && !includedHandlers;i++) {
            for(var evtDef = evt.$getDef$();evtDef;evtDef = evtDef.$getSuperDef$()) {
              var hDef = cmpHandlerDefs[i]["eventDef"];
              if(cmpHandlerDefs[i]["name"] === eventName && (!hDef || hDef === evtDef)) {
                for(var j = 0;j < phasedHandlers.length;j++) {
                  if(isOwner || phasedHandlers[j].$includeFacets$) {
                    handlers.push(phasedHandlers[j])
                  }
                }
                includedHandlers = true;
                break
              }
              if(!hDef && isOwner) {
                handlers.push(this.$eventStopPropagationHandler$)
              }
            }
          }
        }
        if(!includedHandlers && cmp.$getDef$().$getEventDef$(eventName) && isOwner) {
          handlers.push(this.$eventStopPropagationHandler$);
          handlers.push.apply(handlers, phasedHandlers)
        }
      }
    }
  }
  return handlers || []
};
AuraEventService.prototype.$getNonBubblingComponentEventHandlers$ = function(cmp, evt, phase) {
  var handlers;
  if(cmp.$destroyed$ !== 1 && cmp.$getDef$().$getEventDef$(evt.getName())) {
    var dispatcher = cmp.$getEventDispatcher$();
    if(dispatcher) {
      var handlersObj = dispatcher[evt.getName()];
      handlers = handlersObj && handlersObj[phase]
    }
  }
  return handlers || []
};
AuraEventService.prototype.$getNonBubblingComponentEventHandlerIterator$ = function() {
  function NonBubblingComponentHandlerIterator(evt, componentEventHandlersSupplierFn) {
    function getHandlers() {
      for(;cmp;) {
        currentCmp = cmp;
        var evtHandlers = componentEventHandlersSupplierFn(currentCmp, evt, PHASE);
        cmp = cmp.$getSuper$();
        if(evtHandlers) {
          handlerIndex = 0;
          return evtHandlers
        }
      }
    }
    var done = false;
    var currentValue;
    var cmp = evt.$getSource$();
    var currentCmp = cmp;
    var handlerIndex = 0;
    var handlers = getHandlers();
    this.next = function() {
      for(;!done;) {
        if(!handlers) {
          done = true;
          currentValue = undefined
        }else {
          if(handlerIndex < handlers.length) {
            currentValue = {$cmp$:currentCmp, $phase$:PHASE, $handler$:handlers[handlerIndex++]};
            break
          }else {
            handlers = getHandlers()
          }
        }
      }
      return{value:currentValue, $done$:done}
    };
    this.$return$ = function(value) {
      if(!done) {
        done = true;
        currentValue = value
      }
      return{value:currentValue, $done$:done}
    };
    this.$throw$ = function(e) {
      if(!done) {
        done = true;
        currentValue = undefined
      }
      throw e;
    }
  }
  var PHASE = AuraEventService.$Phase$.$BUBBLE$;
  return function(evt) {
    return new NonBubblingComponentHandlerIterator(evt, this.$getNonBubblingComponentEventHandlers$)
  }
}();
AuraEventService.prototype.$getValueHandlerIterator$ = function() {
  function ValueHandlerIterator(evt) {
    var done = false;
    var currentValue;
    var queue = [];
    var queueIndex = 0;
    var cmp = evt.$getSource$();
    var evtDef = evt.$eventDef$;
    for(var eventDispatcher = evt.$eventDispatcher$;evtDef;) {
      var qname = evtDef.$getDescriptor$().$getQualifiedName$();
      var handlers = eventDispatcher[qname] && eventDispatcher[qname][PHASE];
      if(handlers) {
        if($A["util"].isArray(handlers)) {
          for(var i = 0;i < handlers.length;i++) {
            queue.push({$cmp$:cmp, $phase$:PHASE, $handler$:handlers[i]})
          }
        }
      }
      evtDef = evtDef.$getSuperDef$()
    }
    this.next = function() {
      for(;!done;) {
        if(queueIndex < queue.length) {
          currentValue = queue[queueIndex++];
          break
        }else {
          done = true;
          currentValue = undefined
        }
      }
      return{value:currentValue, $done$:done}
    };
    this.$return$ = function(value) {
      if(!done) {
        done = true;
        currentValue = value
      }
      return{value:currentValue, $done$:done}
    };
    this.$throw$ = function(e) {
      if(!done) {
        done = true;
        currentValue = undefined
      }
      throw e;
    }
  }
  var PHASE = AuraEventService.$Phase$.$DEFAULT$;
  return function(evt) {
    return new ValueHandlerIterator(evt)
  }
}();
AuraEventService.prototype.$getPhasedApplicationEventHandlers$ = function(evt, cmp, phase, isOwner) {
  var evtDef = evt.$eventDef$;
  var eventDispatcher = evt.$eventDispatcher$;
  var globalId = cmp.$globalId$;
  var phasedEvtHandlers = [];
  if(cmp.$destroyed$ !== 1) {
    for(;evtDef;) {
      var qname = evtDef.$getDescriptor$().$getQualifiedName$();
      var handlers = eventDispatcher[qname];
      var cmpPhasedHandlers = handlers && handlers[phase] && handlers[phase][globalId];
      if(cmpPhasedHandlers) {
        for(var i = 0;i < cmpPhasedHandlers.length;i++) {
          if(isOwner || cmpPhasedHandlers[i].$includeFacets$) {
            phasedEvtHandlers.push(cmpPhasedHandlers[i])
          }
        }
      }
      evtDef = evtDef.$getSuperDef$()
    }
  }
  return phasedEvtHandlers
};
AuraEventService.prototype.$applicationEventHasPhasedHandlers$ = function() {
  function hasHandlers(phasedHandlerMap) {
    for(var globalId in phasedHandlerMap) {
      if(phasedHandlerMap.hasOwnProperty(globalId) && phasedHandlerMap[globalId] && phasedHandlerMap[globalId].length) {
        return true
      }
    }
    return false
  }
  return function(evt) {
    var evtDef = evt.$eventDef$;
    for(var eventDispatcher = evt.$eventDispatcher$;evtDef;) {
      var qname = evtDef.$getDescriptor$().$getQualifiedName$();
      var handlers = eventDispatcher[qname];
      if(handlers && (hasHandlers(handlers[AuraEventService.$Phase$.$BUBBLE$]) || hasHandlers(handlers[AuraEventService.$Phase$.$CAPTURE$]))) {
        return true
      }
      evtDef = evtDef.$getSuperDef$()
    }
    return false
  }
}();
AuraEventService.prototype.$getAppEventHandlerIterator$ = function() {
  function AppEventDefaultPhaseHandlerIterator(evt, rootId) {
    function fillQueue() {
      queue = [];
      var evtDef = evt.$eventDef$;
      for(var eventDispatcher = evt.$eventDispatcher$;evtDef;) {
        var qname = evtDef.$getDescriptor$().$getQualifiedName$();
        var handlers = eventDispatcher[qname];
        var defaultHandlersMap = handlers && handlers[AuraEventService.$Phase$.$DEFAULT$];
        var cmpHandlers;
        if(defaultHandlersMap) {
          for(var globalId in defaultHandlersMap) {
            if(defaultHandlersMap.hasOwnProperty(globalId)) {
              var cmp = $A.$getComponent$(globalId);
              if(cmp && cmp.$destroyed$ === 1) {
                delete defaultHandlersMap[globalId];
                continue
              }
              if(rootCmp) {
                var containsResult = $A.$componentService$.$containsComponent$(rootCmp, cmp);
                if(!containsResult.result) {
                  continue
                }
              }
              cmpHandlers = defaultHandlersMap[globalId];
              for(var i = 0;i < cmpHandlers.length;i++) {
                queue.push({$cmp$:cmp, $phase$:AuraEventService.$Phase$.$DEFAULT$, $handler$:cmpHandlers[i]})
              }
            }
          }
        }
        evtDef = evtDef.$getSuperDef$()
      }
    }
    var done = false;
    var queue = null;
    var queueIndex = 0;
    var currentValue;
    var rootCmp = rootId && $A.$getComponent$(rootId);
    this.next = function() {
      for(;!done;) {
        if(!queue) {
          fillQueue()
        }
        if(queueIndex < queue.length) {
          currentValue = queue[queueIndex++];
          break
        }else {
          done = true;
          currentValue = null
        }
      }
      return{value:currentValue, $done$:done}
    };
    this.$return$ = function(value) {
      if(!done) {
        done = true;
        currentValue = value
      }
      return{value:currentValue, $done$:done}
    };
    this.$throw$ = function(e) {
      if(!done) {
        done = true;
        currentValue = undefined
      }
      throw e;
    }
  }
  function AppEventHandlerIterator(evt, eventService) {
    var defaultEventHandlerIterator = null;
    var currentPhase = AuraEventService.$Phase$.$CAPTURE$;
    var currentValue = null;
    var done = false;
    var phasedEventHandlerIterator;
    if(!eventService.$applicationEventHasPhasedHandlers$(evt)) {
      currentPhase = AuraEventService.$Phase$.$DEFAULT$;
      defaultEventHandlerIterator = new AppEventDefaultPhaseHandlerIterator(evt)
    }else {
      phasedEventHandlerIterator = eventService.$getPhasedEventHandlerIterator$(evt, eventService.$getPhasedApplicationEventHandlers$)
    }
    this.next = function() {
      for(;!done;) {
        if(currentPhase === AuraEventService.$Phase$.$CAPTURE$ || currentPhase === AuraEventService.$Phase$.$BUBBLE$) {
          var phaseRes = phasedEventHandlerIterator.next();
          if(!phaseRes.$done$) {
            currentValue = phaseRes.value;
            currentPhase = currentValue.$phase$;
            break
          }else {
            if(evt.defaultPrevented) {
              currentValue = undefined;
              currentPhase = AuraEventService.$Phase$.$DEFAULT$;
              done = true
            }else {
              currentPhase = AuraEventService.$Phase$.$DEFAULT$;
              var bcastRootId = null;
              if(evt.$eventStopPropagation$ && phaseRes.value) {
                bcastRootId = phaseRes.value.$cmp$.$globalId$
              }
              defaultEventHandlerIterator = new AppEventDefaultPhaseHandlerIterator(evt, bcastRootId)
            }
          }
        }else {
          var defaultRes = defaultEventHandlerIterator.next();
          if(!defaultRes.$done$) {
            currentValue = defaultRes.value;
            break
          }
          currentValue = undefined;
          done = true
        }
      }
      return{value:currentValue, $done$:done}
    };
    this.$return$ = function(value) {
      if(!done) {
        done = true;
        currentValue = value
      }
      return{value:currentValue, $done$:done}
    };
    this.$throw$ = function(e) {
      if(!done) {
        done = true;
        currentValue = undefined
      }
      throw e;
    }
  }
  return function(evt) {
    return new AppEventHandlerIterator(evt, this)
  }
}();
AuraEventService.prototype.get = function(name, callback) {
  var newEvent = this.$newEvent$(name);
  if(callback) {
    if(newEvent) {
      return callback(newEvent)
    }
    return this.$getDefinition$(name, callback)
  }
  return newEvent
};
AuraEventService.prototype.$expressionHandler$ = function(expression, event) {
  if(expression) {
    var expressionValue = expression;
    var target = null;
    if($A["util"].$isExpression$(expressionValue)) {
      target = expressionValue.$valueProvider$;
      expressionValue = expressionValue.evaluate()
    }
    if($A["util"].$isAction$(expressionValue)) {
      expressionValue.$run$(event)
    }
    if($A["util"].$isFunction$(expressionValue)) {
      expressionValue(target, event)
    }
  }
};
AuraEventService.prototype.$addEventHandler$ = function(component, eventDef, handler, phase, includeFacets) {
  if(!$A["util"].$isComponent$(component)) {
    throw new Error("AuraEventService.addEventHandler: 'component' must be a valid Component.");
  }
  if(!(eventDef instanceof EventDef)) {
    throw new Error("AuraEventService.addEventHandler: 'eventDef' must be a valid Event definition.");
  }
  if($A["util"].$isExpression$(handler)) {
    var reference = handler;
    handler = this.$expressionHandler$.bind(this, handler);
    handler.$reference$ = reference
  }
  if(!$A["util"].$isFunction$(handler)) {
    throw new Error("AuraEventService.addEventHandler: 'handler' must be a valid Function or a reference to a controller action, e.g., 'cmp.getReference(\"c.myAction\");'");
  }
  phase = AuraEventService.$validatePhase$(phase);
  var event = eventDef.$descriptor$.$qualifiedName$;
  var handlers = this.$eventDispatcher$[event];
  if(!handlers) {
    this.$eventDispatcher$[event] = handlers = {}
  }
  var phaseHandlers = handlers[phase];
  if(!phaseHandlers) {
    handlers[phase] = phaseHandlers = {}
  }
  var globalId = component.$globalId$;
  var cmpHandlers = phaseHandlers[globalId];
  if(!cmpHandlers) {
    phaseHandlers[globalId] = cmpHandlers = []
  }
  if(!this.$componentHandlers$[globalId]) {
    this.$componentHandlers$[globalId] = []
  }
  if(includeFacets) {
    handler.$includeFacets$ = true
  }
  for(var i = 0;i < cmpHandlers.length;i++) {
    if(cmpHandlers[i] === handler || cmpHandlers[i].$reference$ && cmpHandlers[i].$reference$ === handler.$reference$) {
      return
    }
  }
  cmpHandlers.push(handler);
  this.$componentHandlers$[globalId].push({"event":event, "phase":phase})
};
AuraEventService.prototype.$addHandler$ = function(config) {
  var includeFacets = config["includeFacets"];
  includeFacets = includeFacets !== undefined && includeFacets !== null && includeFacets !== false && includeFacets !== 0 && includeFacets !== "false" && includeFacets !== "" && includeFacets !== "f";
  var component = $A.$getComponent$(config["globalId"]);
  if(!component) {
    component = Object.create(Aura.$Component$.$Component$.prototype, {$globalId$:{value:"1:0"}});
    $A.$warning$("$A.eventService.addHandler: Unknown component with globalId '" + config["globalId"] + "'. Does this component exist?")
  }
  var eventDef = this.$getEventDef$(config["event"]);
  if(!eventDef) {
    eventDef = Object.create(Aura.$Event$.$EventDef$.prototype, {$descriptor$:{value:{$qualifiedName$:config["event"]}}});
    $A.$warning$("$A.eventService.addHandler: Unknown event with name '" + config["event"] + "'. Do you have a missing dependency?")
  }
  this.$addEventHandler$(component, eventDef, config["handler"], config["phase"], includeFacets)
};
goog.$exportProperty$(AuraEventService.prototype, "addHandler", AuraEventService.prototype.$addHandler$);
AuraEventService.prototype.$removeEventHandler$ = function(component, eventDef, handler, phase) {
  if(!$A["util"].$isComponent$(component)) {
    throw new Error("AuraEventService.removeEventHandler: 'component' must be a valid Component.");
  }
  if(!(eventDef instanceof EventDef)) {
    throw new Error("AuraEventService.removeEventHandler: 'eventDef' must be a valid Event definition.");
  }
  phase = AuraEventService.$validatePhase$(phase);
  var event = eventDef.$descriptor$.$qualifiedName$;
  var handlers = this.$eventDispatcher$[event];
  if(handlers) {
    var phaseHandlers = handlers[phase];
    if(phaseHandlers) {
      var globalId = component.$globalId$;
      if(!globalId && $A.$finishedInit$) {
        throw new Error("$A.removeEventHandler: Unable to find current component target. Are you running in Aura scope?");
      }
      var cmpHandlers = phaseHandlers[globalId];
      if(cmpHandlers) {
        for(var i = 0;i < cmpHandlers.length;i++) {
          if(cmpHandlers[i] === handler || cmpHandlers[i].$reference$ === handler) {
            delete cmpHandlers[i].$reference$;
            cmpHandlers.splice(i, 1);
            break
          }
        }
      }
    }
  }
};
goog.$exportProperty$(AuraEventService.prototype, "removeEventHandler", AuraEventService.prototype.$removeEventHandler$);
AuraEventService.prototype.$removeHandler$ = function(config) {
  var globalId = config["globalId"];
  var component = $A.$getComponent$(globalId);
  if(!component) {
    globalId = "1:0"
  }
  var def = this.$getEventDef$(config["event"]);
  var handlers = this.$eventDispatcher$[def.$descriptor$.$qualifiedName$];
  if(handlers) {
    var phase = config["phase"] || "default";
    var phaseHandlers = handlers[phase];
    if(phaseHandlers) {
      delete phaseHandlers[globalId]
    }
  }
};
goog.$exportProperty$(AuraEventService.prototype, "removeHandler", AuraEventService.prototype.$removeHandler$);
AuraEventService.prototype.$removeHandlersByComponentId$ = function(globalId) {
  var references = this.$componentHandlers$[globalId];
  if(references) {
    var dispatcher = this.$eventDispatcher$;
    var c = 0;
    for(var reference;c < references.length;c++) {
      reference = references[c];
      if(dispatcher[reference["event"]] && dispatcher[reference["event"]][reference["phase"]] && dispatcher[reference["event"]][reference["phase"]][globalId]) {
        delete dispatcher[reference["event"]][reference["phase"]][globalId]
      }
    }
    delete this.$componentHandlers$[globalId]
  }
};
AuraEventService.prototype.$addHandlerOnce$ = function(config) {
  var handler = config["handler"];
  var component = $A.$getComponent$(config["globalId"]);
  if(!component) {
    component = Object.create($A.$Component$.prototype, {$globalId$:{value:"1:0"}})
  }
  var def = this.$getEventDef$(config["event"]);
  config["handler"] = $A.$getCallback$(function() {
    this.$removeEventHandler$(component, def, config["handler"], config["phase"]);
    handler()
  }.bind(this));
  this.$addEventHandler$(component, def, config["handler"], config["phase"], config["includeFacets"])
};
goog.$exportProperty$(AuraEventService.prototype, "addHandlerOnce", AuraEventService.prototype.$addHandlerOnce$);
AuraEventService.prototype.$getEventDef$ = function(config) {
  var descConfig = this.$createDescriptorConfig$(config);
  var descriptor = this.$getDescriptorFromConfig$(descConfig);
  var definition = this.$eventDefRegistry$[descriptor];
  if(!definition && this.$savedEventConfigs$[descriptor]) {
    definition = this.$createFromSavedConfigs$(descConfig)
  }
  return definition
};
AuraEventService.prototype.$getDef$ = function(descriptor) {
  $A.assert(descriptor, "No EventDefinition was descriptor specified.");
  var definition = this.$getEventDef$(descriptor);
  if(definition && !$A.$clientService$.$allowAccess$(definition)) {
    var message = "Access Check Failed! EventService.getEventDef():'" + definition.$getDescriptor$().toString() + "' is not visible to '" + $A.$clientService$.$currentAccess$ + "'.";
    if($A.$clientService$.$enableAccessChecks$) {
      if($A.$clientService$.$logAccessFailures$) {
        $A.error(null, new $A.$auraError$(message))
      }
      return null
    }else {
      if($A.$clientService$.$logAccessFailures$) {
        $A.$warning$(message)
      }
    }
  }
  return definition
};
AuraEventService.prototype.$hasDefinition$ = function(descriptor) {
  var definition = this.$getEventDef$(descriptor);
  if(definition && !$A.$clientService$.$allowAccess$(definition)) {
    var message = "Access Check Failed! EventService.hasDefinition():'" + definition.$getDescriptor$().toString() + "' is not visible to '" + $A.$clientService$.$currentAccess$ + "'.";
    if($A.$clientService$.$enableAccessChecks$) {
      if($A.$clientService$.$logAccessFailures$) {
        $A.error(null, new $A.$auraError$(message))
      }
      return false
    }else {
      if($A.$clientService$.$logAccessFailures$) {
        $A.$warning$(message)
      }
    }
  }
  return!!definition
};
AuraEventService.prototype.$createDescriptorConfig$ = function(descriptor) {
  descriptor = typeof descriptor === "string" ? descriptor : descriptor[Json.$ApplicationKey$.$DESCRIPTOR$].toString();
  descriptor = descriptor.indexOf("://") < 0 ? "markup://" + descriptor : descriptor;
  return{"descriptor":descriptor}
};
AuraEventService.prototype.$getDefinition$ = function(descriptor, callback) {
  var descriptorName = descriptor.replace("e.", "");
  var def = this.$getDef$(descriptorName);
  if(def === null || def) {
    callback(def);
    return
  }
  var action = $A.get("c.aura://ComponentController.getEventDef");
  action.$setParams$({"name":descriptorName});
  action.$setCallback$(this, function(actionReponse) {
    var definition = null;
    var state = actionReponse.$getState$();
    if(state === "SUCCESS") {
      definition = this.$getDef$(descriptorName)
    }
    callback(definition)
  });
  $A.$enqueueAction$(action)
};
AuraEventService.prototype.$getDescriptorFromConfig$ = function(descriptorConfig) {
  var descriptor = descriptorConfig && descriptorConfig[Json.$ApplicationKey$.$DESCRIPTOR$];
  $A.assert(descriptor, "Event Descriptor for Config required for registration");
  return descriptor
};
AuraEventService.prototype.$createFromSavedConfigs$ = function(config) {
  var descriptor = config[Json.$ApplicationKey$.$DESCRIPTOR$];
  if(!descriptor && config["getDescriptor"]) {
    descriptor = config.$getDescriptor$()
  }
  var def = new EventDef(this.$savedEventConfigs$[descriptor]);
  this.$eventDefRegistry$[descriptor] = def;
  delete this.$savedEventConfigs$[descriptor];
  return def
};
AuraEventService.prototype.$createEventDef$ = function(config) {
  var descConfig = this.$createDescriptorConfig$(config);
  var descriptor = this.$getDescriptorFromConfig$(descConfig);
  var definition = this.$eventDefRegistry$[descriptor];
  if(!definition) {
    if(this.$savedEventConfigs$[descriptor]) {
      definition = this.$createFromSavedConfigs$(descConfig)
    }else {
      definition = new EventDef(config);
      this.$eventDefRegistry$[descriptor] = definition
    }
  }
  return definition
};
AuraEventService.prototype.$saveEventConfig$ = function(config) {
  $A.assert(config && config[Json.$ApplicationKey$.$DESCRIPTOR$], "Event config required for registration");
  this.$savedEventConfigs$[config[Json.$ApplicationKey$.$DESCRIPTOR$]] = config
};
AuraEventService.prototype.$hasHandlers$ = function(name) {
  var qualifiedName = DefDescriptor.normalize(name);
  var phases = this.$eventDispatcher$[qualifiedName];
  if(phases) {
    for(var phase in phases) {
      if(!$A["util"].$isEmpty$(phases[phase])) {
        return true
      }
    }
  }
  return false
};
goog.$exportProperty$(AuraEventService.prototype, "hasHandlers", AuraEventService.prototype.$hasHandlers$);
AuraEventService.prototype.$getRegisteredEvents$ = function() {
  return Object.keys(this.$eventDefRegistry$)
};
goog.$exportProperty$(AuraEventService.prototype, "getRegisteredEvents", AuraEventService.prototype.$getRegisteredEvents$);
AuraEventService.prototype.$hasPendingEvents$ = function() {
  return $A.$clientService$.$inAuraLoop$()
};
goog.$exportProperty$(AuraEventService.prototype, "hasPendingEvents", AuraEventService.prototype.$hasPendingEvents$);
Aura.$Services$.$AuraEventService$ = AuraEventService;
function AuraLocalizationService() {
  this.$numberFormat$ = undefined;
  this.$percentFormat$ = undefined;
  this.$currencyFormat$ = undefined;
  this.ZERO = "0";
  this.$localeCache$ = {};
  this.$cache$ = {$format$:{}, $strictModeFormat$:{}}
}
goog.$exportSymbol$("AuraLocalizationService", AuraLocalizationService);
AuraLocalizationService.prototype.$formatNumber$ = function(number) {
  return this.$getDefaultNumberFormat$().$format$(number)
};
goog.$exportProperty$(AuraLocalizationService.prototype, "formatNumber", AuraLocalizationService.prototype.$formatNumber$);
AuraLocalizationService.prototype.$formatPercent$ = function(number) {
  return this.$getDefaultPercentFormat$().$format$(number)
};
goog.$exportProperty$(AuraLocalizationService.prototype, "formatPercent", AuraLocalizationService.prototype.$formatPercent$);
AuraLocalizationService.prototype.$formatCurrency$ = function(number) {
  return this.$getDefaultCurrencyFormat$().$format$(number)
};
goog.$exportProperty$(AuraLocalizationService.prototype, "formatCurrency", AuraLocalizationService.prototype.$formatCurrency$);
AuraLocalizationService.prototype.$getNumberFormat$ = function(format, symbols) {
  return new Aura.$Utils$.$NumberFormat$(format, symbols)
};
goog.$exportProperty$(AuraLocalizationService.prototype, "getNumberFormat", AuraLocalizationService.prototype.$getNumberFormat$);
AuraLocalizationService.prototype.$getDefaultNumberFormat$ = function() {
  if(!this.$numberFormat$) {
    this.$numberFormat$ = new Aura.$Utils$.$NumberFormat$($A.get("$Locale.numberFormat"))
  }
  return this.$numberFormat$
};
goog.$exportProperty$(AuraLocalizationService.prototype, "getDefaultNumberFormat", AuraLocalizationService.prototype.$getDefaultNumberFormat$);
AuraLocalizationService.prototype.$getDefaultPercentFormat$ = function() {
  if(!this.$percentFormat$) {
    this.$percentFormat$ = new Aura.$Utils$.$NumberFormat$($A.get("$Locale.percentFormat"))
  }
  return this.$percentFormat$
};
goog.$exportProperty$(AuraLocalizationService.prototype, "getDefaultPercentFormat", AuraLocalizationService.prototype.$getDefaultPercentFormat$);
AuraLocalizationService.prototype.$getDefaultCurrencyFormat$ = function() {
  if(!this.$currencyFormat$) {
    this.$currencyFormat$ = new Aura.$Utils$.$NumberFormat$($A.get("$Locale.currencyFormat"))
  }
  return this.$currencyFormat$
};
goog.$exportProperty$(AuraLocalizationService.prototype, "getDefaultCurrencyFormat", AuraLocalizationService.prototype.$getDefaultCurrencyFormat$);
AuraLocalizationService.prototype.$displayDuration$ = function(d, noSuffix) {
  return d["humanize"](noSuffix)
};
goog.$exportProperty$(AuraLocalizationService.prototype, "displayDuration", AuraLocalizationService.prototype.$displayDuration$);
AuraLocalizationService.prototype.$displayDurationInDays$ = function(d) {
  return d["asDays"]()
};
goog.$exportProperty$(AuraLocalizationService.prototype, "displayDurationInDays", AuraLocalizationService.prototype.$displayDurationInDays$);
AuraLocalizationService.prototype.$displayDurationInHours$ = function(d) {
  return d["asHours"]()
};
goog.$exportProperty$(AuraLocalizationService.prototype, "displayDurationInHours", AuraLocalizationService.prototype.$displayDurationInHours$);
AuraLocalizationService.prototype.$displayDurationInMilliseconds$ = function(d) {
  return d["asMilliseconds"]()
};
goog.$exportProperty$(AuraLocalizationService.prototype, "displayDurationInMilliseconds", AuraLocalizationService.prototype.$displayDurationInMilliseconds$);
AuraLocalizationService.prototype.$displayDurationInMinutes$ = function(d) {
  return d["asMinutes"]()
};
goog.$exportProperty$(AuraLocalizationService.prototype, "displayDurationInMinutes", AuraLocalizationService.prototype.$displayDurationInMinutes$);
AuraLocalizationService.prototype.$displayDurationInMonths$ = function(d) {
  return d["asMonths"]()
};
goog.$exportProperty$(AuraLocalizationService.prototype, "displayDurationInMonths", AuraLocalizationService.prototype.$displayDurationInMonths$);
AuraLocalizationService.prototype.$displayDurationInSeconds$ = function(d) {
  return d["asSeconds"]()
};
goog.$exportProperty$(AuraLocalizationService.prototype, "displayDurationInSeconds", AuraLocalizationService.prototype.$displayDurationInSeconds$);
AuraLocalizationService.prototype.$displayDurationInYears$ = function(d) {
  return d["asYears"]()
};
goog.$exportProperty$(AuraLocalizationService.prototype, "displayDurationInYears", AuraLocalizationService.prototype.$displayDurationInYears$);
AuraLocalizationService.prototype.duration = function(num, unit) {
  return unit ? this.$moment$["duration"](num, unit) : this.$moment$["duration"](num)
};
goog.$exportProperty$(AuraLocalizationService.prototype, "duration", AuraLocalizationService.prototype.duration);
AuraLocalizationService.prototype.$endOf$ = function(date, unit) {
  return this.$moment$(date)["endOf"](unit)["toDate"]()
};
goog.$exportProperty$(AuraLocalizationService.prototype, "endOf", AuraLocalizationService.prototype.$endOf$);
AuraLocalizationService.prototype.$formatDate$ = function(date, formatString, locale) {
  var mDate = this.$moment$(date);
  if(!mDate || !mDate["isValid"]()) {
    throw{message:"Invalid date value"};
  }
  if(!formatString) {
    formatString = $A.get("$Locale.dateFormat")
  }
  var langLocale = locale;
  if(locale !== undefined) {
    $A.$deprecated$("$A.localizationService.formatDate(date, formatString, locale) is deprecated. " + "Do NOT rely on the [locale] parameter. It only allows to use the value which is provided " + "by Locale Value Provider. It will be removed in an upcoming release.", "Use $A.localizationService.formatDate(date, formatString)");
    if(!this.$isAvailableLocale$(locale)) {
      langLocale = $A.get("$Locale.langLocale");
      $A.$warning$("AuraLocalizationService.formatDate(): Locale '" + locale + "' is not available. " + "Falls back to the locale in $Locale.langLocale: " + langLocale)
    }
  }else {
    langLocale = $A.get("$Locale.langLocale")
  }
  return this.$displayDateTime$(mDate, formatString, langLocale)
};
goog.$exportProperty$(AuraLocalizationService.prototype, "formatDate", AuraLocalizationService.prototype.$formatDate$);
AuraLocalizationService.prototype.$formatDateUTC$ = function(date, formatString, locale) {
  var mDate = this.$moment$["utc"](date);
  if(!mDate || !mDate["isValid"]()) {
    throw{message:"Invalid date value"};
  }
  if(!formatString) {
    formatString = $A.get("$Locale.dateFormat")
  }
  var langLocale = locale;
  if(locale !== undefined) {
    $A.$deprecated$("$A.localizationService.formatDateUTC(date, formatString, locale) is deprecated. " + "Do NOT rely on the [locale] parameter. It only allows to use the value which is provided " + "by Locale Value Provider. It will be removed in an upcoming release.", "Use $A.localizationService.formatDateUTC(date, formatString)");
    if(!this.$isAvailableLocale$(locale)) {
      langLocale = $A.get("$Locale.langLocale");
      $A.$warning$("AuraLocalizationService.formatDateUTC(): Locale '" + locale + "' is not available. " + "Falls back to the locale in $Locale.langLocale: " + langLocale)
    }
  }else {
    langLocale = $A.get("$Locale.langLocale")
  }
  return this.$displayDateTime$(mDate, formatString, langLocale)
};
goog.$exportProperty$(AuraLocalizationService.prototype, "formatDateUTC", AuraLocalizationService.prototype.$formatDateUTC$);
AuraLocalizationService.prototype.$formatDateTime$ = function(date, formatString, locale) {
  var mDate = this.$moment$(date);
  if(!mDate || !mDate["isValid"]()) {
    throw{message:"Invalid date time value"};
  }
  if(!formatString) {
    formatString = $A.get("$Locale.datetimeFormat")
  }
  var langLocale = locale;
  if(locale !== undefined) {
    $A.$deprecated$("$A.localizationService.formatDateTime(date, formatString, locale) is deprecated. " + "Do NOT rely on the [locale] parameter. It only allows to use the value which is provided " + "by Locale Value Provider. It will be removed in an upcoming release.", "Use $A.localizationService.formatDateTime(date, formatString)");
    if(!this.$isAvailableLocale$(locale)) {
      langLocale = $A.get("$Locale.langLocale");
      $A.$warning$("AuraLocalizationService.formatDateTime(): Locale '" + locale + "' is not available. " + "Falls back to the locale in $Locale.langLocale: " + langLocale)
    }
  }else {
    langLocale = $A.get("$Locale.langLocale")
  }
  return this.$displayDateTime$(mDate, formatString, langLocale)
};
goog.$exportProperty$(AuraLocalizationService.prototype, "formatDateTime", AuraLocalizationService.prototype.$formatDateTime$);
AuraLocalizationService.prototype.$formatDateTimeUTC$ = function(date, formatString, locale) {
  var mDate = this.$moment$["utc"](date);
  if(!mDate || !mDate["isValid"]()) {
    throw{message:"Invalid date time value"};
  }
  if(!formatString) {
    formatString = $A.get("$Locale.datetimeFormat")
  }
  var langLocale = locale;
  if(locale !== undefined) {
    $A.$deprecated$("$A.localizationService.formatDateTimeUTC(date, formatString, locale) is deprecated. " + "Do NOT rely on the [locale] parameter. It only allows to use the value which is provided " + "by Locale Value Provider. It will be removed in an upcoming release.", "Use $A.localizationService.formatDateTimeUTC(date, formatString)");
    if(!this.$isAvailableLocale$(locale)) {
      langLocale = $A.get("$Locale.langLocale");
      $A.$warning$("AuraLocalizationService.formatDateTimeUTC(): Locale '" + locale + "' is not available. " + "Falls back to the locale in $Locale.langLocale: " + langLocale)
    }
  }else {
    langLocale = $A.get("$Locale.langLocale")
  }
  return this.$displayDateTime$(mDate, formatString, langLocale)
};
goog.$exportProperty$(AuraLocalizationService.prototype, "formatDateTimeUTC", AuraLocalizationService.prototype.$formatDateTimeUTC$);
AuraLocalizationService.prototype.$formatTime$ = function(date, formatString, locale) {
  var mDate = this.$moment$(date);
  if(!mDate || !mDate["isValid"]()) {
    throw{message:"Invalid time value"};
  }
  if(!formatString) {
    formatString = $A.get("$Locale.timeFormat")
  }
  var langLocale = locale;
  if(locale !== undefined) {
    if(!this.$isAvailableLocale$(locale)) {
      $A.$deprecated$("$A.localizationService.formatTime(date, formatString, locale) is deprecated. " + "Do NOT rely on the [locale] parameter. It only allows to use the value which is provided " + "by Locale Value Provider. It will be removed in an upcoming release.", "Use $A.localizationService.formatTime(date, formatString)");
      langLocale = $A.get("$Locale.langLocale");
      $A.$warning$("AuraLocalizationService.formatTime(): Locale '" + locale + "' is not available. " + "Falls back to the locale in $Locale.langLocale: " + langLocale)
    }
  }else {
    langLocale = $A.get("$Locale.langLocale")
  }
  return this.$displayDateTime$(mDate, formatString, langLocale)
};
goog.$exportProperty$(AuraLocalizationService.prototype, "formatTime", AuraLocalizationService.prototype.$formatTime$);
AuraLocalizationService.prototype.$formatTimeUTC$ = function(date, formatString, locale) {
  var mDate = this.$moment$["utc"](date);
  if(!mDate || !mDate["isValid"]()) {
    throw{message:"Invalid time value"};
  }
  if(!formatString) {
    formatString = $A.get("$Locale.timeFormat")
  }
  var langLocale = locale;
  if(locale !== undefined) {
    if(!this.$isAvailableLocale$(locale)) {
      $A.$deprecated$("$A.localizationService.formatTimeUTC(date, formatString, locale) is deprecated. " + "Do NOT rely on the [locale] parameter. It only allows to use the value which is provided " + "by Locale Value Provider. It will be removed in an upcoming release.", "Use $A.localizationService.formatTimeUTC(date, formatString)");
      langLocale = $A.get("$Locale.langLocale");
      $A.$warning$("AuraLocalizationService.formatTimeUTC(): Locale '" + locale + "' is not available. " + "Falls back to the locale in $Locale.langLocale: " + langLocale)
    }
  }else {
    langLocale = $A.get("$Locale.langLocale")
  }
  return this.$displayDateTime$(mDate, formatString, langLocale)
};
goog.$exportProperty$(AuraLocalizationService.prototype, "formatTimeUTC", AuraLocalizationService.prototype.$formatTimeUTC$);
AuraLocalizationService.prototype.$getDaysInDuration$ = function(d) {
  return d["days"]()
};
goog.$exportProperty$(AuraLocalizationService.prototype, "getDaysInDuration", AuraLocalizationService.prototype.$getDaysInDuration$);
AuraLocalizationService.prototype.$getHoursInDuration$ = function(d) {
  return d["hours"]()
};
goog.$exportProperty$(AuraLocalizationService.prototype, "getHoursInDuration", AuraLocalizationService.prototype.$getHoursInDuration$);
AuraLocalizationService.prototype.$getLocalizedDateTimeLabels$ = function() {
  var langLocale = $A.get("$Locale.langLocale");
  var l = this.$getAvailableMomentLocale$(langLocale);
  return this.$moment$["localeData"](l)
};
goog.$exportProperty$(AuraLocalizationService.prototype, "getLocalizedDateTimeLabels", AuraLocalizationService.prototype.$getLocalizedDateTimeLabels$);
AuraLocalizationService.prototype.$getToday$ = function(timezone, callback) {
  this.$getDateStringBasedOnTimezone$(timezone, new Date, callback)
};
goog.$exportProperty$(AuraLocalizationService.prototype, "getToday", AuraLocalizationService.prototype.$getToday$);
AuraLocalizationService.prototype.$getDateStringBasedOnTimezone$ = function(timezone, dateObj, callback) {
  dateObj.setTime(dateObj.getTime() + dateObj.getTimezoneOffset() * 60 * 1E3);
  var tz = timezone ? timezone : $A.get("$Locale.timezone");
  this.$UTCToWallTime$(dateObj, tz, function(date) {
    callback(date.getFullYear() + "-" + this.$pad$(date.getMonth() + 1) + "-" + this.$pad$(date.getDate()))
  }.bind(this))
};
goog.$exportProperty$(AuraLocalizationService.prototype, "getDateStringBasedOnTimezone", AuraLocalizationService.prototype.$getDateStringBasedOnTimezone$);
AuraLocalizationService.prototype.$getMillisecondsInDuration$ = function(d) {
  return d["milliseconds"]()
};
goog.$exportProperty$(AuraLocalizationService.prototype, "getMillisecondsInDuration", AuraLocalizationService.prototype.$getMillisecondsInDuration$);
AuraLocalizationService.prototype.$getMinutesInDuration$ = function(d) {
  return d["minutes"]()
};
goog.$exportProperty$(AuraLocalizationService.prototype, "getMinutesInDuration", AuraLocalizationService.prototype.$getMinutesInDuration$);
AuraLocalizationService.prototype.$getMonthsInDuration$ = function(d) {
  return d["months"]()
};
goog.$exportProperty$(AuraLocalizationService.prototype, "getMonthsInDuration", AuraLocalizationService.prototype.$getMonthsInDuration$);
AuraLocalizationService.prototype.$getSecondsInDuration$ = function(d) {
  return d["seconds"]()
};
goog.$exportProperty$(AuraLocalizationService.prototype, "getSecondsInDuration", AuraLocalizationService.prototype.$getSecondsInDuration$);
AuraLocalizationService.prototype.$getYearsInDuration$ = function(d) {
  return d["years"]()
};
goog.$exportProperty$(AuraLocalizationService.prototype, "getYearsInDuration", AuraLocalizationService.prototype.$getYearsInDuration$);
AuraLocalizationService.prototype.$isPeriodTimeView$ = function(pattern) {
  if(!pattern || typeof pattern !== "string") {
    return false
  }
  var shouldEscape = false;
  for(var i = 0;i < pattern.length;i++) {
    var c = pattern.charAt(i);
    if(c === "h" && shouldEscape === false) {
      return true
    }
    if(c === "[") {
      shouldEscape = true
    }else {
      if(c === "]") {
        shouldEscape = false
      }
    }
  }
  return false
};
goog.$exportProperty$(AuraLocalizationService.prototype, "isPeriodTimeView", AuraLocalizationService.prototype.$isPeriodTimeView$);
AuraLocalizationService.prototype.$isAfter$ = function(date1, date2, unit) {
  return this.$moment$(date1)["isAfter"](date2, unit)
};
goog.$exportProperty$(AuraLocalizationService.prototype, "isAfter", AuraLocalizationService.prototype.$isAfter$);
AuraLocalizationService.prototype.$isBefore$ = function(date1, date2, unit) {
  return this.$moment$(date1)["isBefore"](date2, unit)
};
goog.$exportProperty$(AuraLocalizationService.prototype, "isBefore", AuraLocalizationService.prototype.$isBefore$);
AuraLocalizationService.prototype.$isSame$ = function(date1, date2, unit) {
  return this.$moment$(date1)["isSame"](date2, unit)
};
goog.$exportProperty$(AuraLocalizationService.prototype, "isSame", AuraLocalizationService.prototype.$isSame$);
AuraLocalizationService.prototype.$isBetween$ = function(date, fromDate, toDate, unit) {
  return this.$moment$(date)["isBetween"](fromDate, toDate, unit, "[]")
};
goog.$exportProperty$(AuraLocalizationService.prototype, "isBetween", AuraLocalizationService.prototype.$isBetween$);
AuraLocalizationService.prototype.$parseDateTime$ = function(dateTimeString, parseFormat, locale, strictParsing) {
  if(!dateTimeString) {
    return null
  }
  var langLocale = locale;
  if(typeof locale === "boolean") {
    strictParsing = locale;
    langLocale = $A.get("$Locale.langLocale")
  }else {
    if(locale !== undefined || strictParsing !== undefined) {
      $A.$deprecated$("$A.localizationService.parseDateTime(dateTimeString, parseFormat, locale, strictParsing) is deprecated. " + "Do NOT rely on the [locale] parameter. It only allows to use the value which is provided " + "by Locale Value Provider. It will be removed in an upcoming release.", "Use $A.localizationService.parseDateTime(dateTimeString, parseFormat, strictParsing)");
      if(locale && !this.$isAvailableLocale$(locale)) {
        langLocale = $A.get("$Locale.langLocale");
        $A.$warning$("AuraLocalizationService.parseDateTime(): Locale '" + locale + "' is not available. " + "Falls back to the locale in $Locale.langLocale: " + langLocale)
      }
    }
  }
  if(!langLocale) {
    langLocale = $A.get("$Locale.langLocale")
  }
  var format = strictParsing ? this.$getStrictModeFormat$(parseFormat) : this.$getNormalizedFormat$(parseFormat);
  var value = strictParsing ? this.$getStrictModeDateTimeString$(dateTimeString) : dateTimeString;
  var mDate = this.$moment$(value, format, this.$getAvailableMomentLocale$(langLocale), strictParsing);
  if(!mDate || !mDate["isValid"]()) {
    return null
  }
  return mDate["toDate"]()
};
goog.$exportProperty$(AuraLocalizationService.prototype, "parseDateTime", AuraLocalizationService.prototype.$parseDateTime$);
AuraLocalizationService.prototype.$parseDateTimeISO8601$ = function(dateTimeString) {
  if(!dateTimeString) {
    return null
  }
  var mDate = this.$moment$(dateTimeString);
  if(mDate && mDate["isValid"]()) {
    return mDate["toDate"]()
  }
  return null
};
goog.$exportProperty$(AuraLocalizationService.prototype, "parseDateTimeISO8601", AuraLocalizationService.prototype.$parseDateTimeISO8601$);
AuraLocalizationService.prototype.$parseDateTimeUTC$ = function(dateTimeString, parseFormat, locale, strictParsing) {
  if(!dateTimeString) {
    return null
  }
  var langLocale = locale;
  if(typeof locale === "boolean") {
    strictParsing = locale;
    langLocale = $A.get("$Locale.langLocale")
  }else {
    if(locale !== undefined || strictParsing !== undefined) {
      $A.$deprecated$("$A.localizationService.parseDateTimeUTC(dateTimeString, parseFormat, locale, strictParsing) is deprecated. " + "Do NOT rely on the [locale] parameter. It only allows to use the value which is provided " + "by Locale Value Provider. It will be removed in an upcoming release.", "Use $A.localizationService.parseDateTimeUTC(dateTimeString, parseFormat, strictParsing)");
      if(locale && !this.$isAvailableLocale$(locale)) {
        langLocale = $A.get("$Locale.langLocale");
        $A.$warning$("AuraLocalizationService.parseDateTimeUTC(): Locale '" + locale + "' is not available. " + "Falls back to the locale in $Locale.langLocale: " + langLocale)
      }
    }
  }
  if(!langLocale) {
    langLocale = $A.get("$Locale.langLocale")
  }
  var format = strictParsing ? this.$getStrictModeFormat$(parseFormat) : this.$getNormalizedFormat$(parseFormat);
  var value = strictParsing ? this.$getStrictModeDateTimeString$(dateTimeString) : dateTimeString;
  var mDate = this.$moment$["utc"](value, format, this.$getAvailableMomentLocale$(langLocale), strictParsing);
  if(!mDate || !mDate["isValid"]()) {
    return null
  }
  return mDate["toDate"]()
};
goog.$exportProperty$(AuraLocalizationService.prototype, "parseDateTimeUTC", AuraLocalizationService.prototype.$parseDateTimeUTC$);
AuraLocalizationService.prototype.$startOf$ = function(date, unit) {
  return this.$moment$(date)["startOf"](unit)["toDate"]()
};
goog.$exportProperty$(AuraLocalizationService.prototype, "startOf", AuraLocalizationService.prototype.$startOf$);
AuraLocalizationService.prototype.toISOString = function(date) {
  if(date && $A.$lockerService$.$instanceOf$(date, Date)) {
    if(date.toISOString) {
      return date.toISOString()
    }else {
      return date.getUTCFullYear() + "-" + this.$pad$(date.getUTCMonth() + 1) + "-" + this.$pad$(date.getUTCDate()) + "T" + this.$pad$(date.getUTCHours()) + ":" + this.$pad$(date.getUTCMinutes()) + ":" + this.$pad$(date.getUTCSeconds()) + "." + this.$doublePad$(date.getUTCMilliseconds()) + "Z"
    }
  }else {
    return date
  }
};
goog.$exportProperty$(AuraLocalizationService.prototype, "toISOString", AuraLocalizationService.prototype.toISOString);
AuraLocalizationService.prototype.$translateFromLocalizedDigits$ = function(input) {
  if(!input) {
    return input
  }
  var localizedZero = $A.get("$Locale.zero");
  var zeroCharCodeOffset = localizedZero.charCodeAt(0) - this.ZERO.charCodeAt(0);
  if(!zeroCharCodeOffset) {
    return input
  }
  var charArray = input.split("");
  for(var i = 0;i < charArray.length;i++) {
    var charCode = charArray[i].charCodeAt(0);
    if(charCode <= localizedZero.charCodeAt(0) + 9 && charCode >= localizedZero.charCodeAt(0)) {
      charArray[i] = String.fromCharCode(charCode - zeroCharCodeOffset)
    }
  }
  return charArray.join("")
};
goog.$exportProperty$(AuraLocalizationService.prototype, "translateFromLocalizedDigits", AuraLocalizationService.prototype.$translateFromLocalizedDigits$);
AuraLocalizationService.prototype.$translateFromOtherCalendar$ = function(date) {
  if(!date) {
    return date
  }
  var userLocaleLang = $A.get("$Locale.userLocaleLang");
  var userLocaleCountry = $A.get("$Locale.userLocaleCountry");
  if(userLocaleLang === "th" && userLocaleCountry === "TH") {
    date.setFullYear(date.getFullYear() - 543)
  }
  return date
};
goog.$exportProperty$(AuraLocalizationService.prototype, "translateFromOtherCalendar", AuraLocalizationService.prototype.$translateFromOtherCalendar$);
AuraLocalizationService.prototype.$translateToLocalizedDigits$ = function(input) {
  if(!input) {
    return input
  }
  var localizedZero = $A.get("$Locale.zero");
  var zeroCharCodeOffset = localizedZero.charCodeAt(0) - this.ZERO.charCodeAt(0);
  if(!zeroCharCodeOffset) {
    return input
  }
  var charArray = input.split("");
  for(var i = 0;i < charArray.length;i++) {
    var charCode = charArray[i].charCodeAt(0);
    if(charCode <= "9".charCodeAt(0) && charCode >= "0".charCodeAt(0)) {
      charArray[i] = String.fromCharCode(charCode + zeroCharCodeOffset)
    }
  }
  return charArray.join("")
};
goog.$exportProperty$(AuraLocalizationService.prototype, "translateToLocalizedDigits", AuraLocalizationService.prototype.$translateToLocalizedDigits$);
AuraLocalizationService.prototype.$translateToOtherCalendar$ = function(date) {
  if(!date) {
    return date
  }
  var userLocaleLang = $A.get("$Locale.userLocaleLang");
  var userLocaleCountry = $A.get("$Locale.userLocaleCountry");
  if(userLocaleLang === "th" && userLocaleCountry === "TH") {
    date.setFullYear(date.getFullYear() + 543)
  }
  return date
};
goog.$exportProperty$(AuraLocalizationService.prototype, "translateToOtherCalendar", AuraLocalizationService.prototype.$translateToOtherCalendar$);
AuraLocalizationService.prototype.$UTCToWallTime$ = function(date, timezone, callback) {
  $A.assert(callback, "Callback is required");
  if(typeof callback !== "function") {
    $A.$warning$("AuraLocalizationService.UTCToWallTime(): callback must be a function.");
    return
  }
  if(!this.$moment$["tz"]) {
    var message = "AuraLocalizationService.UTCToWallTime(): moment-timezone lib is missing on moment. " + "It could be overridden by another version of moment-js in userland code. Current moment-js version: " + this.$moment$["version"];
    $A.$warning$(message);
    $A.$logger$.$reportError$(new $A.$auraError$(message), null, "WARNING");
    callback(date);
    return
  }
  if(!timezone) {
    timezone = $A.get("$Locale.timezone")
  }
  if(!this.$moment$["tz"]["zone"](timezone)) {
    $A.$warning$("AuraLocalizationService.UTCToWallTime(): unsupported time zone: " + timezone + ". Fallback to default timezone.");
    timezone = $A.get("$Locale.timezone")
  }
  if(timezone === "GMT" || timezone === "UTC") {
    callback(date);
    return
  }
  var walltimeDate = date;
  try {
    var zone = this.$moment$["tz"]["zone"](timezone);
    var offset = zone["offset"](date.getTime());
    var walltime = this.$moment$(date)["subtract"](offset, "minutes");
    walltimeDate = walltime["toDate"]()
  }catch(e) {
    $A.$warning$("AuraLocalizationService.UTCToWallTime(): error occurred during time conversion", e)
  }
  callback(walltimeDate)
};
goog.$exportProperty$(AuraLocalizationService.prototype, "UTCToWallTime", AuraLocalizationService.prototype.$UTCToWallTime$);
AuraLocalizationService.prototype.$WallTimeToUTC$ = function(date, timezone, callback) {
  $A.assert(callback, "Callback is required");
  if(typeof callback !== "function") {
    $A.$warning$("AuraLocalizationService.WallTimeToUTC(): callback must be a function.");
    return
  }
  if(!this.$moment$["tz"]) {
    var message = "AuraLocalizationService.WallTimeToUTC(): moment-timezone lib is missing on moment. " + "It could be overridden by another version of moment-js in userland code. Current moment-js version: " + this.$moment$["version"];
    $A.$warning$(message);
    $A.$logger$.$reportError$(new $A.$auraError$(message), null, "WARNING");
    callback(date);
    return
  }
  if(!timezone) {
    timezone = $A.get("$Locale.timezone")
  }
  if(!this.$moment$["tz"]["zone"](timezone)) {
    $A.$warning$("AuraLocalizationService.WallTimeToUTC(): unsupported time zone: " + timezone + ". Fallback to default timezone.");
    timezone = $A.get("$Locale.timezone")
  }
  if(timezone === "GMT" || timezone === "UTC") {
    callback(date);
    return
  }
  var utcDate = date;
  try {
    var zone = this.$moment$["tz"]["zone"](timezone);
    var offset = zone["offset"](date.getTime());
    var utc = this.$moment$(date)["add"](offset, "minutes");
    utcDate = utc["toDate"]()
  }catch(e) {
    $A.$warning$("AuraLocalizationService.WallTimeToUTC(): error occurred during time conversion", e)
  }
  callback(utcDate)
};
goog.$exportProperty$(AuraLocalizationService.prototype, "WallTimeToUTC", AuraLocalizationService.prototype.$WallTimeToUTC$);
AuraLocalizationService.prototype.$init$ = function() {
  if(typeof moment === "undefined") {
    $A.$warning$("moment is required to initialize Localization Service.");
    return
  }
  if(Aura["loadLocaleData"]) {
    Aura["loadLocaleData"]();
    Aura["loadLocaleData"] = undefined
  }
  this.$moment$ = moment;
  var langLocale = $A.get("$Locale.langLocale");
  var userLocale = $A.get("$Locale.userLocaleLang") + "_" + $A.get("$Locale.userLocaleCountry");
  var ltngLocale = $A.get("$Locale.language") + "_" + $A.get("$Locale.userLocaleCountry");
  this.$localeCache$[langLocale] = this.$normalizeToMomentLocale$(langLocale);
  this.$localeCache$[userLocale] = this.$normalizeToMomentLocale$(userLocale);
  this.$localeCache$[ltngLocale] = this.$normalizeToMomentLocale$(ltngLocale);
  this.$moment$.locale(this.$localeCache$[langLocale])
};
AuraLocalizationService.prototype.$normalizeToMomentLocale$ = function(locale) {
  if(!locale) {
    return locale
  }
  var locales = this.$moment$["locales"]();
  var momentLocale;
  var normalized = this.$normalizeLocale$(locale);
  var tokens = normalized.split("-", 2);
  if(tokens[0] === "no") {
    tokens[0] = "nb"
  }
  if(tokens.length > 1) {
    momentLocale = tokens.join("-");
    if(locales.indexOf(momentLocale) > -1) {
      return momentLocale
    }
  }
  momentLocale = tokens[0];
  if(locales.indexOf(momentLocale) > -1) {
    return momentLocale
  }
  return"en"
};
AuraLocalizationService.prototype.$normalizeLocale$ = function(locale) {
  return locale ? locale.toLowerCase().replace("_", "-") : locale
};
AuraLocalizationService.prototype.$getAvailableMomentLocale$ = function(locale) {
  var momentLocale = this.$localeCache$[locale];
  return momentLocale ? momentLocale : "en"
};
AuraLocalizationService.prototype.$isAvailableLocale$ = function(locale) {
  if(!locale) {
    return false
  }
  if(this.$localeCache$.hasOwnProperty(locale)) {
    return true
  }
  var momentLocale = this.$normalizeToMomentLocale$(locale);
  var language = this.$normalizeLocale$(locale).split("-")[0];
  if(momentLocale === "en" && language !== "en") {
    return false
  }else {
    this.$localeCache$[locale] = momentLocale;
    return true
  }
};
AuraLocalizationService.prototype.$displayDateTime$ = function(mDate, format, locale) {
  if(locale) {
    mDate["locale"](this.$getAvailableMomentLocale$(locale))
  }
  return mDate["format"](this.$getNormalizedFormat$(format))
};
AuraLocalizationService.prototype.$getNormalizedFormat$ = function(format) {
  if(format) {
    if(!this.$cache$.$format$[format]) {
      var normalizedFormat = format.replace(/y/g, "Y").replace(/(\b|[^Y])Y(?!Y)/g, "$1YYYY").replace(/d/g, "D").replace(/E/g, "d").replace(/a/g, "A");
      this.$cache$.$format$[format] = normalizedFormat
    }
    return this.$cache$.$format$[format]
  }
  return format
};
AuraLocalizationService.prototype.$getStrictModeFormat$ = function(format) {
  if(format) {
    if(!this.$cache$.$strictModeFormat$[format]) {
      var normalizedFormat = this.$getNormalizedFormat$(format);
      if(normalizedFormat) {
        var strictModeFormat = normalizedFormat.replace(/(\b|[^D])D{2}(?!D)/g, "$1D").replace(/(\b|[^M])M{2}(?!M)/g, "$1M").replace(/(\b|[^h])h{2}(?!h)/g, "$1h").replace(/(\b|[^H])H{2}(?!H)/g, "$1H").replace(/(\b|[^m])m{2}(?!m)/g, "$1m").replace(/(\b|[^s])s{2}(?!s)/g, "$1s").replace(/\s*A/g, " A").trim();
        this.$cache$.$strictModeFormat$[format] = strictModeFormat
      }
    }
    return this.$cache$.$strictModeFormat$[format]
  }
  return format
};
AuraLocalizationService.prototype.$getStrictModeDateTimeString$ = function(dateTimeString) {
  if(dateTimeString) {
    return dateTimeString.replace(/(\d)([AaPp][Mm])/g, "$1 $2")
  }
  return dateTimeString
};
AuraLocalizationService.prototype.$pad$ = function(n) {
  return n < 10 ? "0" + n : n
};
AuraLocalizationService.prototype.$doublePad$ = function(n) {
  return n < 10 ? "00" + n : n < 100 ? "0" + n : n
};
Aura.$Services$.$AuraLocalizationService$ = AuraLocalizationService;
function AuraStyleService() {
  this.$styleUtil$ = new Aura.$Utils$.$Style$;
  this.$added$ = []
}
goog.$exportSymbol$("AuraStyleService", AuraStyleService);
AuraStyleService.prototype.$applyTokens$ = function(descriptor, config) {
  $A.assert(!$A["util"].$isUndefinedOrNull$(descriptor), "applyTokens() cannot be given a null or undefined descriptor argument");
  this.$applyAllTokens$([descriptor], config)
};
goog.$exportProperty$(AuraStyleService.prototype, "applyTokens", AuraStyleService.prototype.$applyTokens$);
AuraStyleService.prototype.$applyAllTokens$ = function(descriptors, config) {
  $A.assert($A["util"].isArray(descriptors), "applyAllTokens() expects the 'descriptors' arg to be an array of strings");
  var that = this;
  config = config || {};
  $A.$run$(function() {
    var action = $A.get("c.aura://StyleController.applyTokens");
    action.$setParams$({"descriptors":descriptors, "extraStyles":config["extraStyles"] || []});
    if($A["util"].$isUndefined$(config["storable"]) || config["storable"]) {
      action.$setStorable$()
    }
    action.$setCallback$(this, function(a) {
      var state = a.$getState$();
      if(state === "SUCCESS") {
        if($A["util"].$isFunction$(config["customHandler"])) {
          config["customHandler"](a.$getReturnValue$());
          return
        }
        var node = that.$styleUtil$.apply(a.$getReturnValue$());
        if($A["util"].$isUndefinedOrNull$(config["replaceExisting"]) || $A["util"].$getBooleanValue$(config["replaceExisting"]) === true) {
          that.$removeTokens$();
          that.$added$ = [node]
        }else {
          that.$added$.push(node)
        }
      }else {
        if(state === "INCOMPLETE") {
          var offlineMessageEvt = $A.$getEvt$("markup://force:showOfflineMessage");
          if(offlineMessageEvt) {
            offlineMessageEvt.$setParams$({$retryAction$:action}).$fire$()
          }
        }else {
          if(state === "ERROR") {
            var errors = a.getError();
            var e;
            if(errors && errors[0] && errors[0].message) {
              e = new Error(errors[0].message)
            }else {
              e = new Error("Unable to apply tokens, action state \x3d " + a.$getState$())
            }
            e["reported"] = true;
            throw e;
          }
        }
      }
      if($A["util"].$isFunction$(config["callback"])) {
        config["callback"]()
      }
    });
    $A.$clientService$.$enqueueAction$(action)
  }, "applyAllTokens")
};
goog.$exportProperty$(AuraStyleService.prototype, "applyAllTokens", AuraStyleService.prototype.$applyAllTokens$);
AuraStyleService.prototype.$removeTokens$ = function() {
  var head = this.$styleUtil$.$getHead$();
  var i = 0;
  for(var len = this.$added$.length;i < len;i++) {
    head.removeChild(this.$added$[i])
  }
};
goog.$exportProperty$(AuraStyleService.prototype, "removeTokens", AuraStyleService.prototype.$removeTokens$);
Aura.$Services$.$AuraStyleService$ = AuraStyleService;
Aura.$Services$.$MetricsService$ = function MetricsService() {
  this.$collector$ = {"default":[]};
  this.$globalHandlers$ = {"transactionEnd":[], "transactionsKilled":[]};
  this.$bootstrap$ = {"cache":{}};
  this.$registeredPlugins$ = {};
  this.$pluginInstances$ = {};
  this.$beaconProviders$ = {};
  this.$transactions$ = {};
  this.$doneBootstrap$ = false;
  this.$pluginsInitialized$ = false;
  this.$clearCompleteTransactions$ = true;
  this.$shouldLogBootstrap$ = true;
  this["PAGE_IN_DOM"] = "PageInDOM";
  this["PAGE_HAS_ERROR"] = "PageHasError";
  this["PAGE_NOT_LOADED"] = "PageNotLoaded";
  this["PREVIOUS_PAGE_NOT_LOADED"] = "PreviousPageNotLoaded";
  this["INTERACTION_BEFORE_PAGE_LOADED"] = "InteractionBeforePageLoaded";
  this["PAGE_IN_BACKGROUND_BEFORE_LOADED"] = "PageInBackgroundBeforeLoaded"
};
goog.$exportSymbol$("Aura.Services.MetricsService", Aura.$Services$.$MetricsService$);
Aura.$Services$.$MetricsService$.VERSION = "2.2.0";
Aura.$Services$.$MetricsService$.$PERFTIME$ = !!(window.performance && window.performance.now);
Aura.$Services$.$MetricsService$.$TIMER$ = Aura.$Services$.$MetricsService$.$PERFTIME$ ? function() {
  return Math.floor(window.performance.now() * 100) / 100
} : Date.now.bind(Date);
Aura.$Services$.$MetricsService$.$START$ = "start";
Aura.$Services$.$MetricsService$.$END$ = "end";
Aura.$Services$.$MetricsService$.$STAMP$ = "stamp";
Aura.$Services$.$MetricsService$.$DEFAULT$ = "default";
Aura.$Services$.$MetricsService$.$MAXTIME$ = 3E4;
Aura.$Services$.$MetricsService$.$CUSTOM_MARKS$ = "custom";
Aura.$Services$.$MetricsService$.prototype.$initialize$ = function() {
  this.$getPageStartTime$();
  this.$transactionStart$("aura", "bootstrap");
  this.$initializePlugins$();
  window.addEventListener("load", this.$emitBootstrapTransaction$.bind(this))
};
Aura.$Services$.$MetricsService$.prototype.$instrument$ = function(instance, method, ns, async, before, after, override) {
  var self = this;
  var original = instance[method];
  var beforeFn = typeof before === "function";
  var afterFn = typeof after === "function";
  instance[method] = function() {
    var mark = !override && self.$markStart$(ns, method);
    var ret;
    if(beforeFn) {
      Array.prototype.unshift.call(arguments, mark);
      before.apply(this, arguments);
      Array.prototype.shift.call(arguments)
    }
    if(override) {
      var xargs = Array.prototype.slice.call(arguments);
      xargs.unshift(original);
      ret = override.apply(this, xargs)
    }else {
      ret = original.apply(this, arguments)
    }
    if(async) {
      return ret
    }
    mark = !override && self.$markEnd$(ns, method);
    if(afterFn) {
      Array.prototype.unshift.call(arguments, mark);
      after.apply(this, arguments)
    }
    return ret
  };
  instance[method]["__original"] = original
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "instrument", Aura.$Services$.$MetricsService$.prototype.$instrument$);
Aura.$Services$.$MetricsService$.prototype.$unInstrument$ = function(instance, method) {
  var original = instance[method]["__original"];
  delete instance[method]["__original"];
  instance[method] = original
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "unInstrument", Aura.$Services$.$MetricsService$.prototype.$unInstrument$);
Aura.$Services$.$MetricsService$.prototype.$initializePlugins$ = function() {
  for(var plugin in this.$registeredPlugins$) {
    this.$initializePlugin$(plugin, this.$registeredPlugins$[plugin])
  }
  this.$pluginsInitialized$ = true
};
Aura.$Services$.$MetricsService$.prototype.$initializePlugin$ = function(pluginName, PluginContructor) {
  var pluginInstance = typeof PluginContructor === "function" ? new PluginContructor : PluginContructor;
  this.$pluginInstances$[pluginName] = pluginInstance;
  this.$collector$[pluginName] = [];
  pluginInstance["initialize"](this)
};
Aura.$Services$.$MetricsService$.prototype.$applicationReady$ = function() {
  Aura.$bootstrapMark$("bootstrapEPT");
  this.$applicationReadyTime$ = this.time();
  this.$emitBootstrapTransaction$();
  if(!this.$inTransaction$()) {
    this.$clearMarks$()
  }
};
Aura.$Services$.$MetricsService$.prototype.$emitBootstrapTransaction$ = function() {
  var domReady = window.document && window.document.readyState;
  if(!this.$_emittedBootstrap$ && this.$applicationReadyTime$ && domReady === "complete") {
    this.$_emittedBootstrap$ = true;
    if(!this.$shouldLogBootstrap$) {
      return
    }
    setTimeout(function() {
      var bootstrap = this.$getBootstrapMetrics$();
      var appReady = this.$applicationReadyTime$;
      this.$transactionEnd$("aura", "bootstrap", function(transaction) {
        var bootstrapStart = Aura.$Services$.$MetricsService$.$PERFTIME$ ? 0 : transaction["pageStartTime"];
        bootstrap["visibilityStateEnd"] = document.visibilityState;
        transaction["context"] = {"eventType":"bootstrap", "eventSource":"framework", "attributes":bootstrap};
        transaction["ts"] = bootstrapStart;
        transaction["duration"] = parseInt(appReady - bootstrapStart, 10)
      })
    }.bind(this), 0)
  }
};
Aura.$Services$.$MetricsService$.prototype.$syntheticTransactionStart$ = function(ns, name, config) {
  var trx = this.$createTransaction$(ns, name, config);
  $A["util"].apply(this.$transactions$[trx], config, true, true);
  return trx
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "syntheticTransactionStart", Aura.$Services$.$MetricsService$.prototype.$syntheticTransactionStart$);
Aura.$Services$.$MetricsService$.prototype.$onTransactionEnd$ = function(callback) {
  this.$globalHandlers$["transactionEnd"].push(callback)
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "onTransactionEnd", Aura.$Services$.$MetricsService$.prototype.$onTransactionEnd$);
Aura.$Services$.$MetricsService$.prototype.$detachOnTransactionEnd$ = function(callback) {
  this.$detachHandlerOfType$(callback, "transactionEnd")
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "detachOnTransactionEnd", Aura.$Services$.$MetricsService$.prototype.$detachOnTransactionEnd$);
Aura.$Services$.$MetricsService$.prototype.$onTransactionsKilled$ = function(callback) {
  this.$globalHandlers$["transactionsKilled"].push(callback)
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "onTransactionsKilled", Aura.$Services$.$MetricsService$.prototype.$onTransactionsKilled$);
Aura.$Services$.$MetricsService$.prototype.$detachOnKilledTransactions$ = function(callback) {
  this.$detachHandlerOfType$(callback, "transactionsKilled")
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "detachOnKilledTransactions", Aura.$Services$.$MetricsService$.prototype.$detachOnKilledTransactions$);
Aura.$Services$.$MetricsService$.prototype.$detachHandlerOfType$ = function(callback, name) {
  var handlers = this.$globalHandlers$[name];
  var position = handlers.indexOf(callback);
  if(position > -1) {
    handlers.splice(position, 1)
  }
};
Aura.$Services$.$MetricsService$.prototype.$inTransaction$ = function(ignorePageTransactions) {
  $A["util"].$isEmpty$(this.$transactions$);
  if(!ignorePageTransactions) {
    return!$A["util"].$isEmpty$(this.$transactions$)
  }
  if(this.$getCurrentPageTransaction$()) {
    return Object.keys(this.$transactions$).length > 1
  }
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "inTransaction", Aura.$Services$.$MetricsService$.prototype.$inTransaction$);
Aura.$Services$.$MetricsService$.prototype.transaction = function(ns, name, config) {
  config = config || {};
  var postProcess = typeof config === "function" ? config : config["postProcess"];
  this.$createTransaction$(ns, name, config);
  this.$transactionEnd$(ns, name, function(t) {
    t["duration"] = 0;
    if(postProcess) {
      postProcess(t)
    }
  })
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "transaction", Aura.$Services$.$MetricsService$.prototype.transaction);
Aura.$Services$.$MetricsService$.prototype.$transactionUpdate$ = function(ns, name, config) {
  config = config || {};
  var id = (ns || Aura.$Services$.$MetricsService$.$DEFAULT$) + ":" + name;
  var transaction = this.$transactions$[id];
  if(transaction) {
    transaction["config"] = $A["util"].apply(transaction["config"], config, true, true)
  }
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "transactionUpdate", Aura.$Services$.$MetricsService$.prototype.$transactionUpdate$);
Aura.$Services$.$MetricsService$.prototype.$transactionStart$ = function(ns, name, config) {
  return this.$createTransaction$(ns, name, config)
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "transactionStart", Aura.$Services$.$MetricsService$.prototype.$transactionStart$);
Aura.$Services$.$MetricsService$.prototype.$transactionEnd$ = function(ns, name, config, postProcess) {
  var id = ns + ":" + name;
  var transaction = this.$transactions$[id];
  var transactionCfg = $A["util"].apply(transaction && transaction["config"] || {}, config, true, true);
  var beacon = this.$beaconProviders$[ns] || this.$beaconProviders$[Aura.$Services$.$MetricsService$.$DEFAULT$];
  postProcess = typeof config === "function" ? config : postProcess || transactionCfg["postProcess"];
  if(transaction && (beacon || postProcess || !this.$clearCompleteTransactions$)) {
    var parsedTransaction = {"id":id, "ts":transaction["ts"], "duration":parseInt(this.time() - transaction["ts"]), "pageStartTime":this.$pageStartTime$, "marks":{}, "context":transactionCfg["context"] || {}, "unixTS":!Aura.$Services$.$MetricsService$.$PERFTIME$};
    for(var plugin in this.$collector$) {
      var instance = this.$pluginInstances$[plugin];
      if(this.$collector$[plugin].length) {
        var pluginCollector = this.$collector$[plugin];
        var initialOffset = transaction["offsets"] && (transaction["offsets"][plugin] || 0);
        var tMarks = pluginCollector.slice(initialOffset);
        var pluginPostProcess = instance && instance.$postProcess$;
        var parsedMarks = pluginPostProcess ? instance.$postProcess$(tMarks, transactionCfg) : tMarks;
        var pluginName = instance ? plugin : Aura.$Services$.$MetricsService$.$CUSTOM_MARKS$;
        if(!pluginPostProcess && tMarks.length) {
          parsedMarks = this.$defaultPostProcessing$(tMarks)
        }
        if(parsedMarks && parsedMarks.length) {
          parsedTransaction["marks"][pluginName] = parsedTransaction["marks"][pluginName] || [];
          parsedTransaction["marks"][pluginName].push.apply(parsedTransaction["marks"][pluginName], parsedMarks)
        }
      }
    }
    if(postProcess) {
      postProcess(parsedTransaction)
    }
    if(beacon && beacon["middleware"]) {
      beacon["middleware"](parsedTransaction)
    }
    if(this.$globalHandlers$["transactionEnd"].length) {
      this.$callHandlers$("transactionEnd", parsedTransaction)
    }
    if(beacon) {
      beacon["sendData"](parsedTransaction["id"], parsedTransaction)
    }
    if(!this.$clearCompleteTransactions$) {
      var newId = id + ":" + parseInt(parsedTransaction["ts"], 10);
      parsedTransaction["config"] = transactionCfg;
      this.$transactions$[newId] = parsedTransaction;
      parsedTransaction["id"] = newId
    }
    delete this.$transactions$[id];
    if(!this.$inTransaction$()) {
      this.$clearMarks$()
    }else {
      this.$killLongRunningTransactions$()
    }
  }else {
    delete this.$transactions$[id]
  }
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "transactionEnd", Aura.$Services$.$MetricsService$.prototype.$transactionEnd$);
Aura.$Services$.$MetricsService$.prototype.$clearTransactions$ = function() {
  this.$transactions$ = {}
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "clearTransactions", Aura.$Services$.$MetricsService$.prototype.$clearTransactions$);
Aura.$Services$.$MetricsService$.prototype.$callHandlers$ = function(type, t) {
  var handlers = this.$globalHandlers$[type];
  if(handlers) {
    for(var i = 0;i < handlers.length;i++) {
      handlers[i](t)
    }
  }
};
Aura.$Services$.$MetricsService$.prototype.$killLongRunningTransactions$ = function() {
  var now = this.time();
  var transactionsKilled = [];
  for(var i in this.$transactions$) {
    var transaction = this.$transactions$[i];
    var isPageTransaction = transaction["config"]["pageTransaction"];
    if(!isPageTransaction && now - transaction["ts"] > Aura.$Services$.$MetricsService$.$MAXTIME$) {
      transactionsKilled.push(transaction);
      delete this.$transactions$[i]
    }
  }
  if(transactionsKilled.length && this.$globalHandlers$["transactionsKilled"].length) {
    this.$callHandlers$("transactionsKilled", transactionsKilled)
  }
};
Aura.$Services$.$MetricsService$.prototype.$getCurrentPageTransaction$ = function() {
  for(var i in this.$transactions$) {
    if(this.$transactions$[i]["config"]["pageTransaction"]) {
      return this.$transactions$[i]
    }
  }
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "getCurrentPageTransaction", Aura.$Services$.$MetricsService$.prototype.$getCurrentPageTransaction$);
Aura.$Services$.$MetricsService$.prototype.$updateCurrentPageTransaction$ = function(config) {
  var trx = this.$getCurrentPageTransaction$();
  if(trx) {
    trx["config"] = $A["util"].apply(trx["config"], config, true, true)
  }
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "updateCurrentPageTransaction", Aura.$Services$.$MetricsService$.prototype.$updateCurrentPageTransaction$);
Aura.$Services$.$MetricsService$.prototype.$getCurrentMarks$ = function() {
  return $A["util"].apply({}, this.$collector$, true, true)
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "getCurrentMarks", Aura.$Services$.$MetricsService$.prototype.$getCurrentMarks$);
Aura.$Services$.$MetricsService$.prototype.$getVersion$ = function(includePlugins) {
  var msVersion = Aura.$Services$.$MetricsService$.VERSION;
  if(!includePlugins) {
    return msVersion
  }
  var pluginsVersion = {};
  for(var p in this.$registeredPlugins$) {
    pluginsVersion[p] = this.$registeredPlugins$["VERSION"]
  }
  return{"metricsService":msVersion, "plugins":pluginsVersion}
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "getVersion", Aura.$Services$.$MetricsService$.prototype.$getVersion$);
Aura.$Services$.$MetricsService$.prototype.$defaultPostProcessing$ = function(customMarks) {
  var procesedMarks = [];
  var queue = {};
  for(var i = 0;i < customMarks.length;i++) {
    var id = customMarks[i]["ns"] + customMarks[i]["name"];
    var phase = customMarks[i]["phase"];
    if(phase === "stamp") {
      procesedMarks.push(customMarks[i])
    }else {
      if(phase === "start") {
        queue[id] = customMarks[i]
      }else {
        if(phase === "end" && queue[id]) {
          var mark = queue[id];
          mark["context"] = $A["util"].apply(mark["context"] || {}, customMarks[i]["context"] || {});
          mark["duration"] = parseInt(customMarks[i]["ts"] - mark["ts"]);
          procesedMarks.push(mark);
          mark["phase"] = "stamp";
          queue[id] = null
        }
      }
    }
  }
  return procesedMarks
};
Aura.$Services$.$MetricsService$.prototype.$getTransactions$ = function() {
  var transactions = [];
  for(var i in this.$transactions$) {
    transactions.push(this.$transactions$[i])
  }
  return transactions
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "getTransactions", Aura.$Services$.$MetricsService$.prototype.$getTransactions$);
Aura.$Services$.$MetricsService$.prototype.$getTransaction$ = function(ns, id) {
  if(!id) {
    id = ns;
    ns = Aura.$Services$.$MetricsService$.$DEFAULT$
  }
  var key = id.indexOf(":") === -1 ? ns + ":" + id : id;
  for(var i in this.$transactions$) {
    var t = this.$transactions$[i];
    if(t["id"].indexOf(key) === 0) {
      return t
    }
  }
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "getTransaction", Aura.$Services$.$MetricsService$.prototype.$getTransaction$);
Aura.$Services$.$MetricsService$.prototype.$setClearCompletedTransactions$ = function(value) {
  this.$clearCompleteTransactions$ = value
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "setClearCompletedTransactions", Aura.$Services$.$MetricsService$.prototype.$setClearCompletedTransactions$);
Aura.$Services$.$MetricsService$.prototype.$createTransaction$ = function(ns, name, config) {
  var id = (ns || Aura.$Services$.$MetricsService$.$DEFAULT$) + ":" + name;
  var transaction = {"id":id, "offsets":{}, "ts":Math.round(this.time() * 100) / 100, "config":config || {}};
  var offsets = transaction["offsets"];
  for(var c in this.$collector$) {
    offsets[c] = this.$collector$[c].length
  }
  this.$transactions$[id] = transaction;
  return id
};
Aura.$Services$.$MetricsService$.prototype["mark"] = function(ns, name, context) {
  if(!name) {
    name = ns;
    ns = Aura.$Services$.$MetricsService$.$DEFAULT$
  }
  var mark = this.$createMarkNode$(ns, name, Aura.$Services$.$MetricsService$.$STAMP$, context);
  var nsCollector = this.$collector$[ns];
  var collector = nsCollector ? nsCollector : this.$collector$[ns] = [];
  collector.push(mark);
  return mark
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "mark", Aura.$Services$.$MetricsService$.prototype["mark"]);
Aura.$Services$.$MetricsService$.prototype.$markStart$ = function(ns, name, context) {
  if(!name) {
    name = ns;
    ns = Aura.$Services$.$MetricsService$.$DEFAULT$
  }
  var mark = this.$createMarkNode$(ns, name, Aura.$Services$.$MetricsService$.$START$, context);
  var nsCollector = this.$collector$[ns];
  var collector = nsCollector ? nsCollector : this.$collector$[ns] = [];
  collector.push(mark);
  return mark
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "markStart", Aura.$Services$.$MetricsService$.prototype.$markStart$);
Aura.$Services$.$MetricsService$.prototype.$markEnd$ = function(ns, name, context) {
  if(!name) {
    name = ns;
    ns = Aura.$Services$.$MetricsService$.$DEFAULT$
  }
  var mark = this.$createMarkNode$(ns, name, Aura.$Services$.$MetricsService$.$END$, context);
  var nsCollector = this.$collector$[ns];
  var collector = nsCollector ? nsCollector : this.$collector$[ns] = [];
  collector.push(mark);
  return mark
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "markEnd", Aura.$Services$.$MetricsService$.prototype.$markEnd$);
Aura.$Services$.$MetricsService$.prototype.$createMarkNode$ = function(ns, name, eventType, options) {
  var context = options ? options["context"] || options : null;
  return{"ns":ns, "name":name, "phase":eventType, "ts":Aura.$Services$.$MetricsService$.$TIMER$(), "context":context}
};
Aura.$Services$.$MetricsService$.prototype.$clearMarks$ = function(ns) {
  if(ns) {
    if(this.$collector$[ns]) {
      this.$collector$[ns] = []
    }
  }else {
    for(var i in this.$collector$) {
      this.$collector$[i] = []
    }
  }
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "clearMarks", Aura.$Services$.$MetricsService$.prototype.$clearMarks$);
Aura.$Services$.$MetricsService$.prototype.$getPageStartTime$ = function() {
  if(!this.$pageStartTime$) {
    var p = window.performance;
    var pst;
    if(p && p.timing && p.timing.navigationStart) {
      pst = p.timing.navigationStart
    }else {
      pst = window["pageStartTime"]
    }
    this.$pageStartTime$ = pst
  }
  return this.$pageStartTime$
};
Aura.$Services$.$MetricsService$.prototype.time = function() {
  return Aura.$Services$.$MetricsService$.$TIMER$()
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "time", Aura.$Services$.$MetricsService$.prototype.time);
Aura.$Services$.$MetricsService$.prototype.$microsecondsResolution$ = function() {
  return Aura.$Services$.$MetricsService$.$PERFTIME$
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "microsecondsResolution", Aura.$Services$.$MetricsService$.prototype.$microsecondsResolution$);
Aura.$Services$.$MetricsService$.prototype.$disablePlugins$ = function() {
  for(var p in this.$pluginInstances$) {
    this.$disablePlugin$(p)
  }
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "disablePlugins", Aura.$Services$.$MetricsService$.prototype.$disablePlugins$);
Aura.$Services$.$MetricsService$.prototype.$disablePlugin$ = function(name) {
  var plugin = this.$pluginInstances$[name];
  if(plugin && plugin.disable) {
    plugin["disable"]()
  }
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "disablePlugin", Aura.$Services$.$MetricsService$.prototype.$disablePlugin$);
Aura.$Services$.$MetricsService$.prototype.$enablePlugins$ = function() {
  for(var p in this.$pluginInstances$) {
    this.$enablePlugin$(p)
  }
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "enablePlugins", Aura.$Services$.$MetricsService$.prototype.$enablePlugins$);
Aura.$Services$.$MetricsService$.prototype.$enablePlugin$ = function(name) {
  var plugin = this.$pluginInstances$[name];
  if(plugin && plugin.enable) {
    plugin["enable"]()
  }
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "enablePlugin", Aura.$Services$.$MetricsService$.prototype.$enablePlugin$);
Aura.$Services$.$MetricsService$.prototype.$registerPlugin$ = function(pluginConfig) {
  var pluginName = pluginConfig["name"];
  var PluginContructor = pluginConfig["plugin"];
  this.$registeredPlugins$[pluginName] = PluginContructor;
  if(this.$pluginsInitialized$) {
    this.$initializePlugin$(pluginName, PluginContructor)
  }
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "registerPlugin", Aura.$Services$.$MetricsService$.prototype.$registerPlugin$);
Aura.$Services$.$MetricsService$.prototype.$registerBeacon$ = function(beacon) {
  this.$beaconProviders$[beacon["name"] || Aura.$Services$.$MetricsService$.$DEFAULT$] = beacon["beacon"] || beacon
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "registerBeacon", Aura.$Services$.$MetricsService$.prototype.$registerBeacon$);
Aura.$Services$.$MetricsService$.prototype.$summarizeResourcePerfInfo$ = function(r) {
  return{"name":r.name, "initiatorType":r.initiatorType, "duration":parseInt(r.responseEnd - r.startTime, 10), "startTime":parseInt(r.startTime, 10), "fetchStart":parseInt(r.fetchStart, 10), "requestStart":parseInt(r.requestStart, 10), "dns":parseInt(r.domainLookupEnd - r.domainLookupStart, 10), "tcp":parseInt(r.connectEnd - r.connectStart, 10), "ttfb":parseInt(r.responseStart - r.startTime, 10), "transfer":parseInt(r.responseEnd - r.responseStart, 10), "transferSize":r["transferSize"] || 0, "encodedBodySize":r["encodedBodySize"] || 
  0, "decodedBodySize":r["decodedBodySize"] || 0}
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "summarizeResourcePerfInfo", Aura.$Services$.$MetricsService$.prototype.$summarizeResourcePerfInfo$);
Aura.$Services$.$MetricsService$.prototype.$skipBootstrapLogging$ = function() {
  this.$shouldLogBootstrap$ = false
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "skipBootstrapLogging", Aura.$Services$.$MetricsService$.prototype.$skipBootstrapLogging$);
Aura.$Services$.$MetricsService$.prototype.$getBootstrapMetrics$ = function() {
  var bootstrap = this.$bootstrap$;
  var pageStartTime = this.$getPageStartTime$();
  for(var m in Aura["bootstrap"]) {
    bootstrap[m] = parseInt(Aura["bootstrap"][m], 10)
  }
  bootstrap["visibilityStateStart"] = Aura["bootstrap"]["visibilityStateStart"];
  bootstrap["mode"] = $A.getContext().$getMode$();
  bootstrap["pageStartTime"] = pageStartTime;
  if(window.performance && performance.timing) {
    var p = window.performance;
    var pt = p.timing;
    if(!bootstrap["timing"]) {
      bootstrap["timing"] = {"navigationStart":pt.navigationStart, "fetchStart":pt.fetchStart, "readyStart":pt.fetchStart - pt.navigationStart, "dnsStart":pt.domainLookupStart, "dnsEnd":pt.domainLookupEnd, "lookupDomainTime":pt.domainLookupEnd - pt.domainLookupStart, "connectStart":pt.connectStart, "connectEnd":pt.connectEnd, "connectTime":pt.connectEnd - pt.connectStart, "requestStart":pt.requestStart, "responseStart":pt.responseStart, "responseEnd":pt.responseEnd, "requestTime":pt.responseEnd - 
      pt.requestStart, "domLoading":pt.domLoading, "domInteractive":pt.domInteractive, "initDomTreeTime":pt.domInteractive - pt.responseEnd, "contentLoadStart":pt.domContentLoadedEventStart, "contentLoadEnd":pt.domContentLoadedEventEnd, "domComplete":pt.domComplete, "domReadyTime":pt.domComplete - pt.domInteractive, "loadEventStart":pt.loadEventStart, "loadEventEnd":pt.loadEventEnd, "loadEventTime":pt.loadEventEnd - pt.loadEventStart, "loadTime":pt.loadEventEnd - pt.fetchStart, "unloadEventStart":pt.unloadEventStart, 
      "unloadEventEnd":pt.unloadEventEnd, "unloadEventTime":pt.unloadEventEnd - pt.unloadEventStart, "appCacheTime":pt.domainLookupStart - pt.fetchStart, "redirectTime":pt.redirectEnd - pt.redirectStart}
    }
    bootstrap["cache"]["appCache"] = bootstrap["timing"]["appCache"] === 0 && window.applicationCache && window.applicationCache.status !== window.applicationCache.UNCACHED;
    bootstrap["cache"]["gvps"] = $A.$clientService$.$gvpsFromStorage$;
    var frameworkRequests = {"requestBootstrapJs":"bootstrap.js", "requestInlineJs":"inline.js", "requestAppCss":"app.css", "requestAppCoreJs":"appcore.js", "requestAppJs":"app.js", "requestAuraJs":"/aura_"};
    if(p.getEntries && (!bootstrap["allRequests"] || !bootstrap["allRequests"].length)) {
      bootstrap["allRequests"] = [];
      $A["util"].forEach(p.getEntries(), function(resource) {
        if(resource.responseEnd < bootstrap["bootstrapEPT"]) {
          var summaryRequest = this.$summarizeResourcePerfInfo$(resource);
          bootstrap["allRequests"].push(summaryRequest);
          for(var i in frameworkRequests) {
            if(resource.name.indexOf(frameworkRequests[i]) !== -1) {
              summaryRequest.name = frameworkRequests[i];
              bootstrap[i] = summaryRequest;
              continue
            }
          }
        }
      }, this)
    }
  }
  return bootstrap
};
goog.$exportProperty$(Aura.$Services$.$MetricsService$.prototype, "getBootstrapMetrics", Aura.$Services$.$MetricsService$.prototype.$getBootstrapMetrics$);
Aura.$ExportsModule$ = {"dispatchGlobalEvent":function(eventName, eventParams) {
  $A.$clientService$.$setCurrentAccess$($A.$getRoot$());
  try {
    $A.$eventService$.$newEvent$(eventName).$setParams$(eventParams).$fire$()
  }finally {
    $A.$clientService$.$releaseCurrentAccess$()
  }
}, "labels":function(obj) {
  return Object.keys(obj).reduce(function(r, cmpKey) {
    var key = obj[cmpKey];
    r[cmpKey] = $A.get("$Label." + key);
    return r
  }, {})
}, "executeGlobalController":function(endpoint, params) {
  var controllerName = "c.aura://" + endpoint;
  var action = $A.get(controllerName);
  if(!action) {
    return Promise.$reject$(new Error("Controller for endpoint " + endpoint + " is not registered"))
  }
  action.$setParams$(params);
  return new Promise(function(resolve, reject) {
    action.$setBackground$();
    action.$setCallback$(null, function(response) {
      if(response.$getState$() !== "SUCCESS") {
        var actionErrors = response.getError();
        if(actionErrors.length > 0) {
          reject(actionErrors[0])
        }else {
          reject(new Error("Error fetching component"))
        }
        return
      }
      resolve(response.$getReturnValue$())
    });
    $A.$run$(function() {
      $A.$enqueueAction$(action)
    })
  })
}, "registerModule":function(module) {
  $A.$componentService$.$initModuleDefs$([module]);
  return module["descriptor"]
}, "hasModule":function(moduleName) {
  return $A.$componentService$.$hasModuleDefinition$(moduleName)
}, "getModule":function(moduleName) {
  return $A.$componentService$.$evaluateModuleDef$(moduleName)
}, "sanitizeDOM":function(dirty, config) {
  return $A["util"].$sanitizeDOM$(dirty, config)
}, "createComponent":function(componentName, attributes, callback) {
  $A.$clientService$.$setCurrentAccess$($A.$getRoot$());
  try {
    $A.$run$(function() {
      $A.$createComponent$(componentName, attributes, $A.$getCallback$(callback))
    })
  }finally {
    $A.$clientService$.$releaseCurrentAccess$()
  }
}, "logInteraction":function(target, scope, context, eventSource) {
  $A.$metricsService$.transaction("ltng", "interaction", {"context":{"eventSource":eventSource || "click", "eventType":"user", "locator":{"target":target, "scope":scope, "context":context}}})
}};
Aura.$ServiceApi$ = {"replaceModule":function(targetCtor, replacementCtor) {
  var targetDef;
  var replacementDef;
  Object.keys($A.$componentService$.$moduleDefRegistry$).some(function(key) {
    var def = $A.$componentService$.$moduleDefRegistry$[key];
    if(def.$ns$ === targetCtor) {
      targetDef = def
    }else {
      if(def.$ns$ === replacementCtor) {
        replacementDef = def
      }
    }
    return targetDef && replacementDef
  });
  $A.assert(targetDef && replacementDef, "Definitions could not be found");
  $A.assert(targetDef.$access$ === replacementDef.$access$, "Access checks do not match");
  $A.$componentService$.$moduleDefRegistry$[targetDef.$moduleName$] = replacementDef
}, "registerSchema":function(schema, resolver) {
  $A.$clientService$.$addModuleSchemaResolver$(schema, resolver)
}};
Aura.$ExportsStorage$ = {"getStorage":function(name) {
  return $A.$storageService$.$getStorage$(name)
}, "getStorages":function() {
  return $A.$storageService$.$getStorages$()
}, "initStorage":function(config) {
  return $A.$storageService$.$initStorage$(config)
}, "deleteStorage":function(name) {
  return $A.$storageService$.$deleteStorage$(name)
}};
Logger = {"log":noop, "logError":function(message) {
  var isStringMessage = typeof message === "string";
  $A.$clientService$.$setCurrentAccess$($A.$getRoot$());
  $A.$logger$.$reportError$(isStringMessage ? new $A.$auraError$(message) : message);
  $A.$clientService$.$releaseCurrentAccess$();
  console.error(message)
}};
Logger.log = function log() {
  window.console.log.apply(window.console, arguments)
};
Aura.$ExportsLogger$ = Logger;
var assert = noop;
assert = function(condition, message) {
  $A.assert(condition, message)
};
Aura.$ExportsAssert$ = assert;
var LTNG = "ltng";
var PERF = "performance";
var INTERACTION = "interaction";
var USER = "user";
var CLICK = "click";
Aura.$ExportsMetricsService$ = {"perfStart":function(name, attributes) {
  return $A.$metricsService$.$transactionStart$(LTNG, PERF, {"context":{"eventSource":name, "attributes":attributes}})
}, "perfEnd":function(name, attributes) {
  return $A.$metricsService$.$transactionEnd$(LTNG, PERF, {"context":{"eventSource":name, "attributes":attributes}})
}, "mark":function(ns, name, ctx) {
  return $A.$metricsService$["mark"](ns, name, ctx)
}, "markStart":function(ns, name, ctx) {
  return $A.$metricsService$.$markStart$(ns, name, ctx)
}, "markEnd":function(ns, name, ctx) {
  return $A.$metricsService$.$markEnd$(ns, name, ctx)
}, "time":function() {
  return $A.$metricsService$.time()
}, "interaction":function(target, scope, context, eventSource) {
  return $A.$metricsService$.transaction(LTNG, INTERACTION, {"context":{"eventSource":eventSource || CLICK, "eventType":USER, "locator":{"target":target, "scope":scope, "context":context}}})
}};
var AuraDevToolService = function() {
  function flattenRegistry(reg) {
    var ret = [];
    for(var k in reg) {
      ret.push(reg[k])
    }
    return ret
  }
  function Statement() {
    this.$criteria$ = {}
  }
  function ResultSet(config, privConfig) {
    var priv = {};
    for(var k in config) {
      this[k] = config[k]
    }
    for(var j in privConfig) {
      priv[j] = privConfig[j]
    }
    this.$_priv$ = priv
  }
  var s = {"views":{"component":function() {
    return flattenRegistry($A.$services$.$component$.$indexes$.$globalId$)
  }, "componentDef":function() {
    return flattenRegistry($A.$services$.$component$.$componentDefRegistry$)
  }, "controllerDef":function() {
    return flattenRegistry($A.$services$.$component$.$controllerDefRegistry$)
  }, "modelDef":function() {
    return flattenRegistry($A.$services$.$component$.$modelDefRegistry$)
  }}, "filters":{"noop":function() {
    return true
  }}, select:function(config) {
    config = config || {};
    var view;
    var from = config["from"];
    if(from) {
      view = this["views"][from];
      $A.assert(view, "Invalid view : " + from)
    }else {
      view = this.defaultView
    }
    var fields = config["fields"] || this.$defaultFields$;
    var derivedFields = config["derivedFields"] || this.$defaultDerivedFields$;
    var filter = config["where"] || this.$defaultFilter$;
    if($A["util"].$isString$(filter)) {
      filter = new Function("row", "with(row){return " + filter + ";}")
    }
    for(var der in derivedFields) {
      var derField = derivedFields[der];
      if($A["util"].$isString$(derField)) {
        derivedFields[der] = new Function("row", "with(row){return " + derField + ";}")
      }
    }
    var groupBy = config["groupBy"] || this.$defaultGroupBy$;
    var rawRows = view();
    var rows = this.$filterFields$(fields, derivedFields, rawRows);
    rows = this.$applyFilter$(filter, rows, rawRows);
    var ret = this.$applyGroupBy$(groupBy, rows.rows, rows.$rawRows$);
    return ret
  }, $applyGroupBy$:function(groupBy, rows, rawRows) {
    if(groupBy === undefined || groupBy === null) {
      return new ResultSet({"rows":rows, "rowCount":rows.length}, {"rawRows":rawRows})
    }
    var ret = {};
    var groupCount = 0;
    for(var i = 0;i < rows.length;i++) {
      var row = rows[i];
      var key = row[groupBy];
      var group = ret[key];
      if(group === undefined) {
        group = [];
        ret[key] = group;
        groupCount++
      }
      group.push(row)
    }
    return new ResultSet({"rowCount":rows.length, "groupCount":groupCount, "groups":ret}, {"rawRows":rawRows, "rows":rows})
  }, $filterFields$:function(fields, derivedFields, rows) {
    fields = $A["util"].trim(fields);
    if(fields === this.$defaultFields$ && derivedFields === this.$defaultDerivedFields$) {
      return rows
    }
    if(fields === this.$defaultFields$) {
      fields = []
    }
    if(!$A["util"].isArray(fields)) {
      var fieldSplit = fields.split(",");
      fields = [];
      for(var k = 0;k < fieldSplit.length;k++) {
        var field = $A["util"].trim(fieldSplit[k]);
        var fieldConfig = {};
        fields[k] = fieldConfig;
        var splitField = field.match(/^(\S+)(?: as (\w+))?$/i);
        fieldConfig.$alias$ = splitField[2] || field;
        fieldConfig.name = splitField[1].split(".")
      }
    }
    var ret = [];
    for(var j = 0;j < rows.length;j++) {
      var row = rows[j];
      if(row) {
        var newRow = {};
        for(var i = 0;i < fields.length;i++) {
          newRow[fields[i].$alias$] = this.$processField$(row, fields[i].name, 0)
        }
        var uberRow = {};
        $A["util"].apply(uberRow, row, true);
        $A["util"].apply(uberRow, newRow, true);
        for(var key in derivedFields) {
          var derivedField = derivedFields[key];
          var val = derivedField(uberRow);
          newRow[key] = val
        }
        ret.push(newRow)
      }
    }
    return ret
  }, $processField$:function(root, fields, place) {
    var field = fields[place];
    var val;
    val = root[field];
    if(val === undefined) {
      var func = root["get" + this.$initCap$(field)];
      if(func === undefined) {
        func = root["is" + this.$initCap$(field)]
      }
      if(func !== undefined) {
        val = func.call(root)
      }else {
        if(root.$getValue$) {
          var f = "";
          for(var i = place;i < fields.length;i++) {
            if(i !== place) {
              f += "."
            }
            f += fields[i]
          }
          place = i;
          val = root.$getValue$(f)
        }
      }
    }else {
      if($A["util"].$isFunction$(val)) {
        val = val.call(root)
      }
    }
    place++;
    if(val !== undefined && fields.length > place) {
      val = this.$processField$(val, fields, place)
    }
    return val
  }, $initCap$:function(str) {
    return str.substring(0, 1).toUpperCase() + str.substring(1, str.length)
  }, $applyFilter$:function(filter, rows, rawRows) {
    var ret = [];
    var rawRet = [];
    for(var i = 0;i < rows.length;i++) {
      var row = rows[i];
      var rawRow = rawRows[i];
      if(filter(row, rawRow)) {
        ret.push(row);
        rawRet.push(rawRow)
      }
    }
    return{rows:ret, $rawRows$:rawRet}
  }, $newStatement$:function() {
    return new Statement
  }, $output$:function(cmp) {
    return cmp.toJSON()
  }, $accessbilityAide$:{$nodeListToObjectArray$:function(array, nodeList, activeClass) {
    var node;
    for(var i = 0;i < nodeList.length;i++) {
      node = nodeList[i];
      if($A["util"].$isUndefinedOrNull$(activeClass)) {
        array.push({"activeElm":node})
      }else {
        array.push({"activeElm":node, "ariaHidden":node.querySelectorAll(activeClass)[0]})
      }
    }
  }, $findTopLevelErrors$:function(panels, topPanelsCount, elementsCovered) {
    var errorArray = [];
    var activePanel = null;
    var panelObj = null;
    var hiddenValue = "";
    for(var i = 0;i < panels.length;i++) {
      panelObj = panels[i];
      activePanel = panelObj["activeElm"];
      var panelWithAriaHidden;
      if(panelObj.hasOwnProperty("ariaHidden")) {
        panelWithAriaHidden = panelObj["ariaHidden"]
      }else {
        panelWithAriaHidden = panelObj["activeElm"]
      }
      hiddenValue = $A["util"].$getElementAttributeValue$(panelWithAriaHidden, "aria-hidden");
      if($A["util"].$hasClass$(activePanel, "panelSlide")) {
        if(topPanelsCount > 0) {
          if($A["util"].$isEmpty$(hiddenValue) || hiddenValue.toLowerCase().indexOf("false") > -1) {
            errorArray.push(activePanel)
          }
        }else {
          if(!$A["util"].$isUndefinedOrNull$(hiddenValue) && hiddenValue.toLowerCase().indexOf("true") > -1) {
            errorArray.push(activePanel)
          }
        }
      }else {
        if($A["util"].$hasClass$(activePanel, "active") || $A["util"].$hasClass$(activePanel, "slideIn")) {
          if(!$A["util"].$isUndefinedOrNull$(hiddenValue) && hiddenValue.toLowerCase().indexOf("true") > -1) {
            errorArray.push(activePanel)
          }
        }else {
          var hiddenValueParent = $A["util"].$getElementAttributeValue$(activePanel, "aria-hidden");
          if(elementsCovered && ($A["util"].$isEmpty$(hiddenValueParent) || hiddenValueParent.toLowerCase().indexOf("false") > -1)) {
            errorArray.push(activePanel)
          }else {
            if(!elementsCovered && ($A["util"].$isEmpty$(hiddenValue) || hiddenValue.toLowerCase().indexOf("false") > -1)) {
              errorArray.push(activePanel)
            }
          }
        }
      }
    }
    return errorArray
  }, $inputDefaultErrorAide$:function(uls, inputTags, selectTags, textAreaTags) {
    var ul = null;
    var elmntAtrib = "";
    var errorArray = [];
    var accessAideFuncs = aura.$devToolService$.$accessbilityAide$;
    for(var i = 0;i < uls.length;i++) {
      ul = uls[i];
      elmntAtrib = $A["util"].$getElementAttributeValue$(ul, "class");
      if(!$A["util"].$isUndefinedOrNull$(elmntAtrib) && elmntAtrib.indexOf("uiInputDefaultError") > -1) {
        elmntAtrib = $A["util"].$getElementAttributeValue$(ul, "id");
        if(!(accessAideFuncs.$findMatchingId$(elmntAtrib, inputTags, "aria-describedby") || accessAideFuncs.$findMatchingId$(elmntAtrib, selectTags, "aria-describedby") || accessAideFuncs.$findMatchingId$(elmntAtrib, textAreaTags, "aria-describedby"))) {
          errorArray.push(ul)
        }
      }
    }
    return errorArray
  }, $findMatchingId$:function(id, tags, attribute2find) {
    var tagIds = null;
    for(var i = 0;i < tags.length;i++) {
      tagIds = $A["util"].$getElementAttributeValue$(tags[i], attribute2find);
      if(!$A["util"].$isUndefinedOrNull$(tagIds)) {
        tagIds = tagIds.trim().split(/\s+/);
        for(var j = 0;j < tagIds.length;j++) {
          if(tagIds[j].indexOf(id) === 0) {
            return true
          }
        }
      }
    }
    return false
  }, $doesContain$:function(attribute, val) {
    return attribute === val
  }, $doesNotContain$:function(attribute, dict) {
    return!(attribute in dict)
  }, $checkParentMatchesTag$:function(tag, parentTag) {
    for(;tag.tagName !== null && tag.tagName !== "BODY";) {
      if(tag.tagName.toUpperCase() === parentTag) {
        return true
      }
      tag = tag.parentNode
    }
    return false
  }, $getDictFromTags$:function(labels, attribute) {
    var atrib = null;
    var dict = {};
    if($A["util"].$isUndefinedOrNull$(labels)) {
      return dict
    }
    for(var j = 0;j < labels.length;j++) {
      atrib = $A["util"].$getElementAttributeValue$(labels[j], attribute);
      if(!$A["util"].$isEmpty$(atrib)) {
        dict[atrib] = true
      }
    }
    return dict
  }, $findAllImgTags$:function(allImgTags, imgErrorMsg) {
    var accessAideFuncs = aura.$devToolService$.$accessbilityAide$;
    var data_aura_rendered_by = "";
    var errorArray = [];
    var imgType = "";
    var alt = "";
    for(var index = 0;index < allImgTags.length;index++) {
      data_aura_rendered_by = $A["util"].$getElementAttributeValue$(allImgTags[index], "data-aura-rendered-by");
      imgType = null;
      alt = null;
      if(!$A["util"].$isEmpty$(data_aura_rendered_by)) {
        var component = $A.$getCmp$(data_aura_rendered_by);
        if(!$A["util"].$isUndefinedOrNull$(component) && !$A["util"].$isComponent$(component)) {
          if(!component.$isInstanceOf$("ui:image")) {
            component = component.$getAttributeValueProvider$()
          }
          if(!component.$isInstanceOf$("ui:image")) {
            continue
          }
          imgType = component.get("v.imageType");
          alt = component.get("v.alt")
        }
      }
      if($A["util"].$isUndefinedOrNull$(imgType)) {
        var htmlAlt = allImgTags[index].getAttribute("alt");
        if(!$A["util"].$isUndefinedOrNull$(htmlAlt)) {
          htmlAlt = htmlAlt.toLowerCase().replace(/[\s\t\r\n]/g, "");
          if(htmlAlt !== "undefined" && htmlAlt !== "null" && htmlAlt !== "empty") {
            continue
          }
        }
        errorArray.push(allImgTags[index])
      }else {
        if($A["util"].$isUndefinedOrNull$(alt)) {
          alt = ""
        }
        alt = alt.toLowerCase().replace(/[\s\t\r\n]/g, "");
        if(alt === "undefined" || alt === "null" || alt === "empty") {
          errorArray.push(allImgTags[index])
        }else {
          if(imgType === "informational" && alt === "") {
            errorArray.push(allImgTags[index])
          }else {
            if(imgType === "decorative" && alt !== "") {
              errorArray.push(allImgTags[index])
            }
          }
        }
      }
    }
    return accessAideFuncs.$formatOutput$(imgErrorMsg, errorArray)
  }, $getPropertyFromDescendantTag$:function(element, property, childTag) {
    if(!$A["util"].$isUndefinedOrNull$(element)) {
      var matchingChildren = element.getElementsByTagName(childTag);
      if(matchingChildren.length > 0) {
        return $A["util"].$getElementAttributeValue$(matchingChildren[0], property) || $A["util"].$getElementAttributeValue$(matchingChildren[0], "data-aura-rendered-by")
      }
    }
    return null
  }, $matchLabelToInput$:function(lbls) {
    var errorArray = [];
    var atrib = null;
    var isParent = false;
    var dict = {};
    var inputID = null;
    var label = null;
    var accessAideFuncs = aura.$devToolService$.$accessbilityAide$;
    for(var i = 0;i < lbls.length;i++) {
      label = lbls[i];
      atrib = $A["util"].$getElementAttributeValue$(label, "for");
      isParent = accessAideFuncs.$getPropertyFromDescendantTag$(label, "id", "INPUT") || accessAideFuncs.$getPropertyFromDescendantTag$(label, "id", "TEXTAREA") || accessAideFuncs.$getPropertyFromDescendantTag$(label, "id", "SELECT");
      if($A["util"].$isEmpty$(atrib) && !isParent) {
        errorArray.push(label)
      }else {
        inputID = atrib || isParent;
        if($A["util"].$isUndefinedOrNull$(dict[inputID])) {
          dict[inputID] = label
        }else {
          if($A["util"].$getElementAttributeValue$(dict[inputID], "data-aura-rendered-by") !== $A["util"].$getElementAttributeValue$(label, "data-aura-rendered-by")) {
            errorArray.push(dict[inputID]);
            errorArray.push(label)
          }
        }
      }
      if(!$A["util"].$isEmpty$(atrib)) {
        var inputElem = document.getElementById(atrib);
        if($A["util"].$isUndefinedOrNull$(inputElem) || inputElem.tagName !== "INPUT" && inputElem.tagName !== "TEXTAREA" && inputElem.tagName !== "SELECT") {
          errorArray.push(label)
        }
      }
    }
    return errorArray
  }, $inputLabelAide$:function(lbls, inputTags) {
    var errorArray = [];
    var lblIsPres = true;
    var inputTag = null;
    var type = null;
    var inputTypes = "hidden button submit reset";
    var accessAideFuncs = aura.$devToolService$.$accessbilityAide$;
    var lblDict = accessAideFuncs.$getDictFromTags$(lbls, "for");
    for(var index = 0;index < inputTags.length;index++) {
      inputTag = inputTags[index];
      type = $A["util"].$getElementAttributeValue$(inputTag, "type");
      if(!$A["util"].$isEmpty$(type) && inputTypes.indexOf(type) > -1) {
        continue
      }else {
        if(type === "image") {
          var alt = $A["util"].$getElementAttributeValue$(inputTag, "alt");
          if($A["util"].$isEmpty$(alt) || alt.replace(/[\s\t\r\n]/g, "") === "") {
            errorArray.push(inputTag)
          }
        }else {
          lblIsPres = inputTag.id in lblDict || accessAideFuncs.$checkParentMatchesTag$(inputTag, "LABEL");
          if(!lblIsPres) {
            if(inputTag.tagName === "INPUT" && type === "range") {
              var ariaLbl = $A["util"].$getElementAttributeValue$(inputTag, "aria-label");
              var parent = accessAideFuncs.$checkParentMatchesTag$(inputTag, "TH");
              if($A["util"].$isEmpty$(ariaLbl) || parent === false) {
                errorArray.push(inputTag)
              }
            }else {
              errorArray.push(inputTag)
            }
          }
        }
      }
    }
    return errorArray
  }, $checkForAttrib$:function(tags, attribute, errorVal, evalFunc) {
    var errorArray = [];
    var atrib = "";
    for(var i = 0;i < tags.length;i++) {
      atrib = $A["util"].$getElementAttributeValue$(tags[i], attribute);
      if($A["util"].$isEmpty$(atrib) || evalFunc(atrib.toLowerCase(), errorVal)) {
        errorArray.push(tags[i])
      }
    }
    return errorArray
  }, $attribStringVal$:function(attribs) {
    if($A["util"].$isUndefinedOrNull$(attribs)) {
      return"No data found"
    }
    var strAttrib = "";
    var attrib = null;
    for(var i = 0;i < attribs.length;i++) {
      attrib = attribs.item(i);
      strAttrib = strAttrib + " " + attrib.nodeName + '\x3d"' + attrib.value + '"'
    }
    return strAttrib
  }, $getStackTrace$:function(tag) {
    var cmp = null;
    var cmpInfo = {};
    var cmpNameList = "";
    for(var cmpName = "";!$A["util"].$isUndefinedOrNull$(tag) && tag.tagName.toLowerCase() !== "body" && tag.tagName.toLowerCase() !== "html";) {
      var data_aura_rendered_by = $A["util"].$getElementAttributeValue$(tag, "data-aura-rendered-by");
      if(!$A["util"].$isEmpty$(data_aura_rendered_by)) {
        cmp = $A.$getCmp$(data_aura_rendered_by);
        if(!$A["util"].$isUndefinedOrNull$(cmp)) {
          cmp = cmp.$getAttributeValueProvider$();
          if(typeof cmp.getName !== "function") {
            cmp = cmp.$getDef$().$getDescriptor$().$getFullName$()
          }else {
            cmpName = cmp.$getType$()
          }
          if(!(cmpName in cmpInfo)) {
            cmpInfo[cmpName] = "";
            cmpNameList = cmpNameList + "    by " + cmpName + "\n"
          }
        }
      }
      tag = tag.parentNode
    }
    return cmpNameList
  }, $formatOutput$:function(tagError, errArray) {
    if(errArray.length === 0) {
      return""
    }
    var len = errArray.length;
    var nodeName = "";
    var elm = null;
    var errStr = tagError + "\n";
    var accessAideFuncs = aura.$devToolService$.$accessbilityAide$;
    for(var i = 0;i < len;i++) {
      elm = errArray[i];
      nodeName = elm.nodeName.toLowerCase();
      errStr = errStr + "  Error Tag: \x3c" + nodeName + "" + accessAideFuncs.$attribStringVal$(elm.attributes) + "\x3e...\x3c/" + nodeName + "\x3e\n";
      errStr = errStr + "  Stack Trace: error tag is rendered\n" + accessAideFuncs.$getStackTrace$(elm) + "\n"
    }
    return errStr
  }, $checkHeadHasCorrectTitle$:function(hdErrMsg, hd) {
    var title = hd.getElementsByTagName("title")[0];
    var errArray = [];
    if($A["util"].$isUndefinedOrNull$(title) || $A["util"].$getText$(title) === "") {
      errArray.push(hd)
    }
    return errArray
  }, $anchrDoesNotHaveImgWithAlt$:function(anchor) {
    var imgs = anchor.getElementsByTagName("img");
    var alt = "";
    for(var i = 0;i < imgs.length;i++) {
      alt = $A["util"].$getElementAttributeValue$(imgs[i], "alt");
      if(!$A["util"].$isEmpty$(alt) && alt.replace(/[\s\t\r\n]/g, "") !== "") {
        return false
      }
    }
    return true
  }, $checkAnchorHasInnerText$:function(anchors) {
    var errArray = [];
    var anchor = null;
    var text = "";
    var accessAideFuncs = $A.$devToolService$.$accessbilityAide$;
    for(var index = 0;index < anchors.length;index++) {
      anchor = anchors[index];
      text = $A["util"].$getText$(anchor).replace(/[\s\t\r\n]/g, "");
      if(text === "" && accessAideFuncs.$anchrDoesNotHaveImgWithAlt$(anchor)) {
        errArray.push(anchor)
      }
    }
    return errArray
  }, $radioButtonAide$:function(inputTags) {
    var errorArray = [];
    var inputTag = null;
    var inputType = "";
    var rcName = "";
    var dict = {};
    var tmpArray = [];
    var accessAideFuncs = aura.$devToolService$.$accessbilityAide$;
    for(var i = 0;i < inputTags.length;i++) {
      inputTag = inputTags[i];
      inputType = $A["util"].$getElementAttributeValue$(inputTag, "type").toLowerCase();
      if(inputType === "radio" || inputType === "checkbox") {
        rcName = $A["util"].$getElementAttributeValue$(inputTag, "name");
        if($A["util"].$isEmpty$(rcName)) {
          continue
        }
        if(!(rcName in dict)) {
          dict["" + rcName] = []
        }
        dict[rcName].push(inputTag)
      }
    }
    for(rcName in dict) {
      tmpArray = dict[rcName];
      if(tmpArray.length >= 2) {
        for(var index = 0;index < tmpArray.length;index++) {
          if(!accessAideFuncs.$checkParentMatchesTag$(tmpArray[index], "FIELDSET")) {
            errorArray.push(tmpArray[index])
          }
        }
      }
    }
    return errorArray
  }, $buttonLabelAide$:function(buttons) {
    var errorArray = [];
    var button = null;
    var buttonImage = null;
    var testText = null;
    for(var i = 0;i < buttons.length;i++) {
      button = buttons[i];
      if(!$A["util"].$isUndefinedOrNull$(button)) {
        buttonImage = button.getElementsByTagName("img");
        if(buttonImage.length === 0) {
          testText = $A["util"].$getText$(button).replace(/[\s\t\r\n]/g, "");
          if(testText === "") {
            errorArray.push(button)
          }
        }
      }
    }
    return errorArray
  }, $buttonDuplicateTextAide$:function(buttons) {
    var errorArray = [];
    var button = null;
    var text = null;
    var dict = {};
    var descendants = null;
    var descendant = null;
    for(var i = 0;i < buttons.length;i++) {
      dict = [];
      button = buttons[i];
      descendants = button.childNodes;
      for(var j = 0;j < descendants.length;j++) {
        text = null;
        descendant = descendants[j];
        text = $A["util"].$getText$(descendant);
        if(descendant.tagName === "IMG") {
          text = descendant.getAttribute("alt")
        }
        text = text.toLowerCase().trim();
        if(text !== "") {
          if(dict.indexOf(text) >= 0) {
            errorArray.push(button)
          }else {
            dict.push(text)
          }
        }
      }
    }
    return errorArray
  }, $checkTables$:function(tables) {
    var headerDict = {};
    var ths = [];
    var scopeVal = "";
    var idVals = "";
    var errorArray = [];
    var i = 0;
    var j = 0;
    var skipTDCheck = false;
    var validScopes = {"row":false, "col":false, "rowgroup":false, "colgroup":false};
    for(var index = 0;index < tables.length;index++) {
      ths = tables[index].getElementsByTagName("th");
      headerDict = {};
      skipTDCheck = false;
      if(ths.length === 0) {
        continue
      }
      for(i = 0;i < ths.length;i++) {
        scopeVal = $A["util"].$getElementAttributeValue$(ths[i], "scope");
        idVals = $A["util"].$getElementAttributeValue$(ths[i], "id");
        if(!$A["util"].$isEmpty$(scopeVal)) {
          if(!(scopeVal in validScopes) || $A["util"].trim(scopeVal) === "") {
            errorArray.push(ths[i])
          }
          skipTDCheck = true
        }else {
          if(!$A["util"].$isEmpty$(idVals)) {
            headerDict[idVals] = true
          }else {
            errorArray.push(ths[i])
          }
        }
      }
      if(!$A["util"].$isEmpty$(errorArray) || skipTDCheck) {
        continue
      }
      var tds = tables[index].getElementsByTagName("td");
      if(tds.length === 0) {
        continue
      }
      for(i = 0;i < tds.length;i++) {
        idVals = $A["util"].$getElementAttributeValue$(tds[i], "headers");
        if($A["util"].$isEmpty$(idVals)) {
          errorArray.push(tds[i]);
          continue
        }
        idVals = $A["util"].trim(idVals).split(/\s+/);
        for(j = 0;j < idVals.length;j++) {
          if(!(idVals[j] in headerDict)) {
            errorArray.push(tds[i]);
            break
          }
        }
      }
    }
    return errorArray
  }, $findNextHeader$:function(tags, nextTag, allHdrs) {
    var errorArray = [];
    var children = [];
    var child = null;
    var currTag;
    var startLooking = false;
    for(var index = 0;index < tags.length;index++) {
      children = tags[index].parentNode.children;
      currTag = "";
      startLooking = false;
      if($A["util"].$isUndefinedOrNull$(children)) {
        continue
      }
      for(var childIndex = 0;childIndex < children.length;childIndex++) {
        child = children[childIndex];
        if(tags[index] === child) {
          startLooking = true
        }
        if(startLooking) {
          currTag = child.tagName.toLowerCase();
          if(currTag in allHdrs) {
            if(currTag !== nextTag) {
              errorArray.push(child)
            }
            break
          }
        }
      }
    }
    return errorArray
  }}, $verifyAccessibility$:{$checkImagesHaveAlts$:{"tag":"A11Y_DOM_01", "func":function(domElem) {
    var imgError = "[A11Y_DOM_01] All image tags require the presence of the alt attribute.\n  More info http://sfdc.co/a11y_dom_01";
    var allImgTags = domElem.getElementsByTagName("img");
    return aura.$devToolService$.$accessbilityAide$.$findAllImgTags$(allImgTags, imgError)
  }}, $checkInputsHaveLabel$:{"tag":"A11Y_DOM_02", "func":function(domElem) {
    var inputLabelMsg = "[A11Y_DOM_02] An input was found without an associated label. All inputs must be identified by a label.\n  More info http://sfdc.co/a11y_dom_02";
    var accessAideFuncs = aura.$devToolService$.$accessbilityAide$;
    var inputTextTags = domElem.getElementsByTagName("input");
    var textAreaTags = domElem.getElementsByTagName("textarea");
    var selectTags = domElem.getElementsByTagName("select");
    var lbls = domElem.getElementsByTagName("LABEL");
    var errorArray = [];
    errorArray = errorArray.concat(accessAideFuncs.$inputLabelAide$(lbls, inputTextTags));
    errorArray = errorArray.concat(accessAideFuncs.$inputLabelAide$(lbls, textAreaTags));
    errorArray = errorArray.concat(accessAideFuncs.$inputLabelAide$(lbls, selectTags));
    return accessAideFuncs.$formatOutput$(inputLabelMsg, errorArray)
  }}, $checkButtonHaveLabel$:{"tag":"A11Y_DOM_03", "func":function(domElem) {
    var buttonLabelErrorMsg = "[A11Y_DOM_03] Buttons must have non-empty text labels.\n  More info http://sfdc.co/a11y_dom_03";
    var errorArray = [];
    var accessAideFuncs = aura.$devToolService$.$accessbilityAide$;
    var buttonTags = domElem.getElementsByTagName("button");
    errorArray = errorArray.concat(accessAideFuncs.$buttonLabelAide$(buttonTags));
    return accessAideFuncs.$formatOutput$(buttonLabelErrorMsg, errorArray)
  }}, $checkAnchorHasText$:{"tag":"A11Y_DOM_04", "func":function(domElem) {
    var anchorErrMsg = "[A11Y_DOM_04] Links must have non-empty text content.\n  More info http://sfdc.co/a11y_dom_04";
    var accessAideFuncs = $A.$devToolService$.$accessbilityAide$;
    var anchors = domElem.getElementsByTagName("a");
    return accessAideFuncs.$formatOutput$(anchorErrMsg, accessAideFuncs.$checkAnchorHasInnerText$(anchors))
  }}, $checkIframeHasTitle$:{"tag":"A11Y_DOM_06", "func":function(domElem) {
    var iFrameTitleMsg = "[A11Y_DOM_06] Each frame and iframe element must have a non-empty title attribute.\n  More info http://sfdc.co/a11y_dom_06";
    var accessAideFuncs = aura.$devToolService$.$accessbilityAide$;
    var iframes = domElem.getElementsByTagName("iframe");
    var id = null;
    var src = null;
    var frame = null;
    var iframeArray = [];
    for(var i = 0;i < iframes.length;i++) {
      frame = iframes[i];
      id = $A["util"].$getElementAttributeValue$(frame, "id");
      src = $A["util"].$getElementAttributeValue$(frame, "src");
      if(!$A["util"].$isUndefinedOrNull$(src) && src.indexOf("/apex/") !== -1 || !$A["util"].$isUndefinedOrNull$(id) && id.toLowerCase().indexOf("vfframeid") !== -1) {
        continue
      }
      iframeArray.push(frame)
    }
    return accessAideFuncs.$formatOutput$(iFrameTitleMsg, accessAideFuncs.$checkForAttrib$(iframeArray, "title", "", accessAideFuncs.$doesContain$))
  }}, $checkCorrectHeaderOrder$:{"tag":"A11Y_DOM_07", "func":function(domElem) {
    var hdErrMsg = "[A11Y_DOM_07] The head section must have a non-empty title element.\n  More info http://sfdc.co/a11y_dom_07";
    var accessAideFuncs = $A.$devToolService$.$accessbilityAide$;
    var hd = domElem.getElementsByTagName("head")[0];
    if($A["util"].$isEmpty$(hd)) {
      return""
    }
    return accessAideFuncs.$formatOutput$(hdErrMsg, accessAideFuncs.$checkHeadHasCorrectTitle$(hdErrMsg, hd))
  }}, $checkTableCellsHaveScope$:{"tag":"A11Y_DOM_08", "func":function(domElem) {
    var tableErrorMsg = "[A11Y_DOM_08] Data table cells must be associated with data table headers.\n  More info http://sfdc.co/a11y_dom_08";
    var accessAideFuncs = aura.$devToolService$.$accessbilityAide$;
    var tables = domElem.getElementsByTagName("table");
    return accessAideFuncs.$formatOutput$(tableErrorMsg, accessAideFuncs.$checkTables$(tables, tableErrorMsg))
  }}, $checkFieldsetsAreCorrect$:{"tag":"A11Y_DOM_09", "func":function(domElem) {
    var fieldsetLegnedMsg = "[A11Y_DOM_09] Fieldset must have a legend element.\n  More info http://sfdc.co/a11y_dom_09";
    var accessAideFuncs = aura.$devToolService$.$accessbilityAide$;
    var fieldSets = domElem.getElementsByTagName("fieldset");
    var legends = "";
    var errorArray = [];
    var fieldSetSytle = "";
    for(var i = 0;i < fieldSets.length;i++) {
      legends = fieldSets[i].getElementsByTagName("legend");
      fieldSetSytle = fieldSets[i].style.display;
      if(!$A["util"].$isUndefinedOrNull$(fieldSetSytle) && fieldSetSytle === "none") {
        continue
      }
      if(legends.length === 0) {
        errorArray.push(fieldSets[i])
      }
    }
    return accessAideFuncs.$formatOutput$(fieldsetLegnedMsg, errorArray)
  }}, $checkRadioGrouping$:{"tag":"A11Y_DOM_10", "func":function(domElem) {
    var radioButtonFieldSetMsg = "[A11Y_DOM_10] Headings should be properly nested.\n  More info http://sfdc.co/a11y_dom_10";
    var accessAideFuncs = aura.$devToolService$.$accessbilityAide$;
    var inputTags = domElem.getElementsByTagName("input");
    return accessAideFuncs.$formatOutput$(radioButtonFieldSetMsg, accessAideFuncs.$radioButtonAide$(inputTags))
  }}, $checkNestedHeader$:{"tag":"A11Y_DOM_11", "func":function(domElem) {
    var headerErrMsg = "[A11Y_DOM_11] Headings should be properly nested.\n  More info http://sfdc.co/a11y_dom_11";
    var errArray = [];
    var accessAideFuncs = $A.$devToolService$.$accessbilityAide$;
    var hdrs1 = domElem.getElementsByTagName("h1");
    var hdrs2 = domElem.getElementsByTagName("h2");
    var hdrs3 = domElem.getElementsByTagName("h3");
    var hdrs4 = domElem.getElementsByTagName("h4");
    var hdrs5 = domElem.getElementsByTagName("h5");
    errArray = errArray.concat(accessAideFuncs.$findNextHeader$(hdrs1, "h2", {"h2":"", "h3":"", "h4":"", "h5":"", "h6":""}));
    errArray = errArray.concat(accessAideFuncs.$findNextHeader$(hdrs2, "h3", {"h3":"", "h4":"", "h5":"", "h6":""}));
    errArray = errArray.concat(accessAideFuncs.$findNextHeader$(hdrs3, "h4", {"h4":"", "h5":"", "h6":""}));
    errArray = errArray.concat(accessAideFuncs.$findNextHeader$(hdrs4, "h5", {"h5":"", "h6":""}));
    errArray = errArray.concat(accessAideFuncs.$findNextHeader$(hdrs5, "h6", {"h6":""}));
    return accessAideFuncs.$formatOutput$(headerErrMsg, errArray)
  }}, $checkTopLevelPanels$:{"tag":"A11Y_DOM_12", "func":function(domElem) {
    var accessAideFuncs = aura.$devToolService$.$accessbilityAide$;
    var errorMsg = "[A11Y_DOM_12] Base and top panels should have proper aria-hidden properties.\n  More info http://sfdc.co/a11y_dom_12";
    var modalOverlay = "div.uiPanelDialog";
    var panelOverlay = "div.forcePanelOverlay";
    var panelSlide = "section.stage.panelSlide";
    var panelSliderOverlay = "div.forcePanelSlider";
    var panels = [];
    accessAideFuncs.$nodeListToObjectArray$(panels, domElem.querySelectorAll(modalOverlay));
    accessAideFuncs.$nodeListToObjectArray$(panels, domElem.querySelectorAll(panelOverlay));
    accessAideFuncs.$nodeListToObjectArray$(panels, domElem.querySelectorAll(panelSlide));
    accessAideFuncs.$nodeListToObjectArray$(panels, domElem.querySelectorAll(panelSliderOverlay), "div.body");
    var topPanelsCount = domElem.querySelectorAll(modalOverlay + ".active").length + domElem.querySelectorAll(panelOverlay + ".active").length;
    var elementCoveringEverythingActive = topPanelsCount > 0;
    topPanelsCount = topPanelsCount + domElem.querySelectorAll(panelSliderOverlay + ".active").length;
    var errorArray = accessAideFuncs.$findTopLevelErrors$(panels, topPanelsCount, elementCoveringEverythingActive);
    return accessAideFuncs.$formatOutput$(errorMsg, errorArray)
  }}, $checkInputdefaultErrorLinkage$:{"tag":"A11Y_DOM_13", "func":function(domElem) {
    var accessAideFuncs = aura.$devToolService$.$accessbilityAide$;
    var inputErrorMsg = "[A11Y_DOM_13] Aria-describedby must be used to associate error message with input control.\n  More info http://sfdc.co/a11y_dom_13";
    var errorArray = accessAideFuncs.$inputDefaultErrorAide$(domElem.getElementsByTagName("ul"), domElem.getElementsByTagName("input"), domElem.getElementsByTagName("select"), domElem.getElementsByTagName("textarea"));
    return accessAideFuncs.$formatOutput$(inputErrorMsg, errorArray)
  }}, $checkDuplicateButtonText$:{"tag":"A11Y_DOM_14", "func":function(domElem) {
    var dupeButtonTextErrorMsg = "[A11Y_DOM_14] Button must not have duplicate values.\n  More info http://sfdc.co/a11y_dom_14";
    var accessAideFuncs = aura.$devToolService$.$accessbilityAide$;
    var buttonTags = domElem.getElementsByTagName("button");
    var errorArray = accessAideFuncs.$buttonDuplicateTextAide$(buttonTags);
    return accessAideFuncs.$formatOutput$(dupeButtonTextErrorMsg, errorArray)
  }}, $checkOrphanLabels$:{"tag":"A11Y_DOM_15", "func":function(domElem) {
    var orphanLabelErrorMsg = "[A11Y_DOM_15] A label was found without an associated input. Labels should only be used to identify inputs.\n More Info: http://sfdc.co/a11y_dom_15";
    var accessAideFuncs = aura.$devToolService$.$accessbilityAide$;
    var labels = domElem.getElementsByTagName("LABEL");
    var errorArray = accessAideFuncs.$matchLabelToInput$(labels);
    return accessAideFuncs.$formatOutput$(orphanLabelErrorMsg, errorArray)
  }}}, $checkAccessibility$:function(domElem, checksToRun) {
    var functions = aura.$devToolService$.$verifyAccessibility$;
    var result = "";
    var funcObject = "";
    if($A["util"].$isUndefinedOrNull$(domElem)) {
      domElem = document
    }
    if($A["util"].$isEmpty$(checksToRun)) {
      checksToRun = ["A11Y_DOM_01", "A11Y_DOM_02", "A11Y_DOM_03", "A11Y_DOM_04", "A11Y_DOM_06", "A11Y_DOM_07", "A11Y_DOM_08", "A11Y_DOM_09", "A11Y_DOM_10", "A11Y_DOM_11", "A11Y_DOM_12", "A11Y_DOM_13", "A11Y_DOM_14", "A11Y_DOM_15"]
    }
    for(var funcLabel in functions) {
      funcObject = functions[funcLabel];
      if(checksToRun.indexOf(funcObject["tag"]) !== -1) {
        result = result + funcObject["func"](domElem)
      }
    }
    return result
  }, $help$:function() {
    $A.$deprecated$("$A.qhelp and $A.devToolService.help are not supported.", null, "2017/01/06", "2017/02/17");
    var ret = [];
    ret.push("\n COQL Usage");
    var txt = this.$helpText$;
    for(var i = 0;i < txt.length;i++) {
      var item = txt[i];
      ret.push("\n\n" + (i + 1) + ") ");
      ret.push(item.title);
      ret.push("\n\t\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n\t");
      ret.push(item.code);
      ret.push("\n\t\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n\n\t");
      ret.push(item.description)
    }
    return ret.join("")
  }};
  s.$helpText$ = [{title:"Query all components", code:"$A.getQueryStatement().query()", description:'"component" is the default view, and "*" is the default field'}, {title:"Choose a view to query", code:'$A.getQueryStatement().from("componentDef").query()', description:"Available views are : " + function(views) {
    var ret = [];
    for(var i in views) {
      ret.push(i)
    }
    return ret.toString()
  }(s["views"])}, {title:"Choose fields to query", code:'$A.getQueryStatement().from("component").field("toString").field("globalId").fields("def, super").query()', description:'Any property or method on the view, any expression that can be resolved against the view may be specified. "get" and "is" are also tried as prefixes for resolving function names.  Multiple fields can be comma separated or multiple calls to field() can be used.'}, {title:"Group results", code:'$A.getQueryStatement().from("value").field("toString").groupBy("toString").query()', 
  description:'The value of groupBy must be a selected field.  Note : The "value" view is only visible in stats mode.'}, {title:"Define derived fields", code:'$A.getQueryStatement().from("component").field("descriptor", "getDef().getDescriptor().toString()").query()', description:'You can create a derived field, such as getDef().getDescriptor().toString(), and refer to it as a real field called "descriptor" .'}, {title:"Diff the results of running a query twice", code:"var before \x3d $A.getQueryStatement().query(); var after \x3d $A.getQueryStatement().query(); after.diff(before);", 
  description:"This is useful if you want to do something between running the before and after query.  Any options for queries can be used (fields, groupBy, etc...)"}];
  Statement.prototype.$query$ = function() {
    var auraError = $A.error;
    $A.error = function(message, error) {
      if(error.message.indexOf("Access Check Failed!") < 0) {
        auraError.call($A, message, error)
      }
    };
    try {
      var ret = s.select(this.$criteria$);
      ret.$_priv$["statement"] = this;
      return ret
    }finally {
      $A.error = auraError
    }
  };
  ResultSet.prototype.$diff$ = function(from) {
    var origFromRawRows = from.$_priv$["rawRows"];
    var fromRawRows = [];
    var k;
    for(k = 0;k < origFromRawRows.length;k++) {
      fromRawRows[k] = origFromRawRows[k]
    }
    var origFromRows = from["rows"];
    if(!origFromRows) {
      origFromRows = from.$_priv$["rows"]
    }
    var fromRows = [];
    for(k = 0;k < origFromRows.length;k++) {
      fromRows[k] = origFromRows[k]
    }
    var toRawRows = this.$_priv$["rawRows"];
    var toRows = this["rows"];
    if(!toRows) {
      toRows = this.$_priv$["rows"]
    }
    var added = [];
    var addedRaw = [];
    var existing = [];
    var existingRaw = [];
    for(var i = 0;i < toRawRows.length;i++) {
      var rawRow = toRawRows[i];
      var row = toRows[i];
      var fromRawRow = null;
      for(var j = 0;fromRawRow === null && j < fromRows.length;j++) {
        fromRawRow = fromRawRows[j];
        if(rawRow !== fromRawRow) {
          fromRawRow = null
        }else {
          fromRawRows.splice(j, 1);
          fromRows.splice(j, 1)
        }
      }
      if(fromRawRow !== null) {
        existing.push(row);
        existingRaw.push(rawRow)
      }else {
        added.push(row);
        addedRaw.push(rawRow)
      }
    }
    var groupBy = this.$_priv$["statement"].$criteria$["groupBy"];
    var ret = new ResultSet({"added":s.$applyGroupBy$(groupBy, added, addedRaw), "existing":s.$applyGroupBy$(groupBy, existing, existingRaw), "removed":s.$applyGroupBy$(groupBy, fromRows, fromRawRows)}, {"from":from, "to":this, "statement":this.$_priv$["statement"]});
    return ret
  };
  Statement.prototype.$from$ = function(from) {
    this.$criteria$["from"] = from;
    return this
  };
  Statement.prototype.field = function(field, func) {
    if(func) {
      var derivedFields = this.$criteria$["derivedFields"];
      if(!derivedFields) {
        derivedFields = {};
        this.$criteria$["derivedFields"] = derivedFields
      }
      derivedFields[field] = func
    }else {
      var fields = this.$criteria$["fields"];
      if(!fields) {
        fields = field
      }else {
        fields = fields + ", " + field
      }
      this.$criteria$["fields"] = fields
    }
    return this
  };
  Statement.prototype.$fields$ = Statement.prototype.field;
  Statement.prototype.$where$ = function(func) {
    this.$criteria$["where"] = func;
    return this
  };
  Statement.prototype.$groupBy$ = function(col) {
    this.$criteria$["groupBy"] = col;
    return this
  };
  s.defaultView = s["views"]["component"];
  s.$defaultFields$ = "*";
  s.$defaultDerivedFields$ = {};
  s.$defaultFilter$ = s["filters"]["noop"];
  s.$defaultGroupBy$ = undefined;
  ResultSet.prototype["diff"] = ResultSet.prototype.$diff$;
  Statement.prototype["from"] = Statement.prototype.$from$;
  Statement.prototype["query"] = Statement.prototype.$query$;
  Statement.prototype["field"] = Statement.prototype.field;
  Statement.prototype["fields"] = Statement.prototype.$fields$;
  Statement.prototype["where"] = Statement.prototype.$where$;
  Statement.prototype["groupBy"] = Statement.prototype.$groupBy$;
  s["output"] = s.$output$;
  s["checkAccessibility"] = s.$checkAccessibility$;
  return s
};
function LockerService() {
  function selectLib(lib) {
    service.create = lib["create"];
    service.$createForDef$ = lib["createForDef"];
    service.$createForModule$ = lib["createForModule"];
    service.$getEnv$ = lib["getEnv"];
    service.$getEnvForSecureObject$ = lib["getEnvForSecureObject"];
    service.$getKeyForNamespace$ = lib["getKeyForNamespace"];
    service.$getRaw$ = lib["getRaw"];
    service.isEnabled = lib["isEnabled"];
    service.$instanceOf$ = lib["instanceOf"];
    service.$runScript$ = lib["runScript"];
    service.$trust$ = lib["trust"];
    service.$unwrap$ = lib["unwrap"];
    service.$wrapComponent$ = lib["wrapComponent"];
    service.$wrapComponentEvent$ = lib["wrapComponentEvent"];
    service.$wrapEngine$ = lib["wrapEngine"];
    service["create"] = service.create;
    service["createForDef"] = service.$createForDef$;
    service["getEnv"] = service.$getEnv$;
    service["getEnvForSecureObject"] = service.$getEnvForSecureObject$;
    service["getKeyForNamespace"] = service.$getKeyForNamespace$;
    service["runScript"] = service.$runScript$;
    service["trust"] = service.$trust$;
    service["wrapComponent"] = service.$wrapComponent$
  }
  function requireLocker(component) {
    var def = component.$getDef$();
    var descriptor = def.$getDescriptor$();
    var namespace = descriptor.$getNamespace$();
    var isInternal = $A.$clientService$.$isInternalNamespace$(namespace);
    if(isInternal) {
      return def.$isInstanceOf$("aura:requireLocker")
    }
    return parseInt(def.$getApiVersion$() || 40) >= 40
  }
  function getPublicMethodNames(component) {
    var methodsNames = [];
    if(component instanceof Aura.$Component$.$InteropComponent$) {
      methodsNames = component.$getPublicMethodNames$()
    }else {
      var defs = component.$getDef$().$methodDefs$;
      if(defs && defs.length) {
        methodsNames = defs.map(function(method) {
          var descriptor = new DefDescriptor(method.name);
          return descriptor.getName()
        })
      }
    }
    return methodsNames
  }
  function warn(message) {
    $A.$warning$(message)
  }
  function registerEngineServices(serviceHooks) {
    if($A.$componentService$.$moduleEngine$ && $A.$componentService$.$moduleEngine$["register"]) {
      $A.$componentService$.$moduleEngine$["register"](serviceHooks)
    }
  }
  function initialize(isEnabled) {
    if(isInitialized) {
      return
    }
    if(isEnabled && !!window["AuraLocker"]) {
      var types = {"Action":Aura.$Controller$.$Action$, "Component":Aura.$Component$.$Component$, "Event":Aura.$Event$.$Event$, "PropertyReferenceValue":Aura.$Value$.$PropertyReferenceValue$};
      var api = {"getPublicMethodNames":getPublicMethodNames, "requireLocker":requireLocker, "warn":warn, "error":$A.$auraError$, "registerEngineServices":registerEngineServices};
      var lib = window["AuraLocker"];
      selectLib(lib);
      lib["initialize"](types, api)
    }
    Object.freeze(service);
    isInitialized = true
  }
  var isInitialized = false;
  var service = {};
  selectLib(window["AuraLockerDisabled"]);
  service.$initialize$ = initialize;
  service["initialize"] = service.$initialize$;
  return service
}
Aura.$Services$.$LockerService$ = LockerService;
function AuraInstance() {
  this.$globalValueProviders$ = {};
  this.$deprecationUsages$ = {};
  this.$displayErrors$ = true;
  this.$logger$ = new Aura.$Utils$.$Logger$;
  this["util"] = new Aura.$Utils$.$Util$;
  this["util"] = this["util"];
  this.$auraError$ = Aura.$Errors$.$AuraError$;
  this.$auraFriendlyError$ = Aura.$Errors$.$AuraFriendlyError$;
  this.severity = {$ALERT$:"ALERT", $FATAL$:"FATAL", $QUIET$:"QUIET"};
  this.$lastKnownError$ = null;
  this.$localizationService$ = new Aura.$Services$.$AuraLocalizationService$;
  this.$clientService$ = new Aura.$Services$.$AuraClientService$(this["util"]);
  this.$componentService$ = new Aura.$Services$.$AuraComponentService$;
  this.$renderingService$ = new Aura.$Services$.$AuraRenderingService$;
  this.$expressionService$ = new Aura.$Services$.$AuraExpressionService$;
  this.$historyService$ = new Aura.$Services$.$AuraHistoryService$;
  this.$eventService$ = new Aura.$Services$.$AuraEventService$;
  this.$storageService$ = new Aura.$Services$.$AuraStorageService$;
  this.$styleService$ = new Aura.$Services$.$AuraStyleService$;
  this.$metricsService$ = new Aura.$Services$.$MetricsService$;
  this.$lockerService$ = new Aura.$Services$.$LockerService$;
  this.$devToolService$ = new AuraDevToolService;
  this.$injectedServices$ = {"localization":this.$localizationService$, "metrics":this.$metricsService$};
  this.$services$ = {$rendering$:this.$renderingService$, event:this.$eventService$, $component$:this.$componentService$, $client$:this.$clientService$, history:this.$historyService$, $localization$:this.$localizationService$, $storage$:this.$storageService$, $cmp$:this.$componentService$, $e$:this.$eventService$, $l10n$:this.$localizationService$, style:this.$styleService$, $metrics$:this.$metricsService$, $locker$:this.$lockerService$, get:function(key) {
    var ret = $A.$services$[key];
    if(!ret && key === "root") {
      return $A.$getRoot$()
    }
    return ret
  }};
  this.$Component$ = Component;
  this.$enqueueAction$ = this.$clientService$.$enqueueAction$.bind(this.$clientService$);
  this.$deferPendingActions$ = this.$clientService$.$deferPendingActions$.bind(this.$clientService$);
  this.$runAfterInit$ = this.$clientService$.$runAfterInitDefs$.bind(this.$clientService$);
  this.$render$ = this.$renderingService$.$render$.bind(this.$renderingService$);
  this.$rerender$ = this.$renderingService$.$rerender$.bind(this.$renderingService$);
  this.$unrender$ = this.$renderingService$.$unrender$.bind(this.$renderingService$);
  this.$afterRender$ = this.$renderingService$.$afterRender$.bind(this.$renderingService$);
  this.$getCmp$ = this.$componentService$.get.bind(this.$componentService$);
  this.$getComponent$ = this.$componentService$.$getComponent$.bind(this.$componentService$);
  this.$createComponent$ = this.$componentService$["createComponent"].bind(this.$componentService$);
  this.$createComponents$ = this.$componentService$["createComponents"].bind(this.$componentService$);
  this.$createComponentFromConfig$ = this.$componentService$.$createComponentFromConfig$.bind(this.$componentService$);
  this.$getEvt$ = this.$eventService$.$newEvent$.bind(this.$eventService$);
  this.$newCmp$ = this.$componentService$["newComponentDeprecated"].bind(this.$componentService$);
  this.$newCmpDeprecated$ = this.$componentService$["newComponentDeprecated"].bind(this.$componentService$);
  this.$newCmpAsync$ = this.$componentService$["newComponentAsync"].bind(this.$componentService$);
  this.$pushCreationPath$ = function(creationPath) {
    var ctx = this.getContext();
    if(!ctx) {
      return
    }
    var act = ctx.$getCurrentAction$();
    if(!act) {
      return
    }
    act.$pushCreationPath$(creationPath)
  };
  this.$popCreationPath$ = function(creationPath) {
    var ctx = this.getContext();
    if(!ctx) {
      return
    }
    var act = ctx.$getCurrentAction$();
    if(!act) {
      return
    }
    act.$popCreationPath$(creationPath)
  };
  this.$setCreationPathIndex$ = function(idx) {
    var ctx = this.getContext();
    if(!ctx) {
      return
    }
    var act = ctx.$getCurrentAction$();
    if(!act) {
      return
    }
    act.$setCreationPathIndex$(idx)
  };
  this["runAfterInit"] = this.$runAfterInit$;
  this["clientService"] = this.$clientService$;
  this["componentService"] = this.$componentService$;
  this["renderingService"] = this.$renderingService$;
  this["expressionService"] = this.$expressionService$;
  this["historyService"] = this.$historyService$;
  this["localizationService"] = this.$localizationService$;
  this["eventService"] = this.$eventService$;
  this["layoutService"] = this.$layoutService$;
  this["metricsService"] = this.$metricsService$;
  this["lockerService"] = this.$lockerService$;
  this["storageService"] = this.$storageService$;
  this["styleService"] = this.$styleService$;
  this["services"] = this.$services$;
  this["enqueueAction"] = this.$enqueueAction$;
  this["deferPendingActions"] = this.$deferPendingActions$;
  this["render"] = this.$render$;
  this["rerender"] = this.$rerender$;
  this["unrender"] = this.$unrender$;
  this["afterRender"] = this.$afterRender$;
  this["logger"] = this.$logger$;
  this["getCmp"] = this.$getCmp$;
  this["getComponent"] = this.$getComponent$;
  this["pushCreationPath"] = this.$pushCreationPath$;
  this["popCreationPath"] = this.$popCreationPath$;
  this["setCreationPathIndex"] = this.$setCreationPathIndex$;
  this["devToolService"] = this.$devToolService$;
  this["getQueryStatement"] = this.$devToolService$.$newStatement$;
  this["createComponent"] = this.$createComponent$;
  this["createComponents"] = this.$createComponents$;
  this["createComponentFromConfig"] = this.$createComponentFromConfig$;
  this["getEvt"] = this.$getEvt$;
  this["Component"] = this.$Component$;
  this["auraFriendlyError"] = this.$auraFriendlyError$;
  this["severity"] = this.severity;
  this["severity"]["ALERT"] = this.severity.$ALERT$;
  this["severity"]["FATAL"] = this.severity.$FATAL$;
  this["severity"]["QUIET"] = this.severity.$QUIET$;
  this["severity"] = Object.freeze(this["severity"]);
  this["hasDefinition"] = this.$hasDefinition$;
  this["getDefinition"] = this.$getDefinition$;
  this["getDefinitions"] = this.$getDefinitions$;
  this["newCmp"] = this.$newCmp$;
  this["newCmpDeprecated"] = this.$newCmpDeprecated$;
  this["newCmpAsync"] = this.$newCmpAsync$;
  this["qhelp"] = function() {
    return this.$devToolService$.$help$()
  };
  var services = this.$services$;
  services["rendering"] = services.$rendering$;
  services["event"] = services.event;
  services["component"] = services.$component$;
  services["client"] = services.$client$;
  services["history"] = services.history;
  services["l10n"] = services.$localization$;
  services["storage"] = services.$storage$;
  services["metrics"] = services.$metrics$;
  services["cmp"] = services.$cmp$;
  services["e"] = services.$e$;
  services["c"] = {get:function(name) {
    var path = (name || "").split(".");
    var controllerDef = path.shift();
    var action = path.shift();
    return services.$component$.$getControllerDef$(controllerDef).get(action)
  }}
}
AuraInstance.prototype.$beforeInitHooks$ = function() {
  var fncs = Aura["beforeFrameworkInit"];
  if(fncs && fncs.length) {
    for(var i = 0;i < fncs.length;i++) {
      fncs[i]()
    }
  }
};
AuraInstance.prototype.$afterInitHooks$ = function() {
  var fncs = Aura["afterFrameworkInit"];
  if(fncs && fncs.length) {
    for(var i = 0;i < fncs.length;i++) {
      fncs[i]()
    }
  }
};
AuraInstance.prototype.$initAsync$ = function(config) {
  Aura.$bootstrapMark$("runInitAsync");
  this.$beforeInitHooks$();
  this.$clientService$.$setNamespacePrivileges$(config["ns"]);
  this.$clientService$.$setQueueSize$(config["MaxParallelXHRCount"]);
  this.$clientService$.$setXHRExclusivity$(config["XHRExclusivity"]);
  $A.$context$ = new Aura.$Context$.$AuraContext$(config["context"], function(context) {
    function reportError(e) {
      $A.$reportError$("Error initializing the application", e)
    }
    function initializeApp() {
      return $A.$clientService$.$initializeApplication$().$then$(function(bootConfig) {
        $A.$run$(function() {
          $A.$initPriv$(bootConfig)
        })
      }, reportError)
    }
    function ensureCssLoaded() {
      return new Promise(function(resolve) {
        if(Aura["bootstrap"]["appCssLoading"]) {
          Aura["bootstrap"]["appCssLoadedCallback"] = resolve
        }else {
          resolve()
        }
      })
    }
    $A.$context$ = context;
    $A.$clientService$.$reloadPointPassed$ = true;
    if($A.$clientService$.$reloadFunction$) {
      $A.$clientService$.$reloadFunction$();
      return
    }
    $A.$clientService$.$initHost$(config["host"]);
    $A.$clientService$.$setToken$(config["token"]);
    $A.$metricsService$.$initialize$();
    $A.$clientService$.$gvpsFromStorage$ = context.$globalValueProviders$.$LOADED_FROM_PERSISTENT_STORAGE$;
    if(!$A.$clientService$.$gvpsFromStorage$) {
      $A.log("Aura.initAsync: GVP not loaded from storage so not loading defs or actions either");
      $A.$clientService$.$loadTokenFromStorage$().$then$(ensureCssLoaded).$then$(initializeApp).$then$(undefined, reportError)
    }else {
      Promise["all"]([$A.$clientService$.$loadTokenFromStorage$(), $A.$clientService$.$loadBootstrapFromStorage$(), $A.$componentService$.$restoreDefsFromStorage$(context), $A.$clientService$.$populateActionsFilter$(), ensureCssLoaded]).$then$(initializeApp, function(err) {
        $A.log("Aura.initAsync: failed to load defs, get bootstrap or actions from storage", err);
        $A.$clientService$.$clearActionsFilter$();
        return initializeApp()
      }).$then$(undefined, reportError)
    }
  });
  this.$clientService$.$initDefs$();
  $A.$executeExternalLibraries$()
};
AuraInstance.prototype.$executeExternalLibraries$ = function() {
  if(Aura["externalLibraries"]) {
    Aura["externalLibraries"].call(window)
  }
};
AuraInstance.prototype.$initConfig$ = function(config, useExisting, doNotInitializeServices) {
  this.$clientService$.$setNamespacePrivileges$(config["ns"]);
  this.$clientService$.$setQueueSize$(config["MaxParallelXHRCount"]);
  this.$clientService$.$setXHRExclusivity$(config["XHRExclusivity"]);
  this.$beforeInitHooks$();
  $A.$executeExternalLibraries$();
  if(!useExisting || $A["util"].$isUndefined$($A.getContext())) {
    $A.$clientService$.$initHost$(config["host"], config["sid"]);
    $A.$context$ = new Aura.$Context$.$AuraContext$(config["context"], function(context) {
      $A.$context$ = context;
      $A.$clientService$.$initDefs$();
      $A.$metricsService$.$initialize$();
      $A.$initPriv$(config["instance"], config["token"], null, doNotInitializeServices);
      $A.$context$.$finishComponentConfigs$($A.$context$.$getCurrentAction$().$getId$());
      $A.$context$.$setCurrentAction$(null)
    })
  }else {
    $A.getContext()["merge"](config["context"])
  }
};
AuraInstance.prototype.$initPriv$ = function(config, token, container, doNotInitializeServices) {
  Aura.$bootstrapMark$("AuraFrameworkEPT");
  if(!$A["hasErrors"]) {
    $A.$addTearDownHandler$();
    $A.$clientService$.$initializeClientLibraries$();
    $A.$clientService$.$initializeInjectedServices$($A.$context$.$moduleServices$);
    $A.$localizationService$.$init$();
    var app = $A.$clientService$["init"](config, token, $A["util"].$getElement$(container));
    $A.$setRoot$(app);
    if(!$A.$initialized$) {
      $A.$initialized$ = true;
      $A.$addDefaultEventHandlers$(app);
      $A.$afterInitHooks$();
      $A.$finishInit$(doNotInitializeServices)
    }
  }
};
AuraInstance.prototype.$addTearDownHandler$ = function() {
  window.addEventListener("unload", $A.$getCallback$($A.$clientService$.$tearDown$.bind($A.$clientService$)))
};
AuraInstance.prototype.$addDefaultEventHandlers$ = function(app) {
  app.$addEventHandler$("aura:clientRedirect", $A.$defaultRedirectHandler$);
  app.$addEventHandler$("aura:systemError", $A.$defaultErrorHandler$);
  app.$addEventHandler$("aura:customerError", $A.$defaultErrorHandler$)
};
AuraInstance.prototype.$defaultErrorHandler$ = function(event) {
  if(event["handled"]) {
    return
  }
  $A.message(event.$getParam$("message"), event.$getParam$("auraError"));
  event["handled"] = true
};
AuraInstance.prototype.$defaultRedirectHandler$ = function(evt) {
  var url = evt.$getParam$("url");
  if(url != null) {
    var protocolBlacklist = ["javascript", "data"];
    var doc = document.implementation.createDocument("http://www.w3.org/1999/xhtml", "html", null);
    var testXSSLink = doc.createElement("a");
    testXSSLink.setAttribute("href", url);
    if(testXSSLink.protocol != null) {
      for(var i = 0;i < protocolBlacklist.length;i++) {
        if(testXSSLink.protocol.indexOf(protocolBlacklist[i]) === 0) {
          url = encodeURIComponent(url);
          break
        }
      }
    }
    window.location = url
  }
};
AuraInstance.prototype.$finishInit$ = function(doNotInitializeServices) {
  if(!this["finishedInit"]) {
    $A["util"].$removeClass$(document.body, "loading");
    delete $A.$globalValueProviders$;
    this["finishedInit"] = true;
    $A.$metricsService$.$applicationReady$();
    $A.$eventService$.$getNewEvent$("markup://aura:initialized").$fire$();
    $A.$clientService$.$checkBootstrapUpgrade$();
    $A.$clientService$.$clearReloadCount$()
  }
  if(!doNotInitializeServices && !Aura["disableHistoryService"]) {
    $A.$historyService$.$init$()
  }
  var readyCallbacks = Aura["afterAppReady"];
  for(var i in readyCallbacks) {
    readyCallbacks[i]()
  }
  delete Aura["afterAppReady"];
  Aura["applicationReady"] = true
};
AuraInstance.prototype.error = function(msg, e) {
  this.$logger$.error(msg, e)
};
AuraInstance.prototype.$showErrors$ = function(toggle) {
  if(toggle !== undefined) {
    this.$displayErrors$ = !!toggle
  }
  return this.$displayErrors$
};
AuraInstance.prototype.handleError = function(message, e) {
  $A.$logger$.$devDebugConsoleLog$("ERROR", message, e);
  var dispMsg = message;
  var evtArgs = {"message":dispMsg, "error":null, "auraError":null};
  if(e) {
    if(e["handled"]) {
      return
    }else {
      e["handled"] = true
    }
    if(e instanceof $A.$auraFriendlyError$) {
      e.severity = e.severity || this.severity.$QUIET$;
      evtArgs = {"message":e["message"], "error":e["name"], "auraError":e}
    }else {
      if(e instanceof $A.$auraError$) {
        var format = "This page has an error. You might just need to refresh it.\n{0}";
        e.severity = e.severity || this.severity["ALERT"];
        var displayMessage = e.message || e.name;
        displayMessage += "\n" + (e["component"] ? "Failing descriptor: {" + e["component"] + "}" : "");
        dispMsg = $A["util"].$format$(format, displayMessage);
        evtArgs = {"message":dispMsg, "error":null, "auraError":e}
      }else {
        e = new $A.$auraError$(null, e);
        var component = e.$findComponentFromStackTrace$();
        e.$setComponent$(component);
        evtArgs = {"message":dispMsg, "error":null, "auraError":e}
      }
    }
  }
  if($A.$initialized$) {
    window.setTimeout(function() {
      if($A.$isCustomerError$(e)) {
        $A.$eventService$.$getNewEvent$("markup://aura:customerError").$fire$(evtArgs)
      }else {
        $A.$eventService$.$getNewEvent$("markup://aura:systemError").$fire$(evtArgs)
      }
    }, 0)
  }else {
    if($A.$showErrors$()) {
      $A.message(dispMsg, e)
    }
  }
};
AuraInstance.prototype.$isCustomerError$ = function(e) {
  if(e && e instanceof $A.$auraError$) {
    if(e["component"]) {
      if($A.$isCustomerComponent$(e["component"])) {
        return true
      }else {
        if(e["componentStack"]) {
          return $A.$isCustomerComponentStack$(e["componentStack"])
        }
      }
    }
  }
  return false
};
AuraInstance.prototype.$isCustomerComponent$ = function(cmp) {
  if(!$A["util"].$isEmpty$(cmp)) {
    var descriptor = cmp.split("$", 1);
    var componentDef = $A.$componentService$.$getComponentDef$($A.$componentService$.$createDescriptorConfig$(descriptor[0]));
    if(!$A["util"].$isUndefinedOrNull$(componentDef)) {
      var namespace = componentDef.$getDescriptor$().$getNamespace$();
      var internal = $A.$clientService$.$isInternalNamespace$(namespace);
      var privileged = $A.$clientService$.$isPrivilegedNamespace$(namespace);
      if(!$A["util"].$isEmpty$(namespace) && !internal && !privileged) {
        return true
      }
    }
  }
  return false
};
AuraInstance.prototype.$isCustomerComponentStack$ = function(cmpStack) {
  if(!$A["util"].$isEmpty$(cmpStack)) {
    var stack = cmpStack.split("\x3e");
    for(var i = stack.length - 1;i >= 0;i--) {
      var cmp = stack[i];
      if(!$A["util"].$isUndefinedOrNull$(cmp)) {
        cmp = cmp.trim().replace(new RegExp("^\\[|\\]$", "g"), "");
        if($A.$isCustomerComponent$(cmp)) {
          return true
        }
      }
    }
  }
  return false
};
AuraInstance.prototype.$reportError$ = function(message, error) {
  if($A.$logger$.$isExternalError$(error)) {
    return false
  }
  error = error || (this.$lastKnownError$ && message && message.indexOf(this.$lastKnownError$.message) > -1 ? this.$lastKnownError$ : null) || new $A.$auraError$("[NoErrorObjectAvailable] " + message);
  $A.handleError(message, error);
  if($A.$initialized$ && $A["util"].$hasSourceURL$()) {
    $A.$getCallback$(function() {
      if(error && message) {
        if(message !== error.message && message.indexOf(error.message) > -1) {
          error.message = message + ". Caused by: " + error.message
        }
      }
      var reportingLevel = $A.$logger$.$isExternalRaisedError$(error) ? "WARNING" : "ERROR";
      $A.$logger$.$reportError$(error, null, reportingLevel)
    })();
    $A.$clientService$.$postProcess$()
  }
  this.$lastKnownError$ = null;
  return true
};
AuraInstance.prototype.$warning$ = function(w, e) {
  this.$logger$.$warning$(w, e)
};
AuraInstance.prototype.message = function(msg, error, showReload) {
  if(!this.$displayErrors$) {
    return
  }
  var message = $A["util"].$getElement$("auraErrorMessage");
  message.innerHTML = "";
  message.appendChild(document.createTextNode(msg));
  if(error && error.$stackTrace$) {
    var auraErrorStack = $A["util"].$getElement$("auraErrorStack");
    auraErrorStack.innerHTML = "";
    var stack = error.$stackTrace$;
    if(stack.trim) {
      stack = stack.trim()
    }else {
      if($A["util"].isArray(stack)) {
        for(var i = 0;i < stack.length;i++) {
          stack[i] = stack[i].trim()
        }
        stack = stack.join("\n")
      }
    }
    auraErrorStack.appendChild(document.createTextNode(stack))
  }
  $A["util"].$removeClass$(document.body, "loading");
  if(showReload) {
    $A["util"].$addClass$($A["util"].$getElement$("auraErrorReload"), "show")
  }
  $A["util"].$addClass$($A["util"].$getElement$("auraErrorMask"), "auraForcedErrorBox")
};
AuraInstance.prototype.$getCallback$ = function(callback) {
  function callbackWrapper() {
    $A.$clientService$.$setCurrentAccess$(context);
    $A.$clientService$.$pushStack$("$A.getCallback()");
    try {
      return callback.apply(this, Array.prototype.slice.call(arguments))
    }catch(e) {
      if(e instanceof $A.$auraError$) {
        throw e;
      }else {
        var syntheticStackFrame = "";
        if(arguments.length === 2) {
          var action = arguments[0];
          if($A["util"].$isAction$(action)) {
            var actionDef = action.$getDef$();
            if(actionDef) {
              syntheticStackFrame = actionDef.$getDescriptor$().toString()
            }
          }
          var actionComponent = arguments[1];
          var actionComponentDefDescriptor = null;
          if($A["util"].$isComponent$(actionComponent)) {
            var actionComponentDef = actionComponent.$getDef$();
            if(actionComponentDef) {
              actionComponentDefDescriptor = actionComponentDef.$getDescriptor$().toString()
            }
          }
          if(syntheticStackFrame) {
            syntheticStackFrame = syntheticStackFrame + (actionComponentDefDescriptor ? "@" + actionComponentDefDescriptor : "") + "\n"
          }
        }
        var errorWrapper = new $A.$auraError$("Error in $A.getCallback()", e);
        if(syntheticStackFrame) {
          errorWrapper.$setStackTrace$(syntheticStackFrame + errorWrapper.$stackTrace$)
        }
        $A.$lastKnownError$ = errorWrapper;
        throw errorWrapper;
      }
    }finally {
      $A.$clientService$.$popStack$("$A.getCallback()");
      $A.$clientService$.$releaseCurrentAccess$()
    }
  }
  $A.assert($A["util"].$isFunction$(callback), "$A.getCallback(): 'callback' must be a valid Function");
  var context = $A.$clientService$.$currentAccess$;
  if(callback.$reference$ && callback.toString() === callbackWrapper.toString()) {
    return callback
  }
  callbackWrapper.$reference$ = callback;
  return callbackWrapper
};
AuraInstance.prototype.$executeHotspot$ = function(callback) {
  if(!$A["util"].$isFunction$(callback)) {
    throw new Error("$A.executeHotspot: 'callback' must be a valid Function.");
  }
  this.$clientService$.$allowFlowthrough$ = true;
  try {
    callback()
  }finally {
    this.$clientService$.$allowFlowthrough$ = false
  }
};
AuraInstance.prototype.$getToken$ = function(token) {
  var context = $A.getContext();
  var tokens = context && context.$getTokens$();
  if(tokens) {
    if(tokens.hasOwnProperty(token)) {
      return tokens[token]
    }
    throw new $A.$auraError$("Unknown token: '" + token + "'. Are you missing a tokens file or declaration?");
  }
};
AuraInstance.prototype.$getService$ = function(name) {
  return this.$injectedServices$[name]
};
goog.$exportSymbol$("AuraInstance.prototype.getService", AuraInstance.prototype.$getService$);
AuraInstance.prototype.get = function(key, callback) {
  key = $A.$expressionService$.normalize(key);
  var path = key.split(".");
  var root = path.shift();
  var valueProvider = $A.$services$[root] || $A.$getValueProvider$(root);
  if(valueProvider) {
    if(path.length) {
      if(valueProvider.get) {
        return valueProvider.get(path.join("."), callback)
      }else {
        return $A.$expressionService$.$resolve$(path, valueProvider)
      }
    }
    return valueProvider.$getValues$ ? valueProvider.$getValues$() : valueProvider
  }
};
AuraInstance.prototype.set = function(key, value) {
  key = $A.$expressionService$.normalize(key);
  var path = key.split(".");
  var root = path.shift();
  var valueProvider = $A.$getValueProvider$(root);
  if(!valueProvider) {
    $A.assert(false, "Unable to set value for key '" + key + "'. No value provider was found for '" + root + "'.")
  }
  if(!valueProvider["set"]) {
    $A.assert(false, "Unable to set value for key '" + key + "'. Value provider does not implement 'set(key, value)'.")
  }
  var oldValue = $A.get(key);
  var result = valueProvider["set"](path.join("."), value);
  $A.$expressionService$.$updateGlobalReference$(key, oldValue, value);
  return result
};
AuraInstance.prototype.$getReference$ = function(key) {
  return $A.$expressionService$.$getReference$(key)
};
goog.$exportSymbol$("AuraInstance.prototype.getReference", AuraInstance.prototype.$getReference$);
Aura.$OverrideMap$Instance$ = undefined;
AuraInstance.prototype.$installOverride$ = function(name, fn, scope, priority) {
  if(Aura.$OverrideMap$Instance$ === undefined) {
    Aura.$OverrideMap$Instance$ = new Aura.$OverrideMap$
  }
  if(priority === undefined) {
    priority = 50
  }
  var override = Aura.$OverrideMap$Instance$.map[name];
  if(!override) {
    throw new $A.$auraError$("$A.installOverride: Invalid name: " + name, null, $A.severity.$QUIET$);
  }
  $A.assert(fn && $A["util"].$isFunction$(fn), "Function must be a defined function");
  override.$install$(fn, scope, priority)
};
AuraInstance.prototype.$uninstallOverride$ = function(name, fn) {
  if(Aura.$OverrideMap$Instance$ === undefined) {
    Aura.$OverrideMap$Instance$ = new Aura.$OverrideMap$
  }
  var override = Aura.$OverrideMap$Instance$.map[name];
  if(!override) {
    throw new $A.$auraError$("$A.uninstallOverride: Invalid name: " + name, null, $A.severity.$QUIET$);
  }
  override.$uninstall$(fn)
};
AuraInstance.prototype.$getRoot$ = function() {
  return this.root
};
goog.$exportSymbol$("AuraInstance.prototype.getRoot", AuraInstance.prototype.$getRoot$);
AuraInstance.prototype.$setRoot$ = function(root) {
  this.root = root
};
AuraInstance.prototype.getContext = function() {
  return this.$context$
};
AuraInstance.prototype.$run$ = function(func, name) {
  $A.assert(func && $A["util"].$isFunction$(func), "The parameter 'func' for $A.run() must be a function!");
  if(name === undefined) {
    name = "$A.run()"
  }
  var nested = $A.$services$.$client$.$inAuraLoop$();
  $A.$services$.$client$.$pushStack$(name);
  try {
    return func()
  }catch(e) {
    if(nested || e instanceof $A.$auraFriendlyError$) {
      throw e;
    }else {
      throw e instanceof $A.$auraError$ ? e : new $A.$auraError$("Uncaught error in " + name, e);
    }
  }finally {
    $A.$services$.$client$.$popStack$(name)
  }
  return undefined
};
AuraInstance.prototype.assert = function(condition, assertMessage) {
  this.$logger$.assert(condition, assertMessage)
};
AuraInstance.prototype.$userAssert$ = function(condition, msg) {
  $A.assert(condition, msg)
};
AuraInstance.prototype.log = function(value, error) {
  this.$logger$.info(value, error)
};
AuraInstance.prototype.trace = function() {
  if(window["console"] && window["console"]["trace"]) {
    window["console"]["trace"]()
  }
};
AuraInstance.prototype.$deprecated$ = function(message, workaround, sinceDate, dueDate, reportSignature) {
  var callingCmp = $A.$clientService$.$getCurrentAccessName$();
  if(/^(ui|aura):\w+$/.test(callingCmp)) {
    return
  }
  var callStack = (new Error).stack;
  if(!callStack) {
    return
  }
  var caller = callStack.split("\n", 4)[3];
  if(!caller || caller.indexOf("/aura_") > -1) {
    return
  }
  if(workaround) {
    message += ". Workaround: " + workaround
  }
  $A.$warning$("Deprecation warning: " + message)
};
AuraInstance.prototype.$setMode$ = function(mode) {
  this.mode = mode;
  this.$enableAssertions$ = mode !== "PROD" && mode !== "PTEST"
};
AuraInstance.prototype.$getValueProvider$ = function(type) {
  return this.getContext().$getGlobalValueProvider$(type)
};
AuraInstance.prototype.$addValueProvider$ = function(type, valueProvider) {
  $A.assert($A["util"].$isString$(type), "$A.addValueProvider(): 'type' must be a valid String.");
  $A.assert(type.charAt(0) === "$", "$A.addValueProvider(): 'type' must start with '$'.");
  $A.assert(",$browser,$label,$locale,".indexOf("," + type.toLowerCase() + ",") === -1, "$A.addValueProvider(): '" + type + "' is a reserved valueProvider.");
  $A.assert(!$A["util"].$isUndefinedOrNull$(valueProvider), "$A.addValueProvider(): 'valueProvider' is required.");
  var context = this.getContext();
  if(context) {
    $A.assert(this.$getValueProvider$(type) == null, "$A.addValueProvider(): '" + type + "' has already been registered.");
    context.$addGlobalValueProvider$(type, valueProvider)
  }else {
    $A.assert(this.$globalValueProviders$[type] == null, "$A.addValueProvider(): '" + type + "' has already been registered.");
    this.$globalValueProviders$[type] = valueProvider
  }
};
AuraInstance.prototype.$getDefinition$ = function(descriptor, callback) {
  $A.assert($A["util"].$isString$(descriptor), "'descriptor' must be an event or component descriptor such as 'prefix:name' or 'e.prefix:name'.");
  $A.assert($A["util"].$isFunction$(callback), "'callback' must be a valid function.");
  if(descriptor.indexOf("e.") !== -1) {
    return this.$eventService$.$getDefinition$(descriptor, callback)
  }
  return this.$componentService$.$getDefinition$(descriptor, callback)
};
AuraInstance.prototype.$getDefinitions$ = function(descriptors, callback) {
  $A.assert($A["util"].isArray(descriptors), "'descriptors' must be an array of definition descriptors to retrieve.");
  $A.assert($A["util"].$isFunction$(callback), "'callback' must be a valid function.");
  var pendingMap = {};
  var returnDefinitions = [];
  var requestDefinitions = [];
  var descriptor;
  var def;
  var isEvent;
  var c = 0;
  for(var length = descriptors.length;c < length;c++) {
    descriptor = descriptors[c];
    if(descriptor && descriptor.indexOf("e.") !== -1) {
      descriptor = descriptor.replace("e.", "");
      isEvent = true;
      def = this.$eventService$.$getDef$(descriptor)
    }else {
      def = this.$componentService$.$getDef$(descriptor);
      isEvent = false
    }
    if(def) {
      returnDefinitions[c] = def
    }else {
      if(isEvent && !this.$eventService$.$getEventDef$(descriptor) || !isEvent && !this.$componentService$.$getComponentDef$(this.$componentService$.$createDescriptorConfig$(descriptor))) {
        requestDefinitions.push(descriptors[c]);
        pendingMap[descriptor] = {"position":c, "isEvent":isEvent}
      }else {
        returnDefinitions[c] = null
      }
    }
  }
  if(!requestDefinitions.length) {
    callback(returnDefinitions)
  }else {
    var action = $A.get("c.aura://ComponentController.getDefinitions");
    action.$setParams$({"names":requestDefinitions});
    action.$setCallback$(this, function getDefintions$callback() {
      var pendingInfo;
      for(var requestedDescriptor in pendingMap) {
        if(pendingMap.hasOwnProperty(requestedDescriptor)) {
          pendingInfo = pendingMap[requestedDescriptor];
          if(pendingInfo["isEvent"]) {
            returnDefinitions[pendingInfo["position"]] = this.$eventService$.$getDef$(requestedDescriptor) || null
          }else {
            returnDefinitions[pendingInfo["position"]] = this.$componentService$.$getDef$(requestedDescriptor) || null
          }
        }
      }
      callback(returnDefinitions)
    });
    $A.$enqueueAction$(action)
  }
};
AuraInstance.prototype.$hasDefinition$ = function(descriptor) {
  $A.assert($A["util"].$isString$(descriptor), "'descriptor' must be an event or component descriptor such as 'prefix:name' or 'e.prefix:name'.");
  if(descriptor.indexOf("e.") !== -1) {
    return this.$eventService$.$hasDefinition$(descriptor.replace("e.", ""))
  }
  return this.$componentService$.$hasDefinition$(descriptor)
};
var PerfLogLevel = {"DEBUG":{name:"DEBUG", value:1}, "INTERNAL":{name:"INTERNAL", value:2}, "PRODUCTION":{name:"PRODUCTION", value:3}, "DISABLED":{name:"DISABLED", value:4}};
goog.$exportSymbol$("PerfLogLevel", PerfLogLevel);
var PerfConstants = {"PAGE_START_MARK":"PageStart", "PERF_PAYLOAD_PARAM":"bulkPerf", "MARK_NAME":"mark", "MEASURE_NAME":"measure", "MARK_START_TIME":"st", "MARK_LAST_TIME":"lt", "PAGE_NAME":"pn", "ELAPSED_TIME":"et", "REFERENCE_TIME":"rt", "Perf_LOAD_DONE":"loadDone"};
goog.$exportSymbol$("PerfConstants", PerfConstants);
PerfConstants["STATS"] = {"NAME":"stat", "SERVER_ELAPSED":"internal_serverelapsed", "DB_TOTAL_TIME":"internal_serverdbtotaltime", "DB_CALLS":"internal_serverdbcalls", "DB_FETCHES":"internal_serverdbfetches"};
var PerfShim = {"currentLogLevel":PerfLogLevel["DISABLED"], "mark":function(id, logLevel) {
  return this
}, "endMark":function(id, logLevel) {
  return this
}, "updateMarkName":function(oldName, newName) {
  return this
}, "measureToJson":function(measure) {
  return""
}, "toJson":function(includeMarks) {
  return""
}, "setTimer":function(timer_name, timer_delta, logLevel) {
  return this
}, "toPostVar":function() {
  return""
}, "getMeasures":function() {
  return[]
}, "getBeaconData":function() {
  return null
}, "setBeaconData":function(beaconData) {
}, "clearBeaconData":function() {
}, "removeStats":function() {
}, "stat":function(label, elapsedMillis) {
  return this
}, "getStat":function(label) {
  return-1
}, "onLoad":function() {
}, "startTransaction":function(tName) {
  return this
}, "endTransaction":function(tName) {
  return this
}, "updateTransaction":function(oldName, newName) {
  return this
}, "isOnLoadFired":function() {
  return false
}, "util":{"setCookie":function(name, value, expires, path) {
}}, enabled:false};
AuraInstance.prototype.$Perf$ = window["Perf"] || PerfShim;
AuraInstance.prototype["addValueProvider"] = AuraInstance.prototype.$addValueProvider$;
AuraInstance.prototype["initAsync"] = AuraInstance.prototype.$initAsync$;
AuraInstance.prototype["initConfig"] = AuraInstance.prototype.$initConfig$;
AuraInstance.prototype["error"] = AuraInstance.prototype.error;
AuraInstance.prototype["warning"] = AuraInstance.prototype.$warning$;
AuraInstance.prototype["message"] = AuraInstance.prototype.message;
AuraInstance.prototype["enqueueAction"] = AuraInstance.prototype.$enqueueAction$;
AuraInstance.prototype["executeHotspot"] = AuraInstance.prototype.$executeHotspot$;
AuraInstance.prototype["get"] = AuraInstance.prototype.get;
AuraInstance.prototype["getReference"] = AuraInstance.prototype.$getReference$;
AuraInstance.prototype["getRoot"] = AuraInstance.prototype.$getRoot$;
AuraInstance.prototype["getCallback"] = AuraInstance.prototype.$getCallback$;
AuraInstance.prototype["getContext"] = AuraInstance.prototype.getContext;
AuraInstance.prototype["getToken"] = AuraInstance.prototype.$getToken$;
AuraInstance.prototype["getService"] = AuraInstance.prototype.$getService$;
AuraInstance.prototype["run"] = AuraInstance.prototype.$run$;
AuraInstance.prototype["set"] = AuraInstance.prototype.set;
AuraInstance.prototype["assert"] = AuraInstance.prototype.assert;
AuraInstance.prototype["userAssert"] = AuraInstance.prototype.$userAssert$;
AuraInstance.prototype["log"] = AuraInstance.prototype.log;
AuraInstance.prototype["trace"] = AuraInstance.prototype.trace;
AuraInstance.prototype["reportError"] = AuraInstance.prototype.$reportError$;
AuraInstance.prototype["Perf"] = AuraInstance.prototype.$Perf$;
AuraInstance.prototype["mark"] = AuraInstance.prototype.$Perf$["mark"];
AuraInstance.prototype["endMark"] = AuraInstance.prototype.$Perf$["endMark"];
AuraInstance.prototype["startTransaction"] = AuraInstance.prototype.$Perf$["startTransaction"];
AuraInstance.prototype["endTransaction"] = AuraInstance.prototype.$Perf$["endTransaction"];
AuraInstance.prototype["updateTransaction"] = AuraInstance.prototype.$Perf$["updateTransaction"];
AuraInstance.prototype["toJson"] = AuraInstance.prototype.$Perf$["toJson"];
AuraInstance.prototype["setBeaconData"] = AuraInstance.prototype.$Perf$["setBeaconData"];
AuraInstance.prototype["getBeaconData"] = AuraInstance.prototype.$Perf$["getBeaconData"];
AuraInstance.prototype["clearBeaconData"] = AuraInstance.prototype.$Perf$["clearBeaconData"];
AuraInstance.prototype["removeStats"] = AuraInstance.prototype.$Perf$["removeStats"];
AuraInstance.prototype["isLoadFired"] = AuraInstance.prototype.$Perf$.$isLoadFired$;
AuraInstance.prototype["installOverride"] = AuraInstance.prototype.$installOverride$;
AuraInstance.prototype["uninstallOverride"] = AuraInstance.prototype.$uninstallOverride$;
AuraInstance.prototype["devToolService"] = AuraInstance.prototype.$devToolService$;
AuraInstance.prototype["getQueryStatement"] = AuraInstance.prototype.$getQueryStatement$;
AuraInstance.prototype["qhelp"] = AuraInstance.prototype.$qhelp$;
Aura.$OverrideMap$ = function OverrideMap() {
  this.map = {"enqueueAction":new Aura.$Utils$.$Override$($A.$clientService$, $A.$clientService$.$enqueueAction$, false, function(bound) {
    $A.$enqueueAction$ = bound;
    $A["enqueueAction"] = bound;
    $A.$clientService$.$enqueueAction$ = bound;
    $A.$clientService$["enqueueAction"] = bound
  }, function(orig, bound) {
    $A.$enqueueAction$ = bound;
    $A["enqueueAction"] = bound;
    $A.$clientService$.$enqueueAction$ = orig;
    $A.$clientService$["enqueueAction"] = orig
  }), "ClientService.decode":new Aura.$Utils$.$Override$($A.$clientService$, $A.$clientService$.$decode$, false, function(bound) {
    $A.$clientService$.$decode$ = bound
  }, function(orig) {
    $A.$clientService$.$decode$ = orig
  }), "ClientService.send":new Aura.$Utils$.$Override$($A.$clientService$, $A.$clientService$.send, false, function(bound) {
    $A.$clientService$.send = bound
  }, function(orig) {
    $A.$clientService$.send = orig
  }), "ClientService.collectServerAction":new Aura.$Utils$.$Override$($A.$clientService$, $A.$clientService$.$collectServerAction$, false, function(bound) {
    $A.$clientService$.$collectServerAction$ = bound
  }, function(orig) {
    $A.$clientService$.$collectServerAction$ = orig
  }), "ClientService.receive":new Aura.$Utils$.$Override$($A.$clientService$, $A.$clientService$.$receive$, false, function(bound) {
    $A.$clientService$.$receive$ = bound
  }, function(orig) {
    $A.$clientService$.$receive$ = orig
  }), "ComponentService.createComponentPriv":new Aura.$Utils$.$Override$($A.$componentService$, $A.$componentService$.$createComponentPriv$, false, function(bound) {
    $A.$componentService$.$createComponentPriv$ = bound
  }, function(orig) {
    $A.$componentService$.$createComponentPriv$ = orig
  }), "ClientService.processResponses":new Aura.$Utils$.$Override$($A.$clientService$, $A.$clientService$.$processResponses$, false, function(bound) {
    $A.$clientService$.$processResponses$ = bound
  }, function(orig) {
    $A.$clientService$.$processResponses$ = orig
  }), "ClientService.getAvailableXHR":new Aura.$Utils$.$Override$($A.$clientService$, $A.$clientService$.$getAvailableXHR$, false, function(bound) {
    $A.$clientService$.$getAvailableXHR$ = bound
  }, function(orig) {
    $A.$clientService$.$getAvailableXHR$ = orig
  }), "Action.finishAction":new Aura.$Utils$.$Override$(null, Aura.$Controller$.$Action$.prototype.$finishAction$, true, function(bound) {
    Aura.$Controller$.$Action$.prototype.$finishAction$ = bound
  }, function(orig) {
    Aura.$Controller$.$Action$.prototype.$finishAction$ = orig
  }), "Action.abort":new Aura.$Utils$.$Override$(null, Aura.$Controller$.$Action$.prototype.abort, true, function(bound) {
    Aura.$Controller$.$Action$.prototype.abort = bound
  }, function(orig) {
    Aura.$Controller$.$Action$.prototype.abort = orig
  }), "Action.runDeprecated":new Aura.$Utils$.$Override$(null, Aura.$Controller$.$Action$.prototype.$runDeprecated$, true, function(bound) {
    Aura.$Controller$.$Action$.prototype.$runDeprecated$ = bound;
    Aura.$Controller$.$Action$.prototype["runDeprecated"] = bound;
    Aura.$Controller$.$Action$.prototype["getComponent"] = function() {
      return this.$cmp$
    }
  }, function(orig) {
    Aura.$Controller$.$Action$.prototype.$runDeprecated$ = orig;
    Aura.$Controller$.$Action$.prototype["runDeprecated"] = orig;
    delete Aura.$Controller$.$Action$.prototype["getComponent"]
  }), "Event.fire":new Aura.$Utils$.$Override$(null, Aura.$Event$.$Event$.prototype.$fire$, true, function(bound) {
    Aura.$Event$.$Event$.prototype.$fire$ = bound;
    Aura.$Event$.$Event$.prototype["fire"] = bound
  }, function(orig) {
    Aura.$Event$.$Event$.prototype.$fire$ = orig;
    Aura.$Event$.$Event$.prototype["fire"] = orig
  }), "outputComponent":new Aura.$Utils$.$Override$(null, Aura.$Component$.$Component$.prototype.toJSON, true, function(bound) {
    Aura.$Component$.$Component$.prototype.toJSON = bound;
    Aura.$Component$.$Component$.prototype["toJSON"] = bound;
    Aura.$Component$.$Component$.prototype["_$getSelfGlobalId$"] = function() {
      return this.$globalId$
    };
    Aura.$Component$.$Component$.prototype["_$getRawValue$"] = function(key) {
      return this.$attributeSet$.$values$[key]
    }
  }, function(orig) {
    Aura.$Component$.$Component$.prototype.toJSON = orig;
    Aura.$Component$.$Component$.prototype["toJSON"] = orig;
    delete Aura.$Component$.$Component$.prototype["_$getSelfGlobalId$"];
    delete Aura.$Component$.$Component$.prototype["_$getRawValue$"]
  }), "StorageService.selectAdapter":new Aura.$Utils$.$Override$($A.$storageService$, $A.$storageService$.$selectAdapter$, false, function(bound) {
    $A.$storageService$.$selectAdapter$ = bound
  }, function(orig) {
    $A.$storageService$.$selectAdapter$ = orig
  }), "RenderingService.addDirtyValue":new Aura.$Utils$.$Override$($A.$renderingService$, $A.$renderingService$.$addDirtyValue$, false, function(bound) {
    $A.$renderingService$.$addDirtyValue$ = bound
  }, function(orig) {
    $A.$renderingService$.$addDirtyValue$ = orig
  }), "MetricsService.transaction":new Aura.$Utils$.$Override$($A.$metricsService$, $A.$metricsService$.transaction, false, function(bound) {
    $A.$metricsService$.transaction = bound
  }, function(orig) {
    $A.$metricsService$.transaction = orig
  }), "HtmlComopnent.dispatchAction":new Aura.$Utils$.$Override$(null, Aura.$Component$.$HtmlComponent$.prototype["helper"].$dispatchAction$, true, function(bound) {
    HtmlComponent.prototype["helper"].$dispatchAction$ = bound
  }, function(orig) {
    HtmlComponent.prototype["helper"].$dispatchAction$ = orig
  }), "ComponentService.indexComponent":new Aura.$Utils$.$Override$($A.$componentService$, $A.$componentService$.$indexComponent$, false, function(bound) {
    $A.$componentService$.$indexComponent$ = bound
  }, function(orig) {
    $A.$componentService$.$indexComponent$ = orig
  })}
};
(function bootstrap() {
  Aura.$bootstrapMark$("execAuraJs");
  window["$A"] = new AuraInstance
})();
window["aura"] = window["$A"];
var MemoryAdapter = function MemoryAdapter(config) {
  this.reset();
  this.$maxSize$ = config["maxSize"];
  this.$instanceName$ = config["name"];
  this.$debugLogging$ = config["debugLogging"]
};
MemoryAdapter["NAME"] = "memory";
MemoryAdapter.$LOG_LEVEL$ = {$INFO$:{id:0, $fn$:"log"}, $WARNING$:{id:1, $fn$:"warning"}};
MemoryAdapter.prototype.reset = function() {
  this.$backingStore$ = {};
  this.$mru$ = [];
  this.$cachedSize$ = 0
};
MemoryAdapter.prototype.getName = function() {
  return MemoryAdapter["NAME"]
};
MemoryAdapter.prototype.$initialize$ = function() {
  return Promise["resolve"]()
};
MemoryAdapter.prototype.$getSize$ = function() {
  return Promise["resolve"](this.$cachedSize$)
};
MemoryAdapter.prototype.$getItems$ = function(keys) {
  var that = this;
  return new Promise(function(resolve) {
    var store = that.$backingStore$;
    var updateMru = true;
    if(!Array.isArray(keys) || keys.length === 0) {
      keys = Object.keys(store);
      updateMru = false
    }
    var results = {};
    var key;
    var value;
    var innerItem;
    for(var i = 0;i < keys.length;i++) {
      key = keys[i];
      value = store[key];
      if(value) {
        innerItem = value.getItem();
        try {
          innerItem = JSON.parse($A["util"].$json$.$encode$(innerItem))
        }catch(ignore) {
        }
        results[key] = innerItem;
        if(updateMru) {
          that.$updateMRU$(key)
        }
      }
    }
    resolve(results)
  })
};
MemoryAdapter.prototype.$updateMRU$ = function(key) {
  var index = this.$mru$.indexOf(key);
  if(index > -1) {
    this.$mru$.splice(index, 1);
    this.$mru$.push(key)
  }
};
MemoryAdapter.prototype.$setItems$ = function(tuples) {
  var that = this;
  return new Promise(function(resolve) {
    var key;
    var item;
    var size;
    var existingItem;
    var mruIndex;
    var sizeDelta = 0;
    for(var i = 0;i < tuples.length;i++) {
      key = tuples[i][0];
      item = tuples[i][1];
      size = tuples[i][2];
      existingItem = that.$backingStore$[key];
      sizeDelta += size - (existingItem ? existingItem.$getSize$() : 0);
      that.$backingStore$[key] = new MemoryAdapter.$Entry$(item, size);
      mruIndex = that.$mru$.indexOf(key);
      if(mruIndex > -1) {
        that.$mru$.splice(mruIndex, 1)
      }
      that.$mru$.push(key)
    }
    that.$cachedSize$ += sizeDelta;
    var spaceNeeded = that.$cachedSize$ - that.$maxSize$;
    if(spaceNeeded > 0) {
      that.$expireCache$(spaceNeeded).$then$(undefined, function(e) {
        that.log(MemoryAdapter.$LOG_LEVEL$.$WARNING$, "setItems(): error during eviction", e)
      })
    }
    resolve()
  })
};
MemoryAdapter.prototype.$removeItems$ = function(keys) {
  var that = this;
  return new Promise(function(resolve) {
    for(var i = 0;i < keys.length;i++) {
      that.$removeItemInternal$(keys[i])
    }
    resolve()
  })
};
MemoryAdapter.prototype.$removeItemInternal$ = function(key) {
  var item = this.$backingStore$[key];
  if(item) {
    var index = this.$mru$.indexOf(key);
    if(index > -1) {
      this.$mru$.splice(index, 1)
    }
    this.$cachedSize$ -= item.$getSize$();
    delete this.$backingStore$[key]
  }
  return item
};
MemoryAdapter.prototype.clear = function() {
  var that = this;
  return new Promise(function(resolve) {
    that.reset();
    resolve()
  })
};
MemoryAdapter.prototype.$expireCache$ = function(spaceNeeded) {
  if(this.$mru$.length <= 0) {
    return Promise["resolve"]()
  }
  var that = this;
  return new Promise(function(resolve) {
    var spaceReclaimed = 0;
    var key;
    var item;
    var now = (new Date).getTime();
    for(key in that.$backingStore$) {
      var expires = that.$backingStore$[key].getItem()["expires"];
      if(now > expires) {
        item = that.$removeItemInternal$(key);
        spaceReclaimed += item.$getSize$();
        that.log(MemoryAdapter.$LOG_LEVEL$.$INFO$, "evict(): evicted expired item with key " + key)
      }
    }
    for(;spaceReclaimed < spaceNeeded && that.$mru$.length > 0;) {
      key = that.$mru$[0];
      item = that.$removeItemInternal$(key);
      spaceReclaimed += item.$getSize$();
      that.log(MemoryAdapter.$LOG_LEVEL$.$INFO$, "evict(): evicted for size item with key " + key)
    }
    resolve()
  })
};
MemoryAdapter.prototype.$getMRU$ = function() {
  return Promise["resolve"](this.$mru$)
};
MemoryAdapter.prototype.log = function(level, msg, obj) {
  if(this.$debugLogging$ || level.id >= MemoryAdapter.$LOG_LEVEL$.$WARNING$.id) {
    $A[level.$fn$]("MemoryAdapter['" + this.$instanceName$ + "'] " + msg, obj)
  }
};
MemoryAdapter.prototype.$sweep$ = function() {
  return this.$expireCache$(0)
};
MemoryAdapter.prototype.$deleteStorage$ = function() {
  this.reset();
  return Promise["resolve"]()
};
MemoryAdapter.prototype.$isSecure$ = function() {
  return true
};
MemoryAdapter.prototype.$isPersistent$ = function() {
  return false
};
MemoryAdapter.$Entry$ = function Entry(item, size) {
  this.item = JSON.parse($A["util"].$json$.$encode$(item));
  this.size = size
};
MemoryAdapter.$Entry$.prototype.getItem = function() {
  return this.item
};
MemoryAdapter.$Entry$.prototype.$getSize$ = function() {
  return this.size
};
$A.$storageService$.$registerAdapter$({"name":MemoryAdapter["NAME"], "adapterClass":MemoryAdapter, "secure":true});
Aura.$Storage$.$MemoryAdapter$ = MemoryAdapter;
var IndexedDBAdapter = function IndexedDBAdapter(config) {
  this.$instanceName$ = config["name"];
  this.$sizeMax$ = config["maxSize"];
  this.$debugLogging$ = config["debugLogging"];
  this.$keyPrefix$ = config["keyPrefix"];
  this.db = undefined;
  this.$ready$ = undefined;
  this.$initializePromise$ = undefined;
  this.$sizeLastReal$ = 0;
  this.$sizeGuess$ = 0;
  this.$sizeErrorBar$ = 0;
  this.$sizeAge$ = 1E6;
  this.$sizeAvg$ = 100;
  this.$sizeMistake$ = 0;
  this.$sizeMistakeMax$ = 0;
  this.$sizeMistakeCount$ = 0;
  this.$sizeOutsideErrorBar$ = 0;
  this.$lastSweep$ = 0;
  this.$sweepInterval$ = 15 * 60 * 1E3;
  this.$expiresFudge$ = 1E4;
  this.$limitSweepHigh$ = 0.9 * this.$sizeMax$;
  this.$limitSweepLow$ = 0.7 * this.$sizeMax$;
  this.$limitError$ = 0.5 * this.$sizeMax$;
  var context = $A.getContext();
  var tableName = config["partitionName"] || context && (context.$app$ || context.$cmp$);
  tableName = tableName || window["Aura"]["app"];
  this.$tableName$ = tableName || "store";
  this.$sweepingSuspended$ = false;
  this.$initializeTimeoutId$ = undefined
};
IndexedDBAdapter["NAME"] = "indexeddb";
IndexedDBAdapter.$LOG_LEVEL$ = {$INFO$:{id:0, $fn$:"log"}, $WARNING$:{id:1, $fn$:"warning"}};
IndexedDBAdapter.$INITIALIZE_TIMEOUT$ = 30 * 1E3;
IndexedDBAdapter.$OBJECTSTORE__TRANSACTION_THRESHOLD$ = 500;
IndexedDBAdapter.prototype.getName = function() {
  return IndexedDBAdapter["NAME"]
};
IndexedDBAdapter.prototype.$initialize$ = function() {
  if(this.$initializePromise$) {
    return this.$initializePromise$
  }
  var that = this;
  this.$initializePromise$ = new Promise(function(resolve, reject) {
    that.$initializePromiseResolve$ = resolve;
    that.$initializePromiseReject$ = reject
  });
  this.$initializeInternal$();
  return this.$initializePromise$
};
IndexedDBAdapter.prototype.$initializeInternal$ = function(version, transactionTimer) {
  var dbRequest;
  var that = this;
  if(!transactionTimer) {
    transactionTimer = this.$thresholdMetricTimer$("performance:storage-indexeddb-open-transaction");
    transactionTimer.info = {"wasBlocked":false, "wasUpgraded":false}
  }
  if(!this.$initializeTimeoutId$) {
    this.$initializeTimeoutId$ = setTimeout(function() {
      var message = "initializeInternal(): timed out setting up DB";
      that.log(IndexedDBAdapter.$LOG_LEVEL$.$WARNING$, message);
      transactionTimer.info["failureCause"] = "timedout";
      that.$initializeComplete$(false, message, transactionTimer)
    }, IndexedDBAdapter.$INITIALIZE_TIMEOUT$)
  }
  if(version) {
    dbRequest = window.indexedDB.open(this.$instanceName$, version)
  }else {
    dbRequest = window.indexedDB.open(this.$instanceName$)
  }
  dbRequest.onupgradeneeded = function(e) {
    that.$createTables$(e);
    transactionTimer.info["wasUpgraded"] = true
  };
  dbRequest.onsuccess = function(e) {
    that.$setupDB$(e, transactionTimer)
  };
  dbRequest.onerror = function(e) {
    var message = "initializeInternal(): error opening DB";
    message += e.target.error && e.target.error.message ? ": " + e.target.error.message : "";
    that.log(IndexedDBAdapter.$LOG_LEVEL$.$WARNING$, message);
    transactionTimer.info["failureCause"] = "error";
    that.$initializeComplete$(false, message, transactionTimer);
    e.preventDefault && e.preventDefault()
  };
  dbRequest.onblocked = function() {
    var message = "initializeInternal(): blocked from opening DB, most likely by another open browser tab";
    that.log(IndexedDBAdapter.$LOG_LEVEL$.$WARNING$, message);
    transactionTimer.info["wasBlocked"] = true
  }
};
IndexedDBAdapter.prototype.$getSize$ = function() {
  $A.assert(this.$ready$, "IndexedDBAdapter.getSize() called with this.ready\x3d" + this.$ready$);
  var that = this;
  if(this.$sizeAge$ < 50) {
    return Promise["resolve"](this.$sizeGuess$)
  }else {
    return new Promise(function(resolve, reject) {
      that.$walkInternal$(resolve, reject, false)
    })
  }
};
IndexedDBAdapter.prototype.$getItems$ = function(keys) {
  $A.assert(this.$ready$, "IndexedDBAdapter.getItems() called with this.ready\x3d" + this.$ready$);
  var that = this;
  return new Promise(function(resolve, reject) {
    if(!Array.isArray(keys) || keys.length === 0) {
      that.$walkInternal$(resolve, reject, true)
    }else {
      that.$getItemsInternal$(keys, resolve, reject)
    }
  })
};
IndexedDBAdapter.prototype.$suspendSweeping$ = function() {
  this.$sweepingSuspended$ = true
};
IndexedDBAdapter.prototype.$resumeSweeping$ = function() {
  this.$sweepingSuspended$ = false
};
IndexedDBAdapter.prototype.$isSecure$ = function() {
  return false
};
IndexedDBAdapter.prototype.$isPersistent$ = function() {
  return true
};
IndexedDBAdapter.prototype.$sweep$ = function() {
  $A.assert(this.$ready$, "IndexedDBAdapter.sweep() called with this.ready\x3d" + this.$ready$);
  var that = this;
  return new Promise(function(resolve, reject) {
    that.$expireCache$(0, resolve, reject)
  })
};
IndexedDBAdapter.prototype.$setupDB$ = function(event, transactionTimer) {
  var db = event.target.result;
  var that = this;
  this.db = db;
  this.db.onerror = function(e) {
    that.log(IndexedDBAdapter.$LOG_LEVEL$.$WARNING$, "setupDB(): error event received", e)
  };
  this.db.onabort = function(e) {
    that.log(IndexedDBAdapter.$LOG_LEVEL$.$WARNING$, "setupDB(): abort event received", e)
  };
  this.db.onversionchange = function(e) {
    that.log(IndexedDBAdapter.$LOG_LEVEL$.$INFO$, "setupDB(): onversionchanged event received", e);
    e.target.close()
  };
  if(!db.objectStoreNames.contains(this.$tableName$)) {
    var currentVersion = db["version"];
    db.close();
    this.$initializeInternal$(currentVersion + 1, transactionTimer)
  }else {
    this.$initializeComplete$(true, null, transactionTimer)
  }
};
IndexedDBAdapter.prototype.$createTables$ = function(event) {
  var db = event.target.result;
  var transaction = event.target.transaction;
  var objectStore;
  if(!db.objectStoreNames.contains(this.$tableName$)) {
    objectStore = db.createObjectStore(this.$tableName$, {"keyPath":"key"})
  }else {
    if(transaction) {
      objectStore = transaction.objectStore(this.$tableName$)
    }
  }
  if(objectStore) {
    if(!objectStore.indexNames.contains("expires")) {
      objectStore.createIndex("expires", "expires", {"unique":false})
    }
  }
};
IndexedDBAdapter.prototype.$initializeComplete$ = function(ready, errorMessage, transactionTimer) {
  if(this.$ready$ !== undefined) {
    return
  }
  this.$ready$ = !!ready;
  transactionTimer.info["initSucceeded"] = this.$ready$;
  transactionTimer.end(transactionTimer.info);
  clearTimeout(this.$initializeTimeoutId$);
  if(this.$ready$) {
    this.$initializePromiseResolve$()
  }else {
    this.$initializePromiseReject$(new Error(errorMessage))
  }
  delete this.$initializePromiseResolve$;
  delete this.$initializePromiseReject$
};
IndexedDBAdapter.prototype.$cleanseKeys$ = function(keys) {
  var cleansed = [];
  for(var k = 0;k < keys.length;k++) {
    var key = keys[k];
    if(typeof key === "string") {
      key = key.replace(/{.*}/, "PARAMS_REMOVED")
    }
    cleansed.push(key)
  }
  return cleansed
};
IndexedDBAdapter.prototype.$getItemsInternal$ = function(keys, resolve, reject) {
  function collector(event) {
    var stored = event.target.result || {};
    var key = stored["key"];
    var item = stored["item"];
    if(key) {
      results[key] = item
    }
    collected++;
    if(collected === keys.length) {
      transactionTimer.end({"keys":that.$cleanseKeys$(keys), "collected":collected});
      resolve(results);
      return
    }
  }
  var transactionTimer = this.$thresholdMetricTimer$("performance:storage-indexeddb-getItems-read-transaction");
  var transaction = this.db.transaction([this.$tableName$], "readonly");
  var objectStore = transaction.objectStore(this.$tableName$);
  var that = this;
  var results = {};
  var collected = 0;
  transaction.onabort = function() {
    var message = "getItemsInternal(): transaction aborted for keys [" + keys + "]: " + transaction.error;
    that.log(IndexedDBAdapter.$LOG_LEVEL$.$WARNING$, message);
    reject(new Error("IndexedDBAdapter." + message))
  };
  transaction.onerror = function() {
    var message = "getItemsInternal(): transaction error for keys [" + keys + "]: " + transaction.error;
    that.log(IndexedDBAdapter.$LOG_LEVEL$.$WARNING$, message);
    reject(new Error("IndexedDBAdapter." + message))
  };
  var objectStoreRequest;
  for(var i = 0;i < keys.length;i++) {
    objectStoreRequest = objectStore.get(keys[i]);
    objectStoreRequest.onsuccess = collector
  }
};
IndexedDBAdapter.prototype.$walkInternal$ = function(resolve, reject, sendResult) {
  var transactionTimer = this.$thresholdMetricTimer$("performance:storage-indexeddb-walkInternal-read-transaction");
  var transaction = this.db.transaction([this.$tableName$], "readonly");
  var objectStore = transaction.objectStore(this.$tableName$);
  var cursor = objectStore.openCursor();
  var result = {};
  var count = 0;
  var size = 0;
  var that = this;
  cursor.onsuccess = function(event) {
    var icursor = event.target.result;
    if(icursor) {
      var stored = icursor.value;
      if(stored) {
        size += stored["size"];
        count += 1;
        if(sendResult && stored["key"].indexOf(that.$keyPrefix$) === 0) {
          result[stored["key"]] = stored["item"]
        }
      }
      icursor["continue"]()
    }else {
      transactionTimer.end({"count":count, "size":size});
      that.$refreshSize$(size, count);
      if(that.$sizeGuess$ > that.$limitSweepHigh$) {
        that.$expireCache$(0)
      }
      if(sendResult) {
        resolve(result)
      }else {
        resolve(that.$sizeGuess$)
      }
    }
  };
  cursor.onerror = function(event) {
    reject(new Error("IndexedDBAdapter.walkInternal: Transaction failed: " + event.error))
  };
  cursor.onabort = function(event) {
    reject(new Error("IndexedDBAdapter.walkInternal: Transaction aborted: " + event.error))
  }
};
IndexedDBAdapter.prototype.$setItems$ = function(tuples) {
  $A.assert(this.$ready$, "IndexedDBAdapter.setItems() called with this.ready\x3d" + this.$ready$);
  var that = this;
  return new Promise(function(resolve, reject) {
    function collector() {
      collected++;
      if(collected === tuples.length) {
        transactionTimer.end({"collected":collected, "storables":storables.length, "first_key":that.$cleanseKeys$(tuples[0])[0]});
        that.$updateSize$(sizes / 2, sizes / 2);
        resolve();
        return
      }
    }
    var i;
    var sizes = 0;
    var storables = [];
    var storable;
    for(i = 0;i < tuples.length;i++) {
      storable = that.$encodeStorable$(tuples[i]);
      sizes += storable["size"];
      storables.push(storable)
    }
    if(sizes + that.$sizeGuess$ + that.$sizeErrorBar$ > that.$limitSweepHigh$ || that.$sizeErrorBar$ > that.$limitError$) {
      that.$expireCache$(sizes)
    }
    var transactionTimer = that.$thresholdMetricTimer$("performance:storage-indexeddb-setItems-write-transaction");
    var transaction = that.db.transaction([that.$tableName$], "readwrite");
    var objectStore = transaction.objectStore(that.$tableName$);
    var collected = 0;
    transaction.onabort = function() {
      var keys = tuples.map(function(tuple) {
        return tuple[0]
      });
      var message = "setItemsInternal(): transaction aborted for keys [" + keys + "]: " + transaction.error;
      that.log(IndexedDBAdapter.$LOG_LEVEL$.$WARNING$, message);
      reject(new Error("IndexedDBAdapter." + message))
    };
    transaction.onerror = function() {
      var keys = tuples.map(function(tuple) {
        return tuple[0]
      });
      var message = "setItemsInternal(): transaction error for keys [" + keys + "]: " + transaction.error;
      that.log(IndexedDBAdapter.$LOG_LEVEL$.$WARNING$, message);
      reject(new Error("IndexedDBAdapter." + message))
    };
    var objectStoreRequest;
    for(i = 0;i < storables.length;i++) {
      objectStoreRequest = objectStore.put(storables[i]);
      objectStoreRequest.onsuccess = collector
    }
  })
};
IndexedDBAdapter.prototype.$removeItems$ = function(keys) {
  $A.assert(this.$ready$, "IndexedDBAdapter.removeItems() called with this.ready\x3d" + this.$ready$);
  var that = this;
  return new Promise(function(resolve, reject) {
    function collector() {
      collected++;
      if(collected === keys.length) {
        transactionTimer.end({"collected":collected, "keys":that.$cleanseKeys$(keys)});
        that.$updateSize$(-sizeAvg, sizeAvg);
        resolve();
        return
      }
    }
    var transactionTimer = that.$thresholdMetricTimer$("performance:storage-indexeddb-removeItems-write-transaction");
    var transaction = that.db.transaction([that.$tableName$], "readwrite");
    var objectStore = transaction.objectStore(that.$tableName$);
    var sizeAvg = that.$sizeAvg$;
    var collected = 0;
    transaction.onabort = function() {
      var message = "removeItemsInternal(): transaction aborted for keys [" + keys + "]: " + transaction.error;
      that.log(IndexedDBAdapter.$LOG_LEVEL$.$WARNING$, message);
      reject(new Error("IndexedDBAdapter." + message))
    };
    transaction.onerror = function() {
      var message = "removeItemsInternal(): transaction error for keys [" + keys + "]: " + transaction.error;
      that.log(IndexedDBAdapter.$LOG_LEVEL$.$WARNING$, message);
      reject(new Error("IndexedDBAdapter." + message))
    };
    var objectStoreRequest;
    for(var i = 0;i < keys.length;i++) {
      objectStoreRequest = objectStore["delete"](keys[i]);
      objectStoreRequest.onsuccess = collector
    }
  })
};
IndexedDBAdapter.prototype.clear = function() {
  $A.assert(this.$ready$, "IndexedDBAdapter.clear() called with this.ready\x3d" + this.$ready$);
  var that = this;
  return new Promise(function(resolve, reject) {
    var transactionTimer = that.$thresholdMetricTimer$("performance:storage-indexeddb-clear-write-transaction");
    var transaction = that.db.transaction([that.$tableName$], "readwrite");
    var objectStore = transaction.objectStore(that.$tableName$);
    objectStore.clear();
    that.$setSize$(0, 0);
    transaction.onabort = function() {
      reject(new Error("IndexedDBAdapter.clear(): Transaction aborted: " + transaction.error))
    };
    transaction.oncomplete = function() {
      transactionTimer.end({});
      resolve()
    };
    transaction.onerror = function() {
      reject(new Error("IndexedDBAdapter.clear(): Transaction failed: " + transaction.error))
    }
  })
};
IndexedDBAdapter.prototype.$expireCache$ = function(requestedSize, resolve, reject) {
  var now = (new Date).getTime();
  if(this.$sweepingSuspended$ || this.$lastSweep$ + this.$sweepInterval$ > now && this.$sizeGuess$ < this.$limitSweepHigh$) {
    if(resolve) {
      resolve()
    }
    return
  }
  var actionsBlackList = ["globalValueProviders", "$AuraClientService.token$", "$AuraClientService.bootstrap$"];
  this.$lastSweep$ = now;
  try {
    var transactionTimer = this.$thresholdMetricTimer$("performance:storage-indexeddb-expireCache-read-transaction");
    var transaction = this.db.transaction([this.$tableName$], "readonly");
    var objectStore = transaction.objectStore(this.$tableName$);
    var index = objectStore.index("expires");
    var cursor = index.openCursor();
    var count = 0;
    var size = 0;
    var expiredSize = 0;
    var expireDate = now + this.$expiresFudge$;
    var that = this;
    var removeSize = requestedSize || 0;
    var keysToDelete = [];
    if(this.$sizeGuess$ > this.$limitSweepLow$) {
      removeSize += this.$sizeGuess$ - this.$limitSweepLow$
    }
    this.log(IndexedDBAdapter.$LOG_LEVEL$.$INFO$, "expireCache(): sweeping to remove " + removeSize);
    cursor.onsuccess = function(event) {
      var icursor = event.target.result;
      if(icursor) {
        var stored = icursor.value;
        if(stored) {
          var shouldEvict = false;
          if(stored["expires"] < expireDate || expiredSize < removeSize || stored["key"].indexOf(that.$keyPrefix$) !== 0) {
            shouldEvict = true;
            if(that.$instanceName$ === "actions") {
              for(var i = 0;i < actionsBlackList.length;i++) {
                if(icursor.primaryKey.indexOf(actionsBlackList[i]) > -1) {
                  shouldEvict = false;
                  break
                }
              }
            }
          }
          if(shouldEvict) {
            that.log(IndexedDBAdapter.$LOG_LEVEL$.$INFO$, "expireCache(): sweep removing " + icursor.primaryKey);
            keysToDelete.push(icursor.primaryKey);
            expiredSize += stored["size"]
          }else {
            size += stored["size"];
            count += 1
          }
        }
        icursor["continue"]()
      }else {
        transactionTimer.end({"size":size, "count":count});
        that.$refreshSize$(size, count);
        if(keysToDelete.length > 0) {
          that.$removeItems$(keysToDelete)
        }
        if(resolve) {
          resolve()
        }
        if(size > that.$limitSweepHigh$) {
          that.$expireCache$(0)
        }
      }
    };
    cursor.onerror = function(event) {
      if(reject) {
        reject(new Error("IndexedDBAdapter.getAll: Transaction failed: " + event.error))
      }
    };
    cursor.onabort = function(event) {
      if(reject) {
        reject(new Error("IndexedDBAdapter.getAll: Transaction aborted: " + event.error))
      }
    }
  }catch(e) {
    throw e;
  }
};
IndexedDBAdapter.prototype.$updateSize$ = function(sizeChange, error) {
  this.$sizeGuess$ += sizeChange;
  this.$sizeErrorBar$ += error;
  this.$sizeAge$ += 1
};
IndexedDBAdapter.prototype.$refreshSize$ = function(size, count) {
  var mistake = this.$sizeGuess$ - size;
  if(mistake < 0) {
    mistake = -mistake
  }
  if(mistake > this.$sizeMistakeMax$) {
    this.$sizeMistakeMax$ = mistake
  }
  this.$sizeMistake$ += mistake;
  this.$sizeMistakeCount$ += 1;
  if(mistake > this.$sizeErrorBar$) {
    this.$sizeOutsideErrorBar$ += 1
  }
  this.log(IndexedDBAdapter.$LOG_LEVEL$.$INFO$, "refreshSize(): size calculation: current mistake \x3d " + mistake + ", avg mistake \x3d " + (this.$sizeMistake$ / this.$sizeMistakeCount$).toFixed(1) + ", max mistake \x3d " + this.$sizeMistakeMax$ + ", outside error bars \x3d " + this.$sizeOutsideErrorBar$);
  this.$setSize$(size, count)
};
IndexedDBAdapter.prototype.$setSize$ = function(size, count) {
  this.$sizeLastReal$ = size;
  this.$sizeGuess$ = size;
  this.$sizeErrorBar$ = 0;
  this.$sizeAge$ = 0;
  if(count > 0) {
    this.$sizeAvg$ = size / count
  }
};
IndexedDBAdapter.prototype.$decodeStorable$ = function(stored) {
  return{"key":stored["key"], "value":stored["item"]}
};
IndexedDBAdapter.prototype.$encodeStorable$ = function(tuple) {
  return{"key":tuple[0], "item":tuple[1], "size":tuple[2], "expires":tuple[1]["expires"]}
};
IndexedDBAdapter.prototype.log = function(level, msg, obj) {
  if(this.$debugLogging$ || level.id >= IndexedDBAdapter.$LOG_LEVEL$.$WARNING$.id) {
    $A[level.$fn$]("IndexedDBAdapter['" + this.$instanceName$ + "'] " + msg, obj)
  }
};
IndexedDBAdapter.prototype.$thresholdMetricTimer$ = function(name) {
  var startTime = (new Date).getTime();
  var startVisibility = document.visibilityState === "visible";
  return{end:function(info) {
    var elapsed = (new Date).getTime() - startTime;
    if(elapsed > IndexedDBAdapter.$OBJECTSTORE__TRANSACTION_THRESHOLD$) {
      info["elapsed"] = elapsed;
      info["visibilityStateStart"] = startVisibility;
      info["visibilityStateEnd"] = document.visibilityState === "visible";
      $A.$metricsService$.transaction("aura", name, {"context":{"attributes":info}})
    }
  }}
};
IndexedDBAdapter.prototype.$deleteStorage$ = function() {
  $A.assert(this.$ready$, "IndexedDBAdapter.deleteStorage() called with this.ready\x3d" + this.$ready$);
  var that = this;
  return new Promise(function(resolve, reject) {
    that.db.close();
    var dbRequest = window.indexedDB.deleteDatabase(that.$instanceName$);
    dbRequest.onerror = function() {
      var message = "deleteStorage(): delete database error";
      that.log(IndexedDBAdapter.$LOG_LEVEL$.$WARNING$, message);
      reject(new Error("IndexedDBAdapter." + message))
    };
    dbRequest.onsuccess = function() {
      that.log(IndexedDBAdapter.$LOG_LEVEL$.$INFO$, "deleteStorage(): deleted successfully");
      resolve()
    };
    dbRequest.onblocked = function() {
      that.log(IndexedDBAdapter.$LOG_LEVEL$.$INFO$, "deleteStorage(): blocked from being deleted")
    }
  })
};
IndexedDBAdapter.$register$ = function() {
  if(navigator.userAgent.indexOf("AppleWebKit") !== -1 && navigator.userAgent.indexOf("Chrome") === -1) {
    return
  }
  if(!window.indexedDB) {
    return
  }
  $A.$storageService$.$registerAdapter$({"name":IndexedDBAdapter["NAME"], "adapterClass":IndexedDBAdapter, "persistent":true})
};
IndexedDBAdapter.$register$();
Aura.$Storage$.$IndexedDBAdapter$ = IndexedDBAdapter;
function CryptoAdapter(config) {
  this.$instanceName$ = config["name"];
  this.$debugLogging$ = config["debugLogging"];
  this.key = undefined;
  this.$encoder$ = new window["TextEncoder"];
  this.$decoder$ = new window["TextDecoder"];
  this.$initializePromise$ = undefined;
  var adapterClass = $A.$storageService$.$getAdapterConfig$(Aura.$Storage$.$IndexedDBAdapter$["NAME"])["adapterClass"];
  this.$adapter$ = new adapterClass(config);
  this.$adapterAntiObfuscation$(this.$adapter$);
  var that = this;
  this.$adapterInitializePromise$ = this.$adapter$.$initialize$().$then$(function() {
    that.log(CryptoAdapter.$LOG_LEVEL$.$INFO$, "adapter.initialize(): internal IndexedDB adapter initialization completed")
  }, function(e) {
    that.log(CryptoAdapter.$LOG_LEVEL$.$INFO$, "adapter.initialize(): internal IndexedDB adapter initialization failed: " + e);
    throw e;
  })
}
CryptoAdapter["NAME"] = "crypto";
CryptoAdapter.$LOG_LEVEL$ = {$INFO$:{id:0, $fn$:"log"}, $WARNING$:{id:1, $fn$:"warning"}};
CryptoAdapter.$ALGO$ = "AES-CBC";
CryptoAdapter.$IV_LENGTH$ = 16;
CryptoAdapter.$SENTINEL$ = "cryptoadapter";
CryptoAdapter.$initializeEngine$ = function() {
  if(window["msCrypto"] && !window["crypto"]) {
    window["crypto"] = {};
    window["crypto"]["subtle"] = {};
    window["crypto"]["subtle"]["importKey"] = function(format, keyData, algorithm, extractable, keyUsages) {
      return new Promise(function(resolve, reject) {
        var op = window["msCrypto"]["subtle"]["importKey"](format, keyData, algorithm, extractable, keyUsages);
        op.onerror = function() {
          reject(new Error("Failed to importKey"))
        };
        op.oncomplete = function(evt) {
          resolve(evt.target.result)
        }
      })
    };
    window["crypto"]["subtle"]["encrypt"] = function(algorithm, key, buffer) {
      return new Promise(function(resolve, reject) {
        var op = window["msCrypto"]["subtle"]["encrypt"](algorithm, key, buffer);
        op.onerror = function() {
          reject(new Error("Failed to encrypt"))
        };
        op.oncomplete = function(evt) {
          resolve(evt.target.result)
        };
        if(!buffer || buffer.byteLength === 0) {
          op.finish()
        }
      })
    };
    window["crypto"]["subtle"]["decrypt"] = function(algorithm, key, buffer) {
      return new Promise(function(resolve, reject) {
        var op = window["msCrypto"]["subtle"]["decrypt"](algorithm, key, buffer);
        op.onerror = function() {
          reject(new Error("Failed to decrypt"))
        };
        op.oncomplete = function(evt) {
          resolve(evt.target.result)
        };
        if(!buffer || buffer.byteLength === 0) {
          op.finish()
        }
      })
    };
    window["crypto"]["getRandomValues"] = window["msCrypto"]["getRandomValues"].bind(window["msCrypto"])
  }
  CryptoAdapter.$engine$ = window["crypto"] && (window["crypto"]["subtle"] || window["crypto"]["webkitSubtle"])
};
CryptoAdapter.$initializeEngine$();
CryptoAdapter.key = new Promise(function(resolve, reject) {
  CryptoAdapter.$_keyResolve$ = resolve;
  CryptoAdapter.$_keyReject$ = reject
});
CryptoAdapter["setKey"] = function(rawKey) {
  var resolve = CryptoAdapter.$_keyResolve$;
  var reject = CryptoAdapter.$_keyReject$;
  var log;
  delete CryptoAdapter["setKey"];
  delete CryptoAdapter.$_keyResolve$;
  delete CryptoAdapter.$_keyReject$;
  if(!(rawKey instanceof ArrayBuffer)) {
    var type = !rawKey ? typeof rawKey : rawKey.constructor.name;
    log = "CryptoAdapter cannot import key of wrong type (" + type + "), rejecting";
    $A.$warning$(log);
    reject(new Error(log));
    return
  }
  CryptoAdapter.$engine$["importKey"]("raw", rawKey, CryptoAdapter.$ALGO$, false, ["encrypt", "decrypt"])["then"](function(key) {
    if(!key) {
      log = "CryptoAdapter crypto.importKey() returned no key, rejecting";
      $A.$warning$(log);
      reject(new Error(log));
      return
    }
    $A.log("CryptoAdapter crypto.importKey() successfully imported key");
    resolve(key)
  }, function(e) {
    log = "CryptoAdapter crypto.importKey() failed, rejecting: " + e;
    $A.$warning$(log);
    reject(new Error(log))
  })
};
CryptoAdapter["register"] = function() {
  if($A.$storageService$.$isRegisteredAdapter$(CryptoAdapter["NAME"])) {
    $A.$warning$("CryptoAdapter already registered");
    return
  }
  if(!$A.$storageService$.$isRegisteredAdapter$(Aura.$Storage$.$IndexedDBAdapter$["NAME"])) {
    $A.$warning$("CryptoAdapter cannot register because it requires IndexedDB");
    return
  }
  var secure = window.location.href.indexOf("https") === 0 || window.location.hostname === "localhost";
  if(!secure) {
    $A.$warning$("CryptoAdapter cannot register because it requires a secure origin");
    return
  }
  if(!CryptoAdapter.$engine$) {
    $A.$warning$("CryptoAdapter cannot register because it requires Web Cryptography API");
    return
  }
  $A.$storageService$.$registerAdapter$({"name":CryptoAdapter["NAME"], "adapterClass":CryptoAdapter, "secure":true, "persistent":true})
};
CryptoAdapter.prototype.getName = function() {
  return CryptoAdapter["NAME"]
};
CryptoAdapter.prototype.$initialize$ = function() {
  if(this.$initializePromise$) {
    return this.$initializePromise$
  }
  this.$initializePromise$ = this.$initializeInternal$();
  return this.$initializePromise$
};
CryptoAdapter.prototype.$initializeInternal$ = function() {
  var that = this;
  if(!$A["util"].$isLocalStorageEnabled$()) {
    return Promise["reject"](new Error("localStorage is disabled"))
  }
  return Promise["all"]([CryptoAdapter.key, this.$adapterInitializePromise$]).$then$(function keyReceived(values) {
    var key = values[0];
    if(!key) {
      throw new Error("CryptoAdapter.key resolved with no key.");
    }
    that.key = key
  }).$then$(function verifySentinel() {
    function handleInvalidSentinel() {
      that.log(CryptoAdapter.$LOG_LEVEL$.$INFO$, "initialize(): encryption key is different so clearing storage");
      $A.$metricsService$.transaction("aura", "performance:cryptoStorage-keymismatch");
      return that.clear()
    }
    that.log(CryptoAdapter.$LOG_LEVEL$.$INFO$, "initialize(): verifying sentinel");
    return that.$getItems$([CryptoAdapter.$SENTINEL$], true).$then$(function(values) {
      if(!values[CryptoAdapter.$SENTINEL$] || values[CryptoAdapter.$SENTINEL$].value !== CryptoAdapter.$SENTINEL$) {
        return handleInvalidSentinel()
      }
    }, handleInvalidSentinel)
  }).$then$(function storeSentinel() {
    return that.$setSentinelItem$()
  })
};
CryptoAdapter.prototype.$getSize$ = function() {
  return this.$adapter$.$getSize$()
};
CryptoAdapter.prototype.$getItems$ = function(keys, includeInternalKeys) {
  var that = this;
  return this.$adapter$.$getItems$(keys).$then$(function(values) {
    function decryptSucceeded(k, decryptedValue) {
      if(k !== CryptoAdapter.$SENTINEL$ || includeInternalKeys) {
        decrypted[k] = decryptedValue
      }
    }
    function decryptFailed() {
    }
    var decrypted = {};
    var promises = [];
    var promise;
    var value;
    for(var key in values) {
      value = values[key];
      if($A["util"].$isUndefinedOrNull$(value)) {
      }else {
        promise = that.$decrypt$(key, value).$then$(decryptSucceeded.bind(undefined, key), decryptFailed);
        promises.push(promise)
      }
    }
    return Promise["all"](promises).$then$(function() {
      return decrypted
    })
  })
};
CryptoAdapter.prototype.$decrypt$ = function(key, value) {
  var that = this;
  if(!value || !value["value"]) {
    return Promise["reject"](new Error("CryptoAdapter.decrypt() value is malformed for key" + key))
  }
  return CryptoAdapter.$engine$["decrypt"]({"name":CryptoAdapter.$ALGO$, "iv":value["value"]["iv"]}, that.key, value["value"]["cipher"]).$then$(function(decrypted) {
    var obj = that.$arrayBufferToObject$(new Uint8Array(decrypted));
    return{"expires":value["expires"], "value":obj}
  }, function(err) {
    that.log(CryptoAdapter.$LOG_LEVEL$.$WARNING$, "decrypt(): decryption failed for key " + key, err);
    throw new Error(err);
  })
};
CryptoAdapter.prototype.$objectToArrayBuffer$ = function(o) {
  if(o === undefined) {
    return new ArrayBuffer(0)
  }
  var str = $A["util"].$json$.$encode$(o);
  return this.$encoder$["encode"](str)
};
CryptoAdapter.prototype.$encodeValue$ = function(o) {
  return this.$objectToArrayBuffer$(o)
};
CryptoAdapter.prototype.$arrayBufferToObject$ = function(ab) {
  var str = this.$decoder$["decode"](ab);
  if(str === "") {
    return undefined
  }
  return JSON.parse(str)
};
CryptoAdapter.prototype.$setSentinelItem$ = function() {
  var now = (new Date).getTime();
  var tuple = [CryptoAdapter.$SENTINEL$, {"value":CryptoAdapter.$SENTINEL$, "created":now, "expires":now + 15768E6}, 0];
  return this.$setItems$([tuple])
};
CryptoAdapter.prototype.$encryptToTuple$ = function(tuple) {
  var that = this;
  return new Promise(function(resolve, reject) {
    var itemArrayBuffer;
    try {
      if(!tuple[1]["valueEncoded"]) {
        itemArrayBuffer = that.$objectToArrayBuffer$(tuple[1]["value"])
      }else {
        itemArrayBuffer = tuple[1]["value"]
      }
    }catch(e) {
      that.log(CryptoAdapter.$LOG_LEVEL$.$WARNING$, "encryptToTuple(): serialization failed for key " + tuple[0], e);
      reject(e);
      return
    }
    var iv = window["crypto"]["getRandomValues"](new Uint8Array(CryptoAdapter.$IV_LENGTH$));
    CryptoAdapter.$engine$["encrypt"]({"name":CryptoAdapter.$ALGO$, "iv":iv}, that.key, itemArrayBuffer).$then$(function(encrypted) {
      var storable = {"expires":tuple[1]["expires"], "value":{"iv":iv, "cipher":encrypted}};
      resolve([tuple[0], storable, tuple[2]])
    }, function(err) {
      that.log(CryptoAdapter.$LOG_LEVEL$.$WARNING$, "encryptToTuple(): encryption failed for key " + tuple[0], err);
      reject(err)
    })
  })
};
CryptoAdapter.prototype.$setItems$ = function(tuples) {
  var promises = [];
  var tuple;
  for(var i = 0;i < tuples.length;i++) {
    tuple = tuples[i];
    promises.push(this.$encryptToTuple$(tuple))
  }
  var that = this;
  return Promise["all"](promises).$then$(function(encryptedTuples) {
    return that.$adapter$.$setItems$(encryptedTuples)
  }, function(err) {
    var keys = tuples.map(function(t) {
      return t[0]
    });
    that.log(CryptoAdapter.$LOG_LEVEL$.$WARNING$, "setItemsInternal(): transaction error for keys " + keys.toString(), err);
    throw err;
  })
};
CryptoAdapter.prototype.$removeItems$ = function(keys) {
  return this.$adapter$.$removeItems$(keys)
};
CryptoAdapter.prototype.clear = function() {
  var that = this;
  return this.$adapter$.clear().$then$(function() {
    return that.$setSentinelItem$()
  })
};
CryptoAdapter.prototype.$sweep$ = function() {
  var that = this;
  return this.$adapter$.$sweep$().$then$(function() {
    return that.$setSentinelItem$()
  })
};
CryptoAdapter.prototype.$deleteStorage$ = function() {
  return this.$adapter$.$deleteStorage$()
};
CryptoAdapter.prototype.$suspendSweeping$ = function() {
  if(this.$adapter$.$suspendSweeping$) {
    this.$adapter$.$suspendSweeping$()
  }
};
CryptoAdapter.prototype.$resumeSweeping$ = function() {
  if(this.$adapter$.$resumeSweeping$) {
    this.$adapter$.$resumeSweeping$()
  }
};
CryptoAdapter.prototype.$isSecure$ = function() {
  return true
};
CryptoAdapter.prototype.$isPersistent$ = function() {
  return true
};
CryptoAdapter.prototype.log = function(level, msg, obj) {
  if(this.$debugLogging$ || level.id >= CryptoAdapter.$LOG_LEVEL$.$WARNING$.id) {
    $A[level.$fn$]("CryptoAdapter['" + this.$instanceName$ + "']" + msg, obj)
  }
};
CryptoAdapter.prototype.$adapterAntiObfuscation$ = function(adapter) {
  adapter.$initialize$ = adapter.$initialize$ || adapter["initialize"];
  adapter.getName = adapter.getName || adapter["getName"];
  adapter.$isSecure$ = adapter.$isSecure$ || adapter["isSecure"];
  adapter.$isPersistent$ = adapter.$isPersistent$ || adapter["isPersistent"];
  adapter.$suspendSweeping$ = adapter.$suspendSweeping$ || adapter["suspendSweeping"];
  adapter.$resumeSweeping$ = adapter.$resumeSweeping$ || adapter["resumeSweeping"];
  adapter.$setItems$ = adapter.$setItems$ || adapter["setItems"];
  adapter.$getItems$ = adapter.$getItems$ || adapter["getItems"];
  adapter.$removeItems$ = adapter.$removeItems$ || adapter["removeItems"];
  adapter.clear = adapter.clear || adapter["clear"];
  adapter.$sweep$ = adapter.$sweep$ || adapter["sweep"];
  adapter.$getSize$ = adapter.$getSize$ || adapter["getSize"];
  adapter.$deleteStorage$ = adapter.$deleteStorage$ || adapter["deleteStorage"]
};
Aura.$Storage$.$CryptoAdapter$ = CryptoAdapter;
AuraStorageService.prototype["CryptoAdapter"] = CryptoAdapter;
var TransportMetricsPlugin = function TransportMetricsPlugin(config) {
  this.$config$ = config;
  this["enabled"] = true
};
goog.$exportSymbol$("TransportMetricsPlugin", TransportMetricsPlugin);
TransportMetricsPlugin["NAME"] = "transport";
TransportMetricsPlugin.$ORIGIN$ = window.location && window.location.origin;
TransportMetricsPlugin.$AURA_URL$ = TransportMetricsPlugin.$ORIGIN$ + "/aura";
TransportMetricsPlugin.prototype.$initialize$ = function(metricsService) {
  this.$metricsService$ = metricsService;
  if(this["enabled"]) {
    this.bind(metricsService)
  }
};
goog.$exportProperty$(TransportMetricsPlugin.prototype, "initialize", TransportMetricsPlugin.prototype.$initialize$);
TransportMetricsPlugin.prototype.enable = function() {
  if(!this["enabled"]) {
    this["enabled"] = true;
    this.bind(this.$metricsService$)
  }
};
goog.$exportProperty$(TransportMetricsPlugin.prototype, "enable", TransportMetricsPlugin.prototype.enable);
TransportMetricsPlugin.prototype.disable = function() {
  if(this["enabled"]) {
    this["enabled"] = false;
    this.$unbind$(this.$metricsService$)
  }
};
goog.$exportProperty$(TransportMetricsPlugin.prototype, "disable", TransportMetricsPlugin.prototype.disable);
TransportMetricsPlugin.prototype.$sendOverride$ = function() {
  var config = Array.prototype.shift.apply(arguments);
  var auraXHR = arguments[0];
  var options = arguments[3] || {};
  var ret = config["fn"].apply(config["scope"], arguments);
  if(ret) {
    var startMark = this.$metricsService$["markStart"](TransportMetricsPlugin["NAME"], "request");
    var actionDefs = [];
    for(var id in auraXHR.$actions$) {
      if(auraXHR.$actions$.hasOwnProperty(id)) {
        actionDefs.push(id)
      }
    }
    startMark["context"] = {"auraXHRId":auraXHR.$marker$, "requestLength":auraXHR.length, "background":!!options.background, "actionDefs":actionDefs, "requestId":auraXHR["requestId"] || options["requestId"]}
  }
  return ret
};
TransportMetricsPlugin.prototype.$receiveOverride$ = function() {
  var config = Array.prototype.shift.apply(arguments);
  var auraXHR = arguments[0];
  var endMark = this.$metricsService$["markEnd"](TransportMetricsPlugin["NAME"], "request");
  endMark["context"] = {"auraXHRId":auraXHR.$marker$, "status":auraXHR.$request$.status, "statusText":auraXHR.$request$.statusText};
  try {
    endMark["context"]["responseLength"] = auraXHR.$request$.responseText.length
  }catch(ex) {
    endMark["context"]["responseLength"] = 0
  }
  if(window.performance && window.performance.getEntriesByName) {
    var allResources = window.performance.getEntriesByType("resource");
    var r = allResources.filter(function(res) {
      return res.name.indexOf(auraXHR.url) !== -1
    })[0];
    if(r) {
      $A["util"].apply(endMark["context"], {"xhrDuration":parseInt(r.responseEnd - r.startTime, 10), "xhrStall":parseInt(r.requestStart - r.startTime, 10), "startTime":parseInt(r.startTime, 10), "fetchStart":parseInt(r.fetchStart, 10), "requestStart":parseInt(r.requestStart, 10), "dns":parseInt(r.domainLookupEnd - r.domainLookupStart, 10), "tcp":parseInt(r.connectEnd - r.connectStart, 10), "ttfb":parseInt(r.responseStart - r.startTime, 10), "transfer":parseInt(r.responseEnd - r.responseStart, 10), 
      "transferSize":r["transferSize"] || 0})
    }
  }
  var ret = config["fn"].apply(config["scope"], arguments);
  var perfSummary = ret && ret["message"] && ret["message"]["perfSummary"];
  if(perfSummary && perfSummary["version"] === "core") {
    endMark["context"]["serverTime"] = perfSummary["request"]
  }
  return ret
};
TransportMetricsPlugin.prototype.bind = function() {
  $A.$installOverride$("ClientService.send", this.$sendOverride$, this);
  $A.$installOverride$("ClientService.receive", this.$receiveOverride$, this)
};
TransportMetricsPlugin.prototype.$postProcess$ = function(transportMarks) {
  var procesedMarks = [];
  var queue = {};
  for(var i = 0;i < transportMarks.length;i++) {
    var id = transportMarks[i]["context"] && transportMarks[i]["context"]["auraXHRId"];
    if(id === undefined) {
      continue
    }
    var phase = transportMarks[i]["phase"];
    if(phase === "start") {
      queue[id] = transportMarks[i]
    }else {
      if(phase === "end" && queue[id]) {
        var mark = $A["util"].apply({}, queue[id], true, true);
        var duration = parseInt(transportMarks[i]["ts"] - mark["ts"]);
        mark["context"] = $A["util"].apply(mark["context"], transportMarks[i]["context"]);
        mark["duration"] = duration;
        mark["context"]["xhrDelay"] = duration - mark["context"]["xhrDuration"];
        mark["phase"] = "processed";
        procesedMarks.push(mark);
        delete queue[id]
      }
    }
  }
  return procesedMarks
};
goog.$exportProperty$(TransportMetricsPlugin.prototype, "postProcess", TransportMetricsPlugin.prototype.$postProcess$);
TransportMetricsPlugin.prototype.$unbind$ = function() {
  $A.$uninstallOverride$("ClientService.send", this.$sendOverride$);
  $A.$uninstallOverride$("ClientService.receive", this.$receiveOverride$)
};
$A.$metricsService$.$registerPlugin$({"name":TransportMetricsPlugin["NAME"], "plugin":TransportMetricsPlugin});
var PerfMetricsPlugin = function PerfMetricsPlugin(config) {
  this.$config$ = config;
  this["enabled"] = true
};
PerfMetricsPlugin["NAME"] = "server";
PerfMetricsPlugin.prototype = {$initialize$:function(metricsService) {
  this.$collector$ = metricsService;
  if(this["enabled"]) {
    this.bind(metricsService)
  }
}, enable:function() {
  if(!this["enabled"]) {
    this["enabled"] = true;
    this.bind(this.$collector$)
  }
}, disable:function() {
  if(this["enabled"]) {
    this["enabled"] = false;
    this.$unbind$(this.$collector$)
  }
}, $processResponsesOverride$:function() {
  var config = Array.prototype.shift.apply(arguments);
  var auraXHR = arguments[0];
  var responseObject = arguments[1];
  var perfData = responseObject["perf"];
  var stampMark = this.$collector$["mark"](PerfMetricsPlugin["NAME"], "perf");
  if(perfData) {
    stampMark["context"] = {"id":auraXHR.$marker$, "requestId":auraXHR["requestId"], "perf":perfData}
  }
  return config["fn"].apply(config["scope"], arguments)
}, bind:function() {
  $A.$installOverride$("ClientService.processResponses", this.$processResponsesOverride$, this)
}, $postProcess$:function(markList) {
  return markList
}, $unbind$:function() {
  $A.$uninstallOverride$("ClientService.processResponses", this.$processResponsesOverride$)
}};
PerfMetricsPlugin.prototype["initialize"] = PerfMetricsPlugin.prototype.$initialize$;
PerfMetricsPlugin.prototype["enable"] = PerfMetricsPlugin.prototype.enable;
PerfMetricsPlugin.prototype["disable"] = PerfMetricsPlugin.prototype.disable;
PerfMetricsPlugin.prototype["postProcess"] = PerfMetricsPlugin.prototype.$postProcess$;
$A.$metricsService$.$registerPlugin$({"name":PerfMetricsPlugin["NAME"], "plugin":PerfMetricsPlugin});
var QueuedActionsMetricsPlugin = function QueuedActionsMetricsPlugin(config) {
  this.$config$ = config;
  this["enabled"] = true
};
goog.$exportSymbol$("QueuedActionsMetricsPlugin", QueuedActionsMetricsPlugin);
QueuedActionsMetricsPlugin["NAME"] = "actions";
QueuedActionsMetricsPlugin.prototype.$initialize$ = function(metricsService) {
  this.$metricsService$ = metricsService;
  if(this["enabled"]) {
    this.bind(metricsService)
  }
};
goog.$exportProperty$(QueuedActionsMetricsPlugin.prototype, "initialize", QueuedActionsMetricsPlugin.prototype.$initialize$);
QueuedActionsMetricsPlugin.prototype.enable = function() {
  if(!this["enabled"]) {
    this["enabled"] = true;
    this.bind(this.$metricsService$)
  }
};
goog.$exportProperty$(QueuedActionsMetricsPlugin.prototype, "enable", QueuedActionsMetricsPlugin.prototype.enable);
QueuedActionsMetricsPlugin.prototype.disable = function() {
  if(this["enabled"]) {
    this["enabled"] = false;
    this.$unbind$(this.$metricsService$)
  }
};
goog.$exportProperty$(QueuedActionsMetricsPlugin.prototype, "disable", QueuedActionsMetricsPlugin.prototype.disable);
QueuedActionsMetricsPlugin.prototype.$enqueueActionOverride$ = function() {
  var config = Array.prototype.shift.apply(arguments);
  var action = arguments[0];
  var cmp = action.$getComponent$();
  if(action.$getDef$().$isServerAction$()) {
    this.$metricsService$["mark"](QueuedActionsMetricsPlugin["NAME"], "enqueue", {"id":action.$getId$(), "abortable":action.$isAbortable$(), "storable":action.$isStorable$(), "background":action.$isBackground$(), "cmp":cmp && cmp.$getType$() || "none", "def":action.$getDef$().toString()})
  }
  var ret = config["fn"].apply(config["scope"], arguments);
  return ret
};
QueuedActionsMetricsPlugin.prototype.$collectServerActionOverride$ = function() {
  var config = Array.prototype.shift.apply(arguments);
  var action = arguments[0];
  this.$metricsService$["mark"](QueuedActionsMetricsPlugin["NAME"], "sendQueued", {"id":action.$getId$()});
  return config["fn"].apply(config["scope"], arguments)
};
QueuedActionsMetricsPlugin.prototype.$actionSendOverride$ = function() {
  var config = Array.prototype.shift.apply(arguments);
  var actions = arguments[1];
  for(var i = 0;i < actions.length;i++) {
    this.$metricsService$["mark"](QueuedActionsMetricsPlugin["NAME"], "sendStart", {"id":actions[i].$getId$()})
  }
  return config["fn"].apply(config["scope"], arguments)
};
QueuedActionsMetricsPlugin.prototype.$actionFinishOverride$ = function() {
  var config = Array.prototype.shift.apply(arguments);
  var action = config["self"];
  var shouldLog = action.$getDef$().$isServerAction$();
  shouldLog && this.$metricsService$["mark"](QueuedActionsMetricsPlugin["NAME"], "finishStart", {"id":action.$getId$(), "state":action.$getState$(), "cache":action.$isFromStorage$()});
  var ret = undefined;
  try {
    ret = config["fn"].apply(config["scope"], arguments)
  }finally {
    shouldLog && this.$metricsService$["mark"](QueuedActionsMetricsPlugin["NAME"], "finishEnd", {"id":action.$getId$()})
  }
  return ret
};
QueuedActionsMetricsPlugin.prototype.$actionsProcessResponses$ = function() {
  var config = Array.prototype.shift.apply(arguments);
  var message = arguments[1];
  var perfSummary = message && message["perfSummary"];
  if(perfSummary && perfSummary["version"] === "core") {
    var actions = perfSummary["actions"] || {};
    var keys = Object.keys(actions);
    for(var i = 0;i < keys.length;i++) {
      var id = keys[i];
      var serverTime = actions[id];
      this.$metricsService$["mark"](QueuedActionsMetricsPlugin["NAME"], "receive", {"id":id, "serverTime":serverTime})
    }
  }
  return config["fn"].apply(config["scope"], arguments)
};
QueuedActionsMetricsPlugin.prototype.bind = function() {
  $A.$installOverride$("enqueueAction", this.$enqueueActionOverride$, this);
  $A.$installOverride$("ClientService.collectServerAction", this.$collectServerActionOverride$, this);
  $A.$installOverride$("ClientService.send", this.$actionSendOverride$, this);
  $A.$installOverride$("ClientService.processResponses", this.$actionsProcessResponses$, this);
  $A.$installOverride$("Action.finishAction", this.$actionFinishOverride$, this)
};
QueuedActionsMetricsPlugin.prototype.$postProcess$ = function(actionMarks) {
  var processedMarks = [];
  var queue = {};
  for(var i = 0;i < actionMarks.length;i++) {
    var actionMark = actionMarks[i];
    var id = actionMark["context"]["id"];
    var mark = queue[id];
    var name = actionMark["name"];
    if(name === "enqueue") {
      queue[id] = $A["util"].apply({}, actionMark)
    }
    if(mark) {
      switch(name) {
        case "sendQueued":
          mark["xhrWait"] = Math.floor(actionMark["ts"]);
          mark["enqueueWait"] = Math.floor(actionMark["ts"] - mark["ts"]);
          break;
        case "sendStart":
          if(mark["xhrWait"] === undefined) {
            mark["xhrWait"] = 0
          }else {
            mark["xhrWait"] = Math.floor(actionMark["ts"] - mark["xhrWait"])
          }
          if(mark["enqueueWait"] === undefined) {
            mark["enqueueWait"] = Math.floor(actionMark["ts"] - mark["ts"])
          }
          break;
        case "receive":
          mark["serverTime"] = actionMark["context"]["serverTime"];
          break;
        case "finishStart":
          $A["util"].apply(mark["context"], actionMark["context"]);
          mark["callbackTime"] = actionMark["ts"];
          if(mark["enqueueWait"] === undefined) {
            mark["enqueueWait"] = Math.floor(actionMark["ts"] - mark["ts"])
          }
          break;
        case "finishEnd":
          mark["callbackTime"] = Math.floor(actionMark["ts"] - mark["callbackTime"]);
          mark["duration"] = Math.floor(actionMark["ts"] - mark["ts"]);
          mark["phase"] = "processed";
          processedMarks.push(mark);
          delete queue[id];
          break
      }
    }
  }
  return processedMarks
};
goog.$exportProperty$(QueuedActionsMetricsPlugin.prototype, "postProcess", QueuedActionsMetricsPlugin.prototype.$postProcess$);
QueuedActionsMetricsPlugin.prototype.$unbind$ = function() {
  $A.$uninstallOverride$("enqueueAction", this.$enqueueActionOverride$);
  $A.$uninstallOverride$("ClientService.collectServerAction", this.$collectServerActionOverride$);
  $A.$uninstallOverride$("ClientService.send", this.$actionSendOverride$, this);
  $A.$uninstallOverride$("ClientService.processResponses", this.$actionsProcessResponses$);
  $A.$uninstallOverride$("Action.finishAction", this.$actionFinishOverride$)
};
$A.$metricsService$.$registerPlugin$({"name":QueuedActionsMetricsPlugin["NAME"], "plugin":QueuedActionsMetricsPlugin});
var AuraContextPlugin = function AuraContextPlugin(config) {
  this.$config$ = config;
  this["enabled"] = true
};
goog.$exportSymbol$("AuraContextPlugin", AuraContextPlugin);
AuraContextPlugin["NAME"] = "defRegistry";
AuraContextPlugin.prototype.$initialize$ = function(metricsService) {
  this.$collector$ = metricsService;
  if(this["enabled"]) {
    this.bind(metricsService)
  }
};
goog.$exportProperty$(AuraContextPlugin.prototype, "initialize", AuraContextPlugin.prototype.$initialize$);
AuraContextPlugin.prototype.enable = function() {
  if(!this["enabled"]) {
    this["enabled"] = true;
    this.bind(this.$collector$)
  }
};
goog.$exportProperty$(AuraContextPlugin.prototype, "enable", AuraContextPlugin.prototype.enable);
AuraContextPlugin.prototype.disable = function() {
  if(this["enabled"]) {
    this["enabled"] = false;
    this.$unbind$(this.$collector$)
  }
};
goog.$exportProperty$(AuraContextPlugin.prototype, "disable", AuraContextPlugin.prototype.disable);
AuraContextPlugin.prototype.bind = function(metricsService) {
  var method = "merge";
  var defIter = function(b) {
    var a = [];
    for(var i = 0;i < b.length;i++) {
      var def = b[i];
      if(def["descriptor"]) {
        a.push(def["descriptor"])
      }
    }
    return a
  };
  var hook = function(original, config) {
    var ret = original.apply(this, Array.prototype.slice.call(arguments, 1));
    var cmpDefs = config["componentDefs"];
    var evtDefs = config["eventDefs"];
    var payload = {};
    var hasDefs = cmpDefs && cmpDefs.length || evtDefs && evtDefs.length;
    if(cmpDefs) {
      payload["componentDefs"] = defIter(cmpDefs)
    }
    if(evtDefs) {
      payload["eventDefs"] = defIter(evtDefs)
    }
    if(hasDefs) {
      metricsService["transaction"]("aura", "newDefs", {"context":{"attributes":payload}})
    }
    return ret
  };
  metricsService.$instrument$(Aura.$Context$.$AuraContext$.prototype, method, AuraContextPlugin["NAME"], false, null, null, hook)
};
AuraContextPlugin.prototype.$postProcess$ = function(transportMarks) {
  return transportMarks
};
goog.$exportProperty$(AuraContextPlugin.prototype, "postProcess", AuraContextPlugin.prototype.$postProcess$);
AuraContextPlugin.prototype.$unbind$ = function(metricsService) {
  metricsService["unInstrument"](Aura.$Context$.$AuraContext$.prototype, "merge")
};
$A.$metricsService$.$registerPlugin$({"name":AuraContextPlugin["NAME"], "plugin":AuraContextPlugin});
var DomHandlersPlugin = function DomHandlersPlugin(config) {
  this.$config$ = config;
  this["enabled"] = true
};
goog.$exportSymbol$("DomHandlersPlugin", DomHandlersPlugin);
DomHandlersPlugin["NAME"] = "domHandlers";
DomHandlersPlugin.$DEFAULT_INTERACTION_TYPE$ = "user";
DomHandlersPlugin.$WHITELISTEVENTS$ = {"click":true, "change":true};
DomHandlersPlugin.prototype.$initialize$ = function(metricsService) {
  this.$metricsService$ = metricsService;
  if(this["enabled"]) {
    this.bind()
  }
};
goog.$exportProperty$(DomHandlersPlugin.prototype, "initialize", DomHandlersPlugin.prototype.$initialize$);
DomHandlersPlugin.prototype.enable = function() {
  if(!this["enabled"]) {
    this["enabled"] = true;
    this.bind()
  }
};
goog.$exportProperty$(DomHandlersPlugin.prototype, "enable", DomHandlersPlugin.prototype.enable);
DomHandlersPlugin.prototype.disable = function() {
  if(this["enabled"]) {
    this["enabled"] = false;
    this.$unbind$(this.$metricsService$)
  }
};
goog.$exportProperty$(DomHandlersPlugin.prototype, "disable", DomHandlersPlugin.prototype.disable);
DomHandlersPlugin.prototype.$dispatchActionHook$ = function(action, event, root) {
  if(!(event.type in DomHandlersPlugin.$WHITELISTEVENTS$)) {
    return
  }
  var parent = $A.$expressionService$.$getContainer$(root).$getConcreteComponent$();
  var locator = parent.$getLocator$(root, false);
  if(locator) {
    var target = root["getElement"]();
    var meta = target && target.getAttribute("data-refid");
    var context = {"locator":locator, "eventType":DomHandlersPlugin.$DEFAULT_INTERACTION_TYPE$, "eventSource":event.type};
    if(meta) {
      locator["context"] = locator["context"] || {};
      if(!locator["context"][meta]) {
        locator["context"][meta] = target.getAttribute("data-" + meta)
      }
    }
    $A.$metricsService$.transaction("aura", "interaction", {"context":context})
  }else {
    if(event.type === "click") {
      this.$logUnInstrumentedClick$(parent, root)
    }
  }
};
DomHandlersPlugin.prototype.$logUnInstrumentedClick$ = function(parent, root) {
  var es = $A.$expressionService$;
  var grandparent = es.$getContainer$(parent).$getConcreteComponent$();
  var grandparentContainer = es.$getContainer$(grandparent).$getConcreteComponent$();
  var hierarchy = {"rootHtmlTag":root.get("v.tag"), "rootId":root.$getLocalId$(), "parent":parent.$getDef$().toString(), "parentId":parent.$getLocalId$(), "grandparent":grandparent.$getDef$().toString(), "grandparentId":grandparent.$getLocalId$(), "grandparentContainer":grandparentContainer.$getDef$().toString()};
  $A.$metricsService$.transaction("ltng", "performance:missingLocator", {"context":{"attributes":hierarchy}});
  $A.log("WARNING: **** Un-Instrumented click logged. Details: " + JSON.stringify(hierarchy))
};
DomHandlersPlugin.prototype.$bindToMetricsService$ = function(jsObject, method) {
  var self = this;
  if(jsObject) {
    this.$metricsService$.$instrument$(jsObject, method, DomHandlersPlugin["NAME"], false, null, null, function(original) {
      var xargs = Array.prototype.slice.call(arguments, 1);
      self.$dispatchActionHook$.apply(self, xargs);
      return original.apply(this, xargs)
    })
  }
};
DomHandlersPlugin.prototype.$bindToHelper$ = function(descriptor, helperMethod) {
  var defConfig = $A.$componentService$.$createDescriptorConfig$(descriptor);
  var def = $A.$componentService$.$getComponentDef$(defConfig);
  var defHelper = def && def.$getHelper$();
  this.$bindToMetricsService$(defHelper, helperMethod)
};
DomHandlersPlugin.prototype.$bindToLib$ = function(lib, jsFile) {
  var fileObject = $A.$componentService$.$hasLibrary$(lib) && $A.$componentService$.$getLibraryInclude$(jsFile);
  if(fileObject) {
    this.$bindToMetricsService$(fileObject, "_dispatchAction")
  }
};
DomHandlersPlugin.prototype.bind = function() {
  var self = this;
  $A.$clientService$.$runAfterInitDefs$(function() {
    $A.$installOverride$("HtmlComopnent.dispatchAction", self.$instrumentCallback$, self);
    self.$bindToHelper$("markup://ui:virtualList", "_dispatchAction");
    self.$bindToHelper$("markup://ui:virtualDataGrid", "_dispatchAction");
    self.$bindToHelper$("markup://ui:virtualDataTable", "_dispatchAction");
    self.$bindToLib$("markup://ui:eventLib", "js://ui.eventLib.interactive");
    self.$bindToLib$("markup://force:virtualGridLib", "js://force.virtualGridLib.gridHelper")
  })
};
DomHandlersPlugin.prototype.$instrumentCallback$ = function() {
  var xargs = Array.prototype.slice.call(arguments, 1);
  var config = Array.prototype.shift.apply(arguments);
  this.$dispatchActionHook$.apply(this, xargs);
  return config["fn"].apply(config["scope"], arguments)
};
DomHandlersPlugin.prototype.$postProcess$ = function(transportMarks) {
  return transportMarks
};
goog.$exportProperty$(DomHandlersPlugin.prototype, "postProcess", DomHandlersPlugin.prototype.$postProcess$);
DomHandlersPlugin.prototype.$unbind$ = function() {
  $A.$uninstallOverride$("HtmlComopnent.dispatchAction", this.$instrumentCallback$, this)
};
$A.$metricsService$.$registerPlugin$({"name":DomHandlersPlugin["NAME"], "plugin":DomHandlersPlugin});
var ComponentMetricsPlugin = function ComponentMetricsPlugin(config) {
  this.$config$ = config;
  this["enabled"] = true
};
goog.$exportSymbol$("ComponentMetricsPlugin", ComponentMetricsPlugin);
ComponentMetricsPlugin["NAME"] = "component";
ComponentMetricsPlugin.prototype.$initialize$ = function(metricsService) {
  this.$metricsService$ = metricsService
};
goog.$exportProperty$(ComponentMetricsPlugin.prototype, "initialize", ComponentMetricsPlugin.prototype.$initialize$);
ComponentMetricsPlugin.prototype.enable = function() {
  if(!this["enabled"]) {
    this["enabled"] = true
  }
};
goog.$exportProperty$(ComponentMetricsPlugin.prototype, "enable", ComponentMetricsPlugin.prototype.enable);
ComponentMetricsPlugin.prototype.disable = function() {
  if(this["enabled"]) {
    this["enabled"] = false
  }
};
goog.$exportProperty$(ComponentMetricsPlugin.prototype, "disable", ComponentMetricsPlugin.prototype.disable);
ComponentMetricsPlugin.prototype.$summarizeCreateInfo$ = function(cmp, duration, ts) {
  cmp["createCount"] = cmp["createCount"] || 0;
  cmp["createTimeTotal"] = cmp["createTimeTotal"] || 0;
  cmp["createCount"]++;
  cmp["createTimeTotal"] += duration;
  cmp["createTs"] = cmp["createTs"] || [];
  cmp["createDuration"] = cmp["createDuration"] || [];
  cmp["createTs"].push(ts);
  cmp["createDuration"].push(duration)
};
ComponentMetricsPlugin.prototype.$postProcess$ = function(marks) {
  var processedMarks = [];
  var uniqueCmps = {};
  var mark;
  for(var i = 0;i < marks.length;i++) {
    mark = marks[i];
    var name = mark["context"]["name"];
    var ts = mark["ts"];
    var duration = Math.floor(mark["duration"] * 100) / 100;
    var type = mark["name"];
    var cmp = uniqueCmps[name];
    if(!cmp) {
      cmp = {"name":name};
      processedMarks.push(cmp);
      uniqueCmps[name] = cmp
    }
    if(type === "create") {
      this.$summarizeCreateInfo$(cmp, duration, ts)
    }else {
      $A.$warning$("[ComponentMetricsPlugin] Unexpected type of mark encountered in the component namespace:" + type)
    }
  }
  return processedMarks
};
goog.$exportProperty$(ComponentMetricsPlugin.prototype, "postProcess", ComponentMetricsPlugin.prototype.$postProcess$);
$A.$metricsService$.$registerPlugin$({"name":ComponentMetricsPlugin["NAME"], "plugin":ComponentMetricsPlugin});
var ComponentServiceMetricsPlugin = function ComponentServiceMetricsPlugin(config) {
  this.$config$ = config;
  this["enabled"] = false
};
goog.$exportSymbol$("ComponentServiceMetricsPlugin", ComponentServiceMetricsPlugin);
ComponentServiceMetricsPlugin["NAME"] = "componentService";
ComponentServiceMetricsPlugin.prototype.$initialize$ = function(metricsService) {
  this.$metricsService$ = metricsService;
  if(this["enabled"]) {
    this.bind(metricsService)
  }
};
goog.$exportProperty$(ComponentServiceMetricsPlugin.prototype, "initialize", ComponentServiceMetricsPlugin.prototype.$initialize$);
ComponentServiceMetricsPlugin.prototype.enable = function() {
  if(!this["enabled"]) {
    this["enabled"] = true;
    this.bind(this.$metricsService$)
  }
};
goog.$exportProperty$(ComponentServiceMetricsPlugin.prototype, "enable", ComponentServiceMetricsPlugin.prototype.enable);
ComponentServiceMetricsPlugin.prototype.disable = function() {
  if(this["enabled"]) {
    this["enabled"] = false;
    this.$unbind$(this.$metricsService$)
  }
};
goog.$exportProperty$(ComponentServiceMetricsPlugin.prototype, "disable", ComponentServiceMetricsPlugin.prototype.disable);
ComponentServiceMetricsPlugin.prototype.$createComponentOverride$ = function() {
  var config = Array.prototype.shift.apply(arguments);
  var cmpConfig = arguments[0];
  var descriptor = $A["util"].$isString$(cmpConfig) ? cmpConfig : (cmpConfig["componentDef"]["descriptor"] || cmpConfig["componentDef"]) + "";
  this.$metricsService$["markStart"](ComponentServiceMetricsPlugin["NAME"], "createComponent", {$context$:{"descriptor":descriptor}});
  var ret = config["fn"].apply(config["scope"], arguments);
  this.$metricsService$["markEnd"](ComponentServiceMetricsPlugin["NAME"], "createComponent", {$context$:{"descriptor":descriptor}});
  return ret
};
ComponentServiceMetricsPlugin.prototype.bind = function() {
  $A.$installOverride$("ComponentService.createComponentPriv", this.$createComponentOverride$, this)
};
ComponentServiceMetricsPlugin.prototype.$postProcess$ = function(componentMarks) {
  var procesedMarks = [];
  var stack = [];
  for(var i = 0;i < componentMarks.length;i++) {
    var phase = componentMarks[i]["phase"];
    if(phase === "start") {
      stack.push(componentMarks[i])
    }else {
      if(phase === "end" && stack.length) {
        var mark = $A["util"].apply({}, stack.pop(), true, true);
        if(mark["context"]["descriptor"] === componentMarks[i]["context"]["descriptor"]) {
          mark["context"] = $A["util"].apply(mark["context"], componentMarks[i]["context"]);
          mark["duration"] = componentMarks[i]["ts"] - mark["ts"];
          procesedMarks.push(mark)
        }
      }
    }
  }
  return procesedMarks
};
goog.$exportProperty$(ComponentServiceMetricsPlugin.prototype, "postProcess", ComponentServiceMetricsPlugin.prototype.$postProcess$);
ComponentServiceMetricsPlugin.prototype.$unbind$ = function() {
  $A.$unInstallOverride$("ComponentService.createComponentPriv", this.$createComponentOverride$)
};
$A.$metricsService$.$registerPlugin$({"name":ComponentServiceMetricsPlugin["NAME"], "plugin":ComponentServiceMetricsPlugin});
(function() {
  $A.$logger$.$subscribe$("INFO", $A.$logger$.$devDebugConsoleLog$);
  $A.$logger$.$subscribe$("WARNING", $A.$logger$.$devDebugConsoleLog$);
  $A.$logger$.$subscribe$("ASSERT", function(level, message) {
    throw new $A.$auraError$(message);
  });
  $A.$logger$.$subscribe$("ERROR", function(level, message, e) {
    $A.$reportError$(message, e)
  });
  window.onerror = function() {
    var existing = window.onerror;
    var newHandler = function(message, url, line, col, err) {
      if(url && line && col) {
        message = message + "\nthrows at " + url + ":" + line + ":" + col
      }
      if(!$A.$reportError$(message, err) && !existing) {
        var console_error = window.console && window.console.error.bind(window.console);
        if(console_error) {
          console_error(message, err)
        }
      }
      return true
    };
    return function() {
      if(existing) {
        try {
          existing.apply(this, arguments)
        }catch(e) {
          $A.$warning$("error from external onerror handler!", e)
        }
      }
      return newHandler.apply(this, arguments)
    }
  }();
  window.addEventListener("unhandledrejection", function(event) {
    var error = event.reason;
    var validError = false;
    if(error && error.name && error.name.indexOf("Error") !== -1) {
      error = new $A.$auraError$(null, error);
      validError = true
    }
    if(!validError || !$A.$reportError$(null, error)) {
      var console_error = window.console && window.console.error.bind(window.console);
      if(console_error) {
        console_error(null, event.reason)
      }
    }
  })
})();
Aura["frameworkJsReady"] = true;
if(Aura["initConfig"]) {
  $A.$lockerService$.$initialize$(Aura["initConfig"]["context"]["ls"]);
  var scripts = Aura["inlineJsLocker"];
  if(scripts) {
    for(var i = 0;i < scripts.length;i++) {
      $A.$lockerService$.$runScript$(scripts[i]["callback"], scripts[i]["namespace"])
    }
    delete Aura["inlineJsLocker"]
  }
  setTimeout(function() {
    $A.$initAsync$(Aura["initConfig"])
  }, 0)
}
;
};
Aura.externalLibraries=function(){(function(global,factory){typeof exports==="object"&&typeof module!=="undefined"?module.exports=factory():typeof define==="function"&&define.amd?define(factory):global.moment=factory()})(this,function(){var hookCallback;function utils_hooks__hooks(){return hookCallback.apply(null,arguments)}function setHookCallback(callback){hookCallback=callback}function isArray(input){return input instanceof Array||Object.prototype.toString.call(input)==="[object Array]"}function isObject(input){return Object.prototype.toString.call(input)===
"[object Object]"}function isObjectEmpty(obj){var k;for(k in obj)return false;return true}function isDate(input){return input instanceof Date||Object.prototype.toString.call(input)==="[object Date]"}function map(arr,fn){var res=[],i;for(i=0;i<arr.length;++i)res.push(fn(arr[i],i));return res}function hasOwnProp(a,b){return Object.prototype.hasOwnProperty.call(a,b)}function extend(a,b){for(var i in b)if(hasOwnProp(b,i))a[i]=b[i];if(hasOwnProp(b,"toString"))a.toString=b.toString;if(hasOwnProp(b,"valueOf"))a.valueOf=
b.valueOf;return a}function create_utc__createUTC(input,format,locale,strict){return createLocalOrUTC(input,format,locale,strict,true).utc()}function defaultParsingFlags(){return{empty:false,unusedTokens:[],unusedInput:[],overflow:-2,charsLeftOver:0,nullInput:false,invalidMonth:null,invalidFormat:false,userInvalidated:false,iso:false,parsedDateParts:[],meridiem:null}}function getParsingFlags(m){if(m._pf==null)m._pf=defaultParsingFlags();return m._pf}var some;if(Array.prototype.some)some=Array.prototype.some;
else some=function(fun){var t=Object(this);var len=t.length>>>0;for(var i=0;i<len;i++)if(i in t&&fun.call(this,t[i],i,t))return true;return false};function valid__isValid(m){if(m._isValid==null){var flags=getParsingFlags(m);var parsedParts=some.call(flags.parsedDateParts,function(i){return i!=null});m._isValid=!isNaN(m._d.getTime())&&flags.overflow<0&&!flags.empty&&!flags.invalidMonth&&!flags.invalidWeekday&&!flags.nullInput&&!flags.invalidFormat&&!flags.userInvalidated&&(!flags.meridiem||flags.meridiem&&
parsedParts);if(m._strict)m._isValid=m._isValid&&flags.charsLeftOver===0&&flags.unusedTokens.length===0&&flags.bigHour===undefined}return m._isValid}function valid__createInvalid(flags){var m=create_utc__createUTC(NaN);if(flags!=null)extend(getParsingFlags(m),flags);else getParsingFlags(m).userInvalidated=true;return m}function isUndefined(input){return input===void 0}var momentProperties=utils_hooks__hooks.momentProperties=[];function copyConfig(to,from){var i,prop,val;if(!isUndefined(from._isAMomentObject))to._isAMomentObject=
from._isAMomentObject;if(!isUndefined(from._i))to._i=from._i;if(!isUndefined(from._f))to._f=from._f;if(!isUndefined(from._l))to._l=from._l;if(!isUndefined(from._strict))to._strict=from._strict;if(!isUndefined(from._tzm))to._tzm=from._tzm;if(!isUndefined(from._isUTC))to._isUTC=from._isUTC;if(!isUndefined(from._offset))to._offset=from._offset;if(!isUndefined(from._pf))to._pf=getParsingFlags(from);if(!isUndefined(from._locale))to._locale=from._locale;if(momentProperties.length>0)for(i in momentProperties){prop=
momentProperties[i];val=from[prop];if(!isUndefined(val))to[prop]=val}return to}var updateInProgress=false;function Moment(config){copyConfig(this,config);this._d=new Date(config._d!=null?config._d.getTime():NaN);if(updateInProgress===false){updateInProgress=true;utils_hooks__hooks.updateOffset(this);updateInProgress=false}}function isMoment(obj){return obj instanceof Moment||obj!=null&&obj._isAMomentObject!=null}function absFloor(number){if(number<0)return Math.ceil(number)||0;else return Math.floor(number)}
function toInt(argumentForCoercion){var coercedNumber=+argumentForCoercion,value=0;if(coercedNumber!==0&&isFinite(coercedNumber))value=absFloor(coercedNumber);return value}function compareArrays(array1,array2,dontConvert){var len=Math.min(array1.length,array2.length),lengthDiff=Math.abs(array1.length-array2.length),diffs=0,i;for(i=0;i<len;i++)if(dontConvert&&array1[i]!==array2[i]||!dontConvert&&toInt(array1[i])!==toInt(array2[i]))diffs++;return diffs+lengthDiff}function warn(msg){if(utils_hooks__hooks.suppressDeprecationWarnings===
false&&typeof console!=="undefined"&&console.warn)console.warn("Deprecation warning: "+msg)}function deprecate(msg,fn){var firstTime=true;return extend(function(){if(utils_hooks__hooks.deprecationHandler!=null)utils_hooks__hooks.deprecationHandler(null,msg);if(firstTime){warn(msg+"\nArguments: "+Array.prototype.slice.call(arguments).join(", ")+"\n"+(new Error).stack);firstTime=false}return fn.apply(this,arguments)},fn)}var deprecations={};function deprecateSimple(name,msg){if(utils_hooks__hooks.deprecationHandler!=
null)utils_hooks__hooks.deprecationHandler(name,msg);if(!deprecations[name]){warn(msg);deprecations[name]=true}}utils_hooks__hooks.suppressDeprecationWarnings=false;utils_hooks__hooks.deprecationHandler=null;function isFunction(input){return input instanceof Function||Object.prototype.toString.call(input)==="[object Function]"}function locale_set__set(config){var prop,i;for(i in config){prop=config[i];if(isFunction(prop))this[i]=prop;else this["_"+i]=prop}this._config=config;this._ordinalParseLenient=
new RegExp(this._ordinalParse.source+"|"+/\d{1,2}/.source)}function mergeConfigs(parentConfig,childConfig){var res=extend({},parentConfig),prop;for(prop in childConfig)if(hasOwnProp(childConfig,prop))if(isObject(parentConfig[prop])&&isObject(childConfig[prop])){res[prop]={};extend(res[prop],parentConfig[prop]);extend(res[prop],childConfig[prop])}else if(childConfig[prop]!=null)res[prop]=childConfig[prop];else delete res[prop];for(prop in parentConfig)if(hasOwnProp(parentConfig,prop)&&!hasOwnProp(childConfig,
prop)&&isObject(parentConfig[prop]))res[prop]=extend({},res[prop]);return res}function Locale(config){if(config!=null)this.set(config)}var keys;if(Object.keys)keys=Object.keys;else keys=function(obj){var i,res=[];for(i in obj)if(hasOwnProp(obj,i))res.push(i);return res};var defaultCalendar={sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"};function locale_calendar__calendar(key,mom,now){var output=this._calendar[key]||
this._calendar["sameElse"];return isFunction(output)?output.call(mom,now):output}var defaultLongDateFormat={LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"};function longDateFormat(key){var format=this._longDateFormat[key],formatUpper=this._longDateFormat[key.toUpperCase()];if(format||!formatUpper)return format;this._longDateFormat[key]=formatUpper.replace(/MMMM|MM|DD|dddd/g,function(val){return val.slice(1)});return this._longDateFormat[key]}
var defaultInvalidDate="Invalid date";function invalidDate(){return this._invalidDate}var defaultOrdinal="%d";var defaultOrdinalParse=/\d{1,2}/;function ordinal(number){return this._ordinal.replace("%d",number)}var defaultRelativeTime={future:"in %s",past:"%s ago",s:"a few seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"};function relative__relativeTime(number,withoutSuffix,string,isFuture){var output=this._relativeTime[string];
return isFunction(output)?output(number,withoutSuffix,string,isFuture):output.replace(/%d/i,number)}function pastFuture(diff,output){var format=this._relativeTime[diff>0?"future":"past"];return isFunction(format)?format(output):format.replace(/%s/i,output)}var aliases={};function addUnitAlias(unit,shorthand){var lowerCase=unit.toLowerCase();aliases[lowerCase]=aliases[lowerCase+"s"]=aliases[shorthand]=unit}function normalizeUnits(units){return typeof units==="string"?aliases[units]||aliases[units.toLowerCase()]:
undefined}function normalizeObjectUnits(inputObject){var normalizedInput={},normalizedProp,prop;for(prop in inputObject)if(hasOwnProp(inputObject,prop)){normalizedProp=normalizeUnits(prop);if(normalizedProp)normalizedInput[normalizedProp]=inputObject[prop]}return normalizedInput}var priorities={};function addUnitPriority(unit,priority){priorities[unit]=priority}function getPrioritizedUnits(unitsObj){var units=[];for(var u in unitsObj)units.push({unit:u,priority:priorities[u]});units.sort(function(a,
b){return a.priority-b.priority});return units}function makeGetSet(unit,keepTime){return function(value){if(value!=null){get_set__set(this,unit,value);utils_hooks__hooks.updateOffset(this,keepTime);return this}else return get_set__get(this,unit)}}function get_set__get(mom,unit){return mom.isValid()?mom._d["get"+(mom._isUTC?"UTC":"")+unit]():NaN}function get_set__set(mom,unit,value){if(mom.isValid())mom._d["set"+(mom._isUTC?"UTC":"")+unit](value)}function stringGet(units){units=normalizeUnits(units);
if(isFunction(this[units]))return this[units]();return this}function stringSet(units,value){if(typeof units==="object"){units=normalizeObjectUnits(units);var prioritized=getPrioritizedUnits(units);for(var i=0;i<prioritized.length;i++)this[prioritized[i].unit](units[prioritized[i].unit])}else{units=normalizeUnits(units);if(isFunction(this[units]))return this[units](value)}return this}function zeroFill(number,targetLength,forceSign){var absNumber=""+Math.abs(number),zerosToFill=targetLength-absNumber.length,
sign=number>=0;return(sign?forceSign?"+":"":"-")+Math.pow(10,Math.max(0,zerosToFill)).toString().substr(1)+absNumber}var formattingTokens=/(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;var localFormattingTokens=/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;var formatFunctions={};var formatTokenFunctions={};function addFormatToken(token,padded,ordinal,callback){var func=
callback;if(typeof callback==="string")func=function(){return this[callback]()};if(token)formatTokenFunctions[token]=func;if(padded)formatTokenFunctions[padded[0]]=function(){return zeroFill(func.apply(this,arguments),padded[1],padded[2])};if(ordinal)formatTokenFunctions[ordinal]=function(){return this.localeData().ordinal(func.apply(this,arguments),token)}}function removeFormattingTokens(input){if(input.match(/\[[\s\S]/))return input.replace(/^\[|\]$/g,"");return input.replace(/\\/g,"")}function makeFormatFunction(format){var array=
format.match(formattingTokens),i,length;for(i=0,length=array.length;i<length;i++)if(formatTokenFunctions[array[i]])array[i]=formatTokenFunctions[array[i]];else array[i]=removeFormattingTokens(array[i]);return function(mom){var output="",i;for(i=0;i<length;i++)output+=array[i]instanceof Function?array[i].call(mom,format):array[i];return output}}function formatMoment(m,format){if(!m.isValid())return m.localeData().invalidDate();format=expandFormat(format,m.localeData());formatFunctions[format]=formatFunctions[format]||
makeFormatFunction(format);return formatFunctions[format](m)}function expandFormat(format,locale){var i=5;function replaceLongDateFormatTokens(input){return locale.longDateFormat(input)||input}localFormattingTokens.lastIndex=0;while(i>=0&&localFormattingTokens.test(format)){format=format.replace(localFormattingTokens,replaceLongDateFormatTokens);localFormattingTokens.lastIndex=0;i-=1}return format}var match1=/\d/;var match2=/\d\d/;var match3=/\d{3}/;var match4=/\d{4}/;var match6=/[+-]?\d{6}/;var match1to2=
/\d\d?/;var match3to4=/\d\d\d\d?/;var match5to6=/\d\d\d\d\d\d?/;var match1to3=/\d{1,3}/;var match1to4=/\d{1,4}/;var match1to6=/[+-]?\d{1,6}/;var matchUnsigned=/\d+/;var matchSigned=/[+-]?\d+/;var matchOffset=/Z|[+-]\d\d:?\d\d/gi;var matchShortOffset=/Z|[+-]\d\d(?::?\d\d)?/gi;var matchTimestamp=/[+-]?\d+(\.\d{1,3})?/;var matchWord=/[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;var regexes={};function addRegexToken(token,regex,strictRegex){regexes[token]=
isFunction(regex)?regex:function(isStrict,localeData){return isStrict&&strictRegex?strictRegex:regex}}function getParseRegexForToken(token,config){if(!hasOwnProp(regexes,token))return new RegExp(unescapeFormat(token));return regexes[token](config._strict,config._locale)}function unescapeFormat(s){return regexEscape(s.replace("\\","").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,function(matched,p1,p2,p3,p4){return p1||p2||p3||p4}))}function regexEscape(s){return s.replace(/[-\/\\^$*+?.()|[\]{}]/g,
"\\$\x26")}var tokens={};function addParseToken(token,callback){var i,func=callback;if(typeof token==="string")token=[token];if(typeof callback==="number")func=function(input,array){array[callback]=toInt(input)};for(i=0;i<token.length;i++)tokens[token[i]]=func}function addWeekParseToken(token,callback){addParseToken(token,function(input,array,config,token){config._w=config._w||{};callback(input,config._w,config,token)})}function addTimeToArrayFromToken(token,input,config){if(input!=null&&hasOwnProp(tokens,
token))tokens[token](input,config._a,config,token)}var YEAR=0;var MONTH=1;var DATE=2;var HOUR=3;var MINUTE=4;var SECOND=5;var MILLISECOND=6;var WEEK=7;var WEEKDAY=8;var indexOf;if(Array.prototype.indexOf)indexOf=Array.prototype.indexOf;else indexOf=function(o){var i;for(i=0;i<this.length;++i)if(this[i]===o)return i;return-1};function daysInMonth(year,month){return(new Date(Date.UTC(year,month+1,0))).getUTCDate()}addFormatToken("M",["MM",2],"Mo",function(){return this.month()+1});addFormatToken("MMM",
0,0,function(format){return this.localeData().monthsShort(this,format)});addFormatToken("MMMM",0,0,function(format){return this.localeData().months(this,format)});addUnitAlias("month","M");addUnitPriority("month",8);addRegexToken("M",match1to2);addRegexToken("MM",match1to2,match2);addRegexToken("MMM",function(isStrict,locale){return locale.monthsShortRegex(isStrict)});addRegexToken("MMMM",function(isStrict,locale){return locale.monthsRegex(isStrict)});addParseToken(["M","MM"],function(input,array){array[MONTH]=
toInt(input)-1});addParseToken(["MMM","MMMM"],function(input,array,config,token){var month=config._locale.monthsParse(input,token,config._strict);if(month!=null)array[MONTH]=month;else getParsingFlags(config).invalidMonth=input});var MONTHS_IN_FORMAT=/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/;var defaultLocaleMonths="January_February_March_April_May_June_July_August_September_October_November_December".split("_");function localeMonths(m,format){return isArray(this._months)?this._months[m.month()]:this._months[(this._months.isFormat||
MONTHS_IN_FORMAT).test(format)?"format":"standalone"][m.month()]}var defaultLocaleMonthsShort="Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");function localeMonthsShort(m,format){return isArray(this._monthsShort)?this._monthsShort[m.month()]:this._monthsShort[MONTHS_IN_FORMAT.test(format)?"format":"standalone"][m.month()]}function units_month__handleStrictParse(monthName,format,strict){var i,ii,mom,llc=monthName.toLocaleLowerCase();if(!this._monthsParse){this._monthsParse=[];this._longMonthsParse=
[];this._shortMonthsParse=[];for(i=0;i<12;++i){mom=create_utc__createUTC([2E3,i]);this._shortMonthsParse[i]=this.monthsShort(mom,"").toLocaleLowerCase();this._longMonthsParse[i]=this.months(mom,"").toLocaleLowerCase()}}if(strict)if(format==="MMM"){ii=indexOf.call(this._shortMonthsParse,llc);return ii!==-1?ii:null}else{ii=indexOf.call(this._longMonthsParse,llc);return ii!==-1?ii:null}else if(format==="MMM"){ii=indexOf.call(this._shortMonthsParse,llc);if(ii!==-1)return ii;ii=indexOf.call(this._longMonthsParse,
llc);return ii!==-1?ii:null}else{ii=indexOf.call(this._longMonthsParse,llc);if(ii!==-1)return ii;ii=indexOf.call(this._shortMonthsParse,llc);return ii!==-1?ii:null}}function localeMonthsParse(monthName,format,strict){var i,mom,regex;if(this._monthsParseExact)return units_month__handleStrictParse.call(this,monthName,format,strict);if(!this._monthsParse){this._monthsParse=[];this._longMonthsParse=[];this._shortMonthsParse=[]}for(i=0;i<12;i++){mom=create_utc__createUTC([2E3,i]);if(strict&&!this._longMonthsParse[i]){this._longMonthsParse[i]=
new RegExp("^"+this.months(mom,"").replace(".","")+"$","i");this._shortMonthsParse[i]=new RegExp("^"+this.monthsShort(mom,"").replace(".","")+"$","i")}if(!strict&&!this._monthsParse[i]){regex="^"+this.months(mom,"")+"|^"+this.monthsShort(mom,"");this._monthsParse[i]=new RegExp(regex.replace(".",""),"i")}if(strict&&format==="MMMM"&&this._longMonthsParse[i].test(monthName))return i;else if(strict&&format==="MMM"&&this._shortMonthsParse[i].test(monthName))return i;else if(!strict&&this._monthsParse[i].test(monthName))return i}}
function setMonth(mom,value){var dayOfMonth;if(!mom.isValid())return mom;if(typeof value==="string")if(/^\d+$/.test(value))value=toInt(value);else{value=mom.localeData().monthsParse(value);if(typeof value!=="number")return mom}dayOfMonth=Math.min(mom.date(),daysInMonth(mom.year(),value));mom._d["set"+(mom._isUTC?"UTC":"")+"Month"](value,dayOfMonth);return mom}function getSetMonth(value){if(value!=null){setMonth(this,value);utils_hooks__hooks.updateOffset(this,true);return this}else return get_set__get(this,
"Month")}function getDaysInMonth(){return daysInMonth(this.year(),this.month())}var defaultMonthsShortRegex=matchWord;function monthsShortRegex(isStrict){if(this._monthsParseExact){if(!hasOwnProp(this,"_monthsRegex"))computeMonthsParse.call(this);if(isStrict)return this._monthsShortStrictRegex;else return this._monthsShortRegex}else{if(!hasOwnProp(this,"_monthsShortRegex"))this._monthsShortRegex=defaultMonthsShortRegex;return this._monthsShortStrictRegex&&isStrict?this._monthsShortStrictRegex:this._monthsShortRegex}}
var defaultMonthsRegex=matchWord;function monthsRegex(isStrict){if(this._monthsParseExact){if(!hasOwnProp(this,"_monthsRegex"))computeMonthsParse.call(this);if(isStrict)return this._monthsStrictRegex;else return this._monthsRegex}else{if(!hasOwnProp(this,"_monthsRegex"))this._monthsRegex=defaultMonthsRegex;return this._monthsStrictRegex&&isStrict?this._monthsStrictRegex:this._monthsRegex}}function computeMonthsParse(){function cmpLenRev(a,b){return b.length-a.length}var shortPieces=[],longPieces=
[],mixedPieces=[],i,mom;for(i=0;i<12;i++){mom=create_utc__createUTC([2E3,i]);shortPieces.push(this.monthsShort(mom,""));longPieces.push(this.months(mom,""));mixedPieces.push(this.months(mom,""));mixedPieces.push(this.monthsShort(mom,""))}shortPieces.sort(cmpLenRev);longPieces.sort(cmpLenRev);mixedPieces.sort(cmpLenRev);for(i=0;i<12;i++){shortPieces[i]=regexEscape(shortPieces[i]);longPieces[i]=regexEscape(longPieces[i])}for(i=0;i<24;i++)mixedPieces[i]=regexEscape(mixedPieces[i]);this._monthsRegex=
new RegExp("^("+mixedPieces.join("|")+")","i");this._monthsShortRegex=this._monthsRegex;this._monthsStrictRegex=new RegExp("^("+longPieces.join("|")+")","i");this._monthsShortStrictRegex=new RegExp("^("+shortPieces.join("|")+")","i")}addFormatToken("Y",0,0,function(){var y=this.year();return y<=9999?""+y:"+"+y});addFormatToken(0,["YY",2],0,function(){return this.year()%100});addFormatToken(0,["YYYY",4],0,"year");addFormatToken(0,["YYYYY",5],0,"year");addFormatToken(0,["YYYYYY",6,true],0,"year");addUnitAlias("year",
"y");addUnitPriority("year",1);addRegexToken("Y",matchSigned);addRegexToken("YY",match1to2,match2);addRegexToken("YYYY",match1to4,match4);addRegexToken("YYYYY",match1to6,match6);addRegexToken("YYYYYY",match1to6,match6);addParseToken(["YYYYY","YYYYYY"],YEAR);addParseToken("YYYY",function(input,array){array[YEAR]=input.length===2?utils_hooks__hooks.parseTwoDigitYear(input):toInt(input)});addParseToken("YY",function(input,array){array[YEAR]=utils_hooks__hooks.parseTwoDigitYear(input)});addParseToken("Y",
function(input,array){array[YEAR]=parseInt(input,10)});function daysInYear(year){return isLeapYear(year)?366:365}function isLeapYear(year){return year%4===0&&year%100!==0||year%400===0}utils_hooks__hooks.parseTwoDigitYear=function(input){return toInt(input)+(toInt(input)>68?1900:2E3)};var getSetYear=makeGetSet("FullYear",true);function getIsLeapYear(){return isLeapYear(this.year())}function createDate(y,m,d,h,M,s,ms){var date=new Date(y,m,d,h,M,s,ms);if(y<100&&y>=0&&isFinite(date.getFullYear()))date.setFullYear(y);
return date}function createUTCDate(y){var date=new Date(Date.UTC.apply(null,arguments));if(y<100&&y>=0&&isFinite(date.getUTCFullYear()))date.setUTCFullYear(y);return date}function firstWeekOffset(year,dow,doy){var fwd=7+dow-doy,fwdlw=(7+createUTCDate(year,0,fwd).getUTCDay()-dow)%7;return-fwdlw+fwd-1}function dayOfYearFromWeeks(year,week,weekday,dow,doy){var localWeekday=(7+weekday-dow)%7,weekOffset=firstWeekOffset(year,dow,doy),dayOfYear=1+7*(week-1)+localWeekday+weekOffset,resYear,resDayOfYear;if(dayOfYear<=
0){resYear=year-1;resDayOfYear=daysInYear(resYear)+dayOfYear}else if(dayOfYear>daysInYear(year)){resYear=year+1;resDayOfYear=dayOfYear-daysInYear(year)}else{resYear=year;resDayOfYear=dayOfYear}return{year:resYear,dayOfYear:resDayOfYear}}function weekOfYear(mom,dow,doy){var weekOffset=firstWeekOffset(mom.year(),dow,doy),week=Math.floor((mom.dayOfYear()-weekOffset-1)/7)+1,resWeek,resYear;if(week<1){resYear=mom.year()-1;resWeek=week+weeksInYear(resYear,dow,doy)}else if(week>weeksInYear(mom.year(),dow,
doy)){resWeek=week-weeksInYear(mom.year(),dow,doy);resYear=mom.year()+1}else{resYear=mom.year();resWeek=week}return{week:resWeek,year:resYear}}function weeksInYear(year,dow,doy){var weekOffset=firstWeekOffset(year,dow,doy),weekOffsetNext=firstWeekOffset(year+1,dow,doy);return(daysInYear(year)-weekOffset+weekOffsetNext)/7}addFormatToken("w",["ww",2],"wo","week");addFormatToken("W",["WW",2],"Wo","isoWeek");addUnitAlias("week","w");addUnitAlias("isoWeek","W");addUnitPriority("week",5);addUnitPriority("isoWeek",
5);addRegexToken("w",match1to2);addRegexToken("ww",match1to2,match2);addRegexToken("W",match1to2);addRegexToken("WW",match1to2,match2);addWeekParseToken(["w","ww","W","WW"],function(input,week,config,token){week[token.substr(0,1)]=toInt(input)});function localeWeek(mom){return weekOfYear(mom,this._week.dow,this._week.doy).week}var defaultLocaleWeek={dow:0,doy:6};function localeFirstDayOfWeek(){return this._week.dow}function localeFirstDayOfYear(){return this._week.doy}function getSetWeek(input){var week=
this.localeData().week(this);return input==null?week:this.add((input-week)*7,"d")}function getSetISOWeek(input){var week=weekOfYear(this,1,4).week;return input==null?week:this.add((input-week)*7,"d")}addFormatToken("d",0,"do","day");addFormatToken("dd",0,0,function(format){return this.localeData().weekdaysMin(this,format)});addFormatToken("ddd",0,0,function(format){return this.localeData().weekdaysShort(this,format)});addFormatToken("dddd",0,0,function(format){return this.localeData().weekdays(this,
format)});addFormatToken("e",0,0,"weekday");addFormatToken("E",0,0,"isoWeekday");addUnitAlias("day","d");addUnitAlias("weekday","e");addUnitAlias("isoWeekday","E");addUnitPriority("day",11);addUnitPriority("weekday",11);addUnitPriority("isoWeekday",11);addRegexToken("d",match1to2);addRegexToken("e",match1to2);addRegexToken("E",match1to2);addRegexToken("dd",function(isStrict,locale){return locale.weekdaysMinRegex(isStrict)});addRegexToken("ddd",function(isStrict,locale){return locale.weekdaysShortRegex(isStrict)});
addRegexToken("dddd",function(isStrict,locale){return locale.weekdaysRegex(isStrict)});addWeekParseToken(["dd","ddd","dddd"],function(input,week,config,token){var weekday=config._locale.weekdaysParse(input,token,config._strict);if(weekday!=null)week.d=weekday;else getParsingFlags(config).invalidWeekday=input});addWeekParseToken(["d","e","E"],function(input,week,config,token){week[token]=toInt(input)});function parseWeekday(input,locale){if(typeof input!=="string")return input;if(!isNaN(input))return parseInt(input,
10);input=locale.weekdaysParse(input);if(typeof input==="number")return input;return null}function parseIsoWeekday(input,locale){if(typeof input==="string")return locale.weekdaysParse(input)%7||7;return isNaN(input)?null:input}var defaultLocaleWeekdays="Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_");function localeWeekdays(m,format){return isArray(this._weekdays)?this._weekdays[m.day()]:this._weekdays[this._weekdays.isFormat.test(format)?"format":"standalone"][m.day()]}var defaultLocaleWeekdaysShort=
"Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_");function localeWeekdaysShort(m){return this._weekdaysShort[m.day()]}var defaultLocaleWeekdaysMin="Su_Mo_Tu_We_Th_Fr_Sa".split("_");function localeWeekdaysMin(m){return this._weekdaysMin[m.day()]}function day_of_week__handleStrictParse(weekdayName,format,strict){var i,ii,mom,llc=weekdayName.toLocaleLowerCase();if(!this._weekdaysParse){this._weekdaysParse=[];this._shortWeekdaysParse=[];this._minWeekdaysParse=[];for(i=0;i<7;++i){mom=create_utc__createUTC([2E3,
1]).day(i);this._minWeekdaysParse[i]=this.weekdaysMin(mom,"").toLocaleLowerCase();this._shortWeekdaysParse[i]=this.weekdaysShort(mom,"").toLocaleLowerCase();this._weekdaysParse[i]=this.weekdays(mom,"").toLocaleLowerCase()}}if(strict)if(format==="dddd"){ii=indexOf.call(this._weekdaysParse,llc);return ii!==-1?ii:null}else if(format==="ddd"){ii=indexOf.call(this._shortWeekdaysParse,llc);return ii!==-1?ii:null}else{ii=indexOf.call(this._minWeekdaysParse,llc);return ii!==-1?ii:null}else if(format==="dddd"){ii=
indexOf.call(this._weekdaysParse,llc);if(ii!==-1)return ii;ii=indexOf.call(this._shortWeekdaysParse,llc);if(ii!==-1)return ii;ii=indexOf.call(this._minWeekdaysParse,llc);return ii!==-1?ii:null}else if(format==="ddd"){ii=indexOf.call(this._shortWeekdaysParse,llc);if(ii!==-1)return ii;ii=indexOf.call(this._weekdaysParse,llc);if(ii!==-1)return ii;ii=indexOf.call(this._minWeekdaysParse,llc);return ii!==-1?ii:null}else{ii=indexOf.call(this._minWeekdaysParse,llc);if(ii!==-1)return ii;ii=indexOf.call(this._weekdaysParse,
llc);if(ii!==-1)return ii;ii=indexOf.call(this._shortWeekdaysParse,llc);return ii!==-1?ii:null}}function localeWeekdaysParse(weekdayName,format,strict){var i,mom,regex;if(this._weekdaysParseExact)return day_of_week__handleStrictParse.call(this,weekdayName,format,strict);if(!this._weekdaysParse){this._weekdaysParse=[];this._minWeekdaysParse=[];this._shortWeekdaysParse=[];this._fullWeekdaysParse=[]}for(i=0;i<7;i++){mom=create_utc__createUTC([2E3,1]).day(i);if(strict&&!this._fullWeekdaysParse[i]){this._fullWeekdaysParse[i]=
new RegExp("^"+this.weekdays(mom,"").replace(".",".?")+"$","i");this._shortWeekdaysParse[i]=new RegExp("^"+this.weekdaysShort(mom,"").replace(".",".?")+"$","i");this._minWeekdaysParse[i]=new RegExp("^"+this.weekdaysMin(mom,"").replace(".",".?")+"$","i")}if(!this._weekdaysParse[i]){regex="^"+this.weekdays(mom,"")+"|^"+this.weekdaysShort(mom,"")+"|^"+this.weekdaysMin(mom,"");this._weekdaysParse[i]=new RegExp(regex.replace(".",""),"i")}if(strict&&format==="dddd"&&this._fullWeekdaysParse[i].test(weekdayName))return i;
else if(strict&&format==="ddd"&&this._shortWeekdaysParse[i].test(weekdayName))return i;else if(strict&&format==="dd"&&this._minWeekdaysParse[i].test(weekdayName))return i;else if(!strict&&this._weekdaysParse[i].test(weekdayName))return i}}function getSetDayOfWeek(input){if(!this.isValid())return input!=null?this:NaN;var day=this._isUTC?this._d.getUTCDay():this._d.getDay();if(input!=null){input=parseWeekday(input,this.localeData());return this.add(input-day,"d")}else return day}function getSetLocaleDayOfWeek(input){if(!this.isValid())return input!=
null?this:NaN;var weekday=(this.day()+7-this.localeData()._week.dow)%7;return input==null?weekday:this.add(input-weekday,"d")}function getSetISODayOfWeek(input){if(!this.isValid())return input!=null?this:NaN;if(input!=null){var weekday=parseIsoWeekday(input,this.localeData());return this.day(this.day()%7?weekday:weekday-7)}else return this.day()||7}var defaultWeekdaysRegex=matchWord;function weekdaysRegex(isStrict){if(this._weekdaysParseExact){if(!hasOwnProp(this,"_weekdaysRegex"))computeWeekdaysParse.call(this);
if(isStrict)return this._weekdaysStrictRegex;else return this._weekdaysRegex}else{if(!hasOwnProp(this,"_weekdaysRegex"))this._weekdaysRegex=defaultWeekdaysRegex;return this._weekdaysStrictRegex&&isStrict?this._weekdaysStrictRegex:this._weekdaysRegex}}var defaultWeekdaysShortRegex=matchWord;function weekdaysShortRegex(isStrict){if(this._weekdaysParseExact){if(!hasOwnProp(this,"_weekdaysRegex"))computeWeekdaysParse.call(this);if(isStrict)return this._weekdaysShortStrictRegex;else return this._weekdaysShortRegex}else{if(!hasOwnProp(this,
"_weekdaysShortRegex"))this._weekdaysShortRegex=defaultWeekdaysShortRegex;return this._weekdaysShortStrictRegex&&isStrict?this._weekdaysShortStrictRegex:this._weekdaysShortRegex}}var defaultWeekdaysMinRegex=matchWord;function weekdaysMinRegex(isStrict){if(this._weekdaysParseExact){if(!hasOwnProp(this,"_weekdaysRegex"))computeWeekdaysParse.call(this);if(isStrict)return this._weekdaysMinStrictRegex;else return this._weekdaysMinRegex}else{if(!hasOwnProp(this,"_weekdaysMinRegex"))this._weekdaysMinRegex=
defaultWeekdaysMinRegex;return this._weekdaysMinStrictRegex&&isStrict?this._weekdaysMinStrictRegex:this._weekdaysMinRegex}}function computeWeekdaysParse(){function cmpLenRev(a,b){return b.length-a.length}var minPieces=[],shortPieces=[],longPieces=[],mixedPieces=[],i,mom,minp,shortp,longp;for(i=0;i<7;i++){mom=create_utc__createUTC([2E3,1]).day(i);minp=this.weekdaysMin(mom,"");shortp=this.weekdaysShort(mom,"");longp=this.weekdays(mom,"");minPieces.push(minp);shortPieces.push(shortp);longPieces.push(longp);
mixedPieces.push(minp);mixedPieces.push(shortp);mixedPieces.push(longp)}minPieces.sort(cmpLenRev);shortPieces.sort(cmpLenRev);longPieces.sort(cmpLenRev);mixedPieces.sort(cmpLenRev);for(i=0;i<7;i++){shortPieces[i]=regexEscape(shortPieces[i]);longPieces[i]=regexEscape(longPieces[i]);mixedPieces[i]=regexEscape(mixedPieces[i])}this._weekdaysRegex=new RegExp("^("+mixedPieces.join("|")+")","i");this._weekdaysShortRegex=this._weekdaysRegex;this._weekdaysMinRegex=this._weekdaysRegex;this._weekdaysStrictRegex=
new RegExp("^("+longPieces.join("|")+")","i");this._weekdaysShortStrictRegex=new RegExp("^("+shortPieces.join("|")+")","i");this._weekdaysMinStrictRegex=new RegExp("^("+minPieces.join("|")+")","i")}function hFormat(){return this.hours()%12||12}function kFormat(){return this.hours()||24}addFormatToken("H",["HH",2],0,"hour");addFormatToken("h",["hh",2],0,hFormat);addFormatToken("k",["kk",2],0,kFormat);addFormatToken("hmm",0,0,function(){return""+hFormat.apply(this)+zeroFill(this.minutes(),2)});addFormatToken("hmmss",
0,0,function(){return""+hFormat.apply(this)+zeroFill(this.minutes(),2)+zeroFill(this.seconds(),2)});addFormatToken("Hmm",0,0,function(){return""+this.hours()+zeroFill(this.minutes(),2)});addFormatToken("Hmmss",0,0,function(){return""+this.hours()+zeroFill(this.minutes(),2)+zeroFill(this.seconds(),2)});function meridiem(token,lowercase){addFormatToken(token,0,0,function(){return this.localeData().meridiem(this.hours(),this.minutes(),lowercase)})}meridiem("a",true);meridiem("A",false);addUnitAlias("hour",
"h");addUnitPriority("hour",13);function matchMeridiem(isStrict,locale){return locale._meridiemParse}addRegexToken("a",matchMeridiem);addRegexToken("A",matchMeridiem);addRegexToken("H",match1to2);addRegexToken("h",match1to2);addRegexToken("HH",match1to2,match2);addRegexToken("hh",match1to2,match2);addRegexToken("hmm",match3to4);addRegexToken("hmmss",match5to6);addRegexToken("Hmm",match3to4);addRegexToken("Hmmss",match5to6);addParseToken(["H","HH"],HOUR);addParseToken(["a","A"],function(input,array,
config){config._isPm=config._locale.isPM(input);config._meridiem=input});addParseToken(["h","hh"],function(input,array,config){array[HOUR]=toInt(input);getParsingFlags(config).bigHour=true});addParseToken("hmm",function(input,array,config){var pos=input.length-2;array[HOUR]=toInt(input.substr(0,pos));array[MINUTE]=toInt(input.substr(pos));getParsingFlags(config).bigHour=true});addParseToken("hmmss",function(input,array,config){var pos1=input.length-4;var pos2=input.length-2;array[HOUR]=toInt(input.substr(0,
pos1));array[MINUTE]=toInt(input.substr(pos1,2));array[SECOND]=toInt(input.substr(pos2));getParsingFlags(config).bigHour=true});addParseToken("Hmm",function(input,array,config){var pos=input.length-2;array[HOUR]=toInt(input.substr(0,pos));array[MINUTE]=toInt(input.substr(pos))});addParseToken("Hmmss",function(input,array,config){var pos1=input.length-4;var pos2=input.length-2;array[HOUR]=toInt(input.substr(0,pos1));array[MINUTE]=toInt(input.substr(pos1,2));array[SECOND]=toInt(input.substr(pos2))});
function localeIsPM(input){return(input+"").toLowerCase().charAt(0)==="p"}var defaultLocaleMeridiemParse=/[ap]\.?m?\.?/i;function localeMeridiem(hours,minutes,isLower){if(hours>11)return isLower?"pm":"PM";else return isLower?"am":"AM"}var getSetHour=makeGetSet("Hours",true);var baseConfig={calendar:defaultCalendar,longDateFormat:defaultLongDateFormat,invalidDate:defaultInvalidDate,ordinal:defaultOrdinal,ordinalParse:defaultOrdinalParse,relativeTime:defaultRelativeTime,months:defaultLocaleMonths,monthsShort:defaultLocaleMonthsShort,
week:defaultLocaleWeek,weekdays:defaultLocaleWeekdays,weekdaysMin:defaultLocaleWeekdaysMin,weekdaysShort:defaultLocaleWeekdaysShort,meridiemParse:defaultLocaleMeridiemParse};var locales={};var globalLocale;function normalizeLocale(key){return key?key.toLowerCase().replace("_","-"):key}function chooseLocale(names){var i=0,j,next,locale,split;while(i<names.length){split=normalizeLocale(names[i]).split("-");j=split.length;next=normalizeLocale(names[i+1]);next=next?next.split("-"):null;while(j>0){locale=
loadLocale(split.slice(0,j).join("-"));if(locale)return locale;if(next&&next.length>=j&&compareArrays(split,next,true)>=j-1)break;j--}i++}return null}function loadLocale(name){var oldLocale=null;if(!locales[name]&&typeof module!=="undefined"&&module&&module.exports)try{oldLocale=globalLocale._abbr;require("./locale/"+name);locale_locales__getSetGlobalLocale(oldLocale)}catch(e){}return locales[name]}function locale_locales__getSetGlobalLocale(key,values){var data;if(key){if(isUndefined(values))data=
locale_locales__getLocale(key);else data=defineLocale(key,values);if(data)globalLocale=data}return globalLocale._abbr}function defineLocale(name,config){if(config!==null){var parentConfig=baseConfig;config.abbr=name;if(locales[name]!=null){deprecateSimple("defineLocaleOverride","use moment.updateLocale(localeName, config) to change "+"an existing locale. moment.defineLocale(localeName, "+"config) should only be used for creating a new locale "+"See http://momentjs.com/guides/#/warnings/define-locale/ for more info.");
parentConfig=locales[name]._config}else if(config.parentLocale!=null)if(locales[config.parentLocale]!=null)parentConfig=locales[config.parentLocale]._config;else deprecateSimple("parentLocaleUndefined","specified parentLocale is not defined yet. See http://momentjs.com/guides/#/warnings/parent-locale/");locales[name]=new Locale(mergeConfigs(parentConfig,config));locale_locales__getSetGlobalLocale(name);return locales[name]}else{delete locales[name];return null}}function updateLocale(name,config){if(config!=
null){var locale,parentConfig=baseConfig;if(locales[name]!=null)parentConfig=locales[name]._config;config=mergeConfigs(parentConfig,config);locale=new Locale(config);locale.parentLocale=locales[name];locales[name]=locale;locale_locales__getSetGlobalLocale(name)}else if(locales[name]!=null)if(locales[name].parentLocale!=null)locales[name]=locales[name].parentLocale;else if(locales[name]!=null)delete locales[name];return locales[name]}function locale_locales__getLocale(key){var locale;if(key&&key._locale&&
key._locale._abbr)key=key._locale._abbr;if(!key)return globalLocale;if(!isArray(key)){locale=loadLocale(key);if(locale)return locale;key=[key]}return chooseLocale(key)}function locale_locales__listLocales(){return keys(locales)}function checkOverflow(m){var overflow;var a=m._a;if(a&&getParsingFlags(m).overflow===-2){overflow=a[MONTH]<0||a[MONTH]>11?MONTH:a[DATE]<1||a[DATE]>daysInMonth(a[YEAR],a[MONTH])?DATE:a[HOUR]<0||a[HOUR]>24||a[HOUR]===24&&(a[MINUTE]!==0||a[SECOND]!==0||a[MILLISECOND]!==0)?HOUR:
a[MINUTE]<0||a[MINUTE]>59?MINUTE:a[SECOND]<0||a[SECOND]>59?SECOND:a[MILLISECOND]<0||a[MILLISECOND]>999?MILLISECOND:-1;if(getParsingFlags(m)._overflowDayOfYear&&(overflow<YEAR||overflow>DATE))overflow=DATE;if(getParsingFlags(m)._overflowWeeks&&overflow===-1)overflow=WEEK;if(getParsingFlags(m)._overflowWeekday&&overflow===-1)overflow=WEEKDAY;getParsingFlags(m).overflow=overflow}return m}var extendedIsoRegex=/^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
var basicIsoRegex=/^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;var tzRegex=/Z|[+-]\d\d(?::?\d\d)?/;var isoDates=[["YYYYYY-MM-DD",/[+-]\d{6}-\d\d-\d\d/],["YYYY-MM-DD",/\d{4}-\d\d-\d\d/],["GGGG-[W]WW-E",/\d{4}-W\d\d-\d/],["GGGG-[W]WW",/\d{4}-W\d\d/,false],["YYYY-DDD",/\d{4}-\d{3}/],["YYYY-MM",/\d{4}-\d\d/,false],["YYYYYYMMDD",/[+-]\d{10}/],["YYYYMMDD",/\d{8}/],["GGGG[W]WWE",/\d{4}W\d{3}/],["GGGG[W]WW",/\d{4}W\d{2}/,
false],["YYYYDDD",/\d{7}/]];var isoTimes=[["HH:mm:ss.SSSS",/\d\d:\d\d:\d\d\.\d+/],["HH:mm:ss,SSSS",/\d\d:\d\d:\d\d,\d+/],["HH:mm:ss",/\d\d:\d\d:\d\d/],["HH:mm",/\d\d:\d\d/],["HHmmss.SSSS",/\d\d\d\d\d\d\.\d+/],["HHmmss,SSSS",/\d\d\d\d\d\d,\d+/],["HHmmss",/\d\d\d\d\d\d/],["HHmm",/\d\d\d\d/],["HH",/\d\d/]];var aspNetJsonRegex=/^\/?Date\((\-?\d+)/i;function configFromISO(config){var i,l,string=config._i,match=extendedIsoRegex.exec(string)||basicIsoRegex.exec(string),allowTime,dateFormat,timeFormat,tzFormat;
if(match){getParsingFlags(config).iso=true;for(i=0,l=isoDates.length;i<l;i++)if(isoDates[i][1].exec(match[1])){dateFormat=isoDates[i][0];allowTime=isoDates[i][2]!==false;break}if(dateFormat==null){config._isValid=false;return}if(match[3]){for(i=0,l=isoTimes.length;i<l;i++)if(isoTimes[i][1].exec(match[3])){timeFormat=(match[2]||" ")+isoTimes[i][0];break}if(timeFormat==null){config._isValid=false;return}}if(!allowTime&&timeFormat!=null){config._isValid=false;return}if(match[4])if(tzRegex.exec(match[4]))tzFormat=
"Z";else{config._isValid=false;return}config._f=dateFormat+(timeFormat||"")+(tzFormat||"");configFromStringAndFormat(config)}else config._isValid=false}function configFromString(config){var matched=aspNetJsonRegex.exec(config._i);if(matched!==null){config._d=new Date(+matched[1]);return}configFromISO(config);if(config._isValid===false){delete config._isValid;utils_hooks__hooks.createFromInputFallback(config)}}utils_hooks__hooks.createFromInputFallback=deprecate("moment construction falls back to js Date. This is "+
"discouraged and will be removed in upcoming major "+"release. Please refer to "+"http://momentjs.com/guides/#/warnings/js-date/ for more info.",function(config){config._d=new Date(config._i+(config._useUTC?" UTC":""))});function defaults(a,b,c){if(a!=null)return a;if(b!=null)return b;return c}function currentDateArray(config){var nowValue=new Date(utils_hooks__hooks.now());if(config._useUTC)return[nowValue.getUTCFullYear(),nowValue.getUTCMonth(),nowValue.getUTCDate()];return[nowValue.getFullYear(),
nowValue.getMonth(),nowValue.getDate()]}function configFromArray(config){var i,date,input=[],currentDate,yearToUse;if(config._d)return;currentDate=currentDateArray(config);if(config._w&&config._a[DATE]==null&&config._a[MONTH]==null)dayOfYearFromWeekInfo(config);if(config._dayOfYear){yearToUse=defaults(config._a[YEAR],currentDate[YEAR]);if(config._dayOfYear>daysInYear(yearToUse))getParsingFlags(config)._overflowDayOfYear=true;date=createUTCDate(yearToUse,0,config._dayOfYear);config._a[MONTH]=date.getUTCMonth();
config._a[DATE]=date.getUTCDate()}for(i=0;i<3&&config._a[i]==null;++i)config._a[i]=input[i]=currentDate[i];for(;i<7;i++)config._a[i]=input[i]=config._a[i]==null?i===2?1:0:config._a[i];if(config._a[HOUR]===24&&config._a[MINUTE]===0&&config._a[SECOND]===0&&config._a[MILLISECOND]===0){config._nextDay=true;config._a[HOUR]=0}config._d=(config._useUTC?createUTCDate:createDate).apply(null,input);if(config._tzm!=null)config._d.setUTCMinutes(config._d.getUTCMinutes()-config._tzm);if(config._nextDay)config._a[HOUR]=
24}function dayOfYearFromWeekInfo(config){var w,weekYear,week,weekday,dow,doy,temp,weekdayOverflow;w=config._w;if(w.GG!=null||w.W!=null||w.E!=null){dow=1;doy=4;weekYear=defaults(w.GG,config._a[YEAR],weekOfYear(local__createLocal(),1,4).year);week=defaults(w.W,1);weekday=defaults(w.E,1);if(weekday<1||weekday>7)weekdayOverflow=true}else{dow=config._locale._week.dow;doy=config._locale._week.doy;weekYear=defaults(w.gg,config._a[YEAR],weekOfYear(local__createLocal(),dow,doy).year);week=defaults(w.w,1);
if(w.d!=null){weekday=w.d;if(weekday<0||weekday>6)weekdayOverflow=true}else if(w.e!=null){weekday=w.e+dow;if(w.e<0||w.e>6)weekdayOverflow=true}else weekday=dow}if(week<1||week>weeksInYear(weekYear,dow,doy))getParsingFlags(config)._overflowWeeks=true;else if(weekdayOverflow!=null)getParsingFlags(config)._overflowWeekday=true;else{temp=dayOfYearFromWeeks(weekYear,week,weekday,dow,doy);config._a[YEAR]=temp.year;config._dayOfYear=temp.dayOfYear}}utils_hooks__hooks.ISO_8601=function(){};function configFromStringAndFormat(config){if(config._f===
utils_hooks__hooks.ISO_8601){configFromISO(config);return}config._a=[];getParsingFlags(config).empty=true;var string=""+config._i,i,parsedInput,tokens,token,skipped,stringLength=string.length,totalParsedInputLength=0;tokens=expandFormat(config._f,config._locale).match(formattingTokens)||[];for(i=0;i<tokens.length;i++){token=tokens[i];parsedInput=(string.match(getParseRegexForToken(token,config))||[])[0];if(parsedInput){skipped=string.substr(0,string.indexOf(parsedInput));if(skipped.length>0)getParsingFlags(config).unusedInput.push(skipped);
string=string.slice(string.indexOf(parsedInput)+parsedInput.length);totalParsedInputLength+=parsedInput.length}if(formatTokenFunctions[token]){if(parsedInput)getParsingFlags(config).empty=false;else getParsingFlags(config).unusedTokens.push(token);addTimeToArrayFromToken(token,parsedInput,config)}else if(config._strict&&!parsedInput)getParsingFlags(config).unusedTokens.push(token)}getParsingFlags(config).charsLeftOver=stringLength-totalParsedInputLength;if(string.length>0)getParsingFlags(config).unusedInput.push(string);
if(config._a[HOUR]<=12&&getParsingFlags(config).bigHour===true&&config._a[HOUR]>0)getParsingFlags(config).bigHour=undefined;getParsingFlags(config).parsedDateParts=config._a.slice(0);getParsingFlags(config).meridiem=config._meridiem;config._a[HOUR]=meridiemFixWrap(config._locale,config._a[HOUR],config._meridiem);configFromArray(config);checkOverflow(config)}function meridiemFixWrap(locale,hour,meridiem){var isPm;if(meridiem==null)return hour;if(locale.meridiemHour!=null)return locale.meridiemHour(hour,
meridiem);else if(locale.isPM!=null){isPm=locale.isPM(meridiem);if(isPm&&hour<12)hour+=12;if(!isPm&&hour===12)hour=0;return hour}else return hour}function configFromStringAndArray(config){var tempConfig,bestMoment,scoreToBeat,i,currentScore;if(config._f.length===0){getParsingFlags(config).invalidFormat=true;config._d=new Date(NaN);return}for(i=0;i<config._f.length;i++){currentScore=0;tempConfig=copyConfig({},config);if(config._useUTC!=null)tempConfig._useUTC=config._useUTC;tempConfig._f=config._f[i];
configFromStringAndFormat(tempConfig);if(!valid__isValid(tempConfig))continue;currentScore+=getParsingFlags(tempConfig).charsLeftOver;currentScore+=getParsingFlags(tempConfig).unusedTokens.length*10;getParsingFlags(tempConfig).score=currentScore;if(scoreToBeat==null||currentScore<scoreToBeat){scoreToBeat=currentScore;bestMoment=tempConfig}}extend(config,bestMoment||tempConfig)}function configFromObject(config){if(config._d)return;var i=normalizeObjectUnits(config._i);config._a=map([i.year,i.month,
i.day||i.date,i.hour,i.minute,i.second,i.millisecond],function(obj){return obj&&parseInt(obj,10)});configFromArray(config)}function createFromConfig(config){var res=new Moment(checkOverflow(prepareConfig(config)));if(res._nextDay){res.add(1,"d");res._nextDay=undefined}return res}function prepareConfig(config){var input=config._i,format=config._f;config._locale=config._locale||locale_locales__getLocale(config._l);if(input===null||format===undefined&&input==="")return valid__createInvalid({nullInput:true});
if(typeof input==="string")config._i=input=config._locale.preparse(input);if(isMoment(input))return new Moment(checkOverflow(input));else if(isArray(format))configFromStringAndArray(config);else if(isDate(input))config._d=input;else if(format)configFromStringAndFormat(config);else configFromInput(config);if(!valid__isValid(config))config._d=null;return config}function configFromInput(config){var input=config._i;if(input===undefined)config._d=new Date(utils_hooks__hooks.now());else if(isDate(input))config._d=
new Date(input.valueOf());else if(typeof input==="string")configFromString(config);else if(isArray(input)){config._a=map(input.slice(0),function(obj){return parseInt(obj,10)});configFromArray(config)}else if(typeof input==="object")configFromObject(config);else if(typeof input==="number")config._d=new Date(input);else utils_hooks__hooks.createFromInputFallback(config)}function createLocalOrUTC(input,format,locale,strict,isUTC){var c={};if(typeof locale==="boolean"){strict=locale;locale=undefined}if(isObject(input)&&
isObjectEmpty(input)||isArray(input)&&input.length===0)input=undefined;c._isAMomentObject=true;c._useUTC=c._isUTC=isUTC;c._l=locale;c._i=input;c._f=format;c._strict=strict;return createFromConfig(c)}function local__createLocal(input,format,locale,strict){return createLocalOrUTC(input,format,locale,strict,false)}var prototypeMin=deprecate("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",function(){var other=local__createLocal.apply(null,arguments);
if(this.isValid()&&other.isValid())return other<this?this:other;else return valid__createInvalid()});var prototypeMax=deprecate("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",function(){var other=local__createLocal.apply(null,arguments);if(this.isValid()&&other.isValid())return other>this?this:other;else return valid__createInvalid()});function pickBy(fn,moments){var res,i;if(moments.length===1&&isArray(moments[0]))moments=moments[0];if(!moments.length)return local__createLocal();
res=moments[0];for(i=1;i<moments.length;++i)if(!moments[i].isValid()||moments[i][fn](res))res=moments[i];return res}function min(){var args=[].slice.call(arguments,0);return pickBy("isBefore",args)}function max(){var args=[].slice.call(arguments,0);return pickBy("isAfter",args)}var now=function(){return Date.now?Date.now():+new Date};function Duration(duration){var normalizedInput=normalizeObjectUnits(duration),years=normalizedInput.year||0,quarters=normalizedInput.quarter||0,months=normalizedInput.month||
0,weeks=normalizedInput.week||0,days=normalizedInput.day||0,hours=normalizedInput.hour||0,minutes=normalizedInput.minute||0,seconds=normalizedInput.second||0,milliseconds=normalizedInput.millisecond||0;this._milliseconds=+milliseconds+seconds*1E3+minutes*6E4+hours*1E3*60*60;this._days=+days+weeks*7;this._months=+months+quarters*3+years*12;this._data={};this._locale=locale_locales__getLocale();this._bubble()}function isDuration(obj){return obj instanceof Duration}function offset(token,separator){addFormatToken(token,
0,0,function(){var offset=this.utcOffset();var sign="+";if(offset<0){offset=-offset;sign="-"}return sign+zeroFill(~~(offset/60),2)+separator+zeroFill(~~offset%60,2)})}offset("Z",":");offset("ZZ","");addRegexToken("Z",matchShortOffset);addRegexToken("ZZ",matchShortOffset);addParseToken(["Z","ZZ"],function(input,array,config){config._useUTC=true;config._tzm=offsetFromString(matchShortOffset,input)});var chunkOffset=/([\+\-]|\d\d)/gi;function offsetFromString(matcher,string){var matches=(string||"").match(matcher)||
[];var chunk=matches[matches.length-1]||[];var parts=(chunk+"").match(chunkOffset)||["-",0,0];var minutes=+(parts[1]*60)+toInt(parts[2]);return parts[0]==="+"?minutes:-minutes}function cloneWithOffset(input,model){var res,diff;if(model._isUTC){res=model.clone();diff=(isMoment(input)||isDate(input)?input.valueOf():local__createLocal(input).valueOf())-res.valueOf();res._d.setTime(res._d.valueOf()+diff);utils_hooks__hooks.updateOffset(res,false);return res}else return local__createLocal(input).local()}
function getDateOffset(m){return-Math.round(m._d.getTimezoneOffset()/15)*15}utils_hooks__hooks.updateOffset=function(){};function getSetOffset(input,keepLocalTime){var offset=this._offset||0,localAdjust;if(!this.isValid())return input!=null?this:NaN;if(input!=null){if(typeof input==="string")input=offsetFromString(matchShortOffset,input);else if(Math.abs(input)<16)input=input*60;if(!this._isUTC&&keepLocalTime)localAdjust=getDateOffset(this);this._offset=input;this._isUTC=true;if(localAdjust!=null)this.add(localAdjust,
"m");if(offset!==input)if(!keepLocalTime||this._changeInProgress)add_subtract__addSubtract(this,create__createDuration(input-offset,"m"),1,false);else if(!this._changeInProgress){this._changeInProgress=true;utils_hooks__hooks.updateOffset(this,true);this._changeInProgress=null}return this}else return this._isUTC?offset:getDateOffset(this)}function getSetZone(input,keepLocalTime){if(input!=null){if(typeof input!=="string")input=-input;this.utcOffset(input,keepLocalTime);return this}else return-this.utcOffset()}
function setOffsetToUTC(keepLocalTime){return this.utcOffset(0,keepLocalTime)}function setOffsetToLocal(keepLocalTime){if(this._isUTC){this.utcOffset(0,keepLocalTime);this._isUTC=false;if(keepLocalTime)this.subtract(getDateOffset(this),"m")}return this}function setOffsetToParsedOffset(){if(this._tzm)this.utcOffset(this._tzm);else if(typeof this._i==="string")this.utcOffset(offsetFromString(matchOffset,this._i));return this}function hasAlignedHourOffset(input){if(!this.isValid())return false;input=
input?local__createLocal(input).utcOffset():0;return(this.utcOffset()-input)%60===0}function isDaylightSavingTime(){return this.utcOffset()>this.clone().month(0).utcOffset()||this.utcOffset()>this.clone().month(5).utcOffset()}function isDaylightSavingTimeShifted(){if(!isUndefined(this._isDSTShifted))return this._isDSTShifted;var c={};copyConfig(c,this);c=prepareConfig(c);if(c._a){var other=c._isUTC?create_utc__createUTC(c._a):local__createLocal(c._a);this._isDSTShifted=this.isValid()&&compareArrays(c._a,
other.toArray())>0}else this._isDSTShifted=false;return this._isDSTShifted}function isLocal(){return this.isValid()?!this._isUTC:false}function isUtcOffset(){return this.isValid()?this._isUTC:false}function isUtc(){return this.isValid()?this._isUTC&&this._offset===0:false}var aspNetRegex=/^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?\d*)?$/;var isoRegex=/^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;
function create__createDuration(input,key){var duration=input,match=null,sign,ret,diffRes;if(isDuration(input))duration={ms:input._milliseconds,d:input._days,M:input._months};else if(typeof input==="number"){duration={};if(key)duration[key]=input;else duration.milliseconds=input}else if(!!(match=aspNetRegex.exec(input))){sign=match[1]==="-"?-1:1;duration={y:0,d:toInt(match[DATE])*sign,h:toInt(match[HOUR])*sign,m:toInt(match[MINUTE])*sign,s:toInt(match[SECOND])*sign,ms:toInt(match[MILLISECOND])*sign}}else if(!!(match=
isoRegex.exec(input))){sign=match[1]==="-"?-1:1;duration={y:parseIso(match[2],sign),M:parseIso(match[3],sign),w:parseIso(match[4],sign),d:parseIso(match[5],sign),h:parseIso(match[6],sign),m:parseIso(match[7],sign),s:parseIso(match[8],sign)}}else if(duration==null)duration={};else if(typeof duration==="object"&&("from"in duration||"to"in duration)){diffRes=momentsDifference(local__createLocal(duration.from),local__createLocal(duration.to));duration={};duration.ms=diffRes.milliseconds;duration.M=diffRes.months}ret=
new Duration(duration);if(isDuration(input)&&hasOwnProp(input,"_locale"))ret._locale=input._locale;return ret}create__createDuration.fn=Duration.prototype;function parseIso(inp,sign){var res=inp&&parseFloat(inp.replace(",","."));return(isNaN(res)?0:res)*sign}function positiveMomentsDifference(base,other){var res={milliseconds:0,months:0};res.months=other.month()-base.month()+(other.year()-base.year())*12;if(base.clone().add(res.months,"M").isAfter(other))--res.months;res.milliseconds=+other-+base.clone().add(res.months,
"M");return res}function momentsDifference(base,other){var res;if(!(base.isValid()&&other.isValid()))return{milliseconds:0,months:0};other=cloneWithOffset(other,base);if(base.isBefore(other))res=positiveMomentsDifference(base,other);else{res=positiveMomentsDifference(other,base);res.milliseconds=-res.milliseconds;res.months=-res.months}return res}function absRound(number){if(number<0)return Math.round(-1*number)*-1;else return Math.round(number)}function createAdder(direction,name){return function(val,
period){var dur,tmp;if(period!==null&&!isNaN(+period)){deprecateSimple(name,"moment()."+name+"(period, number) is deprecated. Please use moment()."+name+"(number, period). "+"See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.");tmp=val;val=period;period=tmp}val=typeof val==="string"?+val:val;dur=create__createDuration(val,period);add_subtract__addSubtract(this,dur,direction);return this}}function add_subtract__addSubtract(mom,duration,isAdding,updateOffset){var milliseconds=
duration._milliseconds,days=absRound(duration._days),months=absRound(duration._months);if(!mom.isValid())return;updateOffset=updateOffset==null?true:updateOffset;if(milliseconds)mom._d.setTime(mom._d.valueOf()+milliseconds*isAdding);if(days)get_set__set(mom,"Date",get_set__get(mom,"Date")+days*isAdding);if(months)setMonth(mom,get_set__get(mom,"Month")+months*isAdding);if(updateOffset)utils_hooks__hooks.updateOffset(mom,days||months)}var add_subtract__add=createAdder(1,"add");var add_subtract__subtract=
createAdder(-1,"subtract");function getCalendarFormat(myMoment,now){var diff=myMoment.diff(now,"days",true);return diff<-6?"sameElse":diff<-1?"lastWeek":diff<0?"lastDay":diff<1?"sameDay":diff<2?"nextDay":diff<7?"nextWeek":"sameElse"}function moment_calendar__calendar(time,formats){var now=time||local__createLocal(),sod=cloneWithOffset(now,this).startOf("day"),format=utils_hooks__hooks.calendarFormat(this,sod)||"sameElse";var output=formats&&(isFunction(formats[format])?formats[format].call(this,now):
formats[format]);return this.format(output||this.localeData().calendar(format,this,local__createLocal(now)))}function clone(){return new Moment(this)}function isAfter(input,units){var localInput=isMoment(input)?input:local__createLocal(input);if(!(this.isValid()&&localInput.isValid()))return false;units=normalizeUnits(!isUndefined(units)?units:"millisecond");if(units==="millisecond")return this.valueOf()>localInput.valueOf();else return localInput.valueOf()<this.clone().startOf(units).valueOf()}function isBefore(input,
units){var localInput=isMoment(input)?input:local__createLocal(input);if(!(this.isValid()&&localInput.isValid()))return false;units=normalizeUnits(!isUndefined(units)?units:"millisecond");if(units==="millisecond")return this.valueOf()<localInput.valueOf();else return this.clone().endOf(units).valueOf()<localInput.valueOf()}function isBetween(from,to,units,inclusivity){inclusivity=inclusivity||"()";return(inclusivity[0]==="("?this.isAfter(from,units):!this.isBefore(from,units))&&(inclusivity[1]===
")"?this.isBefore(to,units):!this.isAfter(to,units))}function isSame(input,units){var localInput=isMoment(input)?input:local__createLocal(input),inputMs;if(!(this.isValid()&&localInput.isValid()))return false;units=normalizeUnits(units||"millisecond");if(units==="millisecond")return this.valueOf()===localInput.valueOf();else{inputMs=localInput.valueOf();return this.clone().startOf(units).valueOf()<=inputMs&&inputMs<=this.clone().endOf(units).valueOf()}}function isSameOrAfter(input,units){return this.isSame(input,
units)||this.isAfter(input,units)}function isSameOrBefore(input,units){return this.isSame(input,units)||this.isBefore(input,units)}function diff(input,units,asFloat){var that,zoneDelta,delta,output;if(!this.isValid())return NaN;that=cloneWithOffset(input,this);if(!that.isValid())return NaN;zoneDelta=(that.utcOffset()-this.utcOffset())*6E4;units=normalizeUnits(units);if(units==="year"||units==="month"||units==="quarter"){output=monthDiff(this,that);if(units==="quarter")output=output/3;else if(units===
"year")output=output/12}else{delta=this-that;output=units==="second"?delta/1E3:units==="minute"?delta/6E4:units==="hour"?delta/36E5:units==="day"?(delta-zoneDelta)/864E5:units==="week"?(delta-zoneDelta)/6048E5:delta}return asFloat?output:absFloor(output)}function monthDiff(a,b){var wholeMonthDiff=(b.year()-a.year())*12+(b.month()-a.month()),anchor=a.clone().add(wholeMonthDiff,"months"),anchor2,adjust;if(b-anchor<0){anchor2=a.clone().add(wholeMonthDiff-1,"months");adjust=(b-anchor)/(anchor-anchor2)}else{anchor2=
a.clone().add(wholeMonthDiff+1,"months");adjust=(b-anchor)/(anchor2-anchor)}return-(wholeMonthDiff+adjust)||0}utils_hooks__hooks.defaultFormat="YYYY-MM-DDTHH:mm:ssZ";utils_hooks__hooks.defaultFormatUtc="YYYY-MM-DDTHH:mm:ss[Z]";function toString(){return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")}function moment_format__toISOString(){var m=this.clone().utc();if(0<m.year()&&m.year()<=9999)if(isFunction(Date.prototype.toISOString))return this.toDate().toISOString();else return formatMoment(m,
"YYYY-MM-DD[T]HH:mm:ss.SSS[Z]");else return formatMoment(m,"YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]")}function format(inputString){if(!inputString)inputString=this.isUtc()?utils_hooks__hooks.defaultFormatUtc:utils_hooks__hooks.defaultFormat;var output=formatMoment(this,inputString);return this.localeData().postformat(output)}function from(time,withoutSuffix){if(this.isValid()&&(isMoment(time)&&time.isValid()||local__createLocal(time).isValid()))return create__createDuration({to:this,from:time}).locale(this.locale()).humanize(!withoutSuffix);
else return this.localeData().invalidDate()}function fromNow(withoutSuffix){return this.from(local__createLocal(),withoutSuffix)}function to(time,withoutSuffix){if(this.isValid()&&(isMoment(time)&&time.isValid()||local__createLocal(time).isValid()))return create__createDuration({from:this,to:time}).locale(this.locale()).humanize(!withoutSuffix);else return this.localeData().invalidDate()}function toNow(withoutSuffix){return this.to(local__createLocal(),withoutSuffix)}function locale(key){var newLocaleData;
if(key===undefined)return this._locale._abbr;else{newLocaleData=locale_locales__getLocale(key);if(newLocaleData!=null)this._locale=newLocaleData;return this}}var lang=deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",function(key){if(key===undefined)return this.localeData();else return this.locale(key)});function localeData(){return this._locale}function startOf(units){units=normalizeUnits(units);
switch(units){case "year":this.month(0);case "quarter":case "month":this.date(1);case "week":case "isoWeek":case "day":case "date":this.hours(0);case "hour":this.minutes(0);case "minute":this.seconds(0);case "second":this.milliseconds(0)}if(units==="week")this.weekday(0);if(units==="isoWeek")this.isoWeekday(1);if(units==="quarter")this.month(Math.floor(this.month()/3)*3);return this}function endOf(units){units=normalizeUnits(units);if(units===undefined||units==="millisecond")return this;if(units===
"date")units="day";return this.startOf(units).add(1,units==="isoWeek"?"week":units).subtract(1,"ms")}function to_type__valueOf(){return this._d.valueOf()-(this._offset||0)*6E4}function unix(){return Math.floor(this.valueOf()/1E3)}function toDate(){return new Date(this.valueOf())}function toArray(){var m=this;return[m.year(),m.month(),m.date(),m.hour(),m.minute(),m.second(),m.millisecond()]}function toObject(){var m=this;return{years:m.year(),months:m.month(),date:m.date(),hours:m.hours(),minutes:m.minutes(),
seconds:m.seconds(),milliseconds:m.milliseconds()}}function toJSON(){return this.isValid()?this.toISOString():null}function moment_valid__isValid(){return valid__isValid(this)}function parsingFlags(){return extend({},getParsingFlags(this))}function invalidAt(){return getParsingFlags(this).overflow}function creationData(){return{input:this._i,format:this._f,locale:this._locale,isUTC:this._isUTC,strict:this._strict}}addFormatToken(0,["gg",2],0,function(){return this.weekYear()%100});addFormatToken(0,
["GG",2],0,function(){return this.isoWeekYear()%100});function addWeekYearFormatToken(token,getter){addFormatToken(0,[token,token.length],0,getter)}addWeekYearFormatToken("gggg","weekYear");addWeekYearFormatToken("ggggg","weekYear");addWeekYearFormatToken("GGGG","isoWeekYear");addWeekYearFormatToken("GGGGG","isoWeekYear");addUnitAlias("weekYear","gg");addUnitAlias("isoWeekYear","GG");addUnitPriority("weekYear",1);addUnitPriority("isoWeekYear",1);addRegexToken("G",matchSigned);addRegexToken("g",matchSigned);
addRegexToken("GG",match1to2,match2);addRegexToken("gg",match1to2,match2);addRegexToken("GGGG",match1to4,match4);addRegexToken("gggg",match1to4,match4);addRegexToken("GGGGG",match1to6,match6);addRegexToken("ggggg",match1to6,match6);addWeekParseToken(["gggg","ggggg","GGGG","GGGGG"],function(input,week,config,token){week[token.substr(0,2)]=toInt(input)});addWeekParseToken(["gg","GG"],function(input,week,config,token){week[token]=utils_hooks__hooks.parseTwoDigitYear(input)});function getSetWeekYear(input){return getSetWeekYearHelper.call(this,
input,this.week(),this.weekday(),this.localeData()._week.dow,this.localeData()._week.doy)}function getSetISOWeekYear(input){return getSetWeekYearHelper.call(this,input,this.isoWeek(),this.isoWeekday(),1,4)}function getISOWeeksInYear(){return weeksInYear(this.year(),1,4)}function getWeeksInYear(){var weekInfo=this.localeData()._week;return weeksInYear(this.year(),weekInfo.dow,weekInfo.doy)}function getSetWeekYearHelper(input,week,weekday,dow,doy){var weeksTarget;if(input==null)return weekOfYear(this,
dow,doy).year;else{weeksTarget=weeksInYear(input,dow,doy);if(week>weeksTarget)week=weeksTarget;return setWeekAll.call(this,input,week,weekday,dow,doy)}}function setWeekAll(weekYear,week,weekday,dow,doy){var dayOfYearData=dayOfYearFromWeeks(weekYear,week,weekday,dow,doy),date=createUTCDate(dayOfYearData.year,0,dayOfYearData.dayOfYear);this.year(date.getUTCFullYear());this.month(date.getUTCMonth());this.date(date.getUTCDate());return this}addFormatToken("Q",0,"Qo","quarter");addUnitAlias("quarter",
"Q");addUnitPriority("quarter",7);addRegexToken("Q",match1);addParseToken("Q",function(input,array){array[MONTH]=(toInt(input)-1)*3});function getSetQuarter(input){return input==null?Math.ceil((this.month()+1)/3):this.month((input-1)*3+this.month()%3)}addFormatToken("D",["DD",2],"Do","date");addUnitAlias("date","D");addUnitPriority("date",9);addRegexToken("D",match1to2);addRegexToken("DD",match1to2,match2);addRegexToken("Do",function(isStrict,locale){return isStrict?locale._ordinalParse:locale._ordinalParseLenient});
addParseToken(["D","DD"],DATE);addParseToken("Do",function(input,array){array[DATE]=toInt(input.match(match1to2)[0],10)});var getSetDayOfMonth=makeGetSet("Date",true);addFormatToken("DDD",["DDDD",3],"DDDo","dayOfYear");addUnitAlias("dayOfYear","DDD");addUnitPriority("dayOfYear",4);addRegexToken("DDD",match1to3);addRegexToken("DDDD",match3);addParseToken(["DDD","DDDD"],function(input,array,config){config._dayOfYear=toInt(input)});function getSetDayOfYear(input){var dayOfYear=Math.round((this.clone().startOf("day")-
this.clone().startOf("year"))/864E5)+1;return input==null?dayOfYear:this.add(input-dayOfYear,"d")}addFormatToken("m",["mm",2],0,"minute");addUnitAlias("minute","m");addUnitPriority("minute",14);addRegexToken("m",match1to2);addRegexToken("mm",match1to2,match2);addParseToken(["m","mm"],MINUTE);var getSetMinute=makeGetSet("Minutes",false);addFormatToken("s",["ss",2],0,"second");addUnitAlias("second","s");addUnitPriority("second",15);addRegexToken("s",match1to2);addRegexToken("ss",match1to2,match2);addParseToken(["s",
"ss"],SECOND);var getSetSecond=makeGetSet("Seconds",false);addFormatToken("S",0,0,function(){return~~(this.millisecond()/100)});addFormatToken(0,["SS",2],0,function(){return~~(this.millisecond()/10)});addFormatToken(0,["SSS",3],0,"millisecond");addFormatToken(0,["SSSS",4],0,function(){return this.millisecond()*10});addFormatToken(0,["SSSSS",5],0,function(){return this.millisecond()*100});addFormatToken(0,["SSSSSS",6],0,function(){return this.millisecond()*1E3});addFormatToken(0,["SSSSSSS",7],0,function(){return this.millisecond()*
1E4});addFormatToken(0,["SSSSSSSS",8],0,function(){return this.millisecond()*1E5});addFormatToken(0,["SSSSSSSSS",9],0,function(){return this.millisecond()*1E6});addUnitAlias("millisecond","ms");addUnitPriority("millisecond",16);addRegexToken("S",match1to3,match1);addRegexToken("SS",match1to3,match2);addRegexToken("SSS",match1to3,match3);var token;for(token="SSSS";token.length<=9;token+="S")addRegexToken(token,matchUnsigned);function parseMs(input,array){array[MILLISECOND]=toInt(("0."+input)*1E3)}
for(token="S";token.length<=9;token+="S")addParseToken(token,parseMs);var getSetMillisecond=makeGetSet("Milliseconds",false);addFormatToken("z",0,0,"zoneAbbr");addFormatToken("zz",0,0,"zoneName");function getZoneAbbr(){return this._isUTC?"UTC":""}function getZoneName(){return this._isUTC?"Coordinated Universal Time":""}var momentPrototype__proto=Moment.prototype;momentPrototype__proto.add=add_subtract__add;momentPrototype__proto.calendar=moment_calendar__calendar;momentPrototype__proto.clone=clone;
momentPrototype__proto.diff=diff;momentPrototype__proto.endOf=endOf;momentPrototype__proto.format=format;momentPrototype__proto.from=from;momentPrototype__proto.fromNow=fromNow;momentPrototype__proto.to=to;momentPrototype__proto.toNow=toNow;momentPrototype__proto.get=stringGet;momentPrototype__proto.invalidAt=invalidAt;momentPrototype__proto.isAfter=isAfter;momentPrototype__proto.isBefore=isBefore;momentPrototype__proto.isBetween=isBetween;momentPrototype__proto.isSame=isSame;momentPrototype__proto.isSameOrAfter=
isSameOrAfter;momentPrototype__proto.isSameOrBefore=isSameOrBefore;momentPrototype__proto.isValid=moment_valid__isValid;momentPrototype__proto.lang=lang;momentPrototype__proto.locale=locale;momentPrototype__proto.localeData=localeData;momentPrototype__proto.max=prototypeMax;momentPrototype__proto.min=prototypeMin;momentPrototype__proto.parsingFlags=parsingFlags;momentPrototype__proto.set=stringSet;momentPrototype__proto.startOf=startOf;momentPrototype__proto.subtract=add_subtract__subtract;momentPrototype__proto.toArray=
toArray;momentPrototype__proto.toObject=toObject;momentPrototype__proto.toDate=toDate;momentPrototype__proto.toISOString=moment_format__toISOString;momentPrototype__proto.toJSON=toJSON;momentPrototype__proto.toString=toString;momentPrototype__proto.unix=unix;momentPrototype__proto.valueOf=to_type__valueOf;momentPrototype__proto.creationData=creationData;momentPrototype__proto.year=getSetYear;momentPrototype__proto.isLeapYear=getIsLeapYear;momentPrototype__proto.weekYear=getSetWeekYear;momentPrototype__proto.isoWeekYear=
getSetISOWeekYear;momentPrototype__proto.quarter=momentPrototype__proto.quarters=getSetQuarter;momentPrototype__proto.month=getSetMonth;momentPrototype__proto.daysInMonth=getDaysInMonth;momentPrototype__proto.week=momentPrototype__proto.weeks=getSetWeek;momentPrototype__proto.isoWeek=momentPrototype__proto.isoWeeks=getSetISOWeek;momentPrototype__proto.weeksInYear=getWeeksInYear;momentPrototype__proto.isoWeeksInYear=getISOWeeksInYear;momentPrototype__proto.date=getSetDayOfMonth;momentPrototype__proto.day=
momentPrototype__proto.days=getSetDayOfWeek;momentPrototype__proto.weekday=getSetLocaleDayOfWeek;momentPrototype__proto.isoWeekday=getSetISODayOfWeek;momentPrototype__proto.dayOfYear=getSetDayOfYear;momentPrototype__proto.hour=momentPrototype__proto.hours=getSetHour;momentPrototype__proto.minute=momentPrototype__proto.minutes=getSetMinute;momentPrototype__proto.second=momentPrototype__proto.seconds=getSetSecond;momentPrototype__proto.millisecond=momentPrototype__proto.milliseconds=getSetMillisecond;
momentPrototype__proto.utcOffset=getSetOffset;momentPrototype__proto.utc=setOffsetToUTC;momentPrototype__proto.local=setOffsetToLocal;momentPrototype__proto.parseZone=setOffsetToParsedOffset;momentPrototype__proto.hasAlignedHourOffset=hasAlignedHourOffset;momentPrototype__proto.isDST=isDaylightSavingTime;momentPrototype__proto.isLocal=isLocal;momentPrototype__proto.isUtcOffset=isUtcOffset;momentPrototype__proto.isUtc=isUtc;momentPrototype__proto.isUTC=isUtc;momentPrototype__proto.zoneAbbr=getZoneAbbr;
momentPrototype__proto.zoneName=getZoneName;momentPrototype__proto.dates=deprecate("dates accessor is deprecated. Use date instead.",getSetDayOfMonth);momentPrototype__proto.months=deprecate("months accessor is deprecated. Use month instead",getSetMonth);momentPrototype__proto.years=deprecate("years accessor is deprecated. Use year instead",getSetYear);momentPrototype__proto.zone=deprecate("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",getSetZone);
momentPrototype__proto.isDSTShifted=deprecate("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",isDaylightSavingTimeShifted);var momentPrototype=momentPrototype__proto;function moment__createUnix(input){return local__createLocal(input*1E3)}function moment__createInZone(){return local__createLocal.apply(null,arguments).parseZone()}function preParsePostFormat(string){return string}var prototype__proto=Locale.prototype;prototype__proto.calendar=
locale_calendar__calendar;prototype__proto.longDateFormat=longDateFormat;prototype__proto.invalidDate=invalidDate;prototype__proto.ordinal=ordinal;prototype__proto.preparse=preParsePostFormat;prototype__proto.postformat=preParsePostFormat;prototype__proto.relativeTime=relative__relativeTime;prototype__proto.pastFuture=pastFuture;prototype__proto.set=locale_set__set;prototype__proto.months=localeMonths;prototype__proto.monthsShort=localeMonthsShort;prototype__proto.monthsParse=localeMonthsParse;prototype__proto.monthsRegex=
monthsRegex;prototype__proto.monthsShortRegex=monthsShortRegex;prototype__proto.week=localeWeek;prototype__proto.firstDayOfYear=localeFirstDayOfYear;prototype__proto.firstDayOfWeek=localeFirstDayOfWeek;prototype__proto.weekdays=localeWeekdays;prototype__proto.weekdaysMin=localeWeekdaysMin;prototype__proto.weekdaysShort=localeWeekdaysShort;prototype__proto.weekdaysParse=localeWeekdaysParse;prototype__proto.weekdaysRegex=weekdaysRegex;prototype__proto.weekdaysShortRegex=weekdaysShortRegex;prototype__proto.weekdaysMinRegex=
weekdaysMinRegex;prototype__proto.isPM=localeIsPM;prototype__proto.meridiem=localeMeridiem;function lists__get(format,index,field,setter){var locale=locale_locales__getLocale();var utc=create_utc__createUTC().set(setter,index);return locale[field](utc,format)}function listMonthsImpl(format,index,field){if(typeof format==="number"){index=format;format=undefined}format=format||"";if(index!=null)return lists__get(format,index,field,"month");var i;var out=[];for(i=0;i<12;i++)out[i]=lists__get(format,
i,field,"month");return out}function listWeekdaysImpl(localeSorted,format,index,field){if(typeof localeSorted==="boolean"){if(typeof format==="number"){index=format;format=undefined}format=format||""}else{format=localeSorted;index=format;localeSorted=false;if(typeof format==="number"){index=format;format=undefined}format=format||""}var locale=locale_locales__getLocale(),shift=localeSorted?locale._week.dow:0;if(index!=null)return lists__get(format,(index+shift)%7,field,"day");var i;var out=[];for(i=
0;i<7;i++)out[i]=lists__get(format,(i+shift)%7,field,"day");return out}function lists__listMonths(format,index){return listMonthsImpl(format,index,"months")}function lists__listMonthsShort(format,index){return listMonthsImpl(format,index,"monthsShort")}function lists__listWeekdays(localeSorted,format,index){return listWeekdaysImpl(localeSorted,format,index,"weekdays")}function lists__listWeekdaysShort(localeSorted,format,index){return listWeekdaysImpl(localeSorted,format,index,"weekdaysShort")}function lists__listWeekdaysMin(localeSorted,
format,index){return listWeekdaysImpl(localeSorted,format,index,"weekdaysMin")}locale_locales__getSetGlobalLocale("en",{ordinalParse:/\d{1,2}(th|st|nd|rd)/,ordinal:function(number){var b=number%10,output=toInt(number%100/10)===1?"th":b===1?"st":b===2?"nd":b===3?"rd":"th";return number+output}});utils_hooks__hooks.lang=deprecate("moment.lang is deprecated. Use moment.locale instead.",locale_locales__getSetGlobalLocale);utils_hooks__hooks.langData=deprecate("moment.langData is deprecated. Use moment.localeData instead.",
locale_locales__getLocale);var mathAbs=Math.abs;function duration_abs__abs(){var data=this._data;this._milliseconds=mathAbs(this._milliseconds);this._days=mathAbs(this._days);this._months=mathAbs(this._months);data.milliseconds=mathAbs(data.milliseconds);data.seconds=mathAbs(data.seconds);data.minutes=mathAbs(data.minutes);data.hours=mathAbs(data.hours);data.months=mathAbs(data.months);data.years=mathAbs(data.years);return this}function duration_add_subtract__addSubtract(duration,input,value,direction){var other=
create__createDuration(input,value);duration._milliseconds+=direction*other._milliseconds;duration._days+=direction*other._days;duration._months+=direction*other._months;return duration._bubble()}function duration_add_subtract__add(input,value){return duration_add_subtract__addSubtract(this,input,value,1)}function duration_add_subtract__subtract(input,value){return duration_add_subtract__addSubtract(this,input,value,-1)}function absCeil(number){if(number<0)return Math.floor(number);else return Math.ceil(number)}
function bubble(){var milliseconds=this._milliseconds;var days=this._days;var months=this._months;var data=this._data;var seconds,minutes,hours,years,monthsFromDays;if(!(milliseconds>=0&&days>=0&&months>=0||milliseconds<=0&&days<=0&&months<=0)){milliseconds+=absCeil(monthsToDays(months)+days)*864E5;days=0;months=0}data.milliseconds=milliseconds%1E3;seconds=absFloor(milliseconds/1E3);data.seconds=seconds%60;minutes=absFloor(seconds/60);data.minutes=minutes%60;hours=absFloor(minutes/60);data.hours=
hours%24;days+=absFloor(hours/24);monthsFromDays=absFloor(daysToMonths(days));months+=monthsFromDays;days-=absCeil(monthsToDays(monthsFromDays));years=absFloor(months/12);months%=12;data.days=days;data.months=months;data.years=years;return this}function daysToMonths(days){return days*4800/146097}function monthsToDays(months){return months*146097/4800}function as(units){var days;var months;var milliseconds=this._milliseconds;units=normalizeUnits(units);if(units==="month"||units==="year"){days=this._days+
milliseconds/864E5;months=this._months+daysToMonths(days);return units==="month"?months:months/12}else{days=this._days+Math.round(monthsToDays(this._months));switch(units){case "week":return days/7+milliseconds/6048E5;case "day":return days+milliseconds/864E5;case "hour":return days*24+milliseconds/36E5;case "minute":return days*1440+milliseconds/6E4;case "second":return days*86400+milliseconds/1E3;case "millisecond":return Math.floor(days*864E5)+milliseconds;default:throw new Error("Unknown unit "+
units);}}}function duration_as__valueOf(){return this._milliseconds+this._days*864E5+this._months%12*2592E6+toInt(this._months/12)*31536E6}function makeAs(alias){return function(){return this.as(alias)}}var asMilliseconds=makeAs("ms");var asSeconds=makeAs("s");var asMinutes=makeAs("m");var asHours=makeAs("h");var asDays=makeAs("d");var asWeeks=makeAs("w");var asMonths=makeAs("M");var asYears=makeAs("y");function duration_get__get(units){units=normalizeUnits(units);return this[units+"s"]()}function makeGetter(name){return function(){return this._data[name]}}
var milliseconds=makeGetter("milliseconds");var seconds=makeGetter("seconds");var minutes=makeGetter("minutes");var hours=makeGetter("hours");var days=makeGetter("days");var months=makeGetter("months");var years=makeGetter("years");function weeks(){return absFloor(this.days()/7)}var round=Math.round;var thresholds={s:45,m:45,h:22,d:26,M:11};function substituteTimeAgo(string,number,withoutSuffix,isFuture,locale){return locale.relativeTime(number||1,!!withoutSuffix,string,isFuture)}function duration_humanize__relativeTime(posNegDuration,
withoutSuffix,locale){var duration=create__createDuration(posNegDuration).abs();var seconds=round(duration.as("s"));var minutes=round(duration.as("m"));var hours=round(duration.as("h"));var days=round(duration.as("d"));var months=round(duration.as("M"));var years=round(duration.as("y"));var a=seconds<thresholds.s&&["s",seconds]||minutes<=1&&["m"]||minutes<thresholds.m&&["mm",minutes]||hours<=1&&["h"]||hours<thresholds.h&&["hh",hours]||days<=1&&["d"]||days<thresholds.d&&["dd",days]||months<=1&&["M"]||
months<thresholds.M&&["MM",months]||years<=1&&["y"]||["yy",years];a[2]=withoutSuffix;a[3]=+posNegDuration>0;a[4]=locale;return substituteTimeAgo.apply(null,a)}function duration_humanize__getSetRelativeTimeRounding(roundingFunction){if(roundingFunction===undefined)return round;if(typeof roundingFunction==="function"){round=roundingFunction;return true}return false}function duration_humanize__getSetRelativeTimeThreshold(threshold,limit){if(thresholds[threshold]===undefined)return false;if(limit===undefined)return thresholds[threshold];
thresholds[threshold]=limit;return true}function humanize(withSuffix){var locale=this.localeData();var output=duration_humanize__relativeTime(this,!withSuffix,locale);if(withSuffix)output=locale.pastFuture(+this,output);return locale.postformat(output)}var iso_string__abs=Math.abs;function iso_string__toISOString(){var seconds=iso_string__abs(this._milliseconds)/1E3;var days=iso_string__abs(this._days);var months=iso_string__abs(this._months);var minutes,hours,years;minutes=absFloor(seconds/60);hours=
absFloor(minutes/60);seconds%=60;minutes%=60;years=absFloor(months/12);months%=12;var Y=years;var M=months;var D=days;var h=hours;var m=minutes;var s=seconds;var total=this.asSeconds();if(!total)return"P0D";return(total<0?"-":"")+"P"+(Y?Y+"Y":"")+(M?M+"M":"")+(D?D+"D":"")+(h||m||s?"T":"")+(h?h+"H":"")+(m?m+"M":"")+(s?s+"S":"")}var duration_prototype__proto=Duration.prototype;duration_prototype__proto.abs=duration_abs__abs;duration_prototype__proto.add=duration_add_subtract__add;duration_prototype__proto.subtract=
duration_add_subtract__subtract;duration_prototype__proto.as=as;duration_prototype__proto.asMilliseconds=asMilliseconds;duration_prototype__proto.asSeconds=asSeconds;duration_prototype__proto.asMinutes=asMinutes;duration_prototype__proto.asHours=asHours;duration_prototype__proto.asDays=asDays;duration_prototype__proto.asWeeks=asWeeks;duration_prototype__proto.asMonths=asMonths;duration_prototype__proto.asYears=asYears;duration_prototype__proto.valueOf=duration_as__valueOf;duration_prototype__proto._bubble=
bubble;duration_prototype__proto.get=duration_get__get;duration_prototype__proto.milliseconds=milliseconds;duration_prototype__proto.seconds=seconds;duration_prototype__proto.minutes=minutes;duration_prototype__proto.hours=hours;duration_prototype__proto.days=days;duration_prototype__proto.weeks=weeks;duration_prototype__proto.months=months;duration_prototype__proto.years=years;duration_prototype__proto.humanize=humanize;duration_prototype__proto.toISOString=iso_string__toISOString;duration_prototype__proto.toString=
iso_string__toISOString;duration_prototype__proto.toJSON=iso_string__toISOString;duration_prototype__proto.locale=locale;duration_prototype__proto.localeData=localeData;duration_prototype__proto.toIsoString=deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",iso_string__toISOString);duration_prototype__proto.lang=lang;addFormatToken("X",0,0,"unix");addFormatToken("x",0,0,"valueOf");addRegexToken("x",matchSigned);addRegexToken("X",matchTimestamp);addParseToken("X",
function(input,array,config){config._d=new Date(parseFloat(input,10)*1E3)});addParseToken("x",function(input,array,config){config._d=new Date(toInt(input))});utils_hooks__hooks.version="2.14.1";setHookCallback(local__createLocal);utils_hooks__hooks.fn=momentPrototype;utils_hooks__hooks.min=min;utils_hooks__hooks.max=max;utils_hooks__hooks.now=now;utils_hooks__hooks.utc=create_utc__createUTC;utils_hooks__hooks.unix=moment__createUnix;utils_hooks__hooks.months=lists__listMonths;utils_hooks__hooks.isDate=
isDate;utils_hooks__hooks.locale=locale_locales__getSetGlobalLocale;utils_hooks__hooks.invalid=valid__createInvalid;utils_hooks__hooks.duration=create__createDuration;utils_hooks__hooks.isMoment=isMoment;utils_hooks__hooks.weekdays=lists__listWeekdays;utils_hooks__hooks.parseZone=moment__createInZone;utils_hooks__hooks.localeData=locale_locales__getLocale;utils_hooks__hooks.isDuration=isDuration;utils_hooks__hooks.monthsShort=lists__listMonthsShort;utils_hooks__hooks.weekdaysMin=lists__listWeekdaysMin;
utils_hooks__hooks.defineLocale=defineLocale;utils_hooks__hooks.updateLocale=updateLocale;utils_hooks__hooks.locales=locale_locales__listLocales;utils_hooks__hooks.weekdaysShort=lists__listWeekdaysShort;utils_hooks__hooks.normalizeUnits=normalizeUnits;utils_hooks__hooks.relativeTimeRounding=duration_humanize__getSetRelativeTimeRounding;utils_hooks__hooks.relativeTimeThreshold=duration_humanize__getSetRelativeTimeThreshold;utils_hooks__hooks.calendarFormat=getCalendarFormat;utils_hooks__hooks.prototype=
momentPrototype;var _moment=utils_hooks__hooks;return _moment});(function(root,factory){if(typeof define==="function"&&define.amd)define(["moment"],factory);else if(typeof module==="object"&&module.exports)module.exports=factory(require("moment"));else factory(root.moment)})(this,function(moment){if(moment.tz!==undefined){logError("Moment Timezone "+moment.tz.version+" was already loaded "+(moment.tz.dataVersion?"with data from ":"without any data")+moment.tz.dataVersion);return moment}var VERSION=
"0.5.10",zones={},links={},names={},guesses={},cachedGuess,momentVersion=moment.version.split("."),major=+momentVersion[0],minor=+momentVersion[1];if(major<2||major===2&&minor<6)logError("Moment Timezone requires Moment.js \x3e\x3d 2.6.0. You are using Moment.js "+moment.version+". See momentjs.com");function charCodeToInt(charCode){if(charCode>96)return charCode-87;else if(charCode>64)return charCode-29;return charCode-48}function unpackBase60(string){var i=0,parts=string.split("."),whole=parts[0],
fractional=parts[1]||"",multiplier=1,num,out=0,sign=1;if(string.charCodeAt(0)===45){i=1;sign=-1}for(i;i<whole.length;i++){num=charCodeToInt(whole.charCodeAt(i));out=60*out+num}for(i=0;i<fractional.length;i++){multiplier=multiplier/60;num=charCodeToInt(fractional.charCodeAt(i));out+=num*multiplier}return out*sign}function arrayToInt(array){for(var i=0;i<array.length;i++)array[i]=unpackBase60(array[i])}function intToUntil(array,length){for(var i=0;i<length;i++)array[i]=Math.round((array[i-1]||0)+array[i]*
6E4);array[length-1]=Infinity}function mapIndices(source,indices){var out=[],i;for(i=0;i<indices.length;i++)out[i]=source[indices[i]];return out}function unpack(string){var data=string.split("|"),offsets=data[2].split(" "),indices=data[3].split(""),untils=data[4].split(" ");arrayToInt(offsets);arrayToInt(indices);arrayToInt(untils);intToUntil(untils,indices.length);return{name:data[0],abbrs:mapIndices(data[1].split(" "),indices),offsets:mapIndices(offsets,indices),untils:untils,population:data[5]|
0}}function Zone(packedString){if(packedString)this._set(unpack(packedString))}Zone.prototype={_set:function(unpacked){this.name=unpacked.name;this.abbrs=unpacked.abbrs;this.untils=unpacked.untils;this.offsets=unpacked.offsets;this.population=unpacked.population},_index:function(timestamp){var target=+timestamp,untils=this.untils,i;for(i=0;i<untils.length;i++)if(target<untils[i])return i},parse:function(timestamp){var target=+timestamp,offsets=this.offsets,untils=this.untils,max=untils.length-1,offset,
offsetNext,offsetPrev,i;for(i=0;i<max;i++){offset=offsets[i];offsetNext=offsets[i+1];offsetPrev=offsets[i?i-1:i];if(offset<offsetNext&&tz.moveAmbiguousForward)offset=offsetNext;else if(offset>offsetPrev&&tz.moveInvalidForward)offset=offsetPrev;if(target<untils[i]-offset*6E4)return offsets[i]}return offsets[max]},abbr:function(mom){return this.abbrs[this._index(mom)]},offset:function(mom){return this.offsets[this._index(mom)]}};function OffsetAt(at){var timeString=at.toTimeString();var abbr=timeString.match(/\([a-z ]+\)/i);
if(abbr&&abbr[0]){abbr=abbr[0].match(/[A-Z]/g);abbr=abbr?abbr.join(""):undefined}else{abbr=timeString.match(/[A-Z]{3,5}/g);abbr=abbr?abbr[0]:undefined}if(abbr==="GMT")abbr=undefined;this.at=+at;this.abbr=abbr;this.offset=at.getTimezoneOffset()}function ZoneScore(zone){this.zone=zone;this.offsetScore=0;this.abbrScore=0}ZoneScore.prototype.scoreOffsetAt=function(offsetAt){this.offsetScore+=Math.abs(this.zone.offset(offsetAt.at)-offsetAt.offset);if(this.zone.abbr(offsetAt.at).replace(/[^A-Z]/g,"")!==
offsetAt.abbr)this.abbrScore++};function findChange(low,high){var mid,diff;while(diff=((high.at-low.at)/12E4|0)*6E4){mid=new OffsetAt(new Date(low.at+diff));if(mid.offset===low.offset)low=mid;else high=mid}return low}function userOffsets(){var startYear=(new Date).getFullYear()-2,last=new OffsetAt(new Date(startYear,0,1)),offsets=[last],change,next,i;for(i=1;i<48;i++){next=new OffsetAt(new Date(startYear,i,1));if(next.offset!==last.offset){change=findChange(last,next);offsets.push(change);offsets.push(new OffsetAt(new Date(change.at+
6E4)))}last=next}for(i=0;i<4;i++){offsets.push(new OffsetAt(new Date(startYear+i,0,1)));offsets.push(new OffsetAt(new Date(startYear+i,6,1)))}return offsets}function sortZoneScores(a,b){if(a.offsetScore!==b.offsetScore)return a.offsetScore-b.offsetScore;if(a.abbrScore!==b.abbrScore)return a.abbrScore-b.abbrScore;return b.zone.population-a.zone.population}function addToGuesses(name,offsets){var i,offset;arrayToInt(offsets);for(i=0;i<offsets.length;i++){offset=offsets[i];guesses[offset]=guesses[offset]||
{};guesses[offset][name]=true}}function guessesForUserOffsets(offsets){var offsetsLength=offsets.length,filteredGuesses={},out=[],i,j,guessesOffset;for(i=0;i<offsetsLength;i++){guessesOffset=guesses[offsets[i].offset]||{};for(j in guessesOffset)if(guessesOffset.hasOwnProperty(j))filteredGuesses[j]=true}for(i in filteredGuesses)if(filteredGuesses.hasOwnProperty(i))out.push(names[i]);return out}function rebuildGuess(){try{var intlName=Intl.DateTimeFormat().resolvedOptions().timeZone;if(intlName){var name=
names[normalizeName(intlName)];if(name)return name;logError("Moment Timezone found "+intlName+" from the Intl api, but did not have that data loaded.")}}catch(e){}var offsets=userOffsets(),offsetsLength=offsets.length,guesses=guessesForUserOffsets(offsets),zoneScores=[],zoneScore,i,j;for(i=0;i<guesses.length;i++){zoneScore=new ZoneScore(getZone(guesses[i]),offsetsLength);for(j=0;j<offsetsLength;j++)zoneScore.scoreOffsetAt(offsets[j]);zoneScores.push(zoneScore)}zoneScores.sort(sortZoneScores);return zoneScores.length>
0?zoneScores[0].zone.name:undefined}function guess(ignoreCache){if(!cachedGuess||ignoreCache)cachedGuess=rebuildGuess();return cachedGuess}function normalizeName(name){return(name||"").toLowerCase().replace(/\//g,"_")}function addZone(packed){var i,name,split,normalized;if(typeof packed==="string")packed=[packed];for(i=0;i<packed.length;i++){split=packed[i].split("|");name=split[0];normalized=normalizeName(name);zones[normalized]=packed[i];names[normalized]=name;if(split[5])addToGuesses(normalized,
split[2].split(" "))}}function getZone(name,caller){name=normalizeName(name);var zone=zones[name];var link;if(zone instanceof Zone)return zone;if(typeof zone==="string"){zone=new Zone(zone);zones[name]=zone;return zone}if(links[name]&&caller!==getZone&&(link=getZone(links[name],getZone))){zone=zones[name]=new Zone;zone._set(link);zone.name=names[name];return zone}return null}function getNames(){var i,out=[];for(i in names)if(names.hasOwnProperty(i)&&(zones[i]||zones[links[i]])&&names[i])out.push(names[i]);
return out.sort()}function addLink(aliases){var i,alias,normal0,normal1;if(typeof aliases==="string")aliases=[aliases];for(i=0;i<aliases.length;i++){alias=aliases[i].split("|");normal0=normalizeName(alias[0]);normal1=normalizeName(alias[1]);links[normal0]=normal1;names[normal0]=alias[0];links[normal1]=normal0;names[normal1]=alias[1]}}function loadData(data){addZone(data.zones);addLink(data.links);tz.dataVersion=data.version}function zoneExists(name){if(!zoneExists.didShowError){zoneExists.didShowError=
true;logError("moment.tz.zoneExists('"+name+"') has been deprecated in favor of !moment.tz.zone('"+name+"')")}return!!getZone(name)}function needsOffset(m){return!!(m._a&&m._tzm===undefined)}function logError(message){if(typeof console!=="undefined"&&typeof console.error==="function")console.error(message)}function tz(input){var args=Array.prototype.slice.call(arguments,0,-1),name=arguments[arguments.length-1],zone=getZone(name),out=moment.utc.apply(null,args);if(zone&&!moment.isMoment(input)&&needsOffset(out))out.add(zone.parse(out),
"minutes");out.tz(name);return out}tz.version=VERSION;tz.dataVersion="";tz._zones=zones;tz._links=links;tz._names=names;tz.add=addZone;tz.link=addLink;tz.load=loadData;tz.zone=getZone;tz.zoneExists=zoneExists;tz.guess=guess;tz.names=getNames;tz.Zone=Zone;tz.unpack=unpack;tz.unpackBase60=unpackBase60;tz.needsOffset=needsOffset;tz.moveInvalidForward=true;tz.moveAmbiguousForward=false;var fn=moment.fn;moment.tz=tz;moment.defaultZone=null;moment.updateOffset=function(mom,keepTime){var zone=moment.defaultZone,
offset;if(mom._z===undefined){if(zone&&needsOffset(mom)&&!mom._isUTC){mom._d=moment.utc(mom._a)._d;mom.utc().add(zone.parse(mom),"minutes")}mom._z=zone}if(mom._z){offset=mom._z.offset(mom);if(Math.abs(offset)<16)offset=offset/60;if(mom.utcOffset!==undefined)mom.utcOffset(-offset,keepTime);else mom.zone(offset,keepTime)}};fn.tz=function(name){if(name){this._z=getZone(name);if(this._z)moment.updateOffset(this);else logError("Moment Timezone has no data for "+name+". See http://momentjs.com/timezone/docs/#/data-loading/.");
return this}if(this._z)return this._z.name};function abbrWrap(old){return function(){if(this._z)return this._z.abbr(this);return old.call(this)}}function resetZoneWrap(old){return function(){this._z=null;return old.apply(this,arguments)}}fn.zoneName=abbrWrap(fn.zoneName);fn.zoneAbbr=abbrWrap(fn.zoneAbbr);fn.utc=resetZoneWrap(fn.utc);moment.tz.setDefault=function(name){if(major<2||major===2&&minor<9)logError("Moment Timezone setDefault() requires Moment.js \x3e\x3d 2.9.0. You are using Moment.js "+
moment.version+".");moment.defaultZone=name?getZone(name):null;return moment};var momentProperties=moment.momentProperties;if(Object.prototype.toString.call(momentProperties)==="[object Array]"){momentProperties.push("_z");momentProperties.push("_a")}else if(momentProperties)momentProperties._z=null;loadData({"version":"2016j","zones":["Africa/Abidjan|GMT|0|0||48e5","Africa/Nairobi|EAT|-30|0||47e5","Africa/Algiers|CET|-10|0||26e5","Africa/Lagos|WAT|-10|0||17e6","Africa/Maputo|CAT|-20|0||26e5","Africa/Cairo|EET EEST|-20 -30|0101010101010101010101010101010|1bom0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 WL0 1qN0 Rb0 1wp0 On0 1zd0 Lz0 1EN0 Fb0 c10 8n0 8Nd0 gL0 e10 mn0|15e6",
"Africa/Casablanca|WET WEST|0 -10|010101010101010101010101010101010101010101010|1xwo0 AL0 1Nd0 wn0 1FB0 Db0 1zd0 Lz0 1Nf0 wM0 co0 go0 1o00 s00 dA0 vc0 11A0 A00 e00 y00 11A0 uM0 e00 Dc0 11A0 s00 e00 IM0 WM0 mo0 gM0 LA0 WM0 jA0 e00 Rc0 11A0 e00 e00 U00 11A0 8o0 e00 11A0|32e5","Europe/Paris|CET CEST|-10 -20|010101010101010101010101010101010101010101010|1bbd0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|11e6",
"Africa/Johannesburg|SAST|-20|0||84e5","Africa/Khartoum|CAT EAT|-20 -30|01|1d8y0|51e5","Africa/Tripoli|EET CET CEST|-20 -10 -20|0120|1IlA0 TA0 1o00|11e5","Africa/Tunis|CET CEST|-10 -20|010101010|1q1z0 10N0 1aN0 1qM0 WM0 1qM0 11A0 1o00|20e5","Africa/Windhoek|WAST WAT|-20 -10|010101010101010101010101010101010101010101010|1be00 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0|32e4",
"America/Adak|HST HDT|a0 90|010101010101010101010101010101010101010101010|1bec0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|326","America/Anchorage|AKST AKDT|90 80|010101010101010101010101010101010101010101010|1beb0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|30e4",
"America/Puerto_Rico|AST|40|0||24e5","America/Araguaina|BRST BRT|20 30|010101010101|1aVe0 1tB0 WL0 1tB0 Rb0 1zd0 On0 1HB0 FX0 ny10 Lz0|14e4","America/Argentina/Buenos_Aires|ART ARST ARST|30 30 20|0102020|1cqP0 10M0 j3c0 uL0 1qN0 WL0","America/Argentina/Catamarca|ART ARST WART ARST|30 30 40 20|0102030|1cqP0 10M0 ako0 7B0 8zb0 uL0","America/Argentina/Jujuy|ART ARST ARST|30 30 20|01020|1cqP0 10M0 j3c0 uL0","America/Argentina/Mendoza|ART ARST WART ARST|30 30 40 20|0102030|1cqP0 10M0 agM0 Op0 7TX0 uL0",
"America/Argentina/San_Juan|ART ARST WART ARST|30 30 40 20|0102030|1cqP0 10M0 ak00 m10 8lb0 uL0","America/Argentina/San_Luis|ART WARST WART ARST|30 30 40 20|01020312120|1cqP0 10M0 ak00 m10 8lb0 8L0 jd0 1qN0 WL0 1qN0","America/Argentina/Tucuman|ART ARST WART ARST|30 30 40 20|010203030|1cqP0 10M0 ako0 4N0 8BX0 uL0 1qN0 WL0","America/Argentina/Ushuaia|ART ARST WART ARST|30 30 40 20|0102030|1cqP0 10M0 ajA0 8p0 8zb0 uL0","America/Asuncion|PYST PYT|30 40|010101010101010101010101010101010101010101010|1b2P0 1o10 11z0 1o10 11z0 1qN0 1cL0 WN0 1qL0 11B0 1nX0 1ip0 WL0 1qN0 WL0 1qN0 WL0 1tB0 TX0 1tB0 TX0 1tB0 19X0 1a10 1fz0 1a10 1fz0 1cN0 17b0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0|28e5",
"America/Panama|EST|50|0||15e5","America/Bahia|BRST BRT|20 30|010101010101|1aVe0 1tB0 WL0 1tB0 Rb0 1zd0 On0 1HB0 FX0 l5B0 Rb0|27e5","America/Bahia_Banderas|MST MDT CDT CST|70 60 50 60|010101010101010101010102323232323232323232323|1be90 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nW0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0|84e3","America/Belem|BRT|30|0||20e5","America/Costa_Rica|CST|60|0||12e5",
"America/Boa_Vista|AMT AMST|40 30|01010|1cqQ0 WL0 1tB0 2L0|62e2","America/Bogota|COT|50|0||90e5","America/Denver|MST MDT|70 60|010101010101010101010101010101010101010101010|1be90 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|26e5","America/Cambridge_Bay|MST MDT CST CDT EST|70 60 60 50 50|0123421010101010101010101010101010101010101010|1be90 1nX0 11A0 1nX0 2K0 WQ0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|15e2",
"America/Campo_Grande|AMST AMT|30 40|010101010101010101010101010101010101010101010|1aVf0 1tB0 WL0 1tB0 Rb0 1zd0 On0 1HB0 FX0 1C10 Lz0 1Ip0 HX0 1zd0 On0 1HB0 IL0 1wp0 On0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 Rb0 1zd0 Lz0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 On0 1zd0 On0 1C10 Lz0 1C10 Lz0 1C10|77e4","America/Cancun|CST CDT EST|60 50 50|0101010101010101010101010101010102|1be80 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 Dd0|63e4",
"America/Caracas|VET VET|40 4u|010|1wmv0 kqo0|29e5","America/Cayenne|GFT|30|0||58e3","America/Chicago|CST CDT|60 50|010101010101010101010101010101010101010101010|1be80 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|92e5","America/Chihuahua|MST MDT|70 60|010101010101010101010101010101010101010101010|1be90 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0|81e4",
"America/Phoenix|MST|70|0||42e5","America/Cuiaba|AMST AMT|30 40|0101010101010101010101010101010101010101010|1aVf0 1tB0 WL0 1tB0 Rb0 1zd0 On0 1HB0 FX0 4a10 HX0 1zd0 On0 1HB0 IL0 1wp0 On0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 Rb0 1zd0 Lz0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 On0 1zd0 On0 1C10 Lz0 1C10 Lz0 1C10|54e4","America/Los_Angeles|PST PDT|80 70|010101010101010101010101010101010101010101010|1bea0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|15e6",
"America/New_York|EST EDT|50 40|010101010101010101010101010101010101010101010|1be70 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|21e6","America/Rio_Branco|ACT AMT|50 40|010|1xFF0 d5X0|31e4","America/Tijuana|PST PDT|80 70|010101010101010101010101010101010101010101010|1bea0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 U10 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|20e5",
"America/Fort_Nelson|PST PDT MST|80 70 70|0101010101010101010101010101010102|1bea0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0|39e2","America/Fort_Wayne|EST EDT|50 40|0101010101010101010101010101010|1sg70 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0","America/Fortaleza|BRT BRST|30 20|0101010|1cqP0 WL0 1tB0 5z0 2mN0 On0|34e5",
"America/Halifax|AST ADT|40 30|010101010101010101010101010101010101010101010|1be60 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|39e4","America/Godthab|WGT WGST|30 20|010101010101010101010101010101010101010101010|1bbd0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|17e3",
"America/Goose_Bay|AST ADT|40 30|010101010101010101010101010101010101010101010|1be41 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zcX Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|76e2","America/Grand_Turk|EST EDT AST|50 40 40|01010101010101010101010101010101012|1be70 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|37e2",
"America/Guatemala|CST CDT|60 50|010|1sri0 11z0|13e5","America/Guayaquil|ECT|50|0||27e5","America/Guyana|GYT|40|0||80e4","America/Havana|CST CDT|50 40|01010101010101010101010101010101010101010|1bbh0 1qM0 11A0 1o00 11A0 1o00 14o0 1lc0 14o0 1lc0 11A0 6i00 Rc0 1wo0 U00 1tA0 Rc0 1wo0 U00 1wo0 U00 1zc0 U00 1qM0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0|21e5","America/Indiana/Knox|EST CDT CST|50 50 60|0121212121212121212121212121212|1sg70 1o00 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0",
"America/Indiana/Petersburg|EST CDT CST EDT|50 50 60 40|0121030303030303030303030303030|1sg70 1o00 Rd0 1zb0 Oo0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0","America/Indiana/Winamac|EST CDT CST EDT|50 50 60 40|0123030303030303030303030303030|1sg70 1o00 Rd0 1za0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0","America/Iqaluit|EST EDT CST CDT|50 40 60 50|012301010101010101010101010101010101010101010|1be70 1nX0 11C0 1nX0 11A0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|67e2",
"America/Kentucky/Monticello|CST CDT EST EDT|60 50 50 40|010123232323232323232323232323232323232323232|1be80 1nX0 11B0 1nX0 11A0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0","America/La_Paz|BOT|40|0||19e5","America/Lima|PET|50|0||11e6","America/Managua|CST CDT|60 50|01010|1pRi0 19X0 1o30 11y0|22e5","America/Manaus|AMT|40|0||19e5","America/Matamoros|CST CDT|60 50|010101010101010101010101010101010101010101010|1be80 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 U10 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|45e4",
"America/Mexico_City|CST CDT|60 50|010101010101010101010101010101010101010101010|1be80 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0|20e6","America/Metlakatla|PST AKST AKDT|80 90 80|012121212121|1PAa0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|14e2","America/Miquelon|PMST PMDT|30 20|010101010101010101010101010101010101010101010|1be50 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|61e2",
"America/Moncton|AST ADT|40 30|010101010101010101010101010101010101010101010|1be41 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 ReX 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|64e3","America/Montevideo|UYT UYST|30 20|01010101010101010101010|1ow30 1fB0 1ip0 11z0 1ld0 14n0 1o10 11z0 1o10 11z0 1o10 14n0 1ld0 14n0 1ld0 14n0 1o10 11z0 1o10 11z0 1o10 11z0|17e5","America/Noronha|FNT FNST|20 10|0101010|1cqO0 WL0 1tB0 2L0 2pB0 On0|30e2",
"America/North_Dakota/Beulah|MST MDT CST CDT|70 60 60 50|010101010101010101010101232323232323232323232|1be90 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Oo0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0","America/North_Dakota/New_Salem|MST MDT CST CDT|70 60 60 50|010101010123232323232323232323232323232323232|1be90 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14o0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0",
"America/Ojinaga|MST MDT|70 60|010101010101010101010101010101010101010101010|1be90 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 U10 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|23e3","America/Paramaribo|SRT|30|0||24e4","America/Port-au-Prince|EST EDT|50 40|0101010101010|1pOt0 1nX0 11B0 1nX0 d430 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|23e5","America/Rankin_Inlet|CST CDT EST|60 50 50|010121010101010101010101010101010101010101010|1be80 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|26e2",
"America/Recife|BRT BRST|30 20|0101010|1cqP0 WL0 1tB0 2L0 2pB0 On0|33e5","America/Resolute|CST CDT EST|60 50 50|010121010101010121010101010101010101010101010|1be80 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|229","America/Santarem|AMT BRT|40 30|01|1xFE0|21e4","America/Santiago|CLST CLT|30 40|0101010101010101010101010101010101010101010|1be30 1fB0 11z0 1qN0 WL0 1qN0 WL0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 17b0 1ip0 11z0 1o10 19X0 1fB0 1nX0 G10 1EL0 Op0 1zb0 Rd0 1wn0 Rd0 46n0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1Nb0 Ap0|62e5",
"America/Santo_Domingo|AST EST|40 50|010|1f3G0 e00|29e5","America/Sao_Paulo|BRST BRT|20 30|010101010101010101010101010101010101010101010|1aVe0 1tB0 WL0 1tB0 Rb0 1zd0 On0 1HB0 FX0 1C10 Lz0 1Ip0 HX0 1zd0 On0 1HB0 IL0 1wp0 On0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 Rb0 1zd0 Lz0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 On0 1zd0 On0 1C10 Lz0 1C10 Lz0 1C10|20e6","America/Scoresbysund|EGT EGST|10 0|010101010101010101010101010101010101010101010|1bbd0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|452",
"America/St_Johns|NST NDT|3u 2u|010101010101010101010101010101010101010101010|1be3v 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zcX Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|11e4","America/Tegucigalpa|CST CDT|60 50|010|1su60 AL0|11e5","America/Winnipeg|CST CDT|60 50|010101010101010101010101010101010101010101010|1be80 1o00 11A0 1o00 11A0 1o00 14o0 1lc0 14o0 1lc0 14o0 1o00 11A0 1o00 11A0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|66e4",
"Antarctica/Casey|+08 +11|-80 -b0|010101|1ARS0 T90 40P0 KL0 blz0|10","Antarctica/Davis|+07 +05|-70 -50|01010|1ART0 VB0 3Wn0 KN0|70","Antarctica/DumontDUrville|+10|-a0|0||80","Antarctica/Macquarie|AEDT AEST MIST|-b0 -a0 -b0|010101010101010101010102|1bb40 1fA0 1a00 11A0 1o00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1cM0 1a00 1io0 1cM0 1cM0 1cM0 1cM0 1cM0|1","Antarctica/Mawson|+06 +05|-60 -50|01|1ARU0|60","Pacific/Auckland|NZDT NZST|-d0 -c0|010101010101010101010101010101010101010101010|1b8e0 1io0 17c0 1io0 17c0 1lc0 14o0 1lc0 14o0 1lc0 17c0 1io0 17c0 1io0 17c0 1io0 17c0 1io0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00|14e5",
"Antarctica/Rothera|-03|30|0||130","Antarctica/Syowa|+03|-30|0||20","Antarctica/Troll|-00 +00 +02|0 0 -20|0121212121212121212121212121212121|1puo0 hd0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|40","Antarctica/Vostok|+06|-60|0||25","Asia/Riyadh|AST|-30|0||57e5","Asia/Almaty|+06 +07|-60 -70|0101010101010|1bb80 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0|15e5","Asia/Amman|EET EEST|-20 -30|0101010101010101010101010101010101010101010|1bNa0 y00 1fc0 1dc0 1co0 1dc0 1cM0 1cM0 1cM0 1o00 11A0 1lc0 17c0 1cM0 1cM0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 4bX0 Dd0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0|25e5",
"Asia/Kamchatka|+12 +13 +11|-c0 -d0 -b0|0101010101010101010101020|1bb20 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 2sp0 WM0|18e4","Asia/Oral|+04 +05|-40 -50|010101010101|1bba0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0|27e4","Asia/Aqtobe|+05 +06|-50 -60|0101010101010|1bb90 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0|27e4","Asia/Tashkent|+05|-50|0||23e5","Asia/Atyrau|+05 +04|-50 -40|01010101010|1cBW0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0",
"Asia/Baghdad|AST ADT|-30 -40|0101010101010101010|1bcM0 1dc0 1dc0 1dc0 1cM0 1dc0 1cM0 1dc0 1cM0 1dc0 1dc0 1dc0 1cM0 1dc0 1cM0 1dc0 1cM0 1dc0|66e5","Asia/Baku|+04 +05|-40 -50|01010101010101010101010101010101010|1bbc0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|27e5","Asia/Bangkok|ICT|-70|0||15e6","Asia/Barnaul|+06 +07|-60 -70|0101010101010101010101010101|1bb80 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0 3rd0",
"Asia/Beirut|EET EEST|-20 -30|010101010101010101010101010101010101010101010|1bba0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0|22e5","Asia/Bishkek|+05 +06|-50 -60|01010101010101|1bb9u 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0|87e4","Asia/Brunei|BNT|-80|0||42e4","Asia/Kolkata|IST|-5u|0||15e6","Asia/Chita|+09 +10 +08|-90 -a0 -80|0101010101010101010101010120|1bb50 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0 3re0|33e4",
"Asia/Choibalsan|CHOT CHOST CHOT CHOST|-90 -a0 -80 -90|01010101010102323232323232|1gfR0 11z0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 3Db0 h1f0 1cJ0 1cP0 1cJ0 1cP0 1fx0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1cJ0|38e3","Asia/Shanghai|CST|-80|0||23e6","Asia/Colombo|+06 +0530|-60 -5u|01|1sl6u|22e5","Asia/Dhaka|BDT BDST|-60 -70|010|1A5R0 1i00|16e6","Asia/Damascus|EET EEST|-20 -30|010101010101010101010101010101010101010101010|1bcK0 1db0 1dd0 1db0 1cN0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1db0 1cN0 1db0 1cN0 19z0 1fB0 1qL0 11B0 1on0 Wp0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0|26e5",
"Asia/Dili|WITA TLT|-80 -90|01|1eKE0|19e4","Asia/Dubai|GST|-40|0||39e5","Asia/Famagusta|EET EEST +03|-20 -30 -30|0101010101010101010101010101010101012|1bbd0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 15U0","Asia/Gaza|EET EEST|-20 -30|010101010101010101010101010101010101010101010|1biK0 1cL0 1fB0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 17c0 1io0 18N0 1bz0 19z0 1gp0 1610 1iL0 11z0 1o10 14o0 1lA1 SKX 1xd1 MKX 1AN0 1a00 1fA0 1cL0 1cN0 1nX0 1210 1nz0 1220 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0|18e5",
"Asia/Hebron|EET EEST|-20 -30|01010101010101010101010101010101010101010101010|1biK0 1cL0 1fB0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 17c0 1io0 18N0 1bz0 19z0 1gp0 1610 1iL0 12L0 1mN0 14o0 1lc0 Tb0 1xd1 MKX bB0 cn0 1cN0 1a00 1fA0 1cL0 1cN0 1nX0 1210 1nz0 1220 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0|25e4","Asia/Hong_Kong|HKT|-80|0||73e5","Asia/Hovd|HOVT HOVST|-70 -80|0101010101010101010101010|1gfT0 11z0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 kEp0 1cJ0 1cP0 1cJ0 1cP0 1fx0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1cJ0|81e3",
"Asia/Irkutsk|+08 +09|-80 -90|010101010101010101010101010|1bb60 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|60e4","Europe/Istanbul|EET EEST +03|-20 -30 -30|0101010101010101010101010101010101012|1bbb0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WO0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 Xc0 1qo0 WM0 1qM0 11A0 1o00 1200 1nA0 11A0 1tA0 U00 15w0|13e6","Asia/Jakarta|WIB|-70|0||31e6","Asia/Jayapura|WIT|-90|0||26e4",
"Asia/Jerusalem|IST IDT|-20 -30|010101010101010101010101010101010101010101010|1bdc0 11z0 1tB0 19W0 1e10 17b0 1ep0 1gL0 18N0 1fz0 1eN0 17b0 1gq0 1gn0 19d0 1dz0 1c10 17X0 1hB0 1gn0 19d0 1dz0 1c10 17X0 1kp0 1dz0 1c10 1aL0 1eN0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0|81e4","Asia/Kabul|AFT|-4u|0||46e5","Asia/Karachi|PKT PKST|-50 -60|0101010|1ixv0 1cL0 dK10 11b0 1610 1jX0|24e6","Asia/Urumqi|XJT|-60|0||32e5","Asia/Kathmandu|NPT|-5J|0||12e5","Asia/Khandyga|+09 +10 +11|-90 -a0 -b0|01010101010121212121212121210|1bb50 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 qK0 yN0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 17V0 7zD0|66e2",
"Asia/Krasnoyarsk|+07 +08|-70 -80|010101010101010101010101010|1bb70 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|10e5","Asia/Kuala_Lumpur|MYT|-80|0||71e5","Asia/Macau|MOT CST|-80 -80|01|1cVQ0|57e4","Asia/Magadan|+11 +12 +10|-b0 -c0 -a0|0101010101010101010101010120|1bb30 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0 3Cq0|95e3","Asia/Makassar|WITA|-80|0||15e5",
"Asia/Manila|PHT|-80|0||24e6","Europe/Athens|EET EEST|-20 -30|010101010101010101010101010101010101010101010|1bbd0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|35e5","Asia/Novokuznetsk|+07 +08 +06|-70 -80 -60|0101010101010101010101020|1bb70 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 2sp0 WM0|55e4",
"Asia/Novosibirsk|+06 +07|-60 -70|0101010101010101010101010101|1bb80 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0 4eN0|15e5","Asia/Omsk|+06 +07|-60 -70|010101010101010101010101010|1bb80 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|12e5","Asia/Pyongyang|KST KST|-90 -8u|01|1P4D0|29e5","Asia/Qyzylorda|+05 +06|-50 -60|010101010101|1bb90 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0|73e4",
"Asia/Rangoon|MMT|-6u|0||48e5","Asia/Sakhalin|+10 +11|-a0 -b0|0101010101010101010101010101|1bb40 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0 3rd0|58e4","Asia/Seoul|KST|-90|0||23e6","Asia/Singapore|SGT|-80|0||56e5","Asia/Srednekolymsk|+11 +12|-b0 -c0|010101010101010101010101010|1bb30 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|35e2","Asia/Tbilisi|+04 +05 +03|-40 -50 -30|010101010101020|1bb80 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 An0 Os0 WM0|11e5",
"Asia/Tehran|IRST IRDT|-3u -4u|01010101010101010101010101010101010101010|1b8Iu 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 64p0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0|14e6","Asia/Thimphu|BTT|-60|0||79e3","Asia/Tokyo|JST|-90|0||38e6","Asia/Tomsk|+07 +08 +06|-70 -80 -60|01010101020202020202020202020|1bb70 1qM0 WM0 1qM0 WM0 1qM0 11A0 co0 1bB0 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0 3Qp0|10e5",
"Asia/Ulaanbaatar|ULAT ULAST|-80 -90|0101010101010101010101010|1gfS0 11z0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 kEp0 1cJ0 1cP0 1cJ0 1cP0 1fx0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1cJ0|12e5","Asia/Ust-Nera|+11 +12 +10|-b0 -c0 -a0|0101010101010101010101010102|1bb30 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 17V0 7zD0|65e2","Asia/Vladivostok|+10 +11|-a0 -b0|010101010101010101010101010|1bb40 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|60e4",
"Asia/Yakutsk|+09 +10|-90 -a0|010101010101010101010101010|1bb50 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|28e4","Asia/Yekaterinburg|+05 +06|-50 -60|010101010101010101010101010|1bb90 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|14e5","Asia/Yerevan|+04 +05|-40 -50|010101010101010101010101010|1bba0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|13e5",
"Atlantic/Azores|AZOT AZOST|10 0|010101010101010101010101010101010101010101010|1bbd0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|25e4","Europe/Lisbon|WET WEST|0 -10|010101010101010101010101010101010101010101010|1bbd0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|27e5",
"Atlantic/Cape_Verde|CVT|10|0||50e4","Atlantic/South_Georgia|GST|20|0||30","Atlantic/Stanley|FKST FKT|30 40|0101010101010101010101010|1bjD0 WN0 1qL0 WN0 1qN0 U10 1wn0 Rd0 1wn0 U10 1tz0 U10 1tz0 U10 1tz0 U10 1tz0 U10 1wn0 U10 1tz0 U10 1tz0 U10|21e2","Australia/Sydney|AEDT AEST|-b0 -a0|010101010101010101010101010101010101010101010|1bb40 1qM0 WM0 11A0 1o00 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 11A0 1o00 WM0 1qM0 14o0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0|40e5",
"Australia/Adelaide|ACDT ACST|-au -9u|010101010101010101010101010101010101010101010|1bb4u 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 11A0 1o00 WM0 1qM0 14o0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0|11e5","Australia/Brisbane|AEST|-a0|0||20e5","Australia/Hobart|AEDT AEST|-b0 -a0|010101010101010101010101010101010101010101010|1bb40 1fA0 1a00 11A0 1o00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1cM0 1a00 1io0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0|21e4",
"Australia/Darwin|ACST|-9u|0||12e4","Australia/Eucla|ACWST ACWDT|-8J -9J|0101010|1tRRf IM0 1qM0 11A0 1o00 11A0|368","Australia/Lord_Howe|LHDT LHST|-b0 -au|010101010101010101010101010101010101010101010|1bb30 1qMu WLu 11Au 1nXu 1qMu 11zu 1o0u 11zu 1o0u 11zu 1qMu WLu 1qMu 11zu 1o0u WLu 1qMu 14nu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu|347","Australia/Perth|AWST AWDT|-80 -90|0101010|1tRS0 IM0 1qM0 11A0 1o00 11A0|18e5",
"Pacific/Easter|EASST EAST|50 60|0101010101010101010101010101010101010101010|1be30 1fB0 11z0 1qN0 WL0 1qN0 WL0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 17b0 1ip0 11z0 1o10 19X0 1fB0 1nX0 G10 1EL0 Op0 1zb0 Rd0 1wn0 Rd0 46n0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1Nb0 Ap0|30e2","Europe/Dublin|GMT IST|0 -10|010101010101010101010101010101010101010101010|1bbd0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|12e5",
"Etc/GMT+1|-01|10|0|","Etc/GMT+10|-10|a0|0|","Etc/GMT+11|-11|b0|0|","Etc/GMT+12|-12|c0|0|","Etc/GMT+2|-02|20|0|","Etc/GMT+4|-04|40|0|","Etc/GMT+5|-05|50|0|","Etc/GMT+6|-06|60|0|","Etc/GMT+7|-07|70|0|","Etc/GMT+8|-08|80|0|","Etc/GMT+9|-09|90|0|","Etc/GMT-1|+01|-10|0|","Etc/GMT-11|+11|-b0|0|","Etc/GMT-12|+12|-c0|0|","Etc/GMT-13|+13|-d0|0|","Etc/GMT-14|+14|-e0|0|","Etc/GMT-2|+02|-20|0|","Etc/GMT-4|+04|-40|0|","Etc/GMT-7|+07|-70|0|","Etc/GMT-8|+08|-80|0|","Etc/GMT-9|+09|-90|0|","Etc/UCT|UCT|0|0|","Etc/UTC|UTC|0|0|",
"Europe/Astrakhan|+03 +04|-30 -40|0101010101010101010101010101|1bbb0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0 3rd0","Europe/London|GMT BST|0 -10|010101010101010101010101010101010101010101010|1bbd0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|10e6","Europe/Chisinau|EET EEST|-20 -30|010101010101010101010101010101010101010101010|1bbc0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|67e4",
"Europe/Kaliningrad|EET EEST +03|-20 -30 -30|010101010101010101010101020|1bbc0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|44e4","Europe/Volgograd|+03 +04|-30 -40|010101010101010101010101010|1bbb0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|10e5","Europe/Minsk|EET EEST +03|-20 -30 -30|01010101010101010101010102|1bbc0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0|19e5",
"Europe/Moscow|MSK MSD MSK|-30 -40 -40|010101010101010101010101020|1bbb0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|16e6","Europe/Riga|EET EEST|-20 -30|0101010101010101010101010101010101010101010|1bbd0 1qM0 3oo0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|64e4","Europe/Samara|+04 +05 +03|-40 -50 -30|0101010101010101010101020|1bba0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 2sp0 WM0|12e5",
"Europe/Saratov|+03 +04|-30 -40|0101010101010101010101010101|1bbb0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0 5810","Europe/Simferopol|EET EEST MSK MSK|-20 -30 -40 -30|010101010101010101010101010101023|1bbd0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11z0 1nW0|33e4","Europe/Tallinn|EET EEST|-20 -30|01010101010101010101010101010101010101010|1bbd0 1qM0 5QM0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|41e4",
"Europe/Vilnius|CET CEST EET EEST|-10 -20 -20 -30|012323232323232323232323232323232323232|1bbd0 1qM0 8io0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|54e4","Pacific/Honolulu|HST|a0|0||37e4","Indian/Chagos|IOT|-60|0||30e2","Indian/Christmas|CXT|-70|0||21e2","Indian/Cocos|CCT|-6u|0||596","Indian/Mahe|SCT|-40|0||79e3","Indian/Maldives|MVT|-50|0||35e4","Indian/Mauritius|MUT MUST|-40 -50|010|1yva0 11z0|15e4",
"Indian/Reunion|RET|-40|0||84e4","Pacific/Majuro|MHT|-c0|0||28e3","MET|MET MEST|-10 -20|010101010101010101010101010101010101010101010|1bbd0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00","Pacific/Chatham|CHADT CHAST|-dJ -cJ|010101010101010101010101010101010101010101010|1b8e0 1io0 17c0 1io0 17c0 1lc0 14o0 1lc0 14o0 1lc0 17c0 1io0 17c0 1io0 17c0 1io0 17c0 1io0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00|600",
"Pacific/Apia|SST SDT WSDT WSST|b0 a0 -e0 -d0|01012323232323232323232|1Dbn0 1ff0 1a00 CI0 AQ0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00|37e3","Pacific/Bougainville|PGT BST|-a0 -b0|01|1NwE0|18e4","Pacific/Chuuk|CHUT|-a0|0||49e3","Pacific/Efate|VUT|-b0|0||66e3","Pacific/Enderbury|PHOT|-d0|0||1","Pacific/Fakaofo|TKT TKT|b0 -d0|01|1Gfn0|483","Pacific/Fiji|FJST FJT|-d0 -c0|010101010101010101010101010|1aXO0 1EM0 IM0 nJc0 LA0 1o00 Rc0 1wo0 Ao0 1Nc0 Ao0 1Q00 xz0 1SN0 uM0 1SM0 uM0 1VA0 s00 1VA0 uM0 1SM0 uM0 1SM0 uM0 1SM0|88e4",
"Pacific/Funafuti|TVT|-c0|0||45e2","Pacific/Galapagos|GALT|60|0||25e3","Pacific/Gambier|GAMT|90|0||125","Pacific/Guadalcanal|SBT|-b0|0||11e4","Pacific/Guam|GST ChST|-a0 -a0|01|1fpq0|17e4","Pacific/Kiritimati|LINT|-e0|0||51e2","Pacific/Kosrae|KOST|-b0|0||66e2","Pacific/Marquesas|MART|9u|0||86e2","Pacific/Pago_Pago|SST|b0|0||37e2","Pacific/Nauru|NRT|-c0|0||10e3","Pacific/Niue|NUT|b0|0||12e2","Pacific/Norfolk|NFT NFT|-bu -b0|01|1PoCu|25e4","Pacific/Noumea|NCT|-b0|0||98e3","Pacific/Palau|PWT|-90|0||21e3",
"Pacific/Pitcairn|PST|80|0||56","Pacific/Pohnpei|PONT|-b0|0||34e3","Pacific/Port_Moresby|PGT|-a0|0||25e4","Pacific/Rarotonga|CKT|a0|0||13e3","Pacific/Tahiti|TAHT|a0|0||18e4","Pacific/Tarawa|GILT|-c0|0||29e3","Pacific/Tongatapu|+13 +14|-d0 -e0|0101010101010101|1csd0 15A0 1wo0 xz0 1Q10 xz0 zWN0 s00 1VA0 uM0 1SM0 uM0 1SM0 uM0 1SM0|75e3","Pacific/Wake|WAKT|-c0|0||16e3","Pacific/Wallis|WFT|-c0|0||94"],links:["Africa/Abidjan|Africa/Accra","Africa/Abidjan|Africa/Bamako","Africa/Abidjan|Africa/Banjul","Africa/Abidjan|Africa/Bissau",
"Africa/Abidjan|Africa/Conakry","Africa/Abidjan|Africa/Dakar","Africa/Abidjan|Africa/Freetown","Africa/Abidjan|Africa/Lome","Africa/Abidjan|Africa/Monrovia","Africa/Abidjan|Africa/Nouakchott","Africa/Abidjan|Africa/Ouagadougou","Africa/Abidjan|Africa/Sao_Tome","Africa/Abidjan|Africa/Timbuktu","Africa/Abidjan|America/Danmarkshavn","Africa/Abidjan|Atlantic/Reykjavik","Africa/Abidjan|Atlantic/St_Helena","Africa/Abidjan|Etc/GMT","Africa/Abidjan|Etc/GMT+0","Africa/Abidjan|Etc/GMT-0","Africa/Abidjan|Etc/GMT0",
"Africa/Abidjan|Etc/Greenwich","Africa/Abidjan|GMT","Africa/Abidjan|GMT+0","Africa/Abidjan|GMT-0","Africa/Abidjan|GMT0","Africa/Abidjan|Greenwich","Africa/Abidjan|Iceland","Africa/Cairo|Egypt","Africa/Casablanca|Africa/El_Aaiun","Africa/Johannesburg|Africa/Maseru","Africa/Johannesburg|Africa/Mbabane","Africa/Khartoum|Africa/Juba","Africa/Lagos|Africa/Bangui","Africa/Lagos|Africa/Brazzaville","Africa/Lagos|Africa/Douala","Africa/Lagos|Africa/Kinshasa","Africa/Lagos|Africa/Libreville","Africa/Lagos|Africa/Luanda",
"Africa/Lagos|Africa/Malabo","Africa/Lagos|Africa/Ndjamena","Africa/Lagos|Africa/Niamey","Africa/Lagos|Africa/Porto-Novo","Africa/Maputo|Africa/Blantyre","Africa/Maputo|Africa/Bujumbura","Africa/Maputo|Africa/Gaborone","Africa/Maputo|Africa/Harare","Africa/Maputo|Africa/Kigali","Africa/Maputo|Africa/Lubumbashi","Africa/Maputo|Africa/Lusaka","Africa/Nairobi|Africa/Addis_Ababa","Africa/Nairobi|Africa/Asmara","Africa/Nairobi|Africa/Asmera","Africa/Nairobi|Africa/Dar_es_Salaam","Africa/Nairobi|Africa/Djibouti",
"Africa/Nairobi|Africa/Kampala","Africa/Nairobi|Africa/Mogadishu","Africa/Nairobi|Indian/Antananarivo","Africa/Nairobi|Indian/Comoro","Africa/Nairobi|Indian/Mayotte","Africa/Tripoli|Libya","America/Adak|America/Atka","America/Adak|US/Aleutian","America/Anchorage|America/Juneau","America/Anchorage|America/Nome","America/Anchorage|America/Sitka","America/Anchorage|America/Yakutat","America/Anchorage|US/Alaska","America/Argentina/Buenos_Aires|America/Argentina/Cordoba","America/Argentina/Buenos_Aires|America/Buenos_Aires",
"America/Argentina/Buenos_Aires|America/Cordoba","America/Argentina/Buenos_Aires|America/Rosario","America/Argentina/Catamarca|America/Argentina/ComodRivadavia","America/Argentina/Catamarca|America/Argentina/La_Rioja","America/Argentina/Catamarca|America/Argentina/Rio_Gallegos","America/Argentina/Catamarca|America/Catamarca","America/Argentina/Jujuy|America/Argentina/Salta","America/Argentina/Jujuy|America/Jujuy","America/Argentina/Mendoza|America/Mendoza","America/Chicago|America/Menominee","America/Chicago|America/North_Dakota/Center",
"America/Chicago|America/Rainy_River","America/Chicago|CST6CDT","America/Chicago|US/Central","America/Chihuahua|America/Mazatlan","America/Chihuahua|Mexico/BajaSur","America/Costa_Rica|America/Belize","America/Costa_Rica|America/El_Salvador","America/Costa_Rica|America/Regina","America/Costa_Rica|America/Swift_Current","America/Costa_Rica|Canada/East-Saskatchewan","America/Costa_Rica|Canada/Saskatchewan","America/Denver|America/Boise","America/Denver|America/Edmonton","America/Denver|America/Inuvik",
"America/Denver|America/Shiprock","America/Denver|America/Yellowknife","America/Denver|Canada/Mountain","America/Denver|MST7MDT","America/Denver|Navajo","America/Denver|US/Mountain","America/Fort_Wayne|America/Indiana/Indianapolis","America/Fort_Wayne|America/Indiana/Marengo","America/Fort_Wayne|America/Indiana/Vevay","America/Fort_Wayne|America/Indianapolis","America/Fort_Wayne|US/East-Indiana","America/Fortaleza|America/Maceio","America/Halifax|America/Glace_Bay","America/Halifax|America/Thule",
"America/Halifax|Atlantic/Bermuda","America/Halifax|Canada/Atlantic","America/Havana|Cuba","America/Indiana/Knox|America/Indiana/Tell_City","America/Indiana/Knox|America/Knox_IN","America/Indiana/Knox|US/Indiana-Starke","America/Indiana/Petersburg|America/Indiana/Vincennes","America/Iqaluit|America/Pangnirtung","America/Los_Angeles|America/Dawson","America/Los_Angeles|America/Vancouver","America/Los_Angeles|America/Whitehorse","America/Los_Angeles|Canada/Pacific","America/Los_Angeles|Canada/Yukon",
"America/Los_Angeles|PST8PDT","America/Los_Angeles|US/Pacific","America/Los_Angeles|US/Pacific-New","America/Manaus|America/Porto_Velho","America/Manaus|Brazil/West","America/Mexico_City|America/Merida","America/Mexico_City|America/Monterrey","America/Mexico_City|Mexico/General","America/New_York|America/Detroit","America/New_York|America/Kentucky/Louisville","America/New_York|America/Louisville","America/New_York|America/Montreal","America/New_York|America/Nassau","America/New_York|America/Nipigon",
"America/New_York|America/Thunder_Bay","America/New_York|America/Toronto","America/New_York|Canada/Eastern","America/New_York|EST5EDT","America/New_York|US/Eastern","America/New_York|US/Michigan","America/Noronha|Brazil/DeNoronha","America/Panama|America/Atikokan","America/Panama|America/Cayman","America/Panama|America/Coral_Harbour","America/Panama|America/Jamaica","America/Panama|EST","America/Panama|Jamaica","America/Phoenix|America/Creston","America/Phoenix|America/Dawson_Creek","America/Phoenix|America/Hermosillo",
"America/Phoenix|MST","America/Phoenix|US/Arizona","America/Puerto_Rico|America/Anguilla","America/Puerto_Rico|America/Antigua","America/Puerto_Rico|America/Aruba","America/Puerto_Rico|America/Barbados","America/Puerto_Rico|America/Blanc-Sablon","America/Puerto_Rico|America/Curacao","America/Puerto_Rico|America/Dominica","America/Puerto_Rico|America/Grenada","America/Puerto_Rico|America/Guadeloupe","America/Puerto_Rico|America/Kralendijk","America/Puerto_Rico|America/Lower_Princes","America/Puerto_Rico|America/Marigot",
"America/Puerto_Rico|America/Martinique","America/Puerto_Rico|America/Montserrat","America/Puerto_Rico|America/Port_of_Spain","America/Puerto_Rico|America/St_Barthelemy","America/Puerto_Rico|America/St_Kitts","America/Puerto_Rico|America/St_Lucia","America/Puerto_Rico|America/St_Thomas","America/Puerto_Rico|America/St_Vincent","America/Puerto_Rico|America/Tortola","America/Puerto_Rico|America/Virgin","America/Rio_Branco|America/Eirunepe","America/Rio_Branco|America/Porto_Acre","America/Rio_Branco|Brazil/Acre",
"America/Santiago|Antarctica/Palmer","America/Santiago|Chile/Continental","America/Sao_Paulo|Brazil/East","America/St_Johns|Canada/Newfoundland","America/Tijuana|America/Ensenada","America/Tijuana|America/Santa_Isabel","America/Tijuana|Mexico/BajaNorte","America/Winnipeg|Canada/Central","Antarctica/DumontDUrville|Etc/GMT-10","Antarctica/Rothera|Etc/GMT+3","Antarctica/Syowa|Etc/GMT-3","Antarctica/Vostok|Etc/GMT-6","Asia/Bangkok|Asia/Ho_Chi_Minh","Asia/Bangkok|Asia/Phnom_Penh","Asia/Bangkok|Asia/Saigon",
"Asia/Bangkok|Asia/Vientiane","Asia/Dhaka|Asia/Dacca","Asia/Dubai|Asia/Muscat","Asia/Hong_Kong|Hongkong","Asia/Jakarta|Asia/Pontianak","Asia/Jerusalem|Asia/Tel_Aviv","Asia/Jerusalem|Israel","Asia/Kamchatka|Asia/Anadyr","Asia/Kathmandu|Asia/Katmandu","Asia/Kolkata|Asia/Calcutta","Asia/Kuala_Lumpur|Asia/Kuching","Asia/Macau|Asia/Macao","Asia/Makassar|Asia/Ujung_Pandang","Asia/Oral|Asia/Aqtau","Asia/Rangoon|Asia/Yangon","Asia/Riyadh|Asia/Aden","Asia/Riyadh|Asia/Bahrain","Asia/Riyadh|Asia/Kuwait","Asia/Riyadh|Asia/Qatar",
"Asia/Seoul|ROK","Asia/Shanghai|Asia/Chongqing","Asia/Shanghai|Asia/Chungking","Asia/Shanghai|Asia/Harbin","Asia/Shanghai|Asia/Taipei","Asia/Shanghai|PRC","Asia/Shanghai|ROC","Asia/Singapore|Singapore","Asia/Tashkent|Asia/Ashgabat","Asia/Tashkent|Asia/Ashkhabad","Asia/Tashkent|Asia/Dushanbe","Asia/Tashkent|Asia/Samarkand","Asia/Tashkent|Etc/GMT-5","Asia/Tashkent|Indian/Kerguelen","Asia/Tehran|Iran","Asia/Thimphu|Asia/Thimbu","Asia/Tokyo|Japan","Asia/Ulaanbaatar|Asia/Ulan_Bator","Asia/Urumqi|Asia/Kashgar",
"Australia/Adelaide|Australia/Broken_Hill","Australia/Adelaide|Australia/South","Australia/Adelaide|Australia/Yancowinna","Australia/Brisbane|Australia/Lindeman","Australia/Brisbane|Australia/Queensland","Australia/Darwin|Australia/North","Australia/Hobart|Australia/Currie","Australia/Hobart|Australia/Tasmania","Australia/Lord_Howe|Australia/LHI","Australia/Perth|Australia/West","Australia/Sydney|Australia/ACT","Australia/Sydney|Australia/Canberra","Australia/Sydney|Australia/Melbourne","Australia/Sydney|Australia/NSW",
"Australia/Sydney|Australia/Victoria","Etc/UCT|UCT","Etc/UTC|Etc/Universal","Etc/UTC|Etc/Zulu","Etc/UTC|UTC","Etc/UTC|Universal","Etc/UTC|Zulu","Europe/Astrakhan|Europe/Ulyanovsk","Europe/Athens|Asia/Nicosia","Europe/Athens|EET","Europe/Athens|Europe/Bucharest","Europe/Athens|Europe/Helsinki","Europe/Athens|Europe/Kiev","Europe/Athens|Europe/Mariehamn","Europe/Athens|Europe/Nicosia","Europe/Athens|Europe/Sofia","Europe/Athens|Europe/Uzhgorod","Europe/Athens|Europe/Zaporozhye","Europe/Chisinau|Europe/Tiraspol",
"Europe/Dublin|Eire","Europe/Istanbul|Asia/Istanbul","Europe/Istanbul|Turkey","Europe/Lisbon|Atlantic/Canary","Europe/Lisbon|Atlantic/Faeroe","Europe/Lisbon|Atlantic/Faroe","Europe/Lisbon|Atlantic/Madeira","Europe/Lisbon|Portugal","Europe/Lisbon|WET","Europe/London|Europe/Belfast","Europe/London|Europe/Guernsey","Europe/London|Europe/Isle_of_Man","Europe/London|Europe/Jersey","Europe/London|GB","Europe/London|GB-Eire","Europe/Moscow|W-SU","Europe/Paris|Africa/Ceuta","Europe/Paris|Arctic/Longyearbyen",
"Europe/Paris|Atlantic/Jan_Mayen","Europe/Paris|CET","Europe/Paris|Europe/Amsterdam","Europe/Paris|Europe/Andorra","Europe/Paris|Europe/Belgrade","Europe/Paris|Europe/Berlin","Europe/Paris|Europe/Bratislava","Europe/Paris|Europe/Brussels","Europe/Paris|Europe/Budapest","Europe/Paris|Europe/Busingen","Europe/Paris|Europe/Copenhagen","Europe/Paris|Europe/Gibraltar","Europe/Paris|Europe/Ljubljana","Europe/Paris|Europe/Luxembourg","Europe/Paris|Europe/Madrid","Europe/Paris|Europe/Malta","Europe/Paris|Europe/Monaco",
"Europe/Paris|Europe/Oslo","Europe/Paris|Europe/Podgorica","Europe/Paris|Europe/Prague","Europe/Paris|Europe/Rome","Europe/Paris|Europe/San_Marino","Europe/Paris|Europe/Sarajevo","Europe/Paris|Europe/Skopje","Europe/Paris|Europe/Stockholm","Europe/Paris|Europe/Tirane","Europe/Paris|Europe/Vaduz","Europe/Paris|Europe/Vatican","Europe/Paris|Europe/Vienna","Europe/Paris|Europe/Warsaw","Europe/Paris|Europe/Zagreb","Europe/Paris|Europe/Zurich","Europe/Paris|Poland","Europe/Volgograd|Europe/Kirov","Pacific/Auckland|Antarctica/McMurdo",
"Pacific/Auckland|Antarctica/South_Pole","Pacific/Auckland|NZ","Pacific/Chatham|NZ-CHAT","Pacific/Chuuk|Pacific/Truk","Pacific/Chuuk|Pacific/Yap","Pacific/Easter|Chile/EasterIsland","Pacific/Guam|Pacific/Saipan","Pacific/Honolulu|HST","Pacific/Honolulu|Pacific/Johnston","Pacific/Honolulu|US/Hawaii","Pacific/Majuro|Kwajalein","Pacific/Majuro|Pacific/Kwajalein","Pacific/Pago_Pago|Pacific/Midway","Pacific/Pago_Pago|Pacific/Samoa","Pacific/Pago_Pago|US/Samoa","Pacific/Pohnpei|Pacific/Ponape"]});return moment});
(function(factory){var root=typeof window==="undefined"?null:window;if(typeof define==="function"&&define.amd)define(function(){return factory(root)});else if(typeof module!=="undefined")module.exports=factory(root);else root.DOMPurify=factory(root)})(function factory(window){var DOMPurify=function(window){return factory(window)};DOMPurify.version="0.8.3";DOMPurify.removed=[];if(!window||!window.document||window.document.nodeType!==9){DOMPurify.isSupported=false;return DOMPurify}var document=window.document;
var originalDocument=document;var DocumentFragment=window.DocumentFragment;var HTMLTemplateElement=window.HTMLTemplateElement;var NodeFilter=window.NodeFilter;var NamedNodeMap=window.NamedNodeMap||window.MozNamedAttrMap;var Text=window.Text;var Comment=window.Comment;var DOMParser=window.DOMParser;if(typeof HTMLTemplateElement==="function"){var template=document.createElement("template");if(template.content&&template.content.ownerDocument)document=template.content.ownerDocument}var implementation=
document.implementation;var createNodeIterator=document.createNodeIterator;var getElementsByTagName=document.getElementsByTagName;var createDocumentFragment=document.createDocumentFragment;var importNode=originalDocument.importNode;var hooks={};DOMPurify.isSupported=typeof implementation.createHTMLDocument!=="undefined"&&document.documentMode!==9;var _addToSet=function(set,array){var l=array.length;while(l--){if(typeof array[l]==="string")array[l]=array[l].toLowerCase();set[array[l]]=true}return set};
var _cloneObj=function(object){var newObject={};var property;for(property in object)if(object.hasOwnProperty(property))newObject[property]=object[property];return newObject};var ALLOWED_TAGS=null;var DEFAULT_ALLOWED_TAGS=_addToSet({},["a","abbr","acronym","address","area","article","aside","audio","b","bdi","bdo","big","blink","blockquote","body","br","button","canvas","caption","center","cite","code","col","colgroup","content","data","datalist","dd","decorator","del","details","dfn","dir","div",
"dl","dt","element","em","fieldset","figcaption","figure","font","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","img","input","ins","kbd","label","legend","li","main","map","mark","marquee","menu","menuitem","meter","nav","nobr","ol","optgroup","option","output","p","pre","progress","q","rp","rt","ruby","s","samp","section","select","shadow","small","source","spacer","span","strike","strong","style","sub","summary","sup","table","tbody","td","template","textarea",
"tfoot","th","thead","time","tr","track","tt","u","ul","var","video","wbr","svg","altglyph","altglyphdef","altglyphitem","animatecolor","animatemotion","animatetransform","circle","clippath","defs","desc","ellipse","filter","font","g","glyph","glyphref","hkern","image","line","lineargradient","marker","mask","metadata","mpath","path","pattern","polygon","polyline","radialgradient","rect","stop","switch","symbol","text","textpath","title","tref","tspan","view","vkern","feBlend","feColorMatrix","feComponentTransfer",
"feComposite","feConvolveMatrix","feDiffuseLighting","feDisplacementMap","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feMerge","feMergeNode","feMorphology","feOffset","feSpecularLighting","feTile","feTurbulence","math","menclose","merror","mfenced","mfrac","mglyph","mi","mlabeledtr","mmuliscripts","mn","mo","mover","mpadded","mphantom","mroot","mrow","ms","mpspace","msqrt","mystyle","msub","msup","msubsup","mtable","mtd","mtext","mtr","munder","munderover","#text"]);var ALLOWED_ATTR=
null;var DEFAULT_ALLOWED_ATTR=_addToSet({},["accept","action","align","alt","autocomplete","background","bgcolor","border","cellpadding","cellspacing","checked","cite","class","clear","color","cols","colspan","coords","datetime","default","dir","disabled","download","enctype","face","for","headers","height","hidden","high","href","hreflang","id","ismap","label","lang","list","loop","low","max","maxlength","media","method","min","multiple","name","noshade","novalidate","nowrap","open","optimum","pattern",
"placeholder","poster","preload","pubdate","radiogroup","readonly","rel","required","rev","reversed","rows","rowspan","spellcheck","scope","selected","shape","size","span","srclang","start","src","step","style","summary","tabindex","title","type","usemap","valign","value","width","xmlns","accent-height","accumulate","additivive","alignment-baseline","ascent","attributename","attributetype","azimuth","basefrequency","baseline-shift","begin","bias","by","clip","clip-path","clip-rule","color","color-interpolation",
"color-interpolation-filters","color-profile","color-rendering","cx","cy","d","dx","dy","diffuseconstant","direction","display","divisor","dur","edgemode","elevation","end","fill","fill-opacity","fill-rule","filter","flood-color","flood-opacity","font-family","font-size","font-size-adjust","font-stretch","font-style","font-variant","font-weight","fx","fy","g1","g2","glyph-name","glyphref","gradientunits","gradienttransform","image-rendering","in","in2","k","k1","k2","k3","k4","kerning","keypoints",
"keysplines","keytimes","lengthadjust","letter-spacing","kernelmatrix","kernelunitlength","lighting-color","local","marker-end","marker-mid","marker-start","markerheight","markerunits","markerwidth","maskcontentunits","maskunits","max","mask","mode","min","numoctaves","offset","operator","opacity","order","orient","orientation","origin","overflow","paint-order","path","pathlength","patterncontentunits","patterntransform","patternunits","points","preservealpha","r","rx","ry","radius","refx","refy",
"repeatcount","repeatdur","restart","result","rotate","scale","seed","shape-rendering","specularconstant","specularexponent","spreadmethod","stddeviation","stitchtiles","stop-color","stop-opacity","stroke-dasharray","stroke-dashoffset","stroke-linecap","stroke-linejoin","stroke-miterlimit","stroke-opacity","stroke","stroke-width","surfacescale","targetx","targety","transform","text-anchor","text-decoration","text-rendering","textlength","u1","u2","unicode","values","viewbox","visibility","vert-adv-y",
"vert-origin-x","vert-origin-y","word-spacing","wrap","writing-mode","xchannelselector","ychannelselector","x","x1","x2","y","y1","y2","z","zoomandpan","accent","accentunder","bevelled","close","columnsalign","columnlines","columnspan","denomalign","depth","display","displaystyle","fence","frame","largeop","length","linethickness","lspace","lquote","mathbackground","mathcolor","mathsize","mathvariant","maxsize","minsize","movablelimits","notation","numalign","open","rowalign","rowlines","rowspacing",
"rowspan","rspace","rquote","scriptlevel","scriptminsize","scriptsizemultiplier","selection","separator","separators","stretchy","subscriptshift","supscriptshift","symmetric","voffset","xlink:href","xml:id","xlink:title","xml:space","xmlns:xlink"]);var FORBID_TAGS=null;var FORBID_ATTR=null;var ALLOW_DATA_ATTR=true;var ALLOW_UNKNOWN_PROTOCOLS=false;var SAFE_FOR_JQUERY=false;var SAFE_FOR_TEMPLATES=false;var MUSTACHE_EXPR=/\{\{[\s\S]*|[\s\S]*\}\}/gm;var ERB_EXPR=/<%[\s\S]*|[\s\S]*%>/gm;var WHOLE_DOCUMENT=
false;var RETURN_DOM=false;var RETURN_DOM_FRAGMENT=false;var RETURN_DOM_IMPORT=false;var SANITIZE_DOM=true;var KEEP_CONTENT=true;var FORBID_CONTENTS=_addToSet({},["audio","head","math","script","style","svg","video"]);var DATA_URI_TAGS=_addToSet({},["audio","video","img","source"]);var URI_SAFE_ATTRIBUTES=_addToSet({},["alt","class","for","id","label","name","pattern","placeholder","summary","title","value","style","xmlns"]);var CONFIG=null;var formElement=document.createElement("form");var _parseConfig=
function(cfg){if(CONFIG&&CONFIG===cfg)return;if(typeof cfg!=="object")cfg={};ALLOWED_TAGS="ALLOWED_TAGS"in cfg?_addToSet({},cfg.ALLOWED_TAGS):DEFAULT_ALLOWED_TAGS;ALLOWED_ATTR="ALLOWED_ATTR"in cfg?_addToSet({},cfg.ALLOWED_ATTR):DEFAULT_ALLOWED_ATTR;FORBID_TAGS="FORBID_TAGS"in cfg?_addToSet({},cfg.FORBID_TAGS):{};FORBID_ATTR="FORBID_ATTR"in cfg?_addToSet({},cfg.FORBID_ATTR):{};ALLOW_DATA_ATTR=cfg.ALLOW_DATA_ATTR!==false;ALLOW_UNKNOWN_PROTOCOLS=cfg.ALLOW_UNKNOWN_PROTOCOLS||false;SAFE_FOR_JQUERY=cfg.SAFE_FOR_JQUERY||
false;SAFE_FOR_TEMPLATES=cfg.SAFE_FOR_TEMPLATES||false;WHOLE_DOCUMENT=cfg.WHOLE_DOCUMENT||false;RETURN_DOM=cfg.RETURN_DOM||false;RETURN_DOM_FRAGMENT=cfg.RETURN_DOM_FRAGMENT||false;RETURN_DOM_IMPORT=cfg.RETURN_DOM_IMPORT||false;SANITIZE_DOM=cfg.SANITIZE_DOM!==false;KEEP_CONTENT=cfg.KEEP_CONTENT!==false;if(SAFE_FOR_TEMPLATES)ALLOW_DATA_ATTR=false;if(RETURN_DOM_FRAGMENT)RETURN_DOM=true;if(cfg.ADD_TAGS){if(ALLOWED_TAGS===DEFAULT_ALLOWED_TAGS)ALLOWED_TAGS=_cloneObj(ALLOWED_TAGS);_addToSet(ALLOWED_TAGS,
cfg.ADD_TAGS)}if(cfg.ADD_ATTR){if(ALLOWED_ATTR===DEFAULT_ALLOWED_ATTR)ALLOWED_ATTR=_cloneObj(ALLOWED_ATTR);_addToSet(ALLOWED_ATTR,cfg.ADD_ATTR)}if(KEEP_CONTENT)ALLOWED_TAGS["#text"]=true;if(Object&&"freeze"in Object)Object.freeze(cfg);CONFIG=cfg};var _forceRemove=function(node){DOMPurify.removed.push({element:node});try{node.parentNode.removeChild(node)}catch(e){node.outerHTML=""}};var _removeAttribute=function(name,node){DOMPurify.removed.push({attribute:node.getAttributeNode(name),from:node});node.removeAttribute(name)};
var _initDocument=function(dirty){var doc,body;try{doc=(new DOMParser).parseFromString(dirty,"text/html")}catch(e){}if(!doc||!doc.documentElement){doc=implementation.createHTMLDocument("");body=doc.body;body.parentNode.removeChild(body.parentNode.firstElementChild);body.outerHTML=dirty}if(typeof doc.getElementsByTagName==="function")return doc.getElementsByTagName(WHOLE_DOCUMENT?"html":"body")[0];return getElementsByTagName.call(doc,WHOLE_DOCUMENT?"html":"body")[0]};var _createIterator=function(root){return createNodeIterator.call(root.ownerDocument||
root,root,NodeFilter.SHOW_ELEMENT|NodeFilter.SHOW_COMMENT|NodeFilter.SHOW_TEXT,function(){return NodeFilter.FILTER_ACCEPT},false)};var _isClobbered=function(elm){if(elm instanceof Text||elm instanceof Comment)return false;if(typeof elm.nodeName!=="string"||typeof elm.textContent!=="string"||typeof elm.removeChild!=="function"||!(elm.attributes instanceof NamedNodeMap)||typeof elm.removeAttribute!=="function"||typeof elm.setAttribute!=="function")return true;return false};var _sanitizeElements=function(currentNode){var tagName,
content;_executeHook("beforeSanitizeElements",currentNode,null);if(_isClobbered(currentNode)){_forceRemove(currentNode);return true}tagName=currentNode.nodeName.toLowerCase();_executeHook("uponSanitizeElement",currentNode,{tagName:tagName});if(!ALLOWED_TAGS[tagName]||FORBID_TAGS[tagName]){if(KEEP_CONTENT&&!FORBID_CONTENTS[tagName]&&typeof currentNode.insertAdjacentHTML==="function")try{currentNode.insertAdjacentHTML("AfterEnd",currentNode.innerHTML)}catch(e){}_forceRemove(currentNode);return true}if(SAFE_FOR_JQUERY&&
!currentNode.firstElementChild&&(!currentNode.content||!currentNode.content.firstElementChild)&&/</g.test(currentNode.textContent)){DOMPurify.removed.push({element:currentNode.cloneNode()});currentNode.innerHTML=currentNode.textContent.replace(/</g,"\x26lt;")}if(SAFE_FOR_TEMPLATES&&currentNode.nodeType===3){content=currentNode.textContent;content=content.replace(MUSTACHE_EXPR," ");content=content.replace(ERB_EXPR," ");if(currentNode.textContent!==content){DOMPurify.removed.push({element:currentNode.cloneNode()});
currentNode.textContent=content}}_executeHook("afterSanitizeElements",currentNode,null);return false};var DATA_ATTR=/^data-[\-\w.\u00B7-\uFFFF]/;var IS_ALLOWED_URI=/^(?:(?:(?:f|ht)tps?|mailto|tel):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i;var IS_SCRIPT_OR_DATA=/^(?:\w+script|data):/i;var ATTR_WHITESPACE=/[\x00-\x20\xA0\u1680\u180E\u2000-\u2029\u205f\u3000]/g;var _sanitizeAttributes=function(currentNode){var attr,name,value,lcName,idAttr,attributes,hookEvent,l;_executeHook("beforeSanitizeAttributes",
currentNode,null);attributes=currentNode.attributes;if(!attributes)return;hookEvent={attrName:"",attrValue:"",keepAttr:true};l=attributes.length;while(l--){attr=attributes[l];name=attr.name;value=attr.value;lcName=name.toLowerCase();hookEvent.attrName=lcName;hookEvent.attrValue=value;hookEvent.keepAttr=true;_executeHook("uponSanitizeAttribute",currentNode,hookEvent);value=hookEvent.attrValue;if(lcName==="name"&&currentNode.nodeName==="IMG"&&attributes.id){idAttr=attributes.id;attributes=Array.prototype.slice.apply(attributes);
_removeAttribute("id",currentNode);_removeAttribute(name,currentNode);if(attributes.indexOf(idAttr)>l)currentNode.setAttribute("id",idAttr.value)}else{if(name==="id")currentNode.setAttribute(name,"");_removeAttribute(name,currentNode)}if(!hookEvent.keepAttr)continue;if(SANITIZE_DOM&&(lcName==="id"||lcName==="name")&&(value in window||value in document||value in formElement))continue;if(SAFE_FOR_TEMPLATES){value=value.replace(MUSTACHE_EXPR," ");value=value.replace(ERB_EXPR," ")}if(ALLOW_DATA_ATTR&&
DATA_ATTR.test(lcName));else if(!ALLOWED_ATTR[lcName]||FORBID_ATTR[lcName])continue;else if(URI_SAFE_ATTRIBUTES[lcName]);else if(IS_ALLOWED_URI.test(value.replace(ATTR_WHITESPACE,"")));else if(lcName==="src"&&value.indexOf("data:")===0&&DATA_URI_TAGS[currentNode.nodeName.toLowerCase()]);else if(ALLOW_UNKNOWN_PROTOCOLS&&!IS_SCRIPT_OR_DATA.test(value.replace(ATTR_WHITESPACE,"")));else if(!value);else continue;try{currentNode.setAttribute(name,value);DOMPurify.removed.pop()}catch(e){}}_executeHook("afterSanitizeAttributes",
currentNode,null)};var _sanitizeShadowDOM=function(fragment){var shadowNode;var shadowIterator=_createIterator(fragment);_executeHook("beforeSanitizeShadowDOM",fragment,null);while(shadowNode=shadowIterator.nextNode()){_executeHook("uponSanitizeShadowNode",shadowNode,null);if(_sanitizeElements(shadowNode))continue;if(shadowNode.content instanceof DocumentFragment)_sanitizeShadowDOM(shadowNode.content);_sanitizeAttributes(shadowNode)}_executeHook("afterSanitizeShadowDOM",fragment,null)};var _executeHook=
function(entryPoint,currentNode,data){if(!hooks[entryPoint])return;hooks[entryPoint].forEach(function(hook){hook.call(DOMPurify,currentNode,data,CONFIG)})};DOMPurify.sanitize=function(dirty,cfg){var body,currentNode,oldNode,nodeIterator,returnNode;if(!dirty)dirty="";if(typeof dirty!=="string")if(typeof dirty.toString!=="function")throw new TypeError("toString is not a function");else dirty=dirty.toString();if(!DOMPurify.isSupported){if(typeof window.toStaticHTML==="object"||typeof window.toStaticHTML===
"function")return window.toStaticHTML(dirty);return dirty}_parseConfig(cfg);DOMPurify.removed=[];if(!RETURN_DOM&&!WHOLE_DOCUMENT&&dirty.indexOf("\x3c")===-1)return dirty;body=_initDocument(dirty);if(!body)return RETURN_DOM?null:"";nodeIterator=_createIterator(body);while(currentNode=nodeIterator.nextNode()){if(currentNode.nodeType===3&&currentNode===oldNode)continue;if(_sanitizeElements(currentNode))continue;if(currentNode.content instanceof DocumentFragment)_sanitizeShadowDOM(currentNode.content);
_sanitizeAttributes(currentNode);oldNode=currentNode}if(RETURN_DOM){if(RETURN_DOM_FRAGMENT){returnNode=createDocumentFragment.call(body.ownerDocument);while(body.firstChild)returnNode.appendChild(body.firstChild)}else returnNode=body;if(RETURN_DOM_IMPORT)returnNode=importNode.call(originalDocument,returnNode,true);return returnNode}return WHOLE_DOCUMENT?body.outerHTML:body.innerHTML};DOMPurify.addHook=function(entryPoint,hookFunction){if(typeof hookFunction!=="function")return;hooks[entryPoint]=hooks[entryPoint]||
[];hooks[entryPoint].push(hookFunction)};DOMPurify.removeHook=function(entryPoint){if(hooks[entryPoint])hooks[entryPoint].pop()};DOMPurify.removeHooks=function(entryPoint){if(hooks[entryPoint])hooks[entryPoint]=[]};DOMPurify.removeAllHooks=function(){hooks={}};return DOMPurify})};
